{"version":3,"sources":["webpack:///./src/utils/index.js","webpack:///src/pages/homepage/topology.vue","webpack:///./src/pages/homepage/topology.vue?dc77","webpack:///./src/pages/homepage/topology.vue","webpack:///./node_modules/mxgraph/javascript/dist/build.js"],"names":["mxgraph","mx","mxImageBasePath","mxBasePath","window","mxGraph","mxGraphModel","mxEditor","mxGeometry","mxDefaultKeyHandler","mxDefaultPopupMenu","mxStylesheet","mxDefaultToolbar","topology","name","data","value","methods","save","this","$refs","validate","valid","model","console","log","init","mounted","graph","graph_container","parent","getDefaultParent","getModel","beginUpdate","v1","insertVertex","v2","insertEdge","endUpdate","homepage_topology","render","_vm","_h","$createElement","_c","_self","staticClass","ref","staticStyle","margin","attrs","onload","position","white-space","overflow","top","left","max-height","height","right","padding","background-image","id","_v","vertical","callback","$$v","expression","staticRenderFns","Component","__webpack_require__","normalizeComponent","ssrContext","__webpack_exports__","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","factory","opts","__mxOutput","mxClient","VERSION","IS_IE","navigator","userAgent","indexOf","IS_IE6","IS_IE11","match","IS_EDGE","IS_QUIRKS","document","documentMode","IS_EM","createElement","VML_PREFIX","OFFICE_PREFIX","IS_NS","IS_OP","IS_OT","IS_SF","test","vendor","IS_ANDROID","appVersion","IS_IOS","platform","IS_GC","IS_CHROMEAPP","chrome","app","runtime","IS_FF","InstallTrigger","IS_MT","IS_VML","appName","toUpperCase","IS_SVG","NO_FO","createElementNS","IS_WIN","IS_MAC","IS_CHROMEOS","IS_TOUCH","documentElement","IS_POINTER","PointerEvent","IS_LOCAL","location","href","defaultBundles","isBrowserSupported","link","rel","doc","write","setAttribute","getElementsByTagName","appendChild","loadResources","fn","lan","pending","length","i","mxResources","add","include","src","node","mxLoadResources","mxForceIncludes","mxResourceExtension","mxLoadStylesheets","substring","basePath","imageBasePath","mxLanguage","language","userLanguage","mxDefaultLanguage","defaultLanguage","mxLanguages","languages","namespaces","styleSheets","type","styleSheet","cssText","createStyleSheet","module","exports","undefined","mxLog","consoleName","TRACE","DEBUG","WARN","buffer","body","title","table","tbody","tr","td","style","verticalAlign","textarea","resize","compatMode","width","addButton","evt","info","content","mxUtils","getInnerHtml","debug","copy","err","alert","popup","h","w","innerHeight","innerWidth","clientHeight","clientWidth","mxWindow","Math","max","setMaximizable","setScrollable","setResizable","setClosable","destroyOnClose","elt","getElement","resizeHandler","sender","offsetHeight","addListener","mxEvent","RESIZE_END","MAXIMIZE","NORMALIZE","writeln","toString","lab","funct","button","isVisible","show","setVisible","visible","enter","string","Date","getTime","leave","t0","dt","apply","arguments","warn","visibility","scrollTop","scrollHeight","mxObjectIdentity","FIELD_NAME","counter","get","obj","ctor","getFunctionName","constructor","clear","mxDictionary","prototype","map","key","put","previous","remove","getKeys","result","push","getValues","visit","visitor","resources","extension","resourcesEncoded","loadDefaultBundle","loadSpecialBundle","isLanguageSupported","getDefaultBundle","basename","getSpecialBundle","dash","toLowerCase","mxConstants","NONE","defaultBundle","specialBundle","req","parse","getText","load","isReady","e","text","lines","split","charAt","index","idx","charCodeAt","replace","unescape","params","defaultValue","replacePlaceholders","c","parseInt","join","mxPoint","x","y","mxRectangle","call","equals","clone","setRect","getCenterX","getCenterY","rect","minX","min","minY","maxX","maxY","intersect","r1","r2","b1","b2","grow","amount","getPoint","rotate90","t","tmp","fromRectangle","mxEffects","animateChanges","changes","done","step","animate","isRequired","change","mxGeometryChange","mxTerminalChange","mxValueChange","mxChildChange","mxStyleChange","state","getView","getState","cell","child","isEdge","setOpacity","shape","scale","dx","geometry","dy","sx","sy","cellRenderer","redraw","cascadeOpacity","setTimeout","delay","opacity","childCount","getChildCount","getChildAt","childState","edges","getEdges","edgeState","fadeOut","from","isEnabled","f","parentNode","removeChild","errorResource","closeResource","errorImage","removeCursors","element","cursor","children","childNodes","getCurrentStyle","currentStyle","getComputedStyle","parseCssNumber","parseFloat","isNaN","setPrefixedStyle","prefix","hasScrollbars","bind","scope","eval","expr","_mxJavaScriptExpression","message","findNode","attr","nodeType","NODETYPE_ELEMENT","getAttribute","firstChild","nextSibling","str","trim","idx2","ltrim","array","forEach","splice","isNode","nodeName","attributeName","attributeValue","isAncestorNode","ancestor","getChildNodes","importNode","allChildren","importNodeImplementation","newNode","attributes","createTextNode","nodeValue","createXmlDocument","implementation","createDocument","createMsXmlDocument","ActiveXObject","async","validateOnParse","resolveExternals","parseXml","DOMParser","xml","parseFromString","loadXML","clearSelection","selection","empty","getSelection","removeAllRanges","removeWhitespace","before","previousSibling","NODETYPE_TEXT","next","getTextContent","htmlEntities","s","newline","String","isVml","tagUrn","getXml","linefeed","getPrettyXml","XMLSerializer","serializeToString","tab","indent","ns","namespaceURI","NODETYPE_DOCUMENT","NODETYPE_DOCUMENT_FRAGMENT","NODETYPE_COMMENT","NODETYPE_CDATA","val","extractTextWithWhitespace","elems","blocks","ret","doExtract","elts","innerHTML","elem","replaceTrailingNewlines","pattern","postfix","innerText","textContent","setTextContent","getOuterHtml","outerHTML","ownerDocument","br","count","label","para","p","addTransparentBackgroundFilter","filter","linkAction","editor","action","pad","execute","linkInvoke","functName","arg","a","color","textDecoration","paddingLeft","getDocumentSize","b","d","fit","ds","offsetLeft","offsetWidth","offset","getDocumentScrollOrigin","sl","st","offsetTop","bottom","url","mxXmlRequest","send","onerror","binary","timeout","ontimeout","headers","setRequestHeaders","request","setRequestHeader","setBinary","getAll","urls","remain","errors","status","getStatus","post","submit","target","simulate","loadInto","onreadystatechange","readyState","addEventListener","getValue","getNumber","Number","getColor","transients","shallow","equalPoints","equalEntries","removeDuplicates","arr","dict","extend","superCtor","output","toRadians","deg","PI","toDegree","rad","arcToCurves","x0","y0","angle","largeArcFlag","sweepFlag","fS","psai","abs","sds","ctx","cty","cpsi","cos","spsi","sin","rxd","ryd","rxdd","rydd","r1x","r2y","lamda","sqrt","seif","txd","tyd","tx","ty","atan2","s1","dr","sse","seg","ceil","segr","cpsir1","cpsir2","spsir1","spsir2","mc","ms","x2","y2","x3","y3","n","getBoundingBox","rotation","cx","p1","p2","p3","p4","getRotatedPoint","pt","y1","getPortConstraints","terminal","edge","source","STYLE_PORT_CONSTRAINT","STYLE_SOURCE_PORT_CONSTRAINT","STYLE_TARGET_PORT_CONSTRAINT","directions","returnValue","DIRECTION_MASK_NONE","STYLE_PORT_CONSTRAINT_ROTATION","STYLE_ROTATION","quad","DIRECTION_NORTH","DIRECTION_MASK_NORTH","DIRECTION_MASK_EAST","DIRECTION_MASK_SOUTH","DIRECTION_MASK_WEST","DIRECTION_WEST","DIRECTION_SOUTH","DIRECTION_EAST","reversePortConstraints","constraint","findNearestSegment","absolutePoints","last","current","dist","ptSegDistSq","getDirectedBounds","m","flipH","flipV","STYLE_DIRECTION","STYLE_FLIPH","STYLE_FLIPV","round","m2","getPerimeterPoint","pts","center","point","intersection","ip","distSq","rectangleIntersectsSegment","bounds","contains","intersects","tw","th","rw","rh","rx","ry","intersectsHotspot","hotspot","cy","start","STYLE_STARTSIZE","view","STYLE_HORIZONTAL","alpha","getOffset","container","scrollOffset","fixed","r","getBoundingClientRect","scrollLeft","wnd","defaultView","parentWindow","pageXOffset","pageYOffset","getScrollOrigin","includeAncestors","includeDocument","origin","convertPoint","chars","RegExp","rtrim","isNumeric","isFinite","isInteger","mod","x1","denom","ua","ub","px","py","projlenSq","dotprod","lenSq","ptLineDist","relativeCcw","ccw","createImage","imageNode","borderStyle","sortCells","cells","ascending","lookup","sort","o1","o2","mxCellPath","create","PATH_SEPARATOR","comp","compare","getStylename","stylename","getStylenames","pairs","indexOfStylename","tokens","pos","addStylename","removeStylename","removeAllStylenames","setCellStyles","setStyle","getStyle","isValue","setCellStyleFlags","flag","setStyleFlag","sep","cont","getAlignmentAsPoint","align","valign","ALIGN_LEFT","ALIGN_RIGHT","ALIGN_TOP","ALIGN_BOTTOM","getSizeForString","fontSize","fontFamily","textWidth","fontStyle","DEFAULT_FONTSIZE","DEFAULT_FONTFAMILY","div","lineHeight","LINE_HEIGHT","FONT_BOLD","fontWeight","FONT_ITALIC","txtDecor","FONT_UNDERLINE","FONT_STRIKETHROUGH","display","zoom","whiteSpace","size","getViewXml","getRoot","eventsEnabled","isEventsEnabled","setEventsEnabled","drawPane","overlayPane","dialect","DIALECT_SVG","NS_SVG","canvas","cloneNode","translate","getTranslate","temp","mxTemporaryCellStates","mxCodec","encode","destroy","getScaleForPageCount","pageCount","pageFormat","border","PAGE_FORMAT_A4_PORTRAIT","availablePageWidth","availablePageHeight","graphBounds","getGraphBounds","sc","getScale","graphWidth","pagesAspectRatio","pageRoot","pagesAspectRatioSqrt","numRowPages","numColumnPages","scaleChange","currentTotalPages","numLoops","roundRowDownProportion","floor","roundColumnDownProportion","open","html","base","close","links","styles","outer","svg","ownerSVGElement","minWidth","minHeight","printScreen","print","focus","isInternalWindow","pre","prompt","confirm","error","icon","img","makeDraggable","graphF","dragElement","autoscroll","scalePreview","highlightDropTargets","getDropTarget","dragSource","mxDragSource","dragOffset","TOOLTIP_VERTICAL_OFFSET","setGuidesEnabled","getGraphForEvent","createDragElement","createPreviewElement","DEFAULT_HOTSPOT","MIN_HOTSPOT_SIZE","MAX_HOTSPOT_SIZE","RENDERING_HINT_EXACT","RENDERING_HINT_FASTER","RENDERING_HINT_FASTEST","DIALECT_VML","DIALECT_MIXEDHTML","DIALECT_PREFERHTML","DIALECT_STRICTHTML","NS_XHTML","NS_XLINK","SHADOWCOLOR","VML_SHADOWCOLOR","SHADOW_OFFSET_X","SHADOW_OFFSET_Y","SHADOW_OPACITY","NODETYPE_ATTRIBUTE","NODETYPE_ENTITY_REFERENCE","NODETYPE_ENTITY","NODETYPE_PROCESSING_INSTRUCTION","NODETYPE_DOCUMENTTYPE","NODETYPE_NOTATION","DEFAULT_VALID_COLOR","DEFAULT_INVALID_COLOR","OUTLINE_HIGHLIGHT_COLOR","OUTLINE_HIGHLIGHT_STROKEWIDTH","HIGHLIGHT_STROKEWIDTH","HIGHLIGHT_SIZE","HIGHLIGHT_OPACITY","CURSOR_MOVABLE_VERTEX","CURSOR_MOVABLE_EDGE","CURSOR_LABEL_HANDLE","CURSOR_TERMINAL_HANDLE","CURSOR_BEND_HANDLE","CURSOR_VIRTUAL_BEND_HANDLE","CURSOR_CONNECT","HIGHLIGHT_COLOR","CONNECT_TARGET_COLOR","INVALID_CONNECT_TARGET_COLOR","DROP_TARGET_COLOR","VALID_COLOR","INVALID_COLOR","EDGE_SELECTION_COLOR","VERTEX_SELECTION_COLOR","VERTEX_SELECTION_STROKEWIDTH","EDGE_SELECTION_STROKEWIDTH","VERTEX_SELECTION_DASHED","EDGE_SELECTION_DASHED","GUIDE_COLOR","GUIDE_STROKEWIDTH","OUTLINE_COLOR","OUTLINE_STROKEWIDTH","HANDLE_SIZE","LABEL_HANDLE_SIZE","HANDLE_FILLCOLOR","HANDLE_STROKECOLOR","LABEL_HANDLE_FILLCOLOR","CONNECT_HANDLE_FILLCOLOR","LOCKED_HANDLE_FILLCOLOR","OUTLINE_HANDLE_FILLCOLOR","OUTLINE_HANDLE_STROKECOLOR","DEFAULT_TEXT_DIRECTION","WORD_WRAP","ABSOLUTE_LINE_HEIGHT","DEFAULT_FONTSTYLE","DEFAULT_STARTSIZE","DEFAULT_MARKERSIZE","DEFAULT_IMAGESIZE","ENTITY_SEGMENT","RECTANGLE_ROUNDING_FACTOR","LINE_ARCSIZE","ARROW_SPACING","ARROW_WIDTH","ARROW_SIZE","PAGE_FORMAT_A4_LANDSCAPE","PAGE_FORMAT_LETTER_PORTRAIT","PAGE_FORMAT_LETTER_LANDSCAPE","STYLE_PERIMETER","STYLE_SOURCE_PORT","STYLE_TARGET_PORT","STYLE_OPACITY","STYLE_FILL_OPACITY","STYLE_STROKE_OPACITY","STYLE_TEXT_OPACITY","STYLE_TEXT_DIRECTION","STYLE_OVERFLOW","STYLE_ORTHOGONAL","STYLE_EXIT_X","STYLE_EXIT_Y","STYLE_EXIT_DX","STYLE_EXIT_DY","STYLE_EXIT_PERIMETER","STYLE_ENTRY_X","STYLE_ENTRY_Y","STYLE_ENTRY_DX","STYLE_ENTRY_DY","STYLE_ENTRY_PERIMETER","STYLE_WHITE_SPACE","STYLE_FILLCOLOR","STYLE_POINTER_EVENTS","STYLE_SWIMLANE_FILLCOLOR","STYLE_MARGIN","STYLE_GRADIENTCOLOR","STYLE_GRADIENT_DIRECTION","STYLE_STROKECOLOR","STYLE_SEPARATORCOLOR","STYLE_STROKEWIDTH","STYLE_ALIGN","STYLE_VERTICAL_ALIGN","STYLE_LABEL_WIDTH","STYLE_LABEL_POSITION","STYLE_VERTICAL_LABEL_POSITION","STYLE_IMAGE_ASPECT","STYLE_IMAGE_ALIGN","STYLE_IMAGE_VERTICAL_ALIGN","STYLE_GLASS","STYLE_IMAGE","STYLE_IMAGE_WIDTH","STYLE_IMAGE_HEIGHT","STYLE_IMAGE_BACKGROUND","STYLE_IMAGE_BORDER","STYLE_NOLABEL","STYLE_NOEDGESTYLE","STYLE_LABEL_BACKGROUNDCOLOR","STYLE_LABEL_BORDERCOLOR","STYLE_LABEL_PADDING","STYLE_INDICATOR_SHAPE","STYLE_INDICATOR_IMAGE","STYLE_INDICATOR_COLOR","STYLE_INDICATOR_STROKECOLOR","STYLE_INDICATOR_GRADIENTCOLOR","STYLE_INDICATOR_SPACING","STYLE_INDICATOR_WIDTH","STYLE_INDICATOR_HEIGHT","STYLE_INDICATOR_DIRECTION","STYLE_SHADOW","STYLE_SEGMENT","STYLE_ENDARROW","STYLE_STARTARROW","STYLE_ENDSIZE","STYLE_SWIMLANE_LINE","STYLE_ENDFILL","STYLE_STARTFILL","STYLE_DASHED","STYLE_DASH_PATTERN","STYLE_FIX_DASH","STYLE_ROUNDED","STYLE_CURVED","STYLE_ARCSIZE","STYLE_ABSOLUTE_ARCSIZE","STYLE_SOURCE_PERIMETER_SPACING","STYLE_TARGET_PERIMETER_SPACING","STYLE_PERIMETER_SPACING","STYLE_SPACING","STYLE_SPACING_TOP","STYLE_SPACING_LEFT","STYLE_SPACING_BOTTOM","STYLE_SPACING_RIGHT","STYLE_ANCHOR_POINT_DIRECTION","STYLE_ELBOW","STYLE_FONTCOLOR","STYLE_FONTFAMILY","STYLE_FONTSIZE","STYLE_FONTSTYLE","STYLE_ASPECT","STYLE_AUTOSIZE","STYLE_FOLDABLE","STYLE_EDITABLE","STYLE_BACKGROUND_OUTLINE","STYLE_BENDABLE","STYLE_MOVABLE","STYLE_RESIZABLE","STYLE_RESIZE_WIDTH","STYLE_RESIZE_HEIGHT","STYLE_ROTATABLE","STYLE_CLONEABLE","STYLE_DELETABLE","STYLE_SHAPE","STYLE_EDGE","STYLE_JETTY_SIZE","STYLE_SOURCE_JETTY_SIZE","STYLE_TARGET_JETTY_SIZE","STYLE_LOOP","STYLE_ORTHOGONAL_LOOP","STYLE_ROUTING_CENTER_X","STYLE_ROUTING_CENTER_Y","SHAPE_RECTANGLE","SHAPE_ELLIPSE","SHAPE_DOUBLE_ELLIPSE","SHAPE_RHOMBUS","SHAPE_LINE","SHAPE_IMAGE","SHAPE_ARROW","SHAPE_ARROW_CONNECTOR","SHAPE_LABEL","SHAPE_CYLINDER","SHAPE_SWIMLANE","SHAPE_CONNECTOR","SHAPE_ACTOR","SHAPE_CLOUD","SHAPE_TRIANGLE","SHAPE_HEXAGON","ARROW_CLASSIC","ARROW_CLASSIC_THIN","ARROW_BLOCK","ARROW_BLOCK_THIN","ARROW_OPEN","ARROW_OPEN_THIN","ARROW_OVAL","ARROW_DIAMOND","ARROW_DIAMOND_THIN","ALIGN_CENTER","ALIGN_MIDDLE","TEXT_DIRECTION_DEFAULT","TEXT_DIRECTION_AUTO","TEXT_DIRECTION_LTR","TEXT_DIRECTION_RTL","DIRECTION_MASK_ALL","ELBOW_VERTICAL","ELBOW_HORIZONTAL","EDGESTYLE_ELBOW","EDGESTYLE_ENTITY_RELATION","EDGESTYLE_LOOP","EDGESTYLE_SIDETOSIDE","EDGESTYLE_TOPTOBOTTOM","EDGESTYLE_ORTHOGONAL","EDGESTYLE_SEGMENT","PERIMETER_ELLIPSE","PERIMETER_RECTANGLE","PERIMETER_RHOMBUS","PERIMETER_HEXAGON","PERIMETER_TRIANGLE","mxEventObject","properties","mxMouseEvent","sourceState","mxEventSource","eventSource","setEventSource","consumed","getName","getProperties","getProperty","isConsumed","consume","graphX","graphY","getEvent","getSource","isSource","getX","getClientX","getY","getClientY","getGraphX","getGraphY","getCell","isPopupTrigger","preventDefault","touches","isMouseEvent","eventListeners","getEventSource","removeListener","fireEvent","args","listen","updateListenerList","eventName","mxListenerList","entry","attachEvent","updateListener","listenerCount","removeEventListener","detachEvent","removeAllListeners","list","addGestureListeners","startListener","moveListener","endListener","removeGestureListeners","redirectMouseEvents","down","move","up","dblClick","fireMouseEvent","MOUSE_DOWN","MOUSE_MOVE","MOUSE_UP","release","addMouseWheelListener","diff","evtCache","dx0","dy0","pointerId","clientX","clientY","PINCH_THRESHOLD","event","ctrlKey","deltaY","deltaX","disableContextMenu","srcElement","isTouchEvent","pointerType","MSPOINTER_TYPE_TOUCH","mozInputSource","isPenEvent","MSPOINTER_TYPE_PEN","isMultiTouchEvent","MSPOINTER_TYPE_MOUSE","isLeftMouseButton","buttons","which","isMiddleMouseButton","isRightMouseButton","isControlDown","isShiftDown","isMetaDown","isAltDown","shiftKey","altKey","metaKey","getMainEvent","changedTouches","stopPropagation","cancelBubble","LABEL_HANDLE","ROTATION_HANDLE","CUSTOM_HANDLE","VIRTUAL_HANDLE","ACTIVATE","RESIZE_START","RESIZE","MOVE_START","MOVE","MOVE_END","PAN_START","PAN","PAN_END","MINIMIZE","HIDE","SHOW","CLOSE","DESTROY","REFRESH","SIZE","SELECT","FIRED","FIRE_MOUSE_EVENT","GESTURE","TAP_AND_HOLD","GET","RECEIVE","CONNECT","DISCONNECT","SUSPEND","RESUME","MARK","ROOT","POST","OPEN","SAVE","BEFORE_ADD_VERTEX","ADD_VERTEX","AFTER_ADD_VERTEX","DONE","EXECUTE","EXECUTED","BEGIN_UPDATE","START_EDIT","END_UPDATE","END_EDIT","BEFORE_UNDO","UNDO","REDO","CHANGE","NOTIFY","LAYOUT_CELLS","CLICK","SCALE","TRANSLATE","SCALE_AND_TRANSLATE","UP","DOWN","ADD","REMOVE","CLEAR","ADD_CELLS","CELLS_ADDED","MOVE_CELLS","CELLS_MOVED","RESIZE_CELLS","CELLS_RESIZED","TOGGLE_CELLS","CELLS_TOGGLED","ORDER_CELLS","CELLS_ORDERED","REMOVE_CELLS","CELLS_REMOVED","GROUP_CELLS","UNGROUP_CELLS","REMOVE_CELLS_FROM_PARENT","FOLD_CELLS","CELLS_FOLDED","ALIGN_CELLS","LABEL_CHANGED","CONNECT_CELL","CELL_CONNECTED","SPLIT_EDGE","FLIP_EDGE","START_EDITING","EDITING_STARTED","EDITING_STOPPED","ADD_OVERLAY","REMOVE_OVERLAY","UPDATE_CELL_SIZE","ESCAPE","DOUBLE_CLICK","START","RESET","method","username","password","withCredentials","decodeSimulateValues","isBinary","responseText","getDocumentElement","responseXML","XMLHttpRequest","overrideMimeType","old","onbeforeunload","form","pars","decodeURIComponent","mxClipboard","STEPSIZE","insertCount","setCells","getCells","isEmpty","cut","removeCells","getSelectionCells","getExportableCells","getTopmostCells","cloneCells","paste","getImportableCells","delta","importCells","setSelectionCells","minimizable","movable","replaceNode","installMaximizeHandler","installMinimizeHandler","installCloseHandler","setMinimizable","setTitle","installMoveHandler","replaceChild","mxForm","className","mxImage","mxDivResizer","resizeWidth","resizeHeight","handlingResize","dropHandler","mouseDown","eventConsumer","evtName","me","mxToolbar","mxUndoableEdit","significant","mxUndoManager","closeImage","minimizeImage","normalizeImage","maximizeImage","resizeImage","minimumSize","contentHeightCorrection","touchAction","contentWrapper","activator","activate","hide","scrollable","activeWindow","zIndex","previousWindow","isResizable","resizable","startX","startY","dragHandler","setSize","minimize","getMinimumSize","marginLeft","minimized","maxDisplay","maximize","minSize","maximizable","maximized","minDisplay","docHeight","setLocation","closeImg","setImage","image","marginRight","marginTop","insertBefore","closable","getTable","addButtons","okFunct","cancelFunct","addText","input","addField","addCheckbox","checked","addTextarea","rows","addCombo","isMultiSelect","select","addOption","combo","isSelected","option","getDocumentWidth","getDocumentHeight","l","previewElement","previewOffset","enabled","currentGraph","currentDropTarget","currentPoint","currentGuide","currentHighlight","guidesEnabled","gridEnabled","dragElementZIndex","dragElementOpacity","checkEventSource","setEnabled","isGuidesEnabled","isGridEnabled","setGridEnabled","getCellAt","isActive","mouseMoveHandler","reset","dragExit","removeDragElement","removeListeners","stopDrag","startDrag","mouseMove","mouseUpHandler","mouseUp","pointerEvents","getElementForEvent","elementFromPoint","graphContainsEvent","dragEnter","dragOver","drop","isMouseDown","isMouseTrigger","mxGuide","graphHandler","getGuideStates","mxCellHighlight","panDx","panDy","autoScroll","scrollPointToVisible","autoExtend","isDropEnabled","highlight","isGridEnabledEvent","hideGuide","isEnabledForEvent","off","gridSize","snap","dropTarget","noReset","updateDefaultMode","addItem","pressedIcon","factoryMethod","initialClassName","mouseHandler","backgroundColor","menu","mxPopupMenu","currentImg","isMenuShowing","hideMenu","addActionCombo","options","selectedIndex","addSwitchMode","altIcon","selectedMode","defaultMode","selectMode","addMode","toggle","defaultFunction","domNode","resetMode","forced","addSeparator","addBreak","addLine","hr","undone","redone","isSignificant","notify","die","undo","redo","history","indexOfNextAdd","canUndo","edit","canRedo","undoableEditHappened","undoableEdit","shift","edits","mxUrlConverter","mxPanningManager","thread","active","tdx","tdy","t0x","t0y","scrollbars","mouseListener","stop","addMouseListener","mouseUpListener","createThread","setInterval","panGraph","getDx","getDy","panTo","handleMouseOut","damper","clearInterval","setTranslate","removeMouseListener","mxAutoSaveManager","changeHandler","graphModelChanged","setGraph","mxAnimation","mxMorphing","steps","ease","mxImageBundle","alt","images","mxImageExport","mxAbstractCanvas2D","converter","createUrlConverter","mxXmlCanvas2D","root","writeDefaults","mxSvgCanvas2D","styleEnabled","gradients","defs","createStyle","baseUrl","baseDomain","updateBaseUrl","protocol","host","pathname","lastIndexOf","getBaseUrl","setBaseUrl","getBaseDomain","setBaseDomain","isRelativeUrl","convert","submenuImage","useLeftButtonForPopup","itemCount","autoExpand","smartSeparators","labels","iconCls","noHover","willAddSeparator","containsItems","col1","col2","col3","paddingRight","textAlign","createSubmenu","currentSelection","eventReceiver","activeRow","hideSubmenu","showSubmenu","createRange","addCheckmark","item","backgroundImage","backgroundRepeat","backgroundPosition","row","force","showMenu","autoSaveDelay","autoSaveThrottle","autoSaveThreshold","ignoredChanges","lastSnapshot","isRunning","startAnimation","updateAnimation","stopAnimation","mxCellStatePreview","animateCell","recurse","getDelta","isVertex","moveState","stopRecursion","getOriginForCell","getParent","geo","getCellGeometry","relative","pgeo","putImage","fallback","getImage","includeOverlays","drawState","visitStatesRecursive","drawCellState","drawOverlays","getLinkForCellState","setLink","drawShape","drawText","mxShape","checkBounds","beforePaint","paint","afterPaint","restore","overlays","states","path","rotateHtml","lastX","lastY","moveOp","lineOp","quadOp","curveOp","closeOp","createState","fillAlpha","strokeAlpha","fillColor","gradientFillAlpha","gradientColor","gradientAlpha","gradientDirection","strokeColor","strokeWidth","dashed","dashPattern","fixDash","lineCap","lineJoin","miterLimit","fontColor","fontBackgroundColor","fontBorderColor","shadow","shadowColor","shadowAlpha","shadowDx","shadowDy","rotationCx","rotationCy","format","addOp","rotatePoint","theta","pop","rotate","setAlpha","setFillAlpha","setStrokeAlpha","setFillColor","setGradient","color1","color2","direction","alpha1","alpha2","setStrokeColor","setStrokeWidth","setDashed","setDashPattern","setLineCap","setLineJoin","setMiterLimit","setFontColor","setFontBackgroundColor","setFontBorderColor","setFontSize","setFontFamily","setFontStyle","setShadow","setShadowColor","setShadowAlpha","setShadowOffset","begin","moveTo","lineTo","quadTo","curveTo","arcTo","curves","end","textEnabled","compressed","toFixed","roundrect","ellipse","aspect","wrap","clip","dir","stroke","fill","fillAndStroke","useDomParser","useAbsoluteIds","matchHtmlAlignment","foEnabled","foAltText","foOffset","textOffset","imageOffset","strokeTolerance","minStrokeWidth","refCount","lineHeightCorrection","pointerEventsValue","fontMetricsPadding","cacheOffsetSize","hash","tagName","namespace","getAlternateText","fo","createAlternateContent","anchor","createGradientId","getSvgGradient","gradient","tmpId","getElementById","createSvgGradient","op","addNode","filled","stroked","updateFill","updateStroke","transform","createShadow","createTolerance","originalRoot","getCurrentStrokeWidth","sw","updateStrokeAttributes","createDashPattern","pat","tol","removeAttribute","setAttributeNS","convertHtml","xd","xb","adoptNode","ta","createDiv","div2","div3","updateText","updateTextNodes","addForeignObject","group","g","createCss","getTextCss","flex","block","box","yp","bg","ofl","fw","fh","bgc","lh","css","deco","plainText","createClip","updateFont","textHeight","addTextBackground","bbox","getBBox","ie","mxVmlCanvas2D","setStates","stencil","initStyles","mxStencil","desc","parseDescription","parseConstraints","rotatedHtmlBackground","vmlScale","createVmlElement","coordsize","strokeweight","strokecolor","createStroke","createFill","createTransparentFill","flip","endcap","joinstyle","miterlimit","dashstyle","getVmlDashStyle","tok","createShadowStroke","createShadowFill","cpx0","cpy0","qpx1","qpy1","cpx3","cpy3","cpx1","cpy1","cpx2","cpy2","createRect","inner","wordWrap","rot","maxHeight","real_cos","real_sin","sizeDiv","oh","top_fix","left_fix","divParent","textpathok","v","tp","on","horizontal","guideX","guideY","rounded","tolerance","getGuideTolerance","createGuideShape","guide","mxPolyline","isDashed","isStateIgnored","tt","overrideX","stateX","valueX","overrideY","stateY","valueY","ttX","ttY","middle","snapX","centerAlign","override","getOverlayPane","snapY","snapDelta","points","getGuideColor","scrollWidth","antiAlias","minSvgStrokeWidth","boundingBox","svgStrokeTolerance","svgPointerEvents","shapePointerEvents","stencilPointerEvents","outline","useSvgBoundingBox","strokewidth","fillOpacity","strokeOpacity","isParseVml","isHtmlAllowed","getSvgScreenOffset","createSvg","createHtml","createVml","reconfigure","updateBoundsFromPoints","redrawShape","redrawHtmlShape","updateBoundingBox","lastChild","getLabelBounds","isPaintBoundsInverted","getLabelMargins","createVmlGroup","createCanvas","insertAdjacentHTML","destroyCanvas","createSvgCanvas","updateVmlContainer","createVmlCanvas","updateHtmlBounds","updateHtmlFilters","updateHtmlColors","isShadow","east","south","west","north","borderColor","borderWidth","setTransparentBackgroundImage","mxRefCount","releaseSvgGradients","oldGradients","strokeDrawn","updateTransform","configureCanvas","bb","createBoundingBox","createTransparentSvgRectangle","paintEdgeShape","paintVertexShape","getGradientBounds","getShapeRotation","paintBackground","paintForeground","getArcSize","paintGlassEffect","arc","isRounded","addPoints","arcSize","exclude","initialMove","pe","p0","slice","wp","nx1","ny1","nx2","ny2","resetStyles","spacing","startSize","endSize","startArrow","endArrow","glass","setCursor","getCursor","isRoundable","augmentBoundingBox","getRotation","getTextRotation","mxText","verticalTextRotation","grads","defaultLocalized","allowEval","constraints","w0","h0","bgNode","fgNode","conns","parseConstraint","perimeter","mxConnectionConstraint","evaluateTextAttribute","attribute","evaluateAttribute","loc","stack","computeAspect","minScale","drawChildren","disableShadow","drawNode","inverse","parseRegularly","pointCount","segs","childNode","childName","ps","arcsize","factor","mxStencilRegistry","getStencil","stencils","addStencil","mxMarker","markers","addMarker","createMarker","unitX","unitY","mxActor","mxCloud","mxRectangleShape","mxEllipse","mxDoubleEllipse","mxRhombus","mxArrow","arrowWidth","mxArrowConnector","arrowSpacing","family","spacingTop","spacingRight","spacingBottom","spacingLeft","background","clipped","labelPadding","textDirection","updateMargin","mxTriangle","mxHexagon","mxLine","mxImageShape","mxLabel","mxCylinder","mxConnector","mxSwimlane","mxGraphLayout","WeightedCellSorter","weightedValue","mxStackLayout","mxPartitionLayout","mxCompactTreeLayout","invert","mxRadialTreeLayout","mxFastOrganicLayout","mxCircleLayout","radius","mxParallelEdgeLayout","mxCompositeLayout","layouts","master","mxEdgeLabelLayout","mxGraphAbstractHierarchyCell","mxGraphHierarchyNode","connectsAsTarget","connectsAsSource","mxGraphHierarchyEdge","ids","mxGraphHierarchyModel","layout","vertices","roots","tightenToSource","getGraph","vertexMapper","edgeMapper","maxRank","internalVertices","getChildVertices","SOURCESCANSTARTRANK","createInternalCells","j","internalEdge","realEdges","realEdge","targetCell","getVisibleTerminal","internalTargetCell","mxSwimlaneModel","mxHierarchicalLayoutStage","mxMedianHybridCrossingReduction","MedianCellSorter","mxMinimumCycleRemover","mxCoordinateAssignment","intraCellSpacing","interRankCellSpacing","orientation","initialX","parallelEdgeSpacing","mxSwimlaneOrdering","mxHierarchicalLayout","deterministic","createArrow","widthFactor","endOffsetX","endOffsetY","createOpenArrow","diamond","swFactor","tk","redrawPath","events","hw","hh","prev","paintLine","paintCurvedLine","ix","iy","arrow","nx","ny","basex","basey","floorx","floory","p0x","p0y","p1x","p1y","p2x","p2y","p3x","p3y","p5x","p5y","getEdgeWidth","isMarkerStart","getStartArrowWidth","isMarkerEnd","getEndArrowWidth","startWidth","endWidth","edgeWidth","openEnded","isOpenEnded","markerStart","markerEnd","isArrowRounded","i0","orthx","orthy","fns","startNx","startNy","paintMarker","outStartX","outStartY","inEndX","inEndY","dx1","dy1","dist1","tmp1","dist2","strokeWidthFactor","angleFactor","outX","outY","inX","inY","c1x","c1y","c2x","c2y","inStartX","inStartY","ptX","ptY","widthArrowRatio","spaceX","spaceY","baseSpacingTop","baseSpacingBottom","baseSpacingLeft","baseSpacingRight","replaceLinefeeds","ignoreClippedStringSize","ignoreStringSize","textWidthPadding","lastValue","cacheEnabled","update","realHtml","fmt","getAutoDirection","redrawHtmlShapeWithCss3","updateSize","textDiv","updateHtmlFilter","updateHtmlTransform","exec","getContentNode","ow","updateInnerHtml","divs","unrotatedBoundingBox","getHtmlValue","updateValue","bd","enableWrap","maxWidth","getSpacing","mid","preserveImageAspect","useVml","imageSize","indicatorSize","indicatorSpacing","indicatorShape","indicator","indicatorColor","indicatorStrokeColor","indicatorGradientColor","indicatorDirection","paintImage","paintIndicator","getImageBounds","getIndicatorBounds","indicatorImage","hasChildNodes","getCylinderSize","isForeground","sourceMarker","targetMarker","getTitleSize","isHorizontal","shapeVertical","realHorizontal","realFlipH","realFlipV","getSwimlaneArcSize","swimlaneLine","paintRoundedSwimlane","paintSwimlane","paintSeparator","paintDivider","useBoundingBox","moveCell","resizeCell","getConstraint","getCurrentCellStyle","traverse","vertex","directed","func","visited","edgeCount","getEdgeCount","getEdgeAt","getTerminal","isAncestor","traverseAncestors","isVertexMovable","isCellMovable","isVertexIgnored","isCellVisible","isEdgeIgnored","setEdgeStyleEnabled","setOrthogonalEdge","getParentOffset","parentGeo","getGeometry","setEdgePoints","setRelative","parentOffset","setGeometry","setVertexLocation","getVertexBounds","arrangeGroups","topBorder","rightBorder","bottomBorder","leftBorder","updateGroupBounds","nudge","rankIndex","marginBottom","keepFirstLocation","resizeParent","resizeParentMax","resizeLast","borderCollapse","allowGaps","pstate","getIndex","getParentSize","isLayer","currentRoot","getLayoutCells","c1","c2","geo1","geo2","fillValue","isSwimlane","getCellStyle","horz","childStyle","setChildGeometry","isCellCollapsed","updateParentGeometry","pgeo2","resizeVertices","other","getStartSize","maintainParentLocation","groupPadding","groupPaddingTop","groupPaddingRight","groupPaddingBottom","groupPaddingLeft","parentsChanged","moveTree","levelDistance","nodeDistance","resetEdges","prefHozEdgeSep","prefVertEdgeOff","minEdgeJetty","channelBuffer","edgeRouting","sortEdges","alignRanks","maxRankHeight","getConnections","findTreeRoots","Object","parentX","parentY","dfs","findRankHeights","setCellHeights","horizontalLayout","verticalLayout","moveNode","adjustParents","localEdgeProcessing","sortOutgoingEdges","e1","e2","end1","end2","rank","createNode","out","attachParent","layoutLeaf","offsetX","offsetY","siblingOffset","contour","upperHead","createLine","lowerHead","upperTail","lowerTail","sum","merge","total","upper","lower","bridge","a1","a2","line1","line2","line","processNodeOutgoing","parentCell","sortedCells","sortingCriterion","availableWidth","requiredWidth","edgeSpacing","currentXOffset","currentYOffset","maxYOffset","parentBounds","childCell","childBounds","getEdgesBetween","newPoints","angleOffset","rootx","rooty","autoRadius","rowMinX","rowMaxX","rowMinCenX","rowMaxCenX","rowRadi","rootBounds","centerX","centerY","vertexBounds","calcRowDims","maxLeftGrad","maxRightGrad","leftGrad","rightGrad","xLeftLimit","fullWidth","xProportion","totalTheta","averTheta","nextTheta","lastTheta","rowNum","rowHasChildren","useInputOrigin","disableEdgeStyle","forceConstant","forceConstantSquared","minDistanceLimit","maxDistanceLimit","minDistanceLimitSquared","initialTemp","temperature","maxIterations","iteration","vertexArray","dispX","dispY","cellLocation","radiusSquared","isMoveable","neighbours","indices","allowedToRun","initialBounds","getBoundingBoxFromGeometry","getOpposites","resetEdge","calcRepulsion","calcAttraction","calcPositions","reduceTemperature","minx","miny","moveCells","deltaLength","newXDisp","newYDisp","k","xDelta","yDelta","deltaLengthSquared","displacementX","displacementY","vertexCount","random","deltaLengthWithRadius","moveCircle","getRadius","circle","phi","checkOverlap","findParallels","parallels","addCell","getEdgeId","trg","route","scx","scy","len","placeLabels","avoid","labRect","dy2","dx2","minRank","nextLayerConnectedCells","previousLayerConnectedCells","getNextLayerConnectedCells","layer","getPreviousLayerConnectedCells","getGeneralPurposeVariable","setGeneralPurposeVariable","setX","setY","hashCode","getRankValue","otherNode","getCoreCell","isReversed","ranks","dfsCount","undirectedEdges","directedEdges","initialRank","startNodes","internalNode","internalNodes","startNodesCopy","edgesToBeMarked","layerDeterminingEdges","allEdgesScanned","minimumLayer","removedCell","currentMaxLayer","fixRanks","rankList","rootsArray","oldRootsArray","seen","dfsRoots","trackAncestors","seenNodes","extendedDfs","connectingEdge","rootId","outgoingEdges","targetNode","ancestors","childHash","hashCodeLength","ranksPerGroup","swimlanes","swimlaneIndex","ii","maxChainDfs","lowerRank","upperRank","chainCount","slIndex","incomingEdges","nestedBestRanks","currentBestCrossings","iterationsWithoutImprovement","maxNoImprovementIterations","calculateCrossings","weightedMedian","transpose","candidateCrossings","numRanks","totalCrossings","calculateRankCrossing","previousRank","tmpIndices","rankPosition","connectedCells","nodeIndices","otherCellRankPosition","concat","firstIndex","treeSize","tree","treeIndex","mainLoopIteration","improved","orderedCells","tempRank","leftCellAboveConnections","leftCellBelowConnections","rightCellAboveConnections","rightCellBelowConnections","leftAbovePositions","leftBelowPositions","rightAbovePositions","rightBelowPositions","leftCell","rightCell","totalCurrentCrossings","totalSwitchedCrossings","ik","downwardSweep","medianRank","rankValue","numCellsForRank","medianValues","reservedPositions","nextLevelConnectedCells","nextRankValue","sorterEntry","medianValue","arrayCount","medianPoint","leftMedian","rightMedian","unseenNodesArray","unseenNodes","modelRoots","seenNodesCopy","jettyPositions","limitX","currentXDelta","widestRank","rankTopY","rankBottomY","widestRankValue","rankWidths","rankY","fineTuning","nextLayerConnectedCache","previousLayerConnectedCache","printStatus","initialCoords","minNode","bestXDelta","medianPos","minPath","setCellLocations","nodeList","nodeWrapper","maxTries","cellWrapper","numNextLayerConnected","numPreviousLayerConnected","medianNextLevel","medianXValue","medianPreviousLevel","numConnectedNeighbours","currentPosition","cellMedian","positionChanged","leftLimit","rightLimit","connectedCell","connectedCellWrapper","rankMedianPosition","weightedValues","cellMap","currentCell","calculatedWeightedValue","leftBuffer","rightBuffer","collection","totalWeight","facade","calculateWidestRank","rankCoordinates","localX","boundsWarning","numEdges","lastRankMaxCellHeight","maxCellHeight","distanceToNextRank","referenceX","edgeStraight","refSegCount","upSegCount","downSegCount","upXPositions","downXPositions","currentX","nextX","repositionValid","rankArray","MAX_VALUE","edgeStyle","mxHierarchicalEdgeStyle","ORTHOGONAL","POLYLINE","CURVE","setEdgePosition","cellIndex","currentCells","currentRank","sorter","connectedEdgeCount","connectedEdges","connections","innerCell","connIndex","connectedEdgeGroupCount","numActualEdges","parallelEdgeCount","jettys","layoutReversed","realSource","reversed","arrayOffset","jetty","modelSource","isPort","loopStart","loopLimit","loopDelta","positionX","topChannelY","bottomChannelY","modelTarget","realTarget","processReversedEdge","realCell","positionY","reversedOverSwimlane","cellId","STRAIGHT","mxSwimlaneLayout","currentEdit","createUndoableEdit","setRoot","mxRootChange","previousIndex","mxCollapseChange","collapsed","mxVisibleChange","mxCellAttributeChange","mxCell","onInit","moveParent","parentBorder","interHierarchySpacing","edgesCache","edgeSourceTermCache","edgesTargetTermCache","Array","rootsCopy","run","findRoots","best","maxDiff","fanOut","fanIn","cachedEdges","isCollapsed","terminalCache","term","hierarchyVertices","allVertexSet","filledVertexSet","filterDescendants","filledVertexSetEmpty","candidateRoots","vertexSet","cycleStage","layeringStage","crossingStage","placementStage","allVertices","currentComp","vertexID","edgeIsSource","netCount","isSource2","dummyVertexWidth","dummyVertices","getChildCells","layoutBounds","lane","childrenY","maxChildrenY","newGeo","leftGroupBorder","isValidAncestor","laneCounter","otherVertex","otherIndex","maintainEdgeParent","ignoreRelativeEdgeParent","createIds","nextId","updateLevel","endingUpdate","createRoot","isCreateIds","setCreateIds","insert","filterCells","getDescendants","rootChanged","oldRoot","cellAdded","isRoot","parentChanged","updateEdgeParents","getId","setId","createId","collision","updateEdgeParent","getNearestCommonAncestor","origin1","getOrigin","origin2","cell1","cell2","getParentPath","cellRemoved","parentForCellChanged","oldIndex","par","getChildren","getChildEdges","setTerminal","terminalChanged","setTerminals","terminalForCellChanged","removeEdge","getDirectedEdgeCount","outgoing","ignoredEdge","getIncomingEdges","getOutgoingEdges","incoming","includeLoops","tmp2","sources","targets","terminals","topmost","isConnectable","setValue","valueForCellChanged","valueChanged","geometryForCellChanged","styleForCellChanged","setCollapsed","collapsedStateForCellChanged","visibleStateForCellChanged","mergeChildren","to","cloneAllEdges","mapping","mergeChildrenImpl","getParents","parents","cloneCell","includeChildren","clones","cloneCellImpl","restoreClone","ident","cellCloned","cloneChild","connect","isConnect","connectable","mxTransient","newValue","setVertex","setEdge","setConnectable","setParent","removeFromParent","getEdgeIndex","isOutgoing","removeFromTerminal","hasAttribute","userObject","cloneValue","TRANSLATE_CONTROL_POINTS","alternateBounds","sourcePoint","targetPoint","swap","getTerminalPoint","setTerminalPoint","ct","fixedAspect","resolve","t1","t2","mxPerimeter","RectanglePerimeter","orthogonal","pi","beta","tan","EllipsePerimeter","det","xout1","xout2","yout1","yout2","xout","yout","pow","RhombusPerimeter","TrianglePerimeter","corner","HexagonPerimeter","pi2","mxPrintPreview","pageSelector","pageScale","putDefaultVertexStyle","createDefaultVertexStyle","putDefaultEdgeStyle","createDefaultEdgeStyle","mxCellState","absoluteOffset","mxGraphSelectionModel","mxSelectionChange","selectionModel","added","removed","mxCellEditor","zoomHandler","isEditing","editingCell","stopEditing","mxCellRenderer","autoOrigin","printOverlays","printControls","printBackgroundImage","targetWindow","clipping","getWindow","getDoctype","appendGraph","forcePageBreaks","keepOpen","previousInitializeOverlay","initializeOverlay","overlay","getDrawPane","initControl","control","handleEvents","clickHandler","isNewWindow","writeHead","currentScale","availableHeight","hpages","vpages","writePageSelector","createPageSelector","addPage","pageBreakAfter","addPageBreak","cov","getCoverPages","apx","getAppendices","pageNum","renderPage","addGraphFragment","insertBackgroundImage","closeDocument","writePostfix","js","pageNumber","pageBreakInside","innerDiv","viewport","useCssTransforms","previousContainer","getCanvas","backgroundPane","getBackgroundPane","realScale","graphEnabled","tempClip","rendering","orig","svgs","getLinkForCell","putCellStyle","getDefaultVertexStyle","getDefaultEdgeStyle","defaultStyle","tmpStyle","invalidStyle","invalid","visibleSourceState","visibleTargetState","terminalDistance","segments","unscaledWidth","unscaledHeight","getPerimeterBounds","setAbsoluteTerminalPoint","getVisibleTerminalState","setVisibleTerminalState","terminalState","getCellBounds","cellBounds","getPaintBounds","paintBounds","updateCachedBounds","setState","doneResource","updatingSelectionResource","singleSelection","isSingleSelection","setSingleSelection","changeSelection","setCell","getFirstSelectableCell","isCellSelectable","addCells","removeCell","trigger","modified","autoSize","selectText","emptyLabelText","escapeCancelsEditing","textNode","minResize","wordWrapPadding","blurEnabled","initialValue","contentEditable","isLegacyEditor","installListeners","applyValue","labelChanged","setAlign","getInitialValue","getEditingValue","getCurrentValue","isCancelEditingKeyEvent","focusLost","isStopEditingEvent","keyCode","keypressHandler","clearOnChange","getEmptyLabelText","keyupHandler","resizeThread","clearTimeout","isEnterStopsCellEditing","isEventSource","lw","bds","hpos","vpos","legacySpacing","isWrapping","getEditorBounds","isInvokesStopCellEditing","getBackgroundColor","absoluteRoot","startEditing","tooltipHandler","hideTooltip","bold","italic","isHideLabel","isSelectText","execCommand","cancel","initial","blur","prepareTextarea","getEditingCell","defaultShapes","defaultEdgeShape","defaultVertexShape","defaultTextShape","legacyControlPosition","forceControlClickHandler","registerShape","initializeShape","configureShape","createShape","getShapeConstructor","createIndicatorShape","getShape","getIndicatorShape","getIndicatorColor","getIndicatorGradientColor","getIndicatorImage","postConfigureShape","resolveColor","checkPlaceholderStyles","values","field","referenced","getSwimlane","swimlaneIndicatorColorAttribute","rstate","rshape","getLabelValue","getLabel","createLabel","isForceHtml","isHtmlLabel","getVerticalAlign","isLabelClipped","initializeLabel","forceGetCell","isLabelEvent","nativeDblClickEnabled","createCellOverlays","getCellOverlays","installCellOverlayListeners","createControl","getFoldingImage","foldingEnabled","createControlClickHandler","collapse","foldCells","innerNode","first","isShapeEvent","redrawLabel","wrapping","isTextShapeInvalid","nextScale","getTextScale","isClipping","vis","redrawLabelShape","check","property","rotateLabelBounds","redrawCellOverlays","getBounds","redrawControl","getControlBounds","insertStateAfter","htmlNode","shapes","getShapesForState","shapeChanged","selectionCellsHandler","updateHandler","isShapeInvalid","doRedrawShape","mxEdgeStyle","EntityRelation","segment","isSourceLeft","sourceGeometry","isTargetLeft","targetGeometry","getRoutingCenterY","xe","ye","dep","midY","Loop","transformControlPoint","getRoutingCenterX","ElbowConnector","SideToSide","TopToBottom","SegmentConnector","sourceScaled","targetScaled","controlHints","scalePointArray","scaleCellState","lastPushed","hint","pushPoint","lastInx","hints","currentTerm","currentPt","hozChan","vertChan","currentHint","fixedVertAlign","fixedHozAlign","inHozChan","inVertChan","orthBuffer","orthPointsFallback","dirVectors","wayPoints1","routePatterns","inlineRoutePatterns","vertexSeperations","limits","LEFT_MASK","TOP_MASK","RIGHT_MASK","BOTTOM_MASK","LEFT","TOP","RIGHT","BOTTOM","SIDE_MASK","CENTER_MASK","SOURCE_MASK","TARGET_MASK","VERTEX_MASK","getJettySize","OrthConnector","sourceEdge","targetEdge","sourceX","sourceY","sourceWidth","sourceHeight","targetX","targetY","targetWidth","targetHeight","sourceBuffer","targetBuffer","totalBuffer","tooShort","newRect","portConstraint","sourceCenX","sourceCenY","targetCenX","sourceTopDist","sourceLeftDist","sourceBottomDist","sourceRightDist","dirPref","horPref","vertPref","preferredHorizDist","preferredVertDist","prefOrdering","preferredOrderSet","sourceIndex","targetIndex","routePattern","currentIndex","lastOrientation","initialOrientation","currentOrientation","nextDirection","directionIndex","tar","sou","side","limit","souTar","getRoutePattern","mxStyleRegistry","putValue","mxGraphView","mxCurrentRootChange","isUp","renderHint","stylesheet","mouseListeners","multiplicities","imageBundles","createCellRenderer","setSelectionModel","createSelectionModel","setStylesheet","createStylesheet","createGraphView","graphModelChangeListener","createHandlers","revalidate","mxCellOverlay","tooltip","mxOutline","mxMultiplicity","validNeighbors","countError","typeError","validNeighborsAllowed","mxLayoutManager","undoHandler","beforeUndo","moveHandler","cellsMoved","cellsResized","mxSwimlaneManager","addEnabled","resizeEnabled","addHandler","isAddEnabled","cellsAdded","isResizeEnabled","isCellVisibleFn","oldValidateCellState","validateCellState","oldBounds","oldStates","getStates","oldScale","oldDoRedrawShape","self","oldPaint","resurse","setScale","resetValidationState","validateCell","setGraphBounds","deltas","mxGraphHandler","panHandler","suspended","updatePreview","updateHint","escapeHandler","refreshHandler","refreshThread","currentDx","currentDy","pBounds","getPreviewBounds","livePreviewUsed","setHandlesVisibleForCells","getHandledSelectionCells","keyHandler","isCloneEvent","isCellsCloneable","isCloneEnabled","cloning","checkPreview","mxPanningHandler","forcePanningHandler","isForcePanningEvent","gestureHandler","eo","isPinchEnabled","initialScale","mouseDownEvent","zoomGraph","mxPopupMenuHandler","inTolerance","mxCellMarker","validColor","invalidColor","mxSelectionCellsHandler","handlers","refresh","getSelectionModel","mxConnectionHandler","mxConstraintHandler","resetHandler","currentFocus","mxRubberband","forceRubberbandHandler","isForceRubberbandEvent","repaint","mxHandle","mxVertexHandler","livePreview","invalidate","mxEdgeHandler","dirty","isRendering","mxElbowEdgeHandler","mxEdgeSegmentHandler","mxKeyHandler","normalKeys","shiftKeys","controlKeys","controlShiftKeys","keydownHandler","keyDown","mxTooltipHandler","mxCellTracker","highlightColor","repaintHandler","handler","escape","hideProperties","config","actions","addActions","cycleAttributeValues","popupHandler","undoManager","createGraph","toolbar","createToolbar","configure","cycleAttributeName","EMPTY_POINT","updatingDocumentResource","captureDocumentGesture","optimizeVmlReflows","updateStyle","lastNode","lastHtmlNode","lastForegroundNode","lastForegroundHtmlNode","setCurrentRoot","sizeDidChange","scaleAndTranslate","previousScale","previousTranslate","viewStateChanged","removeState","includeEdges","invalidating","prevDisplay","placeholder","getEmptyBounds","validateBackground","createBackgroundPageShape","validateBackgroundImage","validateBackgroundPage","getBackgroundImage","redrawBackgroundImage","pageVisible","getBackgroundPageBounds","backgroundPageShape","isHideOnHover","updateCellState","stateValidated","pState","getChildOffsetForCell","updateVertexState","updateEdgeState","updateVertexLabelOffset","updateFixedTerminalPoints","updatePoints","updateFloatingTerminalPoints","updateEdgeBounds","updateEdgeLabelOffset","fg","keepEdgesInForeground","keepEdgesInBackground","updateFixedTerminalPoint","getConnectionConstraint","getFixedTerminalPoint","getConnectionPoint","updateBoundsFromStencil","asp","getEdgeStyle","getTerminalPort","srcBounds","trgBounds","ignoreScale","isLoopStyleEnabled","tc","defaultLoopStyle","isAllowEval","updateFloatingTerminalPoint","getFloatingTerminalPoint","getNextPoint","orth","isOrthogonal","getPerimeterFunction","opposite","gx","gy","getRelativePoint","totalLength","minDist","xSegment","ySegment","projlen","yDistance","setRendering","setAllowEval","getCellStates","getDecoratorPane","decoratorPane","isContainerEvent","isScrollEvent","outWidth","inWidth","outHeight","inHeight","fireGestureEvent","popupMenuHandler","endHandler","createHtmlPane","updateContainerStyle","onResize","updateHtmlCanvasSize","pane","createVmlPane","getTranslateForRoot","cellEditor","portsEnabled","doubleTapEnabled","doubleTapTimeout","doubleTapTolerance","lastTouchY","lastTouchTime","tapAndHoldEnabled","tapAndHoldDelay","tapAndHoldInProgress","tapAndHoldValid","initialTouchX","initialTouchY","defaultOverlap","defaultParent","alternateEdgeStyle","pageBreaksVisible","pageBreakColor","pageBreakDashed","minPageBreakDist","preferPageSize","escapeEnabled","invokesStopCellEditing","enterStopsCellEditing","useScrollbarsForPanning","exportEnabled","importEnabled","cellsLocked","cellsCloneable","cellsEditable","cellsDeletable","cellsMovable","edgeLabelsMovable","vertexLabelsMovable","dropEnabled","splitEnabled","cellsResizable","cellsBendable","cellsSelectable","cellsDisconnectable","autoSizeCells","autoSizeCellsOnAdd","ignoreScrollbars","translateToScrollPosition","timerAutoScroll","allowAutoPanning","maximumGraphBounds","minimumGraphSize","minimumContainerSize","maximumContainerSize","resizeContainer","allowNegativeCoordinates","constrainChildren","constrainRelativeChildren","extendParents","extendParentsOnAdd","extendParentsOnMove","recursiveResize","collapseToPreferredSize","zoomFactor","keepSelectionVisibleOnZoom","centerZoom","resetViewOnRootChange","resetEdgesOnResize","resetEdgesOnMove","resetEdgesOnConnect","allowLoops","multigraph","connectableEdges","allowDanglingEdges","cloneInvalidEdges","disconnectOnMove","labelsVisible","htmlLabels","swimlaneSelectionEnabled","swimlaneNesting","minFitScale","maxFitScale","collapsedImage","expandedImage","warningImage","alreadyConnectedResource","containsValidationErrorsResource","collapseExpandResource","createCellEditor","relatedTarget","createTooltipHandler","createSelectionCellsHandler","connectionHandler","createConnectionHandler","createGraphHandler","panningHandler","createPanningHandler","panningEnabled","createPopupMenuHandler","getStylesheet","getSelectionCellsForChanges","ignoreFn","processChange","updateSelection","removeSelectionCells","setDefaultParent","removeStateForCell","newParent","home","addCellOverlay","removeCellOverlay","removeCellOverlays","clearCellOverlays","setCellWarning","warning","isSelect","setSelectionCell","startEditingAtCell","getSelectionCell","isCellEditable","convertValueToString","cellLabelChanged","isAutoSizeCell","cellSizeUpdated","click","mxe","isTransparentClickEvent","selected","isCellSelected","isSwimlaneSelectionEnabled","getSwimlaneAt","isToggleEvent","reverse","selectCellForEvent","isSiblingSelected","tapAndHold","panningTrigger","marker","currentColor","markedState","mark","createEdgeState","panningManager","createPanningManager","getBorderSizes","borderLeftStyle","borderLeftWidth","paddingTop","borderTopStyle","borderTopWidth","borderRightStyle","borderRightWidth","paddingBottom","borderBottomStyle","borderBottomWidth","getPreferredPageSize","page","hCount","vCount","keepOrigin","ignoreWidth","ignoreHeight","getBorder","cssBorder","w1","h1","w2","h2","s2","doResizeContainer","updatePageBreaks","gb","horizontalCount","verticalCount","horizontalPageBreaks","verticalPageBreaks","drawPageBreaks","breaks","pageBreak","ignoreState","postProcessCellStyle","getImageFromBundles","encodeURIComponent","comma","setCellStyle","toggleCellStyle","toggleCellStyles","toggleCellStyleFlags","alignCells","param","flipEdge","addImageBundle","bundle","removeImageBundle","orderCells","back","cellsOrdered","groupCells","getCellsForGroup","createGroupCell","getBoundsForGroup","ungroupCells","getCellsForUngroup","removeCellsAfterUngroup","cellsRemoved","addAllEdges","removeCellsFromParent","moveGroup","getActualStartSize","allowInvalidEdges","keepPosition","trans","getEdgeValidationError","createVertex","createEdge","addEdge","absolute","constrain","parentState","zero","oldState","isAllowNegativeCoordinates","autoSizeCell","isExtendParentsOnAdd","isExtendParent","extendParent","constrainChild","cellConnected","updateCellSize","getDeletableCells","getAllEdges","disconnectTerminal","connected","tstate","splitEdge","newEdge","toggleCells","cellsToggled","checkFoldable","getFoldableCells","cellsFolded","isCellFoldable","swapBounds","willCollapse","updateAlternateBounds","getPreferredSizeForCell","allCells","ignoreChildren","cellStyle","gs2","resizeCells","isRecursiveResize","cellResized","ignoreRelative","resizeChildCells","constrainChildCells","scaleCell","isCellResizable","origCells","isCloneInvalidEdges","setAllowNegativeCoordinates","isDisconnectOnMove","isAllowDanglingEdges","isExtendParentsOnMove","disconnect","disconnectGraph","translateCell","getCellContainmentArea","getMaximumGraphBounds","sizeFirst","isConstrainRelativeChildren","isConstrainChild","overlap","getOverlap","getOutlineConstraint","getAllConnectionConstraints","setConnectionConstraint","connectCell","isPortsEnabled","getTerminalForPort","isCellDisconnectable","getCurrentRoot","enterGroup","isValidRoot","exitGroup","includeDescendants","addPoint","ignoreGrid","ignoreHorizontal","ignoreVertical","shiftPreview1","shiftPreview2","zoomIn","zoomOut","zoomActual","zoomTo","cw","ch","sh","scrollRectToVisible","zoomToRect","aspectFactor","rectRight","rectBottom","newHeight","deltaHeightBuffer","upperBuffer","newWidth","deltaWidthBuffer","newScale","scrollCellToVisible","tr2","isChanged","widthLimit","heightLimit","ddx","ddy","isCellConnectable","isLoop","isConstrainedEvent","isIgnoreTerminalEvent","validationAlert","isEdgeValid","isValidConnection","sourceOut","targetIn","validateEdge","validateGraph","context","isValid","getCellValidationError","outCount","inCount","rule","setBackgroundImage","isHtmlLabels","setHtmlLabels","getTooltip","tip","getHandler","getTooltipForNode","getTooltipForCell","getCursorForMouseEvent","getCursorForCell","swimlane","getSwimlaneDirection","isTransparentState","setBorder","isResizeContainer","setResizeContainer","isEscapeEnabled","setEscapeEnabled","setInvokesStopCellEditing","setEnterStopsCellEditing","isCellLocked","isCellsLocked","setCellsLocked","getCloneableCells","isCellCloneable","setCellsCloneable","canExportCell","canImportCell","isCellsSelectable","setCellsSelectable","isCellDeletable","isCellsDeletable","setCellsDeletable","isLabelMovable","isCellRotatable","getMovableCells","isCellsMovable","setCellsMovable","setPortsEnabled","getGridSize","setGridSize","getTolerance","setTolerance","isVertexLabelsMovable","setVertexLabelsMovable","isEdgeLabelsMovable","setEdgeLabelsMovable","isSwimlaneNesting","setSwimlaneNesting","setSwimlaneSelectionEnabled","isMultigraph","setMultigraph","isAllowLoops","setAllowDanglingEdges","setConnectableEdges","isConnectableEdges","setCloneInvalidEdges","setAllowLoops","setDisconnectOnMove","setDropEnabled","isSplitEnabled","setSplitEnabled","isCellsResizable","setCellsResizable","isTerminalPointMovable","isCellBendable","isCellsBendable","setCellsBendable","isCellsEditable","setCellsEditable","isCellsDisconnectable","setCellsDisconnectable","isValidSource","isValidTarget","setTooltips","setPanning","isAutoSizeCells","setAutoSizeCells","isExtendParents","setExtendParents","setExtendParentsOnAdd","setExtendParentsOnMove","setRecursiveResize","isConstrainChildren","setConstrainChildren","setConstrainRelativeChildren","isAllowOverlapParent","isValidDropTarget","isSplitTarget","hitsSwimlaneContent","getPointForEvent","addOffset","hit","getCellsBeyond","rightHalfpane","bottomHalfpane","isolate","isSelectionEmpty","getSelectionCount","addSelectionCell","addSelectionCells","removeSelectionCell","selectRegion","selectCellsForEvent","selectNextCell","selectCell","selectPreviousCell","selectParentCell","selectChildCell","isNext","isParent","isChild","sel","selectAll","descendants","selectVertices","selectGroups","selectCells","selectEdges","createHandler","createEdgeHandler","createVertexHandler","createElbowEdgeHandler","createEdgeSegmentHandler","listener","updateMouseEvent","getStateForTouchEvent","isEventIgnored","mouseEvent","lastEvent","mouseMoveRedirect","mouseUpRedirect","isSyntheticEventIgnored","detail","lastMouseX","lastMouseY","ignoreMouseEvents","isEventSourceIgnored","candidate","getEventState","currentTime","fireDoubleClick","lastTouchEvent","lastTouchX","doubleClickCounter","doubleClickFired","lastTouchCell","tapAndHoldThread","consumeMouseEvent","destroyed","graphRenderHint","showViewport","sizerSize","updateOnPan","sizerImage","forceVmlHandles","outlineGraphModelChanged","selectionBorder","redirect","redirect2","sizer","createSizer","setZoomEnabled","getSourceContainerSize","getOutlineOffset","getSourceGraphBounds","sourceScale","scaledGraphBounds","unscaledGraphBounds","unscaledFinderBounds","union","completeWidth","completeHeight","outlineScale","navView","scale2","scale3","allowHandleBoundsCheck","getTranslateForEvent","checkTerminal","checkNeighbors","sourceValue","targetValue","checkType","attrValue","bubbling","isBubbling","setBubbling","hasLayout","getLayout","executeLayoutForCells","getCellsForChanges","getCellsForChange","addCellsWithLayout","addDescendantsWithLayout","addAncestorsWithLayout","sorted","layoutCells","bubble","executeLayout","setHorizontal","setAddEnabled","setResizeEnabled","isSwimlaneIgnored","isCellHorizontal","swimlaneAdded","parentHorizontal","resizeSwimlane","addEdges","translateState","revalidateState","maxCells","highlightEnabled","cloneEnabled","moveEnabled","handlesVisible","updateCursor","selectEnabled","removeEmptyParents","connectOnDrop","scrollOnMove","previewColor","htmlPreview","scaleGrid","rotationEnabled","maxLivePreview","allowLivePreview","setCloneEnabled","isMoveEnabled","setMoveEnabled","isSelectEnabled","setSelectEnabled","isRemoveCellsFromParent","setRemoveCellsFromParent","isPropagateSelectionCell","immediate","getInitialCellForEvent","isDelayedSelection","isHandled","selectDelayed","delayedSelection","cellWasClicked","initialCell","createPreviewShape","cellCount","addStates","ignore","opps","isCellMoving","useGuidesForEvent","vector","removeHint","roundLength","livePreviewActive","resetLivePreview","setHighlightColor","remote","updateLivePreview","updatePreviewShape","realState","tempState","originalPointerEvents","pt0","ptn","redrawHandles","resetPreviewStates","suspend","resume","setHandlesVisible","destroyShapes","guides","shouldRemoveCellsFromParent","shouldRemoveParent","useLeftButtonForPanning","usePopupTrigger","ignoreCell","previewEnabled","useGrid","pinchEnabled","maxScale","isPanningEnabled","setPanningEnabled","setPinchEnabled","isPanningTrigger","consumePanningTrigger","selectOnPopup","clearSelectionOnBackground","triggerX","triggerY","screenX","screenY","isSelectOnPopup","popupTrigger","getCellForPopupEvent","hotspotEnabled","validState","setHotspot","getHotspot","setHotspotEnabled","isHotspotEnabled","hasValidState","getValidState","getMarkedState","unmark","process","setCurrentState","isValidState","getMarkerColor","markCell","getStateToMark","maxHandlers","oldHandlers","isHandlerActive","updateParentHighlight","moveIconFront","moveIconBack","connectImage","targetConnectImage","createTarget","constraintHandler","waypointsEnabled","ignoreMouseDown","connectIconOffset","drillHandler","mouseDownCounter","movePreviewAway","outlineConnect","insertBeforeSource","isInsertBefore","isCreateTarget","setCreateTarget","iconState","redrawIcons","icons","isConnectableCell","isConnecting","validateConnection","getConnectImage","isMoveIconToFrontForState","createIcons","currentState","getIconPosition","destroyIcons","selectedIcon","isStartEvent","currentConstraint","sourceConstraint","waypoints","isImmediateConnectSource","isOutlineConnectEvent","clientLeft","clientTop","gridX","gridY","isHighlightAt","updateCurrentState","isCellEnabled","setFocus","convertWaypoint","snapToPreview","pt2","getTargetPerimeterPoint","getSourcePerimeterPoint","originalPoint","drawPreview","hitsIcon","updateIcons","realPoints","targetPerimeter","sourcePerimeter","isStopEvent","addWaypointForEvent","checkConstraints","getEdgeColor","terminalInserted","createTargetVertex","getAlignmentTolerance","pointImage","focusIcons","focusHighlight","currentFocusArea","focusPoints","getImageForConstraint","destroyFocusHighlight","isKeepFocusEvent","getCellForEvent","existingEdge","mouseleaveHandler","grid","mouse","minDistSq","hl","createHighlightShape","cp","defaultOpacity","sharedDiv","currentY","createMouseEvent","getPosition","setPosition","copyStyle","processEvent","getTotalRotation","flipPoint","snapPoint","isHtmlRequired","initShape","singleSizer","handleImage","parentHighlightEnabled","rotationRaster","rotationCursor","movePreviewToFront","manageSizers","constrainGroupByChildren","rotationHandleVSpacing","horizontalOffset","verticalOffset","selectionBounds","getSelectionBounds","createSelectionShape","sizers","labelShape","isRotationHandleVisible","rotationShape","customHandles","createCustomHandles","updateMinBounds","isCenteredEvent","minBounds","createParentHighlightShape","getSelectionColor","getSelectionStrokeWidth","isSelectionDashed","createSizerShape","isSizerVisible","moveSizerTo","getHandleForEvent","checkShape","real","isCustomHandleEvent","handle","isLivePreviewBorder","childOffsetX","childOffsetY","isGhostPreview","ghostPreview","createGhostPreview","preview","getRotationHandlePosition","startAngle","atan","startDist","hideSizers","edgeHandlers","checkTolerance","roundAngle","moveToFront","moveLabel","rotateVertex","resizeVertex","currentAlpha","raster","unscaledBounds","dx3","dy3","dx4","dy4","dx5","dy5","rotateCell","rotateClick","constrained","moveChildren","centered","cdx","cdy","ignoreHandles","getHandlePadding","getSizerBounds","isCustomHandleVisible","crs","da","isParentHighlightVisible","isDestroyed","parentHighlight","getSelectionBorderBounds","bends","removeEnabled","dblClickRemoveEnabled","mergeRemoveEnabled","straightRemoveEnabled","virtualBendsEnabled","virtualBendOpacity","preferHtml","snapToTerminals","manageLabelHandle","abspoints","getSelectionPoints","targetState","createBends","isVirtualBendsEnabled","virtualBends","createVirtualBends","createLabelHandleShape","initBend","isAddPointEvent","isRemovePointEvent","otherCell","isHandleVisible","bend","createHandleShape","removePoint","isHandleEnabled","labelHandleImage","isAddVirtualBendEvent","isTarget","isLabel","clonePreviewState","getSnapToTerminalTolerance","isSnapToTerminalsEvent","snapToPoint","snapToTerminal","getPreviewTerminalState","getPreviewPoints","updatePreviewState","targetConstraint","setPreviewColor","changeTerminalPoint","changePoints","isClone","addPointAt","getHandleFillColor","checkLabelHandle","xn","yn","bn","redrawInnerBends","destroyBends","flipEnabled","doubleClickOrientationResource","createVirtualBend","dblClickHandler","getCursorForBend","getCurrentPoints","pt1","rpts","straight","bindKey","code","bindShiftKey","bindControlKey","bindControlShiftKey","getFunction","isGraphEvent","boundFunction","ignoreTouchEvents","hideOnHover","setHideOnHover","getStateForEvent","stateSource","resetTimer","restart","keepOnTop","drawHighlight","getStrokeWidth","bindAction","createMenu","conditions","createConditions","addItems","condition","as","enabledCond","addAction","isCell","condNodes","insertFunction","pressed","addActionOption","mode","setMode","addPrototype","ptype","installDropHandler","addVertex","horizontalFlow","edgeGeometry","sprite","loader","askZoomResource","lastSavedResource","currentFileResource","propertiesResource","tasksResource","helpResource","outlineResource","dblClickAction","swimlaneRequired","forcedInserting","templates","defaultEdge","defaultEdgeStyle","defaultGroup","groupBorderSize","filename","postParameterName","escapePostData","urlPost","urlImage","layoutDiagram","swimlaneSpacing","maintainSwimlanes","layoutSwimlanes","cycleAttributeIndex","tasks","tasksWindowImage","tasksTop","help","helpWindowImage","urlHelp","helpWidth","helpHeight","propertiesWidth","propertiesHeight","movePropertiesDialog","validating","isModified","setModified","getUrlImage","showProperties","showTasks","showHelp","showOutline","decode","resetHistory","resetFirstTime","cookie","actionname","addTemplate","template","getTemplate","installDblClickHandler","installUndoHandler","installDrillHandler","installChangeHandler","installInsertHandler","createPopupMenu","createSwimlaneManager","createLayoutManager","swimlaneMgr","layoutMgr","swimlaneLayout","createSwimlaneLayout","diagramLayout","createDiagramLayout","setGraphContainer","rubberband","insertHandler","gs","setToolbarContainer","setStatusContainer","tstamp","toLocaleString","setStatus","setTitleContainer","getTitle","treeLayout","getRootTitle","createGroup","readGraphModel","getUrlPost","writeGraphModel","postDiagram","swapStyles","second","createProperties","isPropertiesVisible","yField","xField","widthField","heightField","texts","okFunction","cancelFunction","createTasks","refreshTasks","frame","modename","consumeCycleAttribute","cycleAttribute","isConstrainedMoving","mxCodecRegistry","codecs","aliases","register","codec","classname","addAlias","codecname","getCodec","mxObjectCodec","objects","idrefs","elements","encodeDefaults","putObject","getObject","updateElements","addElement","Error","reference","enc","into","dec","encodeCell","isCellCodec","decodeCell","restoreStructures","decoder","insertIntoGraph","cloneTemplate","getFieldName","attributename","mapped","getAttributeName","fieldname","isExcluded","isReference","beforeEncode","encodeObject","afterEncode","encodeValue","writeAttribute","writePrimitiveAttribute","writeComplexAttribute","convertAttributeToXml","isBooleanAttribute","convertAttributeFromXml","isNumericAttribute","beforeDecode","decodeNode","afterDecode","decodeAttributes","decodeChildren","decodeAttribute","isIgnoredAttribute","processInclude","decodeChild","getFieldTemplate","addObjectValue","isWrite","object","mxCellCodec","rootNode","decodeRoot","rootCell","mxModelCodec","mxRootChangeCodec","childRef","mxChildChangeCodec","mxTerminalChangeCodec","mxGenericChangeCodec","variable","mxGraphCodec","mxGraphViewCodec","mxStylesheetCodec","styleNode","getStringValue","mxDefaultKeyHandlerCodec","mxDefaultToolbarCodec","act","inc","mxDefaultPopupMenuCodec","decodeTemplates","decodeUi","setMapContainer","mxEditorCodec"],"mappings":"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","file":"static/js/3.1c3ba608e14324498f26.js","sourcesContent":["import mx from 'mxgraph';\nconst mxgraph = mx({\n    mxImageBasePath: './src/images',\n    mxBasePath: './src'\n});\n// decode bug https://github.com/jgraph/mxgraph/issues/49\nwindow.mxGraph = mxgraph.mxGraph;\nwindow.mxGraphModel = mxgraph.mxGraphModel;\nwindow.mxEditor = mxgraph.mxEditor;\nwindow.mxGeometry = mxgraph.mxGeometry;\nwindow.mxDefaultKeyHandler = mxgraph.mxDefaultKeyHandler;\nwindow.mxDefaultPopupMenu = mxgraph.mxDefaultPopupMenu;\nwindow.mxStylesheet = mxgraph.mxStylesheet;\nwindow.mxDefaultToolbar = mxgraph.mxDefaultToolbar;\n\nexport default mxgraph;\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/index.js","<template>\n    <div class=\"hello\">\n\n        <div onload=\"main(document.getElementById('graphContainer'),\n\t\t\tdocument.getElementById('outlineContainer'),\n\t\t \tdocument.getElementById('toolbarContainer'),\n\t\t\tdocument.getElementById('sidebarContainer'),\n            document.getElementById('statusContainer'));\" style=\"margin:0px;\" class=\"grf\" ref=\"graph_container\">\n\n            <!-- Creates a container for the splash screen -->\n            <!-- <div id=\"splash\"\n                style=\"position:absolute;top:0px;left:0px;width:100%;height:100%;background:white;z-index:1;\">\n                <center id=\"splash\" style=\"padding-top:230px;\">\n                    <img src=\"editors/images/loading.gif\">\n                </center>\n            </div> -->\n\n            <!-- Creates a container for the sidebar -->\n            <div id=\"toolbarContainer\"\n                style=\"position:absolute;white-space:nowrap;overflow:hidden;top:0px;left:0px;max-height:24px;height:36px;right:0px;padding:6px;background-image:url('images/toolbar_bg.gif');\">\n            </div>\n\n            <!-- Creates a container for the toolboox -->\n            <!-- <div id=\"sidebarContainer\"\n                style=\"position:absolute;overflow:hidden;top:36px;left:0px;bottom:36px;max-width:52px;width:56px;padding-top:10px;padding-left:4px;background-image:url('images/sidebar_bg.gif');\">\n            </div> -->\n\n            <!-- Creates a container for the graph -->\n            <!-- <div id=\"graphContainer\"\n                style=\"position:absolute;overflow:hidden;top:36px;left:60px;bottom:36px;right:0px;background-image:url('editors/images/grid.gif');cursor:default;\">\n            </div> -->\n\n            <!-- Creates a container for the outline -->\n            <!-- <div id=\"outlineContainer\"\n                style=\"position:absolute;overflow:hidden;top:36px;right:0px;width:200px;height:140px;background:transparent;border-style:solid;border-color:black;\">\n            </div> -->\n\n            <!-- Creates a container for the sidebar -->\n            <!-- <div id=\"statusContainer\"\n                style=\"text-align:right;position:absolute;overflow:hidden;bottom:0px;left:0px;max-height:24px;height:36px;right:0px;color:white;padding:6px;background-image:url('images/toolbar_bg.gif');\">\n                <div style=\"font-size:10pt;float:left;\">\n                    Created with <a href=\"http://www.jgraph.com\" target=\"_blank\">mxGraph</a>\n                </div>\n            </div> -->\n        </div>\n\n\n        <template>\n            <div class=\"block\">\n                <el-slider v-model=\"value\" vertical height=\"200px\"> </el-slider>\n            </div>\n        </template>\n\n    </div>\n</template>\n\n<script>\n    import mxgraph from '../../utils/index.js';\n    // const { mxGraph, mxClient, mxCodec, mxUtils, mxConstants, mxPerimeter } = mxgraph;\n    export default {\n        name: 'HelloWorld',\n        data() {\n            return {\n                value: 50\n            }\n        },\n        methods: {\n            save() {\n                this.$refs[\"form\"].validate((valid, model) => {\n                    console.log(valid);\n                    console.log(model);\n                })\n            },\n            init() {\n\n                function main(container, outline, toolbar, sidebar, status) {\n                    // Checks if the browser is supported\n                    if (!mxClient.isBrowserSupported()) {\n                        // Displays an error message if the browser is not supported.\n                        mxUtils.error('Browser is not supported!', 200, false);\n                    }\n                    else {\n                        // Assigns some global constants for general behaviour, eg. minimum\n                        // size (in pixels) of the active region for triggering creation of\n                        // new connections, the portion (100%) of the cell area to be used\n                        // for triggering new connections, as well as some fading options for\n                        // windows and the rubberband selection.\n                        mxConstants.MIN_HOTSPOT_SIZE = 16;\n                        mxConstants.DEFAULT_HOTSPOT = 1;\n\n                        // Enables guides\n                        mxGraphHandler.prototype.guidesEnabled = true;\n                        // Alt disables guides\n                        mxGuide.prototype.isEnabledForEvent = function (evt) {\n                            return !mxEvent.isAltDown(evt);\n                        };\n                        // Enables snapping waypoints to terminals\n                        mxEdgeHandler.prototype.snapToTerminals = true;\n                        // Workaround for Internet Explorer ignoring certain CSS directives\n                        if (mxClient.IS_QUIRKS) {\n                            document.body.style.overflow = 'hidden';\n                            new mxDivResizer(container);\n                            new mxDivResizer(outline);\n                            new mxDivResizer(toolbar);\n                            new mxDivResizer(sidebar);\n                            new mxDivResizer(status);\n                        }\n\n                        // Creates a wrapper editor with a graph inside the given container.\n                        // The editor is used to create certain functionality for the\n                        // graph, such as the rubberband selection, but most parts\n                        // of the UI are custom in this example.\n                        var editor = new mxEditor();\n                        var graph = editor.graph;\n                        var model = graph.getModel();\n                        // Disable highlight of cells when dragging from toolbar\n                        graph.setDropEnabled(false);\n                        // Uses the port icon while connections are previewed\n                        graph.connectionHandler.getConnectImage = function (state) {\n                            return new mxImage(state.style[mxConstants.STYLE_IMAGE], 16, 16);\n                        };\n                        // Centers the port icon on the target port\n                        graph.connectionHandler.targetConnectImage = true;\n                        // Does not allow dangling edges\n                        graph.setAllowDanglingEdges(false);\n                        // Sets the graph container and configures the editor\n                        editor.setGraphContainer(container);\n                        var config = mxUtils.load(\n                            'editors/config/keyhandler-commons.xml').\n                            getDocumentElement();\n                        editor.configure(config);\n\n                        // Defines the default group to be used for grouping. The\n                        // default group is a field in the mxEditor instance that\n                        // is supposed to be a cell which is cloned for new cells.\n                        // The groupBorderSize is used to define the spacing between\n                        // the children of a group and the group bounds.\n                        var group = new mxCell('Group', new mxGeometry(), 'group');\n                        group.setVertex(true);\n                        group.setConnectable(false);\n                        editor.defaultGroup = group;\n                        editor.groupBorderSize = 20;\n                        // Disables drag-and-drop into non-swimlanes.\n                        graph.isValidDropTarget = function (cell, cells, evt) {\n                            return this.isSwimlane(cell);\n                        };\n\n                        // Disables drilling into non-swimlanes.\n                        graph.isValidRoot = function (cell) {\n                            return this.isValidDropTarget(cell);\n                        }\n                        // Does not allow selection of locked cells\n                        graph.isCellSelectable = function (cell) {\n                            return !this.isCellLocked(cell);\n                        };\n                        // Returns a shorter label if the cell is collapsed and no\n                        // label for expanded groups\n                        graph.getLabel = function (cell) {\n                            var tmp = mxGraph.prototype.getLabel.apply(this, arguments); // \"supercall\"\n\n                            if (this.isCellLocked(cell)) {\n                                // Returns an empty label but makes sure an HTML\n                                // element is created for the label (for event\n                                // processing wrt the parent label)\n                                return '';\n                            }\n                            else if (this.isCellCollapsed(cell)) {\n                                var index = tmp.indexOf('</h1>');\n\n                                if (index > 0) {\n                                    tmp = tmp.substring(0, index + 5);\n                                }\n                            }\n\n                            return tmp;\n                        }\n                        // Disables HTML labels for swimlanes to avoid conflict\n                        // for the event processing on the child cells. HTML\n                        // labels consume events before underlying cells get the\n                        // chance to process those events.\n                        //\n                        // NOTE: Use of HTML labels is only recommended if the specific\n                        // features of such labels are required, such as special label\n                        // styles or interactive form fields. Otherwise non-HTML labels\n                        // should be used by not overidding the following function.\n                        // See also: configureStylesheet.\n                        graph.isHtmlLabel = function (cell) {\n                            return !this.isSwimlane(cell);\n                        }\n                        // To disable the folding icon, use the following code:\n                        /*graph.isCellFoldable = function(cell)\n                        {\n                            return false;\n                        }*/\n                        // Shows a \"modal\" window when double clicking a vertex.\n                        graph.dblClick = function (evt, cell) {\n                            // Do not fire a DOUBLE_CLICK event here as mxEditor will\n                            // consume the event and start the in-place editor.\n                            if (this.isEnabled() &&\n                                !mxEvent.isConsumed(evt) &&\n                                cell != null &&\n                                this.isCellEditable(cell)) {\n                                if (this.model.isEdge(cell) ||\n                                    !this.isHtmlLabel(cell)) {\n                                    this.startEditingAtCell(cell);\n                                }\n                                else {\n                                    var content = document.createElement('div');\n                                    content.innerHTML = this.convertValueToString(cell);\n                                    showModalWindow(this, 'Properties', content, 400, 300);\n                                }\n                            }\n                            // Disables any default behaviour for the double click\n                            mxEvent.consume(evt);\n                        };\n                        // Enables new connections\n                        graph.setConnectable(true);\n                        // Adds all required styles to the graph (see below)\n                        configureStylesheet(graph);\n                        // Adds sidebar icons.\n                        //\n                        // NOTE: For non-HTML labels a simple string as the third argument\n                        // and the alternative style as shown in configureStylesheet should\n                        // be used. For example, the first call to addSidebar icon would\n                        // be as follows:\n                        // addSidebarIcon(graph, sidebar, 'Website', 'images/icons48/earth.png');\n                        addSidebarIcon(graph, sidebar,\n                            '<h1 style=\"margin:0px;\">Website</h1><br>' +\n                            '<img src=\"images/icons48/earth.png\" width=\"48\" height=\"48\">' +\n                            '<br>' +\n                            '<a href=\"http://www.jgraph.com\" target=\"_blank\">Browse</a>',\n                            'images/icons48/earth.png');\n                        addSidebarIcon(graph, sidebar,\n                            '<h1 style=\"margin:0px;\">Process</h1><br>' +\n                            '<img src=\"images/icons48/gear.png\" width=\"48\" height=\"48\">' +\n                            '<br><select><option>Value1</option><option>Value2</option></select><br>',\n                            'images/icons48/gear.png');\n                        addSidebarIcon(graph, sidebar,\n                            '<h1 style=\"margin:0px;\">Keys</h1><br>' +\n                            '<img src=\"images/icons48/keys.png\" width=\"48\" height=\"48\">' +\n                            '<br>' +\n                            '<button onclick=\"mxUtils.alert(\\'generate\\');\">Generate</button>',\n                            'images/icons48/keys.png');\n                        addSidebarIcon(graph, sidebar,\n                            '<h1 style=\"margin:0px;\">New Mail</h1><br>' +\n                            '<img src=\"images/icons48/mail_new.png\" width=\"48\" height=\"48\">' +\n                            '<br><input type=\"checkbox\"/>CC Archive',\n                            'images/icons48/mail_new.png');\n                        addSidebarIcon(graph, sidebar,\n                            '<h1 style=\"margin:0px;\">Server</h1><br>' +\n                            '<img src=\"images/icons48/server.png\" width=\"48\" height=\"48\">' +\n                            '<br>' +\n                            '<input type=\"text\" size=\"12\" value=\"127.0.0.1\"/>',\n                            'images/icons48/server.png');\n                        // Displays useful hints in a small semi-transparent box.\n                        var hints = document.createElement('div');\n                        hints.style.position = 'absolute';\n                        hints.style.overflow = 'hidden';\n                        hints.style.width = '230px';\n                        hints.style.bottom = '56px';\n                        hints.style.height = '76px';\n                        hints.style.right = '20px';\n\n                        hints.style.background = 'black';\n                        hints.style.color = 'white';\n                        hints.style.fontFamily = 'Arial';\n                        hints.style.fontSize = '10px';\n                        hints.style.padding = '4px';\n                        mxUtils.setOpacity(hints, 50);\n\n                        mxUtils.writeln(hints, '- Drag an image from the sidebar to the graph');\n                        mxUtils.writeln(hints, '- Doubleclick on a vertex or edge to edit');\n                        mxUtils.writeln(hints, '- Shift- or Rightclick and drag for panning');\n                        mxUtils.writeln(hints, '- Move the mouse over a cell to see a tooltip');\n                        mxUtils.writeln(hints, '- Click and drag a vertex to move and connect');\n                        document.body.appendChild(hints);\n\n                        // Creates a new DIV that is used as a toolbar and adds\n                        // toolbar buttons.\n                        var spacer = document.createElement('div');\n                        spacer.style.display = 'inline';\n                        spacer.style.padding = '8px';\n\n                        addToolbarButton(editor, toolbar, 'groupOrUngroup', '(Un)group', 'images/group.png');\n\n                        // Defines a new action for deleting or ungrouping\n                        editor.addAction('groupOrUngroup', function (editor, cell) {\n                            cell = cell || editor.graph.getSelectionCell();\n                            if (cell != null && editor.graph.isSwimlane(cell)) {\n                                editor.execute('ungroup', cell);\n                            }\n                            else {\n                                editor.execute('group');\n                            }\n                        });\n                        addToolbarButton(editor, toolbar, 'delete', 'Delete', 'images/delete2.png');\n\n                        toolbar.appendChild(spacer.cloneNode(true));\n\n                        addToolbarButton(editor, toolbar, 'cut', 'Cut', 'images/cut.png');\n                        addToolbarButton(editor, toolbar, 'copy', 'Copy', 'images/copy.png');\n                        addToolbarButton(editor, toolbar, 'paste', 'Paste', 'images/paste.png');\n                        toolbar.appendChild(spacer.cloneNode(true));\n\n                        addToolbarButton(editor, toolbar, 'undo', '', 'images/undo.png');\n                        addToolbarButton(editor, toolbar, 'redo', '', 'images/redo.png');\n\n                        toolbar.appendChild(spacer.cloneNode(true));\n\n                        addToolbarButton(editor, toolbar, 'show', 'Show', 'images/camera.png');\n                        addToolbarButton(editor, toolbar, 'print', 'Print', 'images/printer.png');\n\n                        toolbar.appendChild(spacer.cloneNode(true));\n                        // Defines a new export action\n                        editor.addAction('export', function (editor, cell) {\n                            var textarea = document.createElement('textarea');\n                            textarea.style.width = '400px';\n                            textarea.style.height = '400px';\n                            var enc = new mxCodec(mxUtils.createXmlDocument());\n                            var node = enc.encode(editor.graph.getModel());\n                            textarea.value = mxUtils.getPrettyXml(node);\n                            showModalWindow(graph, 'XML', textarea, 410, 440);\n                        });\n                        addToolbarButton(editor, toolbar, 'export', 'Export', 'images/export1.png');\n                        // ---\n\n                        // Adds toolbar buttons into the status bar at the bottom\n                        // of the window.\n                        addToolbarButton(editor, status, 'collapseAll', 'Collapse All', 'images/navigate_minus.png', true);\n                        addToolbarButton(editor, status, 'expandAll', 'Expand All', 'images/navigate_plus.png', true);\n                        status.appendChild(spacer.cloneNode(true));\n\n                        addToolbarButton(editor, status, 'enterGroup', 'Enter', 'images/view_next.png', true);\n                        addToolbarButton(editor, status, 'exitGroup', 'Exit', 'images/view_previous.png', true);\n                        status.appendChild(spacer.cloneNode(true));\n                        addToolbarButton(editor, status, 'zoomIn', '', 'images/zoom_in.png', true);\n                        addToolbarButton(editor, status, 'zoomOut', '', 'images/zoom_out.png', true);\n                        addToolbarButton(editor, status, 'actualSize', '', 'images/view_1_1.png', true);\n                        addToolbarButton(editor, status, 'fit', '', 'images/fit_to_size.png', true);\n\n                        // Creates the outline (navigator, overview) for moving\n                        // around the graph in the top, right corner of the window.\n                        var outln = new mxOutline(graph, outline);\n                        // To show the images in the outline, uncomment the following code\n                        //outln.outline.labelsVisible = true;\n                        //outln.outline.setHtmlLabels(true);\n\n                        // Fades-out the splash screen after the UI has been loaded.\n                        var splash = document.getElementById('splash');\n                        if (splash != null) {\n                            try {\n                                mxEvent.release(splash);\n                                mxEffects.fadeOut(splash, 100, true);\n                            }\n                            catch (e) {\n\n                                // mxUtils is not available (library not loaded)\n                                splash.parentNode.removeChild(splash);\n                            }\n                        }\n                    }\n                };\n\n                function addToolbarButton(editor, toolbar, action, label, image, isTransparent) {\n                    var button = document.createElement('button');\n                    button.style.fontSize = '10';\n                    if (image != null) {\n                        var img = document.createElement('img');\n                        img.setAttribute('src', image);\n                        img.style.width = '16px';\n                        img.style.height = '16px';\n                        img.style.verticalAlign = 'middle';\n                        img.style.marginRight = '2px';\n                        button.appendChild(img);\n                    }\n                    if (isTransparent) {\n                        button.style.background = 'transparent';\n                        button.style.color = '#FFFFFF';\n                        button.style.border = 'none';\n                    }\n                    mxEvent.addListener(button, 'click', function (evt) {\n                        editor.execute(action);\n                    });\n                    mxUtils.write(button, label);\n                    toolbar.appendChild(button);\n                };\n\n                function showModalWindow(graph, title, content, width, height) {\n                    var background = document.createElement('div');\n                    background.style.position = 'absolute';\n                    background.style.left = '0px';\n                    background.style.top = '0px';\n                    background.style.right = '0px';\n                    background.style.bottom = '0px';\n                    background.style.background = 'black';\n                    mxUtils.setOpacity(background, 50);\n                    document.body.appendChild(background);\n\n                    if (mxClient.IS_IE) {\n                        new mxDivResizer(background);\n                    }\n\n                    var x = Math.max(0, document.body.scrollWidth / 2 - width / 2);\n                    var y = Math.max(10, (document.body.scrollHeight ||\n                        document.documentElement.scrollHeight) / 2 - height * 2 / 3);\n                    var wnd = new mxWindow(title, content, x, y, width, height, false, true);\n                    wnd.setClosable(true);\n\n                    // Fades the background out after after the window has been closed\n                    wnd.addListener(mxEvent.DESTROY, function (evt) {\n                        graph.setEnabled(true);\n                        mxEffects.fadeOut(background, 50, true,\n                            10, 30, true);\n                    });\n                    graph.setEnabled(false);\n                    graph.tooltipHandler.hide();\n                    wnd.setVisible(true);\n                };\n\n                function addSidebarIcon(graph, sidebar, label, image) {\n                    // Function that is executed when the image is dropped on\n                    // the graph. The cell argument points to the cell under\n                    // the mousepointer if there is one.\n                    var funct = function (graph, evt, cell, x, y) {\n                        var parent = graph.getDefaultParent();\n                        var model = graph.getModel();\n\n                        var v1 = null;\n\n                        model.beginUpdate();\n                        try {\n                            // NOTE: For non-HTML labels the image must be displayed via the style\n                            // rather than the label markup, so use 'image=' + image for the style.\n                            // as follows: v1 = graph.insertVertex(parent, null, label,\n                            // pt.x, pt.y, 120, 120, 'image=' + image);\n                            v1 = graph.insertVertex(parent, null, label, x, y, 120, 120);\n                            v1.setConnectable(false);\n\n                            // Presets the collapsed size\n                            v1.geometry.alternateBounds = new mxRectangle(0, 0, 120, 40);\n\n                            // Adds the ports at various relative locations\n                            var port = graph.insertVertex(v1, null, 'Trigger', 0, 0.25, 16, 16,\n                                'port;image=editors/images/overlays/flash.png;align=right;imageAlign=right;spacingRight=18', true);\n                            port.geometry.offset = new mxPoint(-6, -8);\n\n                            var port = graph.insertVertex(v1, null, 'Input', 0, 0.75, 16, 16,\n                                'port;image=editors/images/overlays/check.png;align=right;imageAlign=right;spacingRight=18', true);\n                            port.geometry.offset = new mxPoint(-6, -4);\n\n                            var port = graph.insertVertex(v1, null, 'Error', 1, 0.25, 16, 16,\n                                'port;image=editors/images/overlays/error.png;spacingLeft=18', true);\n                            port.geometry.offset = new mxPoint(-8, -8);\n                            var port = graph.insertVertex(v1, null, 'Result', 1, 0.75, 16, 16,\n                                'port;image=editors/images/overlays/information.png;spacingLeft=18', true);\n                            port.geometry.offset = new mxPoint(-8, -4);\n                        }\n                        finally {\n                            model.endUpdate();\n                        }\n\n                        graph.setSelectionCell(v1);\n                    }\n\n                    // Creates the image which is used as the sidebar icon (drag source)\n                    var img = document.createElement('img');\n                    img.setAttribute('src', image);\n                    img.style.width = '48px';\n                    img.style.height = '48px';\n                    img.title = 'Drag this to the diagram to create a new vertex';\n                    sidebar.appendChild(img);\n\n                    var dragElt = document.createElement('div');\n                    dragElt.style.border = 'dashed black 1px';\n                    dragElt.style.width = '120px';\n                    dragElt.style.height = '120px';\n\n                    // Creates the image which is used as the drag icon (preview)\n                    var ds = mxUtils.makeDraggable(img, graph, funct, dragElt, 0, 0, true, true);\n                    ds.setGuidesEnabled(true);\n                };\n\n                function configureStylesheet(graph) {\n                    var style = new Object();\n                    style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;\n                    style[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;\n                    style[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;\n                    style[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE;\n                    style[mxConstants.STYLE_GRADIENTCOLOR] = '#41B9F5';\n                    style[mxConstants.STYLE_FILLCOLOR] = '#8CCDF5';\n                    style[mxConstants.STYLE_STROKECOLOR] = '#1B78C8';\n                    style[mxConstants.STYLE_FONTCOLOR] = '#000000';\n                    style[mxConstants.STYLE_ROUNDED] = true;\n                    style[mxConstants.STYLE_OPACITY] = '80';\n                    style[mxConstants.STYLE_FONTSIZE] = '12';\n                    style[mxConstants.STYLE_FONTSTYLE] = 0;\n                    style[mxConstants.STYLE_IMAGE_WIDTH] = '48';\n                    style[mxConstants.STYLE_IMAGE_HEIGHT] = '48';\n                    graph.getStylesheet().putDefaultVertexStyle(style);\n                    // NOTE: Alternative vertex style for non-HTML labels should be as\n                    // follows. This repaces the above style for HTML labels.\n                    /*var style = new Object();\n                    style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_LABEL;\n                    style[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;\n                    style[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_TOP;\n                    style[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;\n                    style[mxConstants.STYLE_IMAGE_ALIGN] = mxConstants.ALIGN_CENTER;\n                    style[mxConstants.STYLE_IMAGE_VERTICAL_ALIGN] = mxConstants.ALIGN_TOP;\n                    style[mxConstants.STYLE_SPACING_TOP] = '56';\n                    style[mxConstants.STYLE_GRADIENTCOLOR] = '#7d85df';\n                    style[mxConstants.STYLE_STROKECOLOR] = '#5d65df';\n                    style[mxConstants.STYLE_FILLCOLOR] = '#adc5ff';\n                    style[mxConstants.STYLE_FONTCOLOR] = '#1d258f';\n                    style[mxConstants.STYLE_FONTFAMILY] = 'Verdana';\n                    style[mxConstants.STYLE_FONTSIZE] = '12';\n                    style[mxConstants.STYLE_FONTSTYLE] = '1';\n                    style[mxConstants.STYLE_ROUNDED] = '1';\n                    style[mxConstants.STYLE_IMAGE_WIDTH] = '48';\n                    style[mxConstants.STYLE_IMAGE_HEIGHT] = '48';\n                    style[mxConstants.STYLE_OPACITY] = '80';\n                    graph.getStylesheet().putDefaultVertexStyle(style);*/\n                    style = new Object();\n                    style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_SWIMLANE;\n                    style[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;\n                    style[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;\n                    style[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_TOP;\n                    style[mxConstants.STYLE_FILLCOLOR] = '#FF9103';\n                    style[mxConstants.STYLE_GRADIENTCOLOR] = '#F8C48B';\n                    style[mxConstants.STYLE_STROKECOLOR] = '#E86A00';\n                    style[mxConstants.STYLE_FONTCOLOR] = '#000000';\n                    style[mxConstants.STYLE_ROUNDED] = true;\n                    style[mxConstants.STYLE_OPACITY] = '80';\n                    style[mxConstants.STYLE_STARTSIZE] = '30';\n                    style[mxConstants.STYLE_FONTSIZE] = '16';\n                    style[mxConstants.STYLE_FONTSTYLE] = 1;\n                    graph.getStylesheet().putCellStyle('group', style);\n\n                    style = new Object();\n                    style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_IMAGE;\n                    style[mxConstants.STYLE_FONTCOLOR] = '#774400';\n                    style[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;\n                    style[mxConstants.STYLE_PERIMETER_SPACING] = '6';\n                    style[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_LEFT;\n                    style[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE;\n                    style[mxConstants.STYLE_FONTSIZE] = '10';\n                    style[mxConstants.STYLE_FONTSTYLE] = 2;\n                    style[mxConstants.STYLE_IMAGE_WIDTH] = '16';\n                    style[mxConstants.STYLE_IMAGE_HEIGHT] = '16';\n                    graph.getStylesheet().putCellStyle('port', style);\n\n                    style = graph.getStylesheet().getDefaultEdgeStyle();\n                    style[mxConstants.STYLE_LABEL_BACKGROUNDCOLOR] = '#FFFFFF';\n                    style[mxConstants.STYLE_STROKEWIDTH] = '2';\n                    style[mxConstants.STYLE_ROUNDED] = true;\n                    style[mxConstants.STYLE_EDGE] = mxEdgeStyle.EntityRelation;\n                };\n            }\n        },\n        mounted() {\n            // Creates the graph inside the given container\n            var graph = new mxGraph(this.$refs.graph_container);\n\n            // Gets the default parent for inserting new cells. This\n            // is normally the first child of the root (ie. layer 0).\n            var parent = graph.getDefaultParent();\n\n            // Adds cells to the model in a single step\n            graph.getModel().beginUpdate();\n\n            try {\n                let v1 = graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30);\n                let v2 = graph.insertVertex(parent, null, 'World!', 200, 150, 80, 30);\n                graph.insertEdge(parent, null, '', v1, v2);\n            } finally {\n                // Updates the display\n                graph.getModel().endUpdate();\n            }\n            // this.init();\n        }\n    }\n</script>\n\n<style scoped>\n    .grf {\n        border: 1px solid red;\n        padding: 50px 0;\n        height: 1000px;\n        overflow: auto;\n    }\n</style>\n\n\n// WEBPACK FOOTER //\n// src/pages/homepage/topology.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"hello\"},[_c('div',{ref:\"graph_container\",staticClass:\"grf\",staticStyle:{\"margin\":\"0px\"},attrs:{\"onload\":\"main(document.getElementById('graphContainer'),\\n\\t\\t\\tdocument.getElementById('outlineContainer'),\\n\\t\\t \\tdocument.getElementById('toolbarContainer'),\\n\\t\\t\\tdocument.getElementById('sidebarContainer'),\\n            document.getElementById('statusContainer'));\"}},[_c('div',{staticStyle:{\"position\":\"absolute\",\"white-space\":\"nowrap\",\"overflow\":\"hidden\",\"top\":\"0px\",\"left\":\"0px\",\"max-height\":\"24px\",\"height\":\"36px\",\"right\":\"0px\",\"padding\":\"6px\",\"background-image\":\"url('images/toolbar_bg.gif')\"},attrs:{\"id\":\"toolbarContainer\"}})]),_vm._v(\" \"),[_c('div',{staticClass:\"block\"},[_c('el-slider',{attrs:{\"vertical\":\"\",\"height\":\"200px\"},model:{value:(_vm.value),callback:function ($$v) {_vm.value=$$v},expression:\"value\"}})],1)]],2)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-3938b050\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/pages/homepage/topology.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true,\\\"publicPath\\\":\\\"../../\\\"}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-3938b050\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./topology.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./topology.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./topology.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-3938b050\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./topology.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-3938b050\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/pages/homepage/topology.vue\n// module id = null\n// module chunks = ","(function (root, factory) {\nif (typeof define === 'function' && define.amd) {\ndefine([], factory);\n} else if (typeof module === 'object' && module.exports) {\nmodule.exports = factory();\n} else {\nroot.mxgraph = factory();\n}\n}(this, function () {\nreturn function (opts) {\nfor (var name in opts) { this[name] = opts[name]; }\nvar __mxOutput = {};\n/**\n * Copyright (c) 2006-2017, JGraph Ltd\n * Copyright (c) 2006-2017, Gaudenz Alder\n */\nvar mxClient =\n{\n\t/**\n\t * Class: mxClient\n\t *\n\t * Bootstrapping mechanism for the mxGraph thin client. The production version\n\t * of this file contains all code required to run the mxGraph thin client, as\n\t * well as global constants to identify the browser and operating system in\n\t * use. You may have to load chrome://global/content/contentAreaUtils.js in\n\t * your page to disable certain security restrictions in Mozilla.\n\t * \n\t * Variable: VERSION\n\t *\n\t * Contains the current version of the mxGraph library. The strings that\n\t * communicate versions of mxGraph use the following format.\n\t * \n\t * versionMajor.versionMinor.buildNumber.revisionNumber\n\t * \n\t * Current version is 4.2.2.\n\t */\n\tVERSION: '4.2.2',\n\n\t/**\n\t * Variable: IS_IE\n\t *\n\t * True if the current browser is Internet Explorer 10 or below. Use <mxClient.IS_IE11>\n\t * to detect IE 11.\n\t */\n\tIS_IE: navigator.userAgent != null && navigator.userAgent.indexOf('MSIE') >= 0,\n\n\t/**\n\t * Variable: IS_IE6\n\t *\n\t * True if the current browser is Internet Explorer 6.x.\n\t */\n\tIS_IE6: navigator.userAgent != null && navigator.userAgent.indexOf('MSIE 6') >= 0,\n\n\t/**\n\t * Variable: IS_IE11\n\t *\n\t * True if the current browser is Internet Explorer 11.x.\n\t */\n\tIS_IE11: navigator.userAgent != null && !!navigator.userAgent.match(/Trident\\/7\\./),\n\n\t/**\n\t * Variable: IS_EDGE\n\t *\n\t * True if the current browser is Microsoft Edge.\n\t */\n\tIS_EDGE: navigator.userAgent != null && !!navigator.userAgent.match(/Edge\\//),\n\n\t/**\n\t * Variable: IS_QUIRKS\n\t *\n\t * True if the current browser is Internet Explorer and it is in quirks mode.\n\t */\n\tIS_QUIRKS: navigator.userAgent != null && navigator.userAgent.indexOf('MSIE') >= 0 &&\n\t\t(document.documentMode == null || document.documentMode == 5),\n\n\t/**\n\t * Variable: IS_EM\n\t * \n\t * True if the browser is IE11 in enterprise mode (IE8 standards mode).\n\t */\n\tIS_EM: 'spellcheck' in document.createElement('textarea') && document.documentMode == 8,\n\n\t/**\n\t * Variable: VML_PREFIX\n\t * \n\t * Prefix for VML namespace in node names. Default is 'v'.\n\t */\n\tVML_PREFIX: 'v',\n\n\t/**\n\t * Variable: OFFICE_PREFIX\n\t * \n\t * Prefix for VML office namespace in node names. Default is 'o'.\n\t */\n\tOFFICE_PREFIX: 'o',\n\n\t/**\n\t * Variable: IS_NS\n\t *\n\t * True if the current browser is Netscape (including Firefox).\n\t */\n  \tIS_NS: navigator.userAgent != null &&\n  \t\tnavigator.userAgent.indexOf('Mozilla/') >= 0 &&\n  \t\tnavigator.userAgent.indexOf('MSIE') < 0 &&\n  \t\tnavigator.userAgent.indexOf('Edge/') < 0,\n\n\t/**\n\t * Variable: IS_OP\n\t *\n\t * True if the current browser is Opera.\n\t */\n  \tIS_OP: navigator.userAgent != null &&\n  \t\t(navigator.userAgent.indexOf('Opera/') >= 0 ||\n  \t\tnavigator.userAgent.indexOf('OPR/') >= 0),\n\n\t/**\n\t * Variable: IS_OT\n\t *\n\t * True if -o-transform is available as a CSS style, ie for Opera browsers\n\t * based on a Presto engine with version 2.5 or later.\n\t */\n  \tIS_OT: navigator.userAgent != null &&\n  \t\tnavigator.userAgent.indexOf('Presto/') >= 0 &&\n  \t\tnavigator.userAgent.indexOf('Presto/2.4.') < 0 &&\n  \t\tnavigator.userAgent.indexOf('Presto/2.3.') < 0 &&\n  \t\tnavigator.userAgent.indexOf('Presto/2.2.') < 0 &&\n  \t\tnavigator.userAgent.indexOf('Presto/2.1.') < 0 &&\n  \t\tnavigator.userAgent.indexOf('Presto/2.0.') < 0 &&\n  \t\tnavigator.userAgent.indexOf('Presto/1.') < 0,\n  \t\n\t/**\n\t * Variable: IS_SF\n\t *\n\t * True if the current browser is Safari.\n\t */\n  \tIS_SF: /Apple Computer, Inc/.test(navigator.vendor),\n\n\t/**\n\t * Variable: IS_ANDROID\n\t * \n\t * Returns true if the user agent contains Android.\n\t */\n  \tIS_ANDROID: navigator.appVersion.indexOf('Android') >= 0,\n\n\t/**\n\t * Variable: IS_IOS\n\t * \n\t * Returns true if the user agent is an iPad, iPhone or iPod.\n\t */\n  \tIS_IOS: (/iP(hone|od|ad)/.test(navigator.platform)),\n\n\t/**\n\t * Variable: IS_GC\n\t *\n\t * True if the current browser is Google Chrome.\n\t */\n  \tIS_GC: /Google Inc/.test(navigator.vendor),\n\t\n\t/**\n\t * Variable: IS_CHROMEAPP\n\t *\n\t * True if the this is running inside a Chrome App.\n\t */\n  \tIS_CHROMEAPP: window.chrome != null && chrome.app != null && chrome.app.runtime != null,\n\n\t/**\n\t * Variable: IS_FF\n\t *\n\t * True if the current browser is Firefox.\n\t */\n  \tIS_FF: typeof InstallTrigger !== 'undefined',\n  \t\n\t/**\n\t * Variable: IS_MT\n\t *\n\t * True if -moz-transform is available as a CSS style. This is the case\n\t * for all Firefox-based browsers newer than or equal 3, such as Camino,\n\t * Iceweasel, Seamonkey and Iceape.\n\t */\n  \tIS_MT: (navigator.userAgent.indexOf('Firefox/') >= 0 &&\n\t\tnavigator.userAgent.indexOf('Firefox/1.') < 0 &&\n  \t\tnavigator.userAgent.indexOf('Firefox/2.') < 0) ||\n  \t\t(navigator.userAgent.indexOf('Iceweasel/') >= 0 &&\n  \t\tnavigator.userAgent.indexOf('Iceweasel/1.') < 0 &&\n  \t\tnavigator.userAgent.indexOf('Iceweasel/2.') < 0) ||\n  \t\t(navigator.userAgent.indexOf('SeaMonkey/') >= 0 &&\n  \t\tnavigator.userAgent.indexOf('SeaMonkey/1.') < 0) ||\n  \t\t(navigator.userAgent.indexOf('Iceape/') >= 0 &&\n  \t\tnavigator.userAgent.indexOf('Iceape/1.') < 0),\n\n\t/**\n\t * Variable: IS_VML\n\t *\n\t * True if the browser supports VML.\n\t */\n  \tIS_VML: navigator.appName.toUpperCase() == 'MICROSOFT INTERNET EXPLORER',\n\n\t/**\n\t * Variable: IS_SVG\n\t *\n\t * True if the browser supports SVG.\n\t */\n  \tIS_SVG: navigator.appName.toUpperCase() != 'MICROSOFT INTERNET EXPLORER',\n\n\t/**\n\t * Variable: NO_FO\n\t *\n\t * True if foreignObject support is not available. This is the case for\n\t * Opera, older SVG-based browsers and all versions of IE.\n\t */\n  \tNO_FO: !document.createElementNS || document.createElementNS('http://www.w3.org/2000/svg',\n  \t\t'foreignObject') != '[object SVGForeignObjectElement]' || navigator.userAgent.indexOf('Opera/') >= 0,\n\n\t/**\n\t * Variable: IS_WIN\n\t *\n\t * True if the client is a Windows.\n\t */\n  \tIS_WIN: navigator.appVersion.indexOf('Win') > 0,\n\n\t/**\n\t * Variable: IS_MAC\n\t *\n\t * True if the client is a Mac.\n\t */\n  \tIS_MAC: navigator.appVersion.indexOf('Mac') > 0,\n\t\n\t/**\n\t * Variable: IS_CHROMEOS\n\t *\n\t * True if the client is a Chrome OS.\n\t */\n  \tIS_CHROMEOS: /\\bCrOS\\b/.test(navigator.appVersion),\n\n\t/**\n\t * Variable: IS_TOUCH\n\t * \n\t * True if this device supports touchstart/-move/-end events (Apple iOS,\n\t * Android, Chromebook and Chrome Browser on touch-enabled devices).\n\t */\n  \tIS_TOUCH: 'ontouchstart' in document.documentElement,\n\n\t/**\n\t * Variable: IS_POINTER\n\t * \n\t * True if this device supports Microsoft pointer events (always false on Macs).\n\t */\n  \tIS_POINTER: window.PointerEvent != null && !(navigator.appVersion.indexOf('Mac') > 0),\n\n\t/**\n\t * Variable: IS_LOCAL\n\t *\n\t * True if the documents location does not start with http:// or https://.\n\t */\n  \tIS_LOCAL: document.location.href.indexOf('http://') < 0 &&\n  \t\t\t  document.location.href.indexOf('https://') < 0,\n\n\t/**\n\t * Variable: defaultBundles\n\t * \n\t * Contains the base names of the default bundles if mxLoadResources is false.\n\t */\n  \tdefaultBundles: [],\n\n\t/**\n\t * Function: isBrowserSupported\n\t *\n\t * Returns true if the current browser is supported, that is, if\n\t * <mxClient.IS_VML> or <mxClient.IS_SVG> is true.\n\t * \n\t * Example:\n\t * \n\t * (code)\n\t * if (!mxClient.isBrowserSupported())\n\t * {\n\t *   mxUtils.error('Browser is not supported!', 200, false);\n\t * }\n\t * (end)\n\t */\n\tisBrowserSupported: function()\n\t{\n\t\treturn mxClient.IS_VML || mxClient.IS_SVG;\n\t},\n\n\t/**\n\t * Function: link\n\t *\n\t * Adds a link node to the head of the document. Use this\n\t * to add a stylesheet to the page as follows:\n\t *\n\t * (code)\n\t * mxClient.link('stylesheet', filename);\n\t * (end)\n\t *\n\t * where filename is the (relative) URL of the stylesheet. The charset\n\t * is hardcoded to ISO-8859-1 and the type is text/css.\n\t * \n\t * Parameters:\n\t * \n\t * rel - String that represents the rel attribute of the link node.\n\t * href - String that represents the href attribute of the link node.\n\t * doc - Optional parent document of the link node.\n\t * id - unique id for the link element to check if it already exists\n\t */\n\tlink: function(rel, href, doc, id)\n\t{\n\t\tdoc = doc || document;\n\n\t\t// Workaround for Operation Aborted in IE6 if base tag is used in head\n\t\tif (mxClient.IS_IE6)\n\t\t{\n\t\t\tdoc.write('<link rel=\"' + rel + '\" href=\"' + href + '\" charset=\"UTF-8\" type=\"text/css\"/>');\n\t\t}\n\t\telse\n\t\t{\t\n\t\t\tvar link = doc.createElement('link');\n\t\t\t\n\t\t\tlink.setAttribute('rel', rel);\n\t\t\tlink.setAttribute('href', href);\n\t\t\tlink.setAttribute('charset', 'UTF-8');\n\t\t\tlink.setAttribute('type', 'text/css');\n\t\t\t\n\t\t\tif (id)\n\t\t\t{\n\t\t\t\tlink.setAttribute('id', id);\n\t\t\t}\n\t\t\t\n\t\t\tvar head = doc.getElementsByTagName('head')[0];\n\t   \t\thead.appendChild(link);\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: loadResources\n\t * \n\t * Helper method to load the default bundles if mxLoadResources is false.\n\t * \n\t * Parameters:\n\t * \n\t * fn - Function to call after all resources have been loaded.\n\t * lan - Optional string to pass to <mxResources.add>.\n\t */\n\tloadResources: function(fn, lan)\n\t{\n\t\tvar pending = mxClient.defaultBundles.length;\n\t\t\n\t\tfunction callback()\n\t\t{\n\t\t\tif (--pending == 0)\n\t\t\t{\n\t\t\t\tfn();\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (var i = 0; i < mxClient.defaultBundles.length; i++)\n\t\t{\n\t\t\tmxResources.add(mxClient.defaultBundles[i], lan, callback);\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: include\n\t *\n\t * Dynamically adds a script node to the document header.\n\t * \n\t * In production environments, the includes are resolved in the mxClient.js\n\t * file to reduce the number of requests required for client startup. This\n\t * function should only be used in development environments, but not in\n\t * production systems.\n\t */\n\tinclude: function(src)\n\t{\n\t\tdocument.write('<script src=\"'+src+'\"></script>');\n\t}\n};\n\n/**\n * Variable: mxLoadResources\n * \n * Optional global config variable to toggle loading of the two resource files\n * in <mxGraph> and <mxEditor>. Default is true. NOTE: This is a global variable,\n * not a variable of mxClient. If this is false, you can use <mxClient.loadResources>\n * with its callback to load the default bundles asynchronously.\n *\n * (code)\n * <script type=\"text/javascript\">\n * \t\tvar mxLoadResources = false;\n * </script>\n * <script type=\"text/javascript\" src=\"/path/to/core/directory/js/mxClient.js\"></script>\n * (end)\n */\nif (typeof(mxLoadResources) == 'undefined')\n{\n\tmxLoadResources = true;\n}\n\n/**\n * Variable: mxForceIncludes\n * \n * Optional global config variable to force loading the JavaScript files in\n * development mode. Default is undefined. NOTE: This is a global variable,\n * not a variable of mxClient.\n *\n * (code)\n * <script type=\"text/javascript\">\n * \t\tvar mxLoadResources = true;\n * </script>\n * <script type=\"text/javascript\" src=\"/path/to/core/directory/js/mxClient.js\"></script>\n * (end)\n */\nif (typeof(mxForceIncludes) == 'undefined')\n{\n\tmxForceIncludes = false;\n}\n\n/**\n * Variable: mxResourceExtension\n * \n * Optional global config variable to specify the extension of resource files.\n * Default is true. NOTE: This is a global variable, not a variable of mxClient.\n *\n * (code)\n * <script type=\"text/javascript\">\n * \t\tvar mxResourceExtension = '.txt';\n * </script>\n * <script type=\"text/javascript\" src=\"/path/to/core/directory/js/mxClient.js\"></script>\n * (end)\n */\nif (typeof(mxResourceExtension) == 'undefined')\n{\n\tmxResourceExtension = '.txt';\n}\n\n/**\n * Variable: mxLoadStylesheets\n * \n * Optional global config variable to toggle loading of the CSS files when\n * the library is initialized. Default is true. NOTE: This is a global variable,\n * not a variable of mxClient.\n *\n * (code)\n * <script type=\"text/javascript\">\n * \t\tvar mxLoadStylesheets = false;\n * </script>\n * <script type=\"text/javascript\" src=\"/path/to/core/directory/js/mxClient.js\"></script>\n * (end)\n */\nif (typeof(mxLoadStylesheets) == 'undefined')\n{\n\tmxLoadStylesheets = true;\n}\n\n/**\n * Variable: basePath\n *\n * Basepath for all URLs in the core without trailing slash. Default is '.'.\n * Set mxBasePath prior to loading the mxClient library as follows to override\n * this setting:\n *\n * (code)\n * <script type=\"text/javascript\">\n * \t\tmxBasePath = '/path/to/core/directory';\n * </script>\n * <script type=\"text/javascript\" src=\"/path/to/core/directory/js/mxClient.js\"></script>\n * (end)\n * \n * When using a relative path, the path is relative to the URL of the page that\n * contains the assignment. Trailing slashes are automatically removed.\n */\nif (typeof(mxBasePath) != 'undefined' && mxBasePath.length > 0)\n{\n\t// Adds a trailing slash if required\n\tif (mxBasePath.substring(mxBasePath.length - 1) == '/')\n\t{\n\t\tmxBasePath = mxBasePath.substring(0, mxBasePath.length - 1);\n\t}\n\n\tmxClient.basePath = mxBasePath;\n}\nelse\n{\n\tmxClient.basePath = '.';\n}\n\n/**\n * Variable: imageBasePath\n *\n * Basepath for all images URLs in the core without trailing slash. Default is\n * <mxClient.basePath> + '/images'. Set mxImageBasePath prior to loading the\n * mxClient library as follows to override this setting:\n *\n * (code)\n * <script type=\"text/javascript\">\n * \t\tmxImageBasePath = '/path/to/image/directory';\n * </script>\n * <script type=\"text/javascript\" src=\"/path/to/core/directory/js/mxClient.js\"></script>\n * (end)\n * \n * When using a relative path, the path is relative to the URL of the page that\n * contains the assignment. Trailing slashes are automatically removed.\n */\nif (typeof(mxImageBasePath) != 'undefined' && mxImageBasePath.length > 0)\n{\n\t// Adds a trailing slash if required\n\tif (mxImageBasePath.substring(mxImageBasePath.length - 1) == '/')\n\t{\n\t\tmxImageBasePath = mxImageBasePath.substring(0, mxImageBasePath.length - 1);\n\t}\n\n\tmxClient.imageBasePath = mxImageBasePath;\n}\nelse\n{\n\tmxClient.imageBasePath = mxClient.basePath + '/images';\t\n}\n\n/**\n * Variable: language\n *\n * Defines the language of the client, eg. en for english, de for german etc.\n * The special value 'none' will disable all built-in internationalization and\n * resource loading. See <mxResources.getSpecialBundle> for handling identifiers\n * with and without a dash.\n * \n * Set mxLanguage prior to loading the mxClient library as follows to override\n * this setting:\n *\n * (code)\n * <script type=\"text/javascript\">\n * \t\tmxLanguage = 'en';\n * </script>\n * <script type=\"text/javascript\" src=\"js/mxClient.js\"></script>\n * (end)\n * \n * If internationalization is disabled, then the following variables should be\n * overridden to reflect the current language of the system. These variables are\n * cleared when i18n is disabled.\n * <mxEditor.askZoomResource>, <mxEditor.lastSavedResource>,\n * <mxEditor.currentFileResource>, <mxEditor.propertiesResource>,\n * <mxEditor.tasksResource>, <mxEditor.helpResource>, <mxEditor.outlineResource>,\n * <mxElbowEdgeHandler.doubleClickOrientationResource>, <mxUtils.errorResource>,\n * <mxUtils.closeResource>, <mxGraphSelectionModel.doneResource>,\n * <mxGraphSelectionModel.updatingSelectionResource>, <mxGraphView.doneResource>,\n * <mxGraphView.updatingDocumentResource>, <mxCellRenderer.collapseExpandResource>,\n * <mxGraph.containsValidationErrorsResource> and\n * <mxGraph.alreadyConnectedResource>.\n */\nif (typeof(mxLanguage) != 'undefined' && mxLanguage != null)\n{\n\tmxClient.language = mxLanguage;\n}\nelse\n{\n\tmxClient.language = (mxClient.IS_IE) ? navigator.userLanguage : navigator.language;\n}\n\n/**\n * Variable: defaultLanguage\n * \n * Defines the default language which is used in the common resource files. Any\n * resources for this language will only load the common resource file, but not\n * the language-specific resource file. Default is 'en'.\n * \n * Set mxDefaultLanguage prior to loading the mxClient library as follows to override\n * this setting:\n *\n * (code)\n * <script type=\"text/javascript\">\n * \t\tmxDefaultLanguage = 'de';\n * </script>\n * <script type=\"text/javascript\" src=\"js/mxClient.js\"></script>\n * (end)\n */\nif (typeof(mxDefaultLanguage) != 'undefined' && mxDefaultLanguage != null)\n{\n\tmxClient.defaultLanguage = mxDefaultLanguage;\n}\nelse\n{\n\tmxClient.defaultLanguage = 'en';\n}\n\n// Adds all required stylesheets and namespaces\nif (mxLoadStylesheets)\n{\n\tmxClient.link('stylesheet', mxClient.basePath + '/css/common.css');\n}\n\n/**\n * Variable: languages\n *\n * Defines the optional array of all supported language extensions. The default\n * language does not have to be part of this list. See\n * <mxResources.isLanguageSupported>.\n *\n * (code)\n * <script type=\"text/javascript\">\n * \t\tmxLanguages = ['de', 'it', 'fr'];\n * </script>\n * <script type=\"text/javascript\" src=\"js/mxClient.js\"></script>\n * (end)\n * \n * This is used to avoid unnecessary requests to language files, ie. if a 404\n * will be returned.\n */\nif (typeof(mxLanguages) != 'undefined' && mxLanguages != null)\n{\n\tmxClient.languages = mxLanguages;\n}\n\n// Adds required namespaces, stylesheets and memory handling for older IE browsers\nif (mxClient.IS_VML)\n{\n\tif (mxClient.IS_SVG)\n\t{\n\t\tmxClient.IS_VML = false;\n\t}\n\telse\n\t{\n\t\t// Enables support for IE8 standards mode. Note that this requires all attributes for VML\n\t\t// elements to be set using direct notation, ie. node.attr = value, not setAttribute.\n\t\tif (document.namespaces != null)\n\t\t{\n\t\t\tif (document.documentMode == 8)\n\t\t\t{\n\t\t\t\tdocument.namespaces.add(mxClient.VML_PREFIX, 'urn:schemas-microsoft-com:vml', '#default#VML');\n\t\t\t\tdocument.namespaces.add(mxClient.OFFICE_PREFIX, 'urn:schemas-microsoft-com:office:office', '#default#VML');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdocument.namespaces.add(mxClient.VML_PREFIX, 'urn:schemas-microsoft-com:vml');\n\t\t\t\tdocument.namespaces.add(mxClient.OFFICE_PREFIX, 'urn:schemas-microsoft-com:office:office');\n\t\t\t}\n\t\t}\n\n\t\t// Workaround for limited number of stylesheets in IE (does not work in standards mode)\n\t\tif (mxClient.IS_QUIRKS && document.styleSheets.length >= 30)\n\t\t{\n\t\t\t(function()\n\t\t\t{\n\t\t\t\tvar node = document.createElement('style');\n\t\t\t\tnode.type = 'text/css';\n\t\t\t\tnode.styleSheet.cssText = mxClient.VML_PREFIX + '\\\\:*{behavior:url(#default#VML)}' +\n\t\t        \tmxClient.OFFICE_PREFIX + '\\\\:*{behavior:url(#default#VML)}';\n\t\t        document.getElementsByTagName('head')[0].appendChild(node);\n\t\t\t})();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdocument.createStyleSheet().cssText = mxClient.VML_PREFIX + '\\\\:*{behavior:url(#default#VML)}' +\n\t\t    \tmxClient.OFFICE_PREFIX + '\\\\:*{behavior:url(#default#VML)}';\n\t\t}\n\t    \n\t    if (mxLoadStylesheets)\n\t    {\n\t    \tmxClient.link('stylesheet', mxClient.basePath + '/css/explorer.css');\n\t    }\n\t}\n}\n\n// PREPROCESSOR-REMOVE-START\n// If script is loaded via CommonJS, do not write <script> tags to the page\n// for dependencies. These are already included in the build.\nif (mxForceIncludes || !(typeof module === 'object' && module.exports != null))\n{\n// PREPROCESSOR-REMOVE-END\n\tmxClient.include(mxClient.basePath+'/js/util/mxLog.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxObjectIdentity.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxDictionary.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxResources.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxPoint.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxRectangle.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxEffects.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxUtils.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxConstants.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxEventObject.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxMouseEvent.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxEventSource.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxEvent.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxXmlRequest.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxClipboard.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxWindow.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxForm.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxImage.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxDivResizer.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxDragSource.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxToolbar.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxUndoableEdit.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxUndoManager.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxUrlConverter.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxPanningManager.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxPopupMenu.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxAutoSaveManager.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxAnimation.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxMorphing.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxImageBundle.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxImageExport.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxAbstractCanvas2D.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxXmlCanvas2D.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxSvgCanvas2D.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxVmlCanvas2D.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxGuide.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxShape.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxStencil.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxStencilRegistry.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxMarker.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxActor.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxCloud.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxRectangleShape.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxEllipse.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxDoubleEllipse.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxRhombus.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxPolyline.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxArrow.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxArrowConnector.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxText.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxTriangle.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxHexagon.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxLine.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxImageShape.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxLabel.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxCylinder.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxConnector.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxSwimlane.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxGraphLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxStackLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxPartitionLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxCompactTreeLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxRadialTreeLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxFastOrganicLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxCircleLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxParallelEdgeLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxCompositeLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxEdgeLabelLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/model/mxGraphAbstractHierarchyCell.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/model/mxGraphHierarchyNode.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/model/mxGraphHierarchyEdge.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/model/mxGraphHierarchyModel.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/model/mxSwimlaneModel.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/stage/mxHierarchicalLayoutStage.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/stage/mxMedianHybridCrossingReduction.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/stage/mxMinimumCycleRemover.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/stage/mxCoordinateAssignment.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/stage/mxSwimlaneOrdering.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/mxHierarchicalLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/mxSwimlaneLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/model/mxGraphModel.js');\n\tmxClient.include(mxClient.basePath+'/js/model/mxCell.js');\n\tmxClient.include(mxClient.basePath+'/js/model/mxGeometry.js');\n\tmxClient.include(mxClient.basePath+'/js/model/mxCellPath.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxPerimeter.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxPrintPreview.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxStylesheet.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxCellState.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxGraphSelectionModel.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxCellEditor.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxCellRenderer.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxEdgeStyle.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxStyleRegistry.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxGraphView.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxGraph.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxCellOverlay.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxOutline.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxMultiplicity.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxLayoutManager.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxSwimlaneManager.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxTemporaryCellStates.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxCellStatePreview.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxConnectionConstraint.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxGraphHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxPanningHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxPopupMenuHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxCellMarker.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxSelectionCellsHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxConnectionHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxConstraintHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxRubberband.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxHandle.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxVertexHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxEdgeHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxElbowEdgeHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxEdgeSegmentHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxKeyHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxTooltipHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxCellTracker.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxCellHighlight.js');\n\tmxClient.include(mxClient.basePath+'/js/editor/mxDefaultKeyHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/editor/mxDefaultPopupMenu.js');\n\tmxClient.include(mxClient.basePath+'/js/editor/mxDefaultToolbar.js');\n\tmxClient.include(mxClient.basePath+'/js/editor/mxEditor.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxCodecRegistry.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxObjectCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxCellCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxModelCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxRootChangeCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxChildChangeCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxTerminalChangeCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxGenericChangeCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxGraphCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxGraphViewCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxStylesheetCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxDefaultKeyHandlerCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxDefaultToolbarCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxDefaultPopupMenuCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxEditorCodec.js');\n// PREPROCESSOR-REMOVE-START\n}\n// PREPROCESSOR-REMOVE-END\n\n__mxOutput.mxClient = typeof mxClient !== 'undefined' ? mxClient : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxLog =\n{\n\t/**\n\t * Class: mxLog\n\t * \n\t * A singleton class that implements a simple console.\n\t * \n\t * Variable: consoleName\n\t * \n\t * Specifies the name of the console window. Default is 'Console'.\n\t */\n\tconsoleName: 'Console',\n\t\n\t/**\n\t * Variable: TRACE\n\t * \n\t * Specified if the output for <enter> and <leave> should be visible in the\n\t * console. Default is false.\n\t */\n\tTRACE: false,\n\n\t/**\n\t * Variable: DEBUG\n\t * \n\t * Specifies if the output for <debug> should be visible in the console.\n\t * Default is true.\n\t */\n\tDEBUG: true,\n\n\t/**\n\t * Variable: WARN\n\t * \n\t * Specifies if the output for <warn> should be visible in the console.\n\t * Default is true.\n\t */\n\tWARN: true,\n\n\t/**\n\t * Variable: buffer\n\t * \n\t * Buffer for pre-initialized content.\n\t */\n\tbuffer: '',\n\t\n\t/**\n\t * Function: init\n\t *\n\t * Initializes the DOM node for the console. This requires document.body to\n\t * point to a non-null value. This is called from within <setVisible> if the\n\t * log has not yet been initialized.\n\t */\n\tinit: function()\n\t{\n\t\tif (mxLog.window == null && document.body != null)\n\t\t{\n\t\t\tvar title = mxLog.consoleName + ' - mxGraph ' + mxClient.VERSION;\n\n\t\t\t// Creates a table that maintains the layout\n\t\t\tvar table = document.createElement('table');\n\t\t\ttable.setAttribute('width', '100%');\n\t\t\ttable.setAttribute('height', '100%');\n\n\t\t\tvar tbody = document.createElement('tbody');\n\t\t\tvar tr = document.createElement('tr');\n\t\t\tvar td = document.createElement('td');\n\t\t\ttd.style.verticalAlign = 'top';\n\t\t\t\t\n\t\t\t// Adds the actual console as a textarea\n\t\t\tmxLog.textarea = document.createElement('textarea');\n\t\t\tmxLog.textarea.setAttribute('wrap', 'off');\n\t\t\tmxLog.textarea.setAttribute('readOnly', 'true');\n\t\t\tmxLog.textarea.style.height = '100%';\n\t\t\tmxLog.textarea.style.resize = 'none';\n\t\t\tmxLog.textarea.value = mxLog.buffer;\n\n\t\t\t// Workaround for wrong width in standards mode\n\t\t\tif (mxClient.IS_NS && document.compatMode != 'BackCompat')\n\t\t\t{\n\t\t\t\tmxLog.textarea.style.width = '99%';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmxLog.textarea.style.width = '100%';\n\t\t\t}\n\t\t\t\n\t\t\ttd.appendChild(mxLog.textarea);\n\t\t\ttr.appendChild(td);\n\t\t\ttbody.appendChild(tr);\n\n\t\t\t// Creates the container div\n\t\t\ttr = document.createElement('tr');\n\t\t\tmxLog.td = document.createElement('td');\n\t\t\tmxLog.td.style.verticalAlign = 'top';\n\t\t\tmxLog.td.setAttribute('height', '30px');\n\t\t\t\n\t\t\ttr.appendChild(mxLog.td);\n\t\t\ttbody.appendChild(tr);\n\t\t\ttable.appendChild(tbody);\n\n\t\t\t// Adds various debugging buttons\n\t\t\tmxLog.addButton('Info', function (evt)\n\t\t\t{\n\t\t\t\tmxLog.info();\n\t\t\t});\n\t\t\n\t\t\tmxLog.addButton('DOM', function (evt)\n\t\t\t{\n\t\t\t\tvar content = mxUtils.getInnerHtml(document.body);\n\t\t\t\tmxLog.debug(content);\n\t\t\t});\n\t\n\t\t\tmxLog.addButton('Trace', function (evt)\n\t\t\t{\n\t\t\t\tmxLog.TRACE = !mxLog.TRACE;\n\t\t\t\t\n\t\t\t\tif (mxLog.TRACE)\n\t\t\t\t{\n\t\t\t\t\tmxLog.debug('Tracing enabled');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmxLog.debug('Tracing disabled');\n\t\t\t\t}\n\t\t\t});\t\n\n\t\t\tmxLog.addButton('Copy', function (evt)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tmxUtils.copy(mxLog.textarea.value);\n\t\t\t\t}\n\t\t\t\tcatch (err)\n\t\t\t\t{\n\t\t\t\t\tmxUtils.alert(err);\n\t\t\t\t}\n\t\t\t});\t\t\t\n\n\t\t\tmxLog.addButton('Show', function (evt)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tmxUtils.popup(mxLog.textarea.value);\n\t\t\t\t}\n\t\t\t\tcatch (err)\n\t\t\t\t{\n\t\t\t\t\tmxUtils.alert(err);\n\t\t\t\t}\n\t\t\t});\t\n\t\t\t\n\t\t\tmxLog.addButton('Clear', function (evt)\n\t\t\t{\n\t\t\t\tmxLog.textarea.value = '';\n\t\t\t});\n\n\t\t\t// Cross-browser code to get window size\n\t\t\tvar h = 0;\n\t\t\tvar w = 0;\n\t\t\t\n\t\t\tif (typeof(window.innerWidth) === 'number')\n\t\t\t{\n\t\t\t\th = window.innerHeight;\n\t\t\t\tw = window.innerWidth;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\th = (document.documentElement.clientHeight || document.body.clientHeight);\n\t\t\t\tw = document.body.clientWidth;\n\t\t\t}\n\n\t\t\tmxLog.window = new mxWindow(title, table, Math.max(0, w - 320), Math.max(0, h - 210), 300, 160);\n\t\t\tmxLog.window.setMaximizable(true);\n\t\t\tmxLog.window.setScrollable(false);\n\t\t\tmxLog.window.setResizable(true);\n\t\t\tmxLog.window.setClosable(true);\n\t\t\tmxLog.window.destroyOnClose = false;\n\t\t\t\n\t\t\t// Workaround for ignored textarea height in various setups\n\t\t\tif (((mxClient.IS_NS || mxClient.IS_IE) && !mxClient.IS_GC &&\n\t\t\t\t!mxClient.IS_SF && document.compatMode != 'BackCompat') ||\n\t\t\t\tdocument.documentMode == 11)\n\t\t\t{\n\t\t\t\tvar elt = mxLog.window.getElement();\n\t\t\t\t\n\t\t\t\tvar resizeHandler = function(sender, evt)\n\t\t\t\t{\n\t\t\t\t\tmxLog.textarea.style.height = Math.max(0, elt.offsetHeight - 70) + 'px';\n\t\t\t\t}; \n\t\t\t\t\n\t\t\t\tmxLog.window.addListener(mxEvent.RESIZE_END, resizeHandler);\n\t\t\t\tmxLog.window.addListener(mxEvent.MAXIMIZE, resizeHandler);\n\t\t\t\tmxLog.window.addListener(mxEvent.NORMALIZE, resizeHandler);\n\n\t\t\t\tmxLog.textarea.style.height = '92px';\n\t\t\t}\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: info\n\t * \n\t * Writes the current navigator information to the console.\n\t */\n\tinfo: function()\n\t{\n\t\tmxLog.writeln(mxUtils.toString(navigator));\n\t},\n\t\t\t\n\t/**\n\t * Function: addButton\n\t * \n\t * Adds a button to the console using the given label and function.\n\t */\n\taddButton: function(lab, funct)\n\t{\n\t\tvar button = document.createElement('button');\n\t\tmxUtils.write(button, lab);\n\t\tmxEvent.addListener(button, 'click', funct);\n\t\tmxLog.td.appendChild(button);\n\t},\n\t\t\t\t\n\t/**\n\t * Function: isVisible\n\t * \n\t * Returns true if the console is visible.\n\t */\n\tisVisible: function()\n\t{\n\t\tif (mxLog.window != null)\n\t\t{\n\t\t\treturn mxLog.window.isVisible();\n\t\t}\n\t\t\n\t\treturn false;\n\t},\n\t\n\n\t/**\n\t * Function: show\n\t * \n\t * Shows the console.\n\t */\n\tshow: function()\n\t{\n\t\tmxLog.setVisible(true);\n\t},\n\n\t/**\n\t * Function: setVisible\n\t * \n\t * Shows or hides the console.\n\t */\n\tsetVisible: function(visible)\n\t{\n\t\tif (mxLog.window == null)\n\t\t{\n\t\t\tmxLog.init();\n\t\t}\n\n\t\tif (mxLog.window != null)\n\t\t{\n\t\t\tmxLog.window.setVisible(visible);\n\t\t}\n\t},\n\n\t/**\n\t * Function: enter\n\t * \n\t * Writes the specified string to the console\n\t * if <TRACE> is true and returns the current \n\t * time in milliseconds.\n\t *\n\t * Example:\n\t * \n\t * (code)\n\t * mxLog.show();\n\t * var t0 = mxLog.enter('Hello');\n\t * // Do something\n\t * mxLog.leave('World!', t0);\n\t * (end)\n\t */\n\tenter: function(string)\n\t{\n\t\tif (mxLog.TRACE)\n\t\t{\n\t\t\tmxLog.writeln('Entering '+string);\n\t\t\t\n\t\t\treturn new Date().getTime();\n\t\t}\n\t},\n\n\t/**\n\t * Function: leave\n\t * \n\t * Writes the specified string to the console\n\t * if <TRACE> is true and computes the difference\n\t * between the current time and t0 in milliseconds.\n\t * See <enter> for an example.\n\t */\n\tleave: function(string, t0)\n\t{\n\t\tif (mxLog.TRACE)\n\t\t{\n\t\t\tvar dt = (t0 != 0) ? ' ('+(new Date().getTime() - t0)+' ms)' : '';\n\t\t\tmxLog.writeln('Leaving '+string+dt);\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: debug\n\t * \n\t * Adds all arguments to the console if <DEBUG> is enabled.\n\t *\n\t * Example:\n\t * \n\t * (code)\n\t * mxLog.show();\n\t * mxLog.debug('Hello, World!');\n\t * (end)\n\t */\n\tdebug: function()\n\t{\n\t\tif (mxLog.DEBUG)\n\t\t{\n\t\t\tmxLog.writeln.apply(this, arguments);\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: warn\n\t * \n\t * Adds all arguments to the console if <WARN> is enabled.\n\t *\n\t * Example:\n\t * \n\t * (code)\n\t * mxLog.show();\n\t * mxLog.warn('Hello, World!');\n\t * (end)\n\t */\n\twarn: function()\n\t{\n\t\tif (mxLog.WARN)\n\t\t{\n\t\t\tmxLog.writeln.apply(this, arguments);\n\t\t}\n\t},\n\n\t/**\n\t * Function: write\n\t * \n\t * Adds the specified strings to the console.\n\t */\n\twrite: function()\n\t{\n\t\tvar string = '';\n\t\t\n\t\tfor (var i = 0; i < arguments.length; i++)\n\t\t{\n\t\t\tstring += arguments[i];\n\t\t\t\n\t\t\tif (i < arguments.length - 1)\n\t\t\t{\n\t\t\t\tstring += ' ';\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (mxLog.textarea != null)\n\t\t{\n\t\t\tmxLog.textarea.value = mxLog.textarea.value + string;\n\n\t\t\t// Workaround for no update in Presto 2.5.22 (Opera 10.5)\n\t\t\tif (navigator.userAgent != null &&\n\t\t\t\tnavigator.userAgent.indexOf('Presto/2.5') >= 0)\n\t\t\t{\n\t\t\t\tmxLog.textarea.style.visibility = 'hidden';\n\t\t\t\tmxLog.textarea.style.visibility = 'visible';\n\t\t\t}\n\t\t\t\n\t\t\tmxLog.textarea.scrollTop = mxLog.textarea.scrollHeight;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmxLog.buffer += string;\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: writeln\n\t * \n\t * Adds the specified strings to the console, appending a linefeed at the\n\t * end of each string.\n\t */\n\twriteln: function()\n\t{\n\t\tvar string = '';\n\t\t\n\t\tfor (var i = 0; i < arguments.length; i++)\n\t\t{\n\t\t\tstring += arguments[i];\n\t\t\t\n\t\t\tif (i < arguments.length - 1)\n\t\t\t{\n\t\t\t\tstring += ' ';\n\t\t\t}\n\t\t}\n\n\t\tmxLog.write(string + '\\n');\n\t}\n\t\n};\n\n__mxOutput.mxLog = typeof mxLog !== 'undefined' ? mxLog : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxObjectIdentity =\n{\n\t/**\n\t * Class: mxObjectIdentity\n\t * \n\t * Identity for JavaScript objects and functions. This is implemented using\n\t * a simple incrementing counter which is stored in each object under\n\t * <FIELD_NAME>.\n\t * \n\t * The identity for an object does not change during its lifecycle.\n\t * \n\t * Variable: FIELD_NAME\n\t * \n\t * Name of the field to be used to store the object ID. Default is\n\t * <code>mxObjectId</code>.\n\t */\n\tFIELD_NAME: 'mxObjectId',\n\n\t/**\n\t * Variable: counter\n\t * \n\t * Current counter.\n\t */\n\tcounter: 0,\n\n\t/**\n\t * Function: get\n\t * \n\t * Returns the ID for the given object or function or null if no object\n\t * is specified.\n\t */\n\tget: function(obj)\n\t{\n\t\tif (obj != null)\n\t\t{\n\t\t\tif (obj[mxObjectIdentity.FIELD_NAME] == null)\n\t\t\t{\n\t\t\t\tif (typeof obj === 'object')\n\t\t\t\t{\n\t\t\t\t\tvar ctor = mxUtils.getFunctionName(obj.constructor);\n\t\t\t\t\tobj[mxObjectIdentity.FIELD_NAME] = ctor + '#' + mxObjectIdentity.counter++;\n\t\t\t\t}\n\t\t\t\telse if (typeof obj === 'function')\n\t\t\t\t{\n\t\t\t\t\tobj[mxObjectIdentity.FIELD_NAME] = 'Function#' + mxObjectIdentity.counter++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn obj[mxObjectIdentity.FIELD_NAME];\n\t\t}\n\t\t\n\t\treturn null;\n\t},\n\n\t/**\n\t * Function: clear\n\t * \n\t * Deletes the ID from the given object or function.\n\t */\n\tclear: function(obj)\n\t{\n\t\tif (typeof(obj) === 'object' || typeof obj === 'function')\n\t\t{\n\t\t\tdelete obj[mxObjectIdentity.FIELD_NAME];\n\t\t}\n\t}\n\n};\n\n__mxOutput.mxObjectIdentity = typeof mxObjectIdentity !== 'undefined' ? mxObjectIdentity : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxDictionary\n *\n * A wrapper class for an associative array with object keys. Note: This\n * implementation uses <mxObjectIdentitiy> to turn object keys into strings.\n * \n * Constructor: mxEventSource\n *\n * Constructs a new dictionary which allows object to be used as keys.\n */\nfunction mxDictionary()\n{\n\tthis.clear();\n};\n\n/**\n * Function: map\n *\n * Stores the (key, value) pairs in this dictionary.\n */\nmxDictionary.prototype.map = null;\n\n/**\n * Function: clear\n *\n * Clears the dictionary.\n */\nmxDictionary.prototype.clear = function()\n{\n\tthis.map = {};\n};\n\n/**\n * Function: get\n *\n * Returns the value for the given key.\n */\nmxDictionary.prototype.get = function(key)\n{\n\tvar id = mxObjectIdentity.get(key);\n\t\n\treturn this.map[id];\n};\n\n/**\n * Function: put\n *\n * Stores the value under the given key and returns the previous\n * value for that key.\n */\nmxDictionary.prototype.put = function(key, value)\n{\n\tvar id = mxObjectIdentity.get(key);\n\tvar previous = this.map[id];\n\tthis.map[id] = value;\n\t\n\treturn previous;\n};\n\n/**\n * Function: remove\n *\n * Removes the value for the given key and returns the value that\n * has been removed.\n */\nmxDictionary.prototype.remove = function(key)\n{\n\tvar id = mxObjectIdentity.get(key);\n\tvar previous = this.map[id];\n\tdelete this.map[id];\n\t\n\treturn previous;\n};\n\n/**\n * Function: getKeys\n *\n * Returns all keys as an array.\n */\nmxDictionary.prototype.getKeys = function()\n{\n\tvar result = [];\n\t\n\tfor (var key in this.map)\n\t{\n\t\tresult.push(key);\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getValues\n *\n * Returns all values as an array.\n */\nmxDictionary.prototype.getValues = function()\n{\n\tvar result = [];\n\t\n\tfor (var key in this.map)\n\t{\n\t\tresult.push(this.map[key]);\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: visit\n *\n * Visits all entries in the dictionary using the given function with the\n * following signature: function(key, value) where key is a string and\n * value is an object.\n * \n * Parameters:\n * \n * visitor - A function that takes the key and value as arguments.\n */\nmxDictionary.prototype.visit = function(visitor)\n{\n\tfor (var key in this.map)\n\t{\n\t\tvisitor(key, this.map[key]);\n\t}\n};\n\n__mxOutput.mxDictionary = typeof mxDictionary !== 'undefined' ? mxDictionary : undefined;\n\n/**\n * Copyright (c) 2006-2016, JGraph Ltd\n * Copyright (c) 2006-2016, Gaudenz Alder\n */\nvar mxResources =\n{\n\t/**\n\t * Class: mxResources\n\t * \n\t * Implements internationalization. You can provide any number of \n\t * resource files on the server using the following format for the \n\t * filename: name[-en].properties. The en stands for any lowercase \n\t * 2-character language shortcut (eg. de for german, fr for french).\n\t *\n\t * If the optional language extension is omitted, then the file is used as a \n\t * default resource which is loaded in all cases. If a properties file for a \n\t * specific language exists, then it is used to override the settings in the \n\t * default resource. All entries in the file are of the form key=value. The\n\t * values may then be accessed in code via <get>. Lines without \n\t * equal signs in the properties files are ignored.\n\t *\n\t * Resource files may either be added programmatically using\n\t * <add> or via a resource tag in the UI section of the \n\t * editor configuration file, eg:\n\t * \n\t * (code)\n\t * <mxEditor>\n\t *   <ui>\n\t *     <resource basename=\"examples/resources/mxWorkflow\"/>\n\t * (end)\n\t * \n\t * The above element will load examples/resources/mxWorkflow.properties as well\n\t * as the language specific file for the current language, if it exists.\n\t * \n\t * Values may contain placeholders of the form {1}...{n} where each placeholder\n\t * is replaced with the value of the corresponding array element in the params\n\t * argument passed to <mxResources.get>. The placeholder {1} maps to the first\n\t * element in the array (at index 0).\n\t * \n\t * See <mxClient.language> for more information on specifying the default\n\t * language or disabling all loading of resources.\n\t * \n\t * Lines that start with a # sign will be ignored.\n\t * \n\t * Special characters\n\t * \n\t * To use unicode characters, use the standard notation (eg. \\u8fd1) or %u as a\n\t * prefix (eg. %u20AC will display a Euro sign). For normal hex encoded strings,\n\t * use % as a prefix, eg. %F6 will display a \"o umlaut\" (&ouml;).\n\t * \n\t * See <resourcesEncoded> to disable this. If you disable this, make sure that\n\t * your files are UTF-8 encoded.\n\t * \n\t * Asynchronous loading\n\t * \n\t * By default, the core adds two resource files synchronously at load time.\n\t * To load these files asynchronously, set <mxLoadResources> to false\n\t * before loading mxClient.js and use <mxResources.loadResources> instead.\n\t * \n\t * Variable: resources\n\t * \n\t * Object that maps from keys to values.\n\t */\n\tresources: {},\n\n\t/**\n\t * Variable: extension\n\t * \n\t * Specifies the extension used for language files. Default is <mxResourceExtension>.\n\t */\n\textension: mxResourceExtension,\n\n\t/**\n\t * Variable: resourcesEncoded\n\t * \n\t * Specifies whether or not values in resource files are encoded with \\u or\n\t * percentage. Default is false.\n\t */\n\tresourcesEncoded: false,\n\n\t/**\n\t * Variable: loadDefaultBundle\n\t * \n\t * Specifies if the default file for a given basename should be loaded.\n\t * Default is true.\n\t */\n\tloadDefaultBundle: true,\n\n\t/**\n\t * Variable: loadDefaultBundle\n\t * \n\t * Specifies if the specific language file file for a given basename should\n\t * be loaded. Default is true.\n\t */\n\tloadSpecialBundle: true,\n\n\t/**\n\t * Function: isLanguageSupported\n\t * \n\t * Hook for subclassers to disable support for a given language. This\n\t * implementation returns true if lan is in <mxClient.languages>.\n\t * \n\t * Parameters:\n\t *\n\t * lan - The current language.\n\t */\n\tisLanguageSupported: function(lan)\n\t{\n\t\tif (mxClient.languages != null)\n\t\t{\n\t\t\treturn mxUtils.indexOf(mxClient.languages, lan) >= 0;\n\t\t}\n\t\t\n\t\treturn true;\n\t},\n\n\t/**\n\t * Function: getDefaultBundle\n\t * \n\t * Hook for subclassers to return the URL for the special bundle. This\n\t * implementation returns basename + <extension> or null if\n\t * <loadDefaultBundle> is false.\n\t * \n\t * Parameters:\n\t * \n\t * basename - The basename for which the file should be loaded.\n\t * lan - The current language.\n\t */\n\tgetDefaultBundle: function(basename, lan)\n\t{\n\t\tif (mxResources.loadDefaultBundle || !mxResources.isLanguageSupported(lan))\n\t\t{\n\t\t\treturn basename + mxResources.extension;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t},\n\n\t/**\n\t * Function: getSpecialBundle\n\t * \n\t * Hook for subclassers to return the URL for the special bundle. This\n\t * implementation returns basename + '_' + lan + <extension> or null if\n\t * <loadSpecialBundle> is false or lan equals <mxClient.defaultLanguage>.\n\t * \n\t * If <mxResources.languages> is not null and <mxClient.language> contains\n\t * a dash, then this method checks if <isLanguageSupported> returns true\n\t * for the full language (including the dash). If that returns false the\n\t * first part of the language (up to the dash) will be tried as an extension.\n\t * \n\t * If <mxResources.language> is null then the first part of the language is\n\t * used to maintain backwards compatibility.\n\t * \n\t * Parameters:\n\t * \n\t * basename - The basename for which the file should be loaded.\n\t * lan - The language for which the file should be loaded.\n\t */\n\tgetSpecialBundle: function(basename, lan)\n\t{\n\t\tif (mxClient.languages == null || !this.isLanguageSupported(lan))\n\t\t{\n\t\t\tvar dash = lan.indexOf('-');\n\t\t\t\n\t\t\tif (dash > 0)\n\t\t\t{\n\t\t\t\tlan = lan.substring(0, dash);\n\t\t\t}\n\t\t}\n\n\t\tif (mxResources.loadSpecialBundle && mxResources.isLanguageSupported(lan) && lan != mxClient.defaultLanguage)\n\t\t{\n\t\t\treturn basename + '_' + lan + mxResources.extension;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t},\n\n\t/**\n\t * Function: add\n\t * \n\t * Adds the default and current language properties file for the specified\n\t * basename. Existing keys are overridden as new files are added. If no\n\t * callback is used then the request is synchronous.\n\t *\n\t * Example:\n\t * \n\t * At application startup, additional resources may be \n\t * added using the following code:\n\t * \n\t * (code)\n\t * mxResources.add('resources/editor');\n\t * (end)\n\t * \n\t * Parameters:\n\t * \n\t * basename - The basename for which the file should be loaded.\n\t * lan - The language for which the file should be loaded.\n\t * callback - Optional callback for asynchronous loading.\n\t */\n\tadd: function(basename, lan, callback)\n\t{\n\t\tlan = (lan != null) ? lan : ((mxClient.language != null) ?\n\t\t\tmxClient.language.toLowerCase() : mxConstants.NONE);\n\t\t\n\t\tif (lan != mxConstants.NONE)\n\t\t{\n\t\t\tvar defaultBundle = mxResources.getDefaultBundle(basename, lan);\n\t\t\tvar specialBundle = mxResources.getSpecialBundle(basename, lan);\n\t\t\t\n\t\t\tvar loadSpecialBundle = function()\n\t\t\t{\n\t\t\t\tif (specialBundle != null)\n\t\t\t\t{\n\t\t\t\t\tif (callback)\n\t\t\t\t\t{\n\t\t\t\t\t\tmxUtils.get(specialBundle, function(req)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmxResources.parse(req.getText());\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}, function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t   \t\tvar req = mxUtils.load(specialBundle);\n\t\t\t\t\t   \t\t\n\t\t\t\t\t   \t\tif (req.isReady())\n\t\t\t\t\t   \t\t{\n\t\t\t\t\t \t   \t\tmxResources.parse(req.getText());\n\t\t\t\t\t   \t\t}\n\t\t\t\t   \t\t}\n\t\t\t\t   \t\tcatch (e)\n\t\t\t\t   \t\t{\n\t\t\t\t   \t\t\t// ignore\n\t\t\t\t\t   \t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (callback != null)\n\t\t\t\t{\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (defaultBundle != null)\n\t\t\t{\n\t\t\t\tif (callback)\n\t\t\t\t{\n\t\t\t\t\tmxUtils.get(defaultBundle, function(req)\n\t\t\t\t\t{\n\t\t\t\t\t\tmxResources.parse(req.getText());\n\t\t\t\t\t\tloadSpecialBundle();\n\t\t\t\t\t}, function()\n\t\t\t\t\t{\n\t\t\t\t\t\tloadSpecialBundle();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t   \t\tvar req = mxUtils.load(defaultBundle);\n\t\t\t\t   \t\t\n\t\t\t\t   \t\tif (req.isReady())\n\t\t\t\t   \t\t{\n\t\t\t\t \t   \t\tmxResources.parse(req.getText());\n\t\t\t\t   \t\t}\n\t\t\t\t   \t\t\n\t\t\t\t   \t\tloadSpecialBundle();\n\t\t\t\t  \t}\n\t\t\t\t  \tcatch (e)\n\t\t\t\t  \t{\n\t\t\t\t  \t\t// ignore\n\t\t\t\t  \t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Overlays the language specific file (_lan-extension)\n\t\t\t\tloadSpecialBundle();\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Function: parse\n\t * \n\t * Parses the key, value pairs in the specified\n\t * text and stores them as local resources.\n\t */\n\tparse: function(text)\n\t{\n\t\tif (text != null)\n\t\t{\n\t\t\tvar lines = text.split('\\n');\n\t\t\t\n\t\t\tfor (var i = 0; i < lines.length; i++)\n\t\t\t{\n\t\t\t\tif (lines[i].charAt(0) != '#')\n\t\t\t\t{\n\t\t\t\t\tvar index = lines[i].indexOf('=');\n\t\t\t\t\t\n\t\t\t\t\tif (index > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar key = lines[i].substring(0, index);\n\t\t\t\t\t\tvar idx = lines[i].length;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (lines[i].charCodeAt(idx - 1) == 13)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tidx--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar value = lines[i].substring(index + 1, idx);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (this.resourcesEncoded)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvalue = value.replace(/\\\\(?=u[a-fA-F\\d]{4})/g,\"%\");\n\t\t\t\t\t\t\tmxResources.resources[key] = unescape(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmxResources.resources[key] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Function: get\n\t * \n\t * Returns the value for the specified resource key.\n\t *\n\t * Example:\n\t * To read the value for 'welomeMessage', use the following:\n\t * (code)\n\t * var result = mxResources.get('welcomeMessage') || '';\n\t * (end)\n\t *\n\t * This would require an entry of the following form in\n\t * one of the English language resource files:\n\t * (code)\n\t * welcomeMessage=Welcome to mxGraph!\n\t * (end)\n\t * \n\t * The part behind the || is the string value to be used if the given\n\t * resource is not available.\n\t * \n\t * Parameters:\n\t * \n\t * key - String that represents the key of the resource to be returned.\n\t * params - Array of the values for the placeholders of the form {1}...{n}\n\t * to be replaced with in the resulting string.\n\t * defaultValue - Optional string that specifies the default return value.\n\t */\n\tget: function(key, params, defaultValue)\n\t{\n\t\tvar value = mxResources.resources[key];\n\t\t\n\t\t// Applies the default value if no resource was found\n\t\tif (value == null)\n\t\t{\n\t\t\tvalue = defaultValue;\n\t\t}\n\t\t\n\t\t// Replaces the placeholders with the values in the array\n\t\tif (value != null && params != null)\n\t\t{\n\t\t\tvalue = mxResources.replacePlaceholders(value, params);\n\t\t}\n\t\t\n\t\treturn value;\n\t},\n\n\t/**\n\t * Function: replacePlaceholders\n\t * \n\t * Replaces the given placeholders with the given parameters.\n\t * \n\t * Parameters:\n\t * \n\t * value - String that contains the placeholders.\n\t * params - Array of the values for the placeholders of the form {1}...{n}\n\t * to be replaced with in the resulting string.\n\t */\n\treplacePlaceholders: function(value, params)\n\t{\n\t\tvar result = [];\n\t\tvar index = null;\n\t\t\n\t\tfor (var i = 0; i < value.length; i++)\n\t\t{\n\t\t\tvar c = value.charAt(i);\n\n\t\t\tif (c == '{')\n\t\t\t{\n\t\t\t\tindex = '';\n\t\t\t}\n\t\t\telse if (index != null && \tc == '}')\n\t\t\t{\n\t\t\t\tindex = parseInt(index)-1;\n\t\t\t\t\n\t\t\t\tif (index >= 0 && index < params.length)\n\t\t\t\t{\n\t\t\t\t\tresult.push(params[index]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tindex = null;\n\t\t\t}\n\t\t\telse if (index != null)\n\t\t\t{\n\t\t\t\tindex += c;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.push(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result.join('');\n\t},\n\n\t/**\n\t * Function: loadResources\n\t * \n\t * Loads all required resources asynchronously. Use this to load the graph and\n\t * editor resources if <mxLoadResources> is false.\n\t * \n\t * Parameters:\n\t * \n\t * callback - Callback function for asynchronous loading.\n\t */\n\tloadResources: function(callback)\n\t{\n\t\tmxResources.add(mxClient.basePath+'/resources/editor', null, function()\n\t\t{\n\t\t\tmxResources.add(mxClient.basePath+'/resources/graph', null, callback);\n\t\t});\n\t}\n\n};\n\n__mxOutput.mxResources = typeof mxResources !== 'undefined' ? mxResources : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxPoint\n *\n * Implements a 2-dimensional vector with double precision coordinates.\n * \n * Constructor: mxPoint\n *\n * Constructs a new point for the optional x and y coordinates. If no\n * coordinates are given, then the default values for <x> and <y> are used.\n */\nfunction mxPoint(x, y)\n{\n\tthis.x = (x != null) ? x : 0;\n\tthis.y = (y != null) ? y : 0;\n};\n\n/**\n * Variable: x\n *\n * Holds the x-coordinate of the point. Default is 0.\n */\nmxPoint.prototype.x = null;\n\n/**\n * Variable: y\n *\n * Holds the y-coordinate of the point. Default is 0.\n */\nmxPoint.prototype.y = null;\n\n/**\n * Function: equals\n * \n * Returns true if the given object equals this point.\n */\nmxPoint.prototype.equals = function(obj)\n{\n\treturn obj != null && obj.x == this.x && obj.y == this.y;\n};\n\n/**\n * Function: clone\n *\n * Returns a clone of this <mxPoint>.\n */\nmxPoint.prototype.clone = function()\n{\n\t// Handles subclasses as well\n\treturn mxUtils.clone(this);\n};\n\n__mxOutput.mxPoint = typeof mxPoint !== 'undefined' ? mxPoint : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxRectangle\n *\n * Extends <mxPoint> to implement a 2-dimensional rectangle with double\n * precision coordinates.\n * \n * Constructor: mxRectangle\n *\n * Constructs a new rectangle for the optional parameters. If no parameters\n * are given then the respective default values are used.\n */\nfunction mxRectangle(x, y, width, height)\n{\n\tmxPoint.call(this, x, y);\n\n\tthis.width = (width != null) ? width : 0;\n\tthis.height = (height != null) ? height : 0;\n};\n\n/**\n * Extends mxPoint.\n */\nmxRectangle.prototype = new mxPoint();\nmxRectangle.prototype.constructor = mxRectangle;\n\n/**\n * Variable: width\n *\n * Holds the width of the rectangle. Default is 0.\n */\nmxRectangle.prototype.width = null;\n\n/**\n * Variable: height\n *\n * Holds the height of the rectangle. Default is 0.\n */\nmxRectangle.prototype.height = null;\n\n/**\n * Function: setRect\n * \n * Sets this rectangle to the specified values\n */\nmxRectangle.prototype.setRect = function(x, y, w, h)\n{\n    this.x = x;\n    this.y = y;\n    this.width = w;\n    this.height = h;\n};\n\n/**\n * Function: getCenterX\n * \n * Returns the x-coordinate of the center point.\n */\nmxRectangle.prototype.getCenterX = function ()\n{\n\treturn this.x + this.width/2;\n};\n\n/**\n * Function: getCenterY\n * \n * Returns the y-coordinate of the center point.\n */\nmxRectangle.prototype.getCenterY = function ()\n{\n\treturn this.y + this.height/2;\n};\n\n/**\n * Function: add\n *\n * Adds the given rectangle to this rectangle.\n */\nmxRectangle.prototype.add = function(rect)\n{\n\tif (rect != null)\n\t{\n\t\tvar minX = Math.min(this.x, rect.x);\n\t\tvar minY = Math.min(this.y, rect.y);\n\t\tvar maxX = Math.max(this.x + this.width, rect.x + rect.width);\n\t\tvar maxY = Math.max(this.y + this.height, rect.y + rect.height);\n\t\t\n\t\tthis.x = minX;\n\t\tthis.y = minY;\n\t\tthis.width = maxX - minX;\n\t\tthis.height = maxY - minY;\n\t}\n};\n\n/**\n * Function: intersect\n * \n * Changes this rectangle to where it overlaps with the given rectangle.\n */\nmxRectangle.prototype.intersect = function(rect)\n{\n\tif (rect != null)\n\t{\n\t\tvar r1 = this.x + this.width;\n\t\tvar r2 = rect.x + rect.width;\n\t\t\n\t\tvar b1 = this.y + this.height;\n\t\tvar b2 = rect.y + rect.height;\n\t\t\n\t\tthis.x = Math.max(this.x, rect.x);\n\t\tthis.y = Math.max(this.y, rect.y);\n\t\tthis.width = Math.min(r1, r2) - this.x;\n\t\tthis.height = Math.min(b1, b2) - this.y;\n\t}\n};\n\n/**\n * Function: grow\n *\n * Grows the rectangle by the given amount, that is, this method subtracts\n * the given amount from the x- and y-coordinates and adds twice the amount\n * to the width and height.\n */\nmxRectangle.prototype.grow = function(amount)\n{\n\tthis.x -= amount;\n\tthis.y -= amount;\n\tthis.width += 2 * amount;\n\tthis.height += 2 * amount;\n\t\n\treturn this;\n};\n\n/**\n * Function: getPoint\n * \n * Returns the top, left corner as a new <mxPoint>.\n */\nmxRectangle.prototype.getPoint = function()\n{\n\treturn new mxPoint(this.x, this.y);\n};\n\n/**\n * Function: rotate90\n * \n * Rotates this rectangle by 90 degree around its center point.\n */\nmxRectangle.prototype.rotate90 = function()\n{\n\tvar t = (this.width - this.height) / 2;\n\tthis.x += t;\n\tthis.y -= t;\n\tvar tmp = this.width;\n\tthis.width = this.height;\n\tthis.height = tmp;\n};\n\n/**\n * Function: equals\n * \n * Returns true if the given object equals this rectangle.\n */\nmxRectangle.prototype.equals = function(obj)\n{\n\treturn obj != null && obj.x == this.x && obj.y == this.y &&\n\t\tobj.width == this.width && obj.height == this.height;\n};\n\n/**\n * Function: fromRectangle\n * \n * Returns a new <mxRectangle> which is a copy of the given rectangle.\n */\nmxRectangle.fromRectangle = function(rect)\n{\n\treturn new mxRectangle(rect.x, rect.y, rect.width, rect.height);\n};\n\n__mxOutput.mxRectangle = typeof mxRectangle !== 'undefined' ? mxRectangle : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxEffects =\n{\n\n\t/**\n\t * Class: mxEffects\n\t * \n\t * Provides animation effects.\n\t */\n\n\t/**\n\t * Function: animateChanges\n\t * \n\t * Asynchronous animated move operation. See also: <mxMorphing>.\n\t * \n\t * Example:\n\t * \n\t * (code)\n\t * graph.model.addListener(mxEvent.CHANGE, function(sender, evt)\n\t * {\n\t *   var changes = evt.getProperty('edit').changes;\n\t * \n\t *   if (changes.length < 10)\n\t *   {\n\t *     mxEffects.animateChanges(graph, changes);\n\t *   }\n\t * });\n\t * (end)\n\t * \n\t * Parameters:\n\t * \n\t * graph - <mxGraph> that received the changes.\n\t * changes - Array of changes to be animated.\n\t * done - Optional function argument that is invoked after the\n\t * last step of the animation.\n\t */\n\tanimateChanges: function(graph, changes, done)\n\t{\n\t\tvar maxStep = 10;\n\t\tvar step = 0;\n\n\t\tvar animate = function() \n\t\t{\n\t\t\tvar isRequired = false;\n\t\t\t\n\t\t\tfor (var i = 0; i < changes.length; i++)\n\t\t\t{\n\t\t\t\tvar change = changes[i];\n\t\t\t\t\n\t\t\t\tif (change instanceof mxGeometryChange ||\n\t\t\t\t\tchange instanceof mxTerminalChange ||\n\t\t\t\t\tchange instanceof mxValueChange ||\n\t\t\t\t\tchange instanceof mxChildChange ||\n\t\t\t\t\tchange instanceof mxStyleChange)\n\t\t\t\t{\n\t\t\t\t\tvar state = graph.getView().getState(change.cell || change.child, false);\n\t\t\t\t\t\n\t\t\t\t\tif (state != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tisRequired = true;\n\t\t\t\t\t\n\t\t\t\t\t\tif (change.constructor != mxGeometryChange || graph.model.isEdge(change.cell))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmxUtils.setOpacity(state.shape.node, 100 * step / maxStep);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar scale = graph.getView().scale;\t\t\t\t\t\n\n\t\t\t\t\t\t\tvar dx = (change.geometry.x - change.previous.x) * scale;\n\t\t\t\t\t\t\tvar dy = (change.geometry.y - change.previous.y) * scale;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar sx = (change.geometry.width - change.previous.width) * scale;\n\t\t\t\t\t\t\tvar sy = (change.geometry.height - change.previous.height) * scale;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (step == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstate.x -= dx;\n\t\t\t\t\t\t\t\tstate.y -= dy;\n\t\t\t\t\t\t\t\tstate.width -= sx;\n\t\t\t\t\t\t\t\tstate.height -= sy;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstate.x += dx / maxStep;\n\t\t\t\t\t\t\t\tstate.y += dy / maxStep;\n\t\t\t\t\t\t\t\tstate.width += sx / maxStep;\n\t\t\t\t\t\t\t\tstate.height += sy / maxStep;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tgraph.cellRenderer.redraw(state);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Fades all connected edges and children\n\t\t\t\t\t\t\tmxEffects.cascadeOpacity(graph, change.cell, 100 * step / maxStep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (step < maxStep && isRequired)\n\t\t\t{\n\t\t\t\tstep++;\n\t\t\t\twindow.setTimeout(animate, delay);\n\t\t\t}\n\t\t\telse if (done != null)\n\t\t\t{\n\t\t\t\tdone();\n\t\t\t}\n\t\t};\n\t\t\n\t\tvar delay = 30;\n\t\tanimate();\n\t},\n    \n\t/**\n\t * Function: cascadeOpacity\n\t * \n\t * Sets the opacity on the given cell and its descendants.\n\t * \n\t * Parameters:\n\t * \n\t * graph - <mxGraph> that contains the cells.\n\t * cell - <mxCell> to set the opacity for.\n\t * opacity - New value for the opacity in %.\n\t */\n    cascadeOpacity: function(graph, cell, opacity)\n\t{\n\t\t// Fades all children\n\t\tvar childCount = graph.model.getChildCount(cell);\n\t\t\n\t\tfor (var i=0; i<childCount; i++)\n\t\t{\n\t\t\tvar child = graph.model.getChildAt(cell, i);\n\t\t\tvar childState = graph.getView().getState(child);\n\t\t\t\n\t\t\tif (childState != null)\n\t\t\t{\n\t\t\t\tmxUtils.setOpacity(childState.shape.node, opacity);\n\t\t\t\tmxEffects.cascadeOpacity(graph, child, opacity);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Fades all connected edges\n\t\tvar edges = graph.model.getEdges(cell);\n\t\t\n\t\tif (edges != null)\n\t\t{\n\t\t\tfor (var i=0; i<edges.length; i++)\n\t\t\t{\n\t\t\t\tvar edgeState = graph.getView().getState(edges[i]);\n\t\t\t\t\n\t\t\t\tif (edgeState != null)\n\t\t\t\t{\n\t\t\t\t\tmxUtils.setOpacity(edgeState.shape.node, opacity);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Function: fadeOut\n\t * \n\t * Asynchronous fade-out operation.\n\t */\n\tfadeOut: function(node, from, remove, step, delay, isEnabled)\n\t{\n\t\tstep = step || 40;\n\t\tdelay = delay || 30;\n\t\t\n\t\tvar opacity = from || 100;\n\t\t\n\t\tmxUtils.setOpacity(node, opacity);\n\t\t\n\t\tif (isEnabled || isEnabled == null)\n\t\t{\n\t\t\tvar f = function()\n\t\t\t{\n\t\t\t    opacity = Math.max(opacity-step, 0);\n\t\t\t\tmxUtils.setOpacity(node, opacity);\n\t\t\t\t\n\t\t\t\tif (opacity > 0)\n\t\t\t\t{\n\t\t\t\t\twindow.setTimeout(f, delay);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnode.style.visibility = 'hidden';\n\t\t\t\t\t\n\t\t\t\t\tif (remove && node.parentNode)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.parentNode.removeChild(node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\twindow.setTimeout(f, delay);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnode.style.visibility = 'hidden';\n\t\t\t\n\t\t\tif (remove && node.parentNode)\n\t\t\t{\n\t\t\t\tnode.parentNode.removeChild(node);\n\t\t\t}\n\t\t}\n\t}\n\n};\n\n__mxOutput.mxEffects = typeof mxEffects !== 'undefined' ? mxEffects : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxUtils =\n{\n\t/**\n\t * Class: mxUtils\n\t * \n\t * A singleton class that provides cross-browser helper methods.\n\t * This is a global functionality. To access the functions in this\n\t * class, use the global classname appended by the functionname.\n\t * You may have to load chrome://global/content/contentAreaUtils.js\n\t * to disable certain security restrictions in Mozilla for the <open>,\n\t * <save>, <saveAs> and <copy> function.\n\t * \n\t * For example, the following code displays an error message:\n\t * \n\t * (code)\n\t * mxUtils.error('Browser is not supported!', 200, false);\n\t * (end)\n\t * \n\t * Variable: errorResource\n\t * \n\t * Specifies the resource key for the title of the error window. If the\n\t * resource for this key does not exist then the value is used as\n\t * the title. Default is 'error'.\n\t */\n\terrorResource: (mxClient.language != 'none') ? 'error' : '',\n\t\n\t/**\n\t * Variable: closeResource\n\t * \n\t * Specifies the resource key for the label of the close button. If the\n\t * resource for this key does not exist then the value is used as\n\t * the label. Default is 'close'.\n\t */\n\tcloseResource: (mxClient.language != 'none') ? 'close' : '',\n\n\t/**\n\t * Variable: errorImage\n\t * \n\t * Defines the image used for error dialogs.\n\t */\n\terrorImage: mxClient.imageBasePath + '/error.gif',\n\t\n\t/**\n\t * Function: removeCursors\n\t * \n\t * Removes the cursors from the style of the given DOM node and its\n\t * descendants.\n\t * \n\t * Parameters:\n\t * \n\t * element - DOM node to remove the cursor style from.\n\t */\n\tremoveCursors: function(element)\n\t{\n\t\tif (element.style != null)\n\t\t{\n\t\t\telement.style.cursor = '';\n\t\t}\n\t\t\n\t\tvar children = element.childNodes;\n\t\t\n\t\tif (children != null)\n\t\t{\n\t        var childCount = children.length;\n\t        \n\t        for (var i = 0; i < childCount; i += 1)\n\t        {\n\t            mxUtils.removeCursors(children[i]);\n\t        }\n\t    }\n\t},\n\n\t/**\n\t * Function: getCurrentStyle\n\t * \n\t * Returns the current style of the specified element.\n\t * \n\t * Parameters:\n\t * \n\t * element - DOM node whose current style should be returned.\n\t */\n\tgetCurrentStyle: function()\n\t{\n\t\tif (mxClient.IS_IE && (document.documentMode == null || document.documentMode < 9))\n\t\t{\n\t\t\treturn function(element)\n\t\t\t{\n\t\t\t\treturn (element != null) ? element.currentStyle : null;\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn function(element)\n\t\t\t{\n\t\t\t\treturn (element != null) ?\n\t\t\t\t\twindow.getComputedStyle(element, '') :\n\t\t\t\t\tnull;\n\t\t\t};\n\t\t}\n\t}(),\n\t\n\t/**\n\t * Function: parseCssNumber\n\t * \n\t * Parses the given CSS numeric value adding handling for the values thin,\n\t * medium and thick (2, 4 and 6).\n\t */\n\tparseCssNumber: function(value)\n\t{\n\t\tif (value == 'thin')\n\t\t{\n\t\t\tvalue = '2';\n\t\t}\n\t\telse if (value == 'medium')\n\t\t{\n\t\t\tvalue = '4';\n\t\t}\n\t\telse if (value == 'thick')\n\t\t{\n\t\t\tvalue = '6';\n\t\t}\n\t\t\n\t\tvalue = parseFloat(value);\n\t\t\n\t\tif (isNaN(value))\n\t\t{\n\t\t\tvalue = 0;\n\t\t}\n\t\t\n\t\treturn value;\n\t},\n\n\t/**\n\t * Function: setPrefixedStyle\n\t * \n\t * Adds the given style with the standard name and an optional vendor prefix for the current\n\t * browser.\n\t * \n\t * (code)\n\t * mxUtils.setPrefixedStyle(node.style, 'transformOrigin', '0% 0%');\n\t * (end)\n\t */\n\tsetPrefixedStyle: function()\n\t{\n\t\tvar prefix = null;\n\t\t\n\t\tif (mxClient.IS_OT)\n\t\t{\n\t\t\tprefix = 'O';\n\t\t}\n\t\telse if (mxClient.IS_SF || mxClient.IS_GC)\n\t\t{\n\t\t\tprefix = 'Webkit';\n\t\t}\n\t\telse if (mxClient.IS_MT)\n\t\t{\n\t\t\tprefix = 'Moz';\n\t\t}\n\t\telse if (mxClient.IS_IE && document.documentMode >= 9 && document.documentMode < 10)\n\t\t{\n\t\t\tprefix = 'ms';\n\t\t}\n\n\t\treturn function(style, name, value)\n\t\t{\n\t\t\tstyle[name] = value;\n\t\t\t\n\t\t\tif (prefix != null && name.length > 0)\n\t\t\t{\n\t\t\t\tname = prefix + name.substring(0, 1).toUpperCase() + name.substring(1);\n\t\t\t\tstyle[name] = value;\n\t\t\t}\n\t\t};\n\t}(),\n\t\n\t/**\n\t * Function: hasScrollbars\n\t * \n\t * Returns true if the overflow CSS property of the given node is either\n\t * scroll or auto.\n\t * \n\t * Parameters:\n\t * \n\t * node - DOM node whose style should be checked for scrollbars.\n\t */\n\thasScrollbars: function(node)\n\t{\n\t\tvar style = mxUtils.getCurrentStyle(node);\n\n\t\treturn style != null && (style.overflow == 'scroll' || style.overflow == 'auto');\n\t},\n\t\n\t/**\n\t * Function: bind\n\t * \n\t * Returns a wrapper function that locks the execution scope of the given\n\t * function to the specified scope. Inside funct, the \"this\" keyword\n\t * becomes a reference to that scope.\n\t */\n\tbind: function(scope, funct)\n\t{\n\t\treturn function()\n\t\t{\n\t\t\treturn funct.apply(scope, arguments);\n\t\t};\n\t},\n\t\n\t/**\n\t * Function: eval\n\t * \n\t * Evaluates the given expression using eval and returns the JavaScript\n\t * object that represents the expression result. Supports evaluation of\n\t * expressions that define functions and returns the function object for\n\t * these expressions.\n\t * \n\t * Parameters:\n\t * \n\t * expr - A string that represents a JavaScript expression.\n\t */\n\teval: function(expr)\n\t{\n\t\tvar result = null;\n\n\t\tif (expr.indexOf('function') >= 0)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\teval('var _mxJavaScriptExpression='+expr);\n\t\t\t\tresult = _mxJavaScriptExpression;\n\t\t\t\t// TODO: Use delete here?\n\t\t\t\t_mxJavaScriptExpression = null;\n\t\t\t}\n\t\t\tcatch (e)\n\t\t\t{\n\t\t\t\tmxLog.warn(e.message + ' while evaluating ' + expr);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tresult = eval(expr);\n\t\t\t}\n\t\t\tcatch (e)\n\t\t\t{\n\t\t\t\tmxLog.warn(e.message + ' while evaluating ' + expr);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t},\n\t\n\t/**\n\t * Function: findNode\n\t * \n\t * Returns the first node where attr equals value.\n\t * This implementation does not use XPath.\n\t */\n\tfindNode: function(node, attr, value)\n\t{\n\t\tif (node.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t{\n\t\t\tvar tmp = node.getAttribute(attr);\n\t\n\t\t\tif (tmp != null && tmp == value)\n\t\t\t{\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t\n\t\tnode = node.firstChild;\n\t\t\n\t\twhile (node != null)\n\t\t{\n\t\t\tvar result = mxUtils.findNode(node, attr, value);\n\t\t\t\n\t\t\tif (result != null)\n\t\t\t{\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t\tnode = node.nextSibling;\n\t\t}\n\t\t\n\t\treturn null;\n\t},\n\n\t/**\n\t * Function: getFunctionName\n\t * \n\t * Returns the name for the given function.\n\t * \n\t * Parameters:\n\t * \n\t * f - JavaScript object that represents a function.\n\t */\n\tgetFunctionName: function(f)\n\t{\n\t\tvar str = null;\n\n\t\tif (f != null)\n\t\t{\n\t\t\tif (f.name != null)\n\t\t\t{\n\t\t\t\tstr = f.name;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = mxUtils.trim(f.toString());\n\t\t\t\t\n\t\t\t\tif (/^function\\s/.test(str))\n\t\t\t\t{\n\t\t\t\t\tstr = mxUtils.ltrim(str.substring(9));\n\t\t\t\t\tvar idx2 = str.indexOf('(');\n\t\t\t\t\t\n\t\t\t\t\tif (idx2 > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstr = str.substring(0, idx2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn str;\n\t},\n\n\t/**\n\t * Function: indexOf\n\t * \n\t * Returns the index of obj in array or -1 if the array does not contain\n\t * the given object.\n\t * \n\t * Parameters:\n\t * \n\t * array - Array to check for the given obj.\n\t * obj - Object to find in the given array.\n\t */\n\tindexOf: function(array, obj)\n\t{\n\t\tif (array != null && obj != null)\n\t\t{\n\t\t\tfor (var i = 0; i < array.length; i++)\n\t\t\t{\n\t\t\t\tif (array[i] == obj)\n\t\t\t\t{\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t},\n\n\t/**\n\t * Function: forEach\n\t * \n\t * Calls the given function for each element of the given array and returns\n\t * the array.\n\t * \n\t * Parameters:\n\t * \n\t * array - Array that contains the elements.\n\t * fn - Function to be called for each object.\n\t */\n\tforEach: function(array, fn)\n\t{\n\t\tif (array != null && fn != null)\n\t\t{\n\t\t\tfor (var i = 0; i < array.length; i++)\n\t\t\t{\n\t\t\t\tfn(array[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn array;\n\t},\n\n\t/**\n\t * Function: remove\n\t * \n\t * Removes all occurrences of the given object in the given array or\n\t * object. If there are multiple occurrences of the object, be they\n\t * associative or as an array entry, all occurrences are removed from\n\t * the array or deleted from the object. By removing the object from\n\t * the array, all elements following the removed element are shifted\n\t * by one step towards the beginning of the array.\n\t * \n\t * The length of arrays is not modified inside this function.\n\t * \n\t * Parameters:\n\t * \n\t * obj - Object to find in the given array.\n\t * array - Array to check for the given obj.\n\t */\n\tremove: function(obj, array)\n\t{\n\t\tvar result = null;\n\t\t\n\t\tif (typeof(array) == 'object')\n\t\t{\n\t\t\tvar index = mxUtils.indexOf(array, obj);\n\t\t\t\n\t\t\twhile (index >= 0)\n\t\t\t{\n\t\t\t\tarray.splice(index, 1);\n\t\t\t\tresult = obj;\n\t\t\t\tindex = mxUtils.indexOf(array, obj);\n\t\t\t}\n\t\t}\n\n\t\tfor (var key in array)\n\t\t{\n\t\t\tif (array[key] == obj)\n\t\t\t{\n\t\t\t\tdelete array[key];\n\t\t\t\tresult = obj;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t},\n\t\n\t/**\n\t * Function: isNode\n\t * \n\t * Returns true if the given value is an XML node with the node name\n\t * and if the optional attribute has the specified value.\n\t * \n\t * This implementation assumes that the given value is a DOM node if the\n\t * nodeType property is numeric, that is, if isNaN returns false for\n\t * value.nodeType.\n\t * \n\t * Parameters:\n\t * \n\t * value - Object that should be examined as a node.\n\t * nodeName - String that specifies the node name.\n\t * attributeName - Optional attribute name to check.\n\t * attributeValue - Optional attribute value to check.\n\t */\n\t isNode: function(value, nodeName, attributeName, attributeValue)\n\t {\n\t \tif (value != null && !isNaN(value.nodeType) && (nodeName == null ||\n\t \t\tvalue.nodeName.toLowerCase() == nodeName.toLowerCase()))\n \t\t{\n \t\t\treturn attributeName == null ||\n \t\t\t\tvalue.getAttribute(attributeName) == attributeValue;\n \t\t}\n\t \t\n\t \treturn false;\n\t },\n\t\n\t/**\n\t * Function: isAncestorNode\n\t * \n\t * Returns true if the given ancestor is an ancestor of the\n\t * given DOM node in the DOM. This also returns true if the\n\t * child is the ancestor.\n\t * \n\t * Parameters:\n\t * \n\t * ancestor - DOM node that represents the ancestor.\n\t * child - DOM node that represents the child.\n\t */\n\t isAncestorNode: function(ancestor, child)\n\t {\n\t \tvar parent = child;\n\t \t\n\t \twhile (parent != null)\n\t \t{\n\t \t\tif (parent == ancestor)\n\t \t\t{\n\t \t\t\treturn true;\n\t \t\t}\n\n\t \t\tparent = parent.parentNode;\n\t \t}\n\t \t\n\t \treturn false;\n\t },\n\n\t/**\n\t * Function: getChildNodes\n\t * \n\t * Returns an array of child nodes that are of the given node type.\n\t * \n\t * Parameters:\n\t * \n\t * node - Parent DOM node to return the children from.\n\t * nodeType - Optional node type to return. Default is\n\t * <mxConstants.NODETYPE_ELEMENT>.\n\t */\n\tgetChildNodes: function(node, nodeType)\n\t{\n\t\tnodeType = nodeType || mxConstants.NODETYPE_ELEMENT;\n\t\t\n\t\tvar children = [];\n\t\tvar tmp = node.firstChild;\n\t\t\n\t\twhile (tmp != null)\n\t\t{\n\t\t\tif (tmp.nodeType == nodeType)\n\t\t\t{\n\t\t\t\tchildren.push(tmp);\n\t\t\t}\n\t\t\t\n\t\t\ttmp = tmp.nextSibling;\n\t\t}\n\t\t\n\t\treturn children;\n\t},\n\n\t/**\n\t * Function: importNode\n\t * \n\t * Cross browser implementation for document.importNode. Uses document.importNode\n\t * in all browsers but IE, where the node is cloned by creating a new node and\n\t * copying all attributes and children into it using importNode, recursively.\n\t * \n\t * Parameters:\n\t * \n\t * doc - Document to import the node into.\n\t * node - Node to be imported.\n\t * allChildren - If all children should be imported.\n\t */\n\timportNode: function(doc, node, allChildren)\n\t{\n\t\tif (mxClient.IS_IE && (document.documentMode == null || document.documentMode < 10))\n\t\t{\n\t\t\treturn mxUtils.importNodeImplementation(doc, node, allChildren);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn doc.importNode(node, allChildren);\n\t\t}\n\t},\n\n\t/**\n\t * Function: importNodeImplementation\n\t * \n\t * Full DOM API implementation for importNode without using importNode API call.\n\t * \n\t * Parameters:\n\t * \n\t * doc - Document to import the node into.\n\t * node - Node to be imported.\n\t * allChildren - If all children should be imported.\n\t */\n\timportNodeImplementation: function(doc, node, allChildren)\n\t{\n\t\tswitch (node.nodeType)\n\t\t{\n\t\t\tcase 1: /* element */\n\t\t\t{\n\t\t\t\tvar newNode = doc.createElement(node.nodeName);\n\t\t\t\t\n\t\t\t\tif (node.attributes && node.attributes.length > 0)\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < node.attributes.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewNode.setAttribute(node.attributes[i].nodeName,\n\t\t\t\t\t\t\tnode.getAttribute(node.attributes[i].nodeName));\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (allChildren && node.childNodes && node.childNodes.length > 0)\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < node.childNodes.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewNode.appendChild(mxUtils.importNodeImplementation(doc, node.childNodes[i], allChildren));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn newNode;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 3: /* text */\n\t\t    case 4: /* cdata-section */\n\t\t    case 8: /* comment */\n\t\t    {\n\t\t    \treturn doc.createTextNode((node.nodeValue != null) ? node.nodeValue : node.value);\n\t\t    \tbreak;\n\t\t    }\n\t\t};\n\t},\n\n\t/**\n\t * Function: createXmlDocument\n\t * \n\t * Returns a new, empty XML document.\n\t */\n\tcreateXmlDocument: function()\n\t{\n\t\tvar doc = null;\n\t\t\n\t\tif (document.implementation && document.implementation.createDocument)\n\t\t{\n\t\t\tdoc = document.implementation.createDocument('', '', null);\n\t\t}\n\t\telse if (\"ActiveXObject\" in window)\n\t\t{\n\t\t\tdoc = mxUtils.createMsXmlDocument();\n\t \t}\n\t \t\n\t \treturn doc;\n\t},\n\n\t/**\n\t * Function: createMsXmlDocument\n\t * \n\t * Returns a new, empty Microsoft.XMLDOM document using ActiveXObject.\n\t */\n\tcreateMsXmlDocument: function()\n\t{\n\t\tvar doc = new ActiveXObject('Microsoft.XMLDOM');\n\t\tdoc.async = false;\n\n\t\t// Workaround for parsing errors with SVG DTD\n\t\tdoc.validateOnParse = false;\n\t\tdoc.resolveExternals = false;\n\t \t\n\t \treturn doc;\n\t},\n\n\t/**\n\t * Function: parseXml\n\t * \n\t * Parses the specified XML string into a new XML document and returns the\n\t * new document.\n\t * \n\t * Example:\n\t * \n\t * (code)\n\t * var doc = mxUtils.parseXml(\n\t *   '<mxGraphModel><root><MyDiagram id=\"0\"><mxCell/></MyDiagram>'+\n\t *   '<MyLayer id=\"1\"><mxCell parent=\"0\" /></MyLayer><MyObject id=\"2\">'+\n\t *   '<mxCell style=\"strokeColor=blue;fillColor=red\" parent=\"1\" vertex=\"1\">'+\n\t *   '<mxGeometry x=\"10\" y=\"10\" width=\"80\" height=\"30\" as=\"geometry\"/>'+\n\t *   '</mxCell></MyObject></root></mxGraphModel>');\n\t * (end)\n\t * \n\t * Parameters:\n\t * \n\t * xml - String that contains the XML data.\n\t */\n\tparseXml: function()\n\t{\n\t\tif (window.DOMParser)\n\t\t{\n\t\t\treturn function(xml)\n\t\t\t{\n\t\t\t\tvar parser = new DOMParser();\n\t\t\t\t\n\t\t\t\treturn parser.parseFromString(xml, 'text/xml');\n\t\t\t};\n\t\t}\n\t\telse // IE<=9\n\t\t{\n\t\t\treturn function(xml)\n\t\t\t{\n\t\t\t\tvar doc = mxUtils.createMsXmlDocument();\n\t\t\t\tdoc.loadXML(xml);\n\t\t\t\t\n\t\t\t\treturn doc;\n\t\t\t};\n\t\t}\n\t}(),\n\n\t/**\n\t * Function: clearSelection\n\t * \n\t * Clears the current selection in the page.\n\t */\n\tclearSelection: function()\n\t{\n\t\tif (document.selection)\n\t\t{\n\t\t\treturn function()\n\t\t\t{\n\t\t\t\tdocument.selection.empty();\n\t\t\t};\n\t\t}\n\t\telse if (window.getSelection)\n\t\t{\n\t\t\treturn function()\n\t\t\t{\n\t\t\t\tif (window.getSelection().empty)\n\t\t\t\t{\n\t\t\t\t\twindow.getSelection().empty();\n\t\t\t\t}\n\t\t\t\telse if (window.getSelection().removeAllRanges)\n\t\t\t\t{\n\t\t\t\t\twindow.getSelection().removeAllRanges();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn function() { };\n\t\t}\n\t}(),\n\n\t/**\n\t * Function: removeWhitespace\n\t * \n\t * Removes the sibling text nodes for the given node that only consists\n\t * of tabs, newlines and spaces.\n\t * \n\t * Parameters:\n\t * \n\t * node - DOM node whose siblings should be removed.\n\t * before - Optional boolean that specifies the direction of the traversal.\n\t */\n\tremoveWhitespace: function(node, before)\n\t{\n\t\tvar tmp = (before) ? node.previousSibling : node.nextSibling;\n\t\t\n\t\twhile (tmp != null && tmp.nodeType == mxConstants.NODETYPE_TEXT)\n\t\t{\n\t\t\tvar next = (before) ? tmp.previousSibling : tmp.nextSibling;\n\t\t\tvar text = mxUtils.getTextContent(tmp);\n\t\t\t\n\t\t\tif (mxUtils.trim(text).length == 0)\n\t\t\t{\n\t\t\t\ttmp.parentNode.removeChild(tmp);\n\t\t\t}\n\t\t\t\n\t\t\ttmp = next;\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: htmlEntities\n\t * \n\t * Replaces characters (less than, greater than, newlines and quotes) with\n\t * their HTML entities in the given string and returns the result.\n\t * \n\t * Parameters:\n\t * \n\t * s - String that contains the characters to be converted.\n\t * newline - If newlines should be replaced. Default is true.\n\t */\n\thtmlEntities: function(s, newline)\n\t{\n\t\ts = String(s || '');\n\t\t\n\t\ts = s.replace(/&/g,'&amp;'); // 38 26\n\t\ts = s.replace(/\"/g,'&quot;'); // 34 22\n\t\ts = s.replace(/\\'/g,'&#39;'); // 39 27\n\t\ts = s.replace(/</g,'&lt;'); // 60 3C\n\t\ts = s.replace(/>/g,'&gt;'); // 62 3E\n\n\t\tif (newline == null || newline)\n\t\t{\n\t\t\ts = s.replace(/\\n/g, '&#xa;');\n\t\t}\n\t\t\n\t\treturn s;\n\t},\n\t\n\t/**\n\t * Function: isVml\n\t * \n\t * Returns true if the given node is in the VML namespace.\n\t * \n\t * Parameters:\n\t * \n\t * node - DOM node whose tag urn should be checked.\n\t */\n\tisVml: function(node)\n\t{\n\t\treturn node != null && node.tagUrn == 'urn:schemas-microsoft-com:vml';\n\t},\n\n\t/**\n\t * Function: getXml\n\t * \n\t * Returns the XML content of the specified node. For Internet Explorer,\n\t * all \\r\\n\\t[\\t]* are removed from the XML string and the remaining \\r\\n\n\t * are replaced by \\n. All \\n are then replaced with linefeed, or &#xa; if\n\t * no linefeed is defined.\n\t * \n\t * Parameters:\n\t * \n\t * node - DOM node to return the XML for.\n\t * linefeed - Optional string that linefeeds are converted into. Default is\n\t * &#xa;\n\t */\n\tgetXml: function(node, linefeed)\n\t{\n\t\tvar xml = '';\n\t\t\n\t\tif (mxClient.IS_IE || mxClient.IS_IE11)\n\t\t{\n\t\t\txml = mxUtils.getPrettyXml(node, '', '', '');\n\t\t}\n\t\telse if (window.XMLSerializer != null)\n\t\t{\n\t\t\tvar xmlSerializer = new XMLSerializer();\n\t\t\txml = xmlSerializer.serializeToString(node);     \n\t\t}\n\t\telse if (node.xml != null)\n\t\t{\n\t\t\txml = node.xml.replace(/\\r\\n\\t[\\t]*/g, '').\n\t\t\t\treplace(/>\\r\\n/g, '>').\n\t\t\t\treplace(/\\r\\n/g, '\\n');\n\t\t}\n\n\t\t// Replaces linefeeds with HTML Entities.\n\t\tlinefeed = linefeed || '&#xa;';\n\t\txml = xml.replace(/\\n/g, linefeed);\n\t\t  \n\t\treturn xml;\n\t},\n\t\n\t/**\n\t * Function: getPrettyXML\n\t * \n\t * Returns a pretty printed string that represents the XML tree for the\n\t * given node. This method should only be used to print XML for reading,\n\t * use <getXml> instead to obtain a string for processing.\n\t * \n\t * Parameters:\n\t * \n\t * node - DOM node to return the XML for.\n\t * tab - Optional string that specifies the indentation for one level.\n\t * Default is two spaces.\n\t * indent - Optional string that represents the current indentation.\n\t * Default is an empty string.\n\t * newline - Option string that represents a linefeed. Default is '\\n'.\n\t */\n\tgetPrettyXml: function(node, tab, indent, newline, ns)\n\t{\n\t\tvar result = [];\n\t\t\n\t\tif (node != null)\n\t\t{\n\t\t\ttab = (tab != null) ? tab : '  ';\n\t\t\tindent = (indent != null) ? indent : '';\n\t\t\tnewline = (newline != null) ? newline : '\\n';\n\t\t\t\n\t\t\tif (node.namespaceURI != null && node.namespaceURI != ns)\n\t\t\t{\n\t\t\t\tns = node.namespaceURI;\n\t\t\t\t\n\t\t\t\tif (node.getAttribute('xmlns') == null)\n\t\t\t\t{\n\t\t\t\t\tnode.setAttribute('xmlns', node.namespaceURI);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (node.nodeType == mxConstants.NODETYPE_DOCUMENT)\n\t\t\t{\n\t\t\t\tresult.push(mxUtils.getPrettyXml(node.documentElement, tab, indent, newline, ns));\n\t\t\t}\n\t\t\telse if (node.nodeType == mxConstants.NODETYPE_DOCUMENT_FRAGMENT)\n\t\t\t{\n\t\t\t\tvar tmp = node.firstChild;\n\t\t\t\t\n\t\t\t\tif (tmp != null)\n\t\t\t\t{\n\t\t\t\t\twhile (tmp != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.push(mxUtils.getPrettyXml(tmp, tab, indent, newline, ns));\n\t\t\t\t\t\ttmp = tmp.nextSibling;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (node.nodeType == mxConstants.NODETYPE_COMMENT)\n\t\t\t{\n\t\t\t\tvar value = mxUtils.getTextContent(node);\n\t\t\t\t\n\t\t\t\tif (value.length > 0)\n\t\t\t\t{\n\t\t\t\t\tresult.push(indent + '<!--' + value + '-->' + newline);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (node.nodeType == mxConstants.NODETYPE_TEXT)\n\t\t\t{\n\t\t\t\tvar value = mxUtils.trim(mxUtils.getTextContent(node));\n\t\t\t\t\n\t\t\t\tif (value.length > 0)\n\t\t\t\t{\n\t\t\t\t\tresult.push(indent + mxUtils.htmlEntities(value, false) + newline);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (node.nodeType == mxConstants.NODETYPE_CDATA)\n\t\t\t{\n\t\t\t\tvar value = mxUtils.getTextContent(node);\n\t\t\t\t\n\t\t\t\tif (value.length > 0)\n\t\t\t\t{\n\t\t\t\t\tresult.push(indent + '<![CDATA[' + value + ']]' + newline);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.push(indent + '<' + node.nodeName);\n\t\t\t\t\n\t\t\t\t// Creates the string with the node attributes\n\t\t\t\t// and converts all HTML entities in the values\n\t\t\t\tvar attrs = node.attributes;\n\t\t\t\t\n\t\t\t\tif (attrs != null)\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < attrs.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar val = mxUtils.htmlEntities(attrs[i].value);\n\t\t\t\t\t\tresult.push(' ' + attrs[i].nodeName + '=\"' + val + '\"');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Recursively creates the XML string for each child\n\t\t\t\t// node and appends it here with an indentation\n\t\t\t\tvar tmp = node.firstChild;\n\t\t\t\t\n\t\t\t\tif (tmp != null)\n\t\t\t\t{\n\t\t\t\t\tresult.push('>' + newline);\n\t\t\t\t\t\n\t\t\t\t\twhile (tmp != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.push(mxUtils.getPrettyXml(tmp, tab, indent + tab, newline, ns));\n\t\t\t\t\t\ttmp = tmp.nextSibling;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tresult.push(indent + '</'+ node.nodeName + '>' + newline);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult.push(' />' + newline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result.join('');\n\t},\n\t\n\t/**\n\t * Function: extractTextWithWhitespace\n\t * \n\t * Returns the text content of the specified node.\n\t * \n\t * Parameters:\n\t * \n\t * elems - DOM nodes to return the text for.\n\t */\n\textractTextWithWhitespace: function(elems)\n\t{\n\t    // Known block elements for handling linefeeds (list is not complete)\n\t\tvar blocks = ['BLOCKQUOTE', 'DIV', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'OL', 'P', 'PRE', 'TABLE', 'UL'];\n\t\tvar ret = [];\n\t\t\n\t\tfunction doExtract(elts)\n\t\t{\n\t\t\t// Single break should be ignored\n\t\t\tif (elts.length == 1 && (elts[0].nodeName == 'BR' ||\n\t\t\t\telts[0].innerHTML == '\\n'))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t    for (var i = 0; i < elts.length; i++)\n\t\t    {\n\t\t        var elem = elts[i];\n\n\t\t\t\t// DIV with a br or linefeed forces a linefeed\n\t\t\t\tif (elem.nodeName == 'BR' || elem.innerHTML == '\\n' ||\n\t\t\t\t\t((elts.length == 1 || i == 0) && (elem.nodeName == 'DIV' &&\n\t\t\t\t\telem.innerHTML.toLowerCase() == '<br>')))\n\t\t    \t{\n\t    \t\t\tret.push('\\n');\n\t\t    \t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t        if (elem.nodeType === 3 || elem.nodeType === 4)\n\t\t\t        {\n\t\t\t        \tif (elem.nodeValue.length > 0)\n\t\t\t        \t{\n\t\t\t        \t\tret.push(elem.nodeValue);\n\t\t\t        \t}\n\t\t\t        }\n\t\t\t        else if (elem.nodeType !== 8 && elem.childNodes.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdoExtract(elem.childNodes);\n\t\t\t\t\t}\n\t\t\t        \n\t        \t\tif (i < elts.length - 1 && mxUtils.indexOf(blocks, elts[i + 1].nodeName) >= 0)\n\t        \t\t{\n\t        \t\t\tret.push('\\n');\t\t\n\t        \t\t}\n\t\t\t\t}\n\t\t    }\n\t\t};\n\t\t\n\t\tdoExtract(elems);\n\t    \n\t    return ret.join('');\n\t},\n\n\t/**\n\t * Function: replaceTrailingNewlines\n\t * \n\t * Replaces each trailing newline with the given pattern.\n\t */\n\treplaceTrailingNewlines: function(str, pattern)\n\t{\n\t\t// LATER: Check is this can be done with a regular expression\n\t\tvar postfix = '';\n\t\t\n\t\twhile (str.length > 0 && str.charAt(str.length - 1) == '\\n')\n\t\t{\n\t\t\tstr = str.substring(0, str.length - 1);\n\t\t\tpostfix += pattern;\n\t\t}\n\t\t\n\t\treturn str + postfix;\n\t},\n\n\t/**\n\t * Function: getTextContent\n\t * \n\t * Returns the text content of the specified node.\n\t * \n\t * Parameters:\n\t * \n\t * node - DOM node to return the text content for.\n\t */\n\tgetTextContent: function(node)\n\t{\n\t\t// Only IE10-\n\t\tif (mxClient.IS_IE && node.innerText !== undefined)\n\t\t{\n\t\t\treturn node.innerText;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn (node != null) ? node[(node.textContent === undefined) ? 'text' : 'textContent'] : '';\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: setTextContent\n\t * \n\t * Sets the text content of the specified node.\n\t * \n\t * Parameters:\n\t * \n\t * node - DOM node to set the text content for.\n\t * text - String that represents the text content.\n\t */\n\tsetTextContent: function(node, text)\n\t{\n\t\tif (node.innerText !== undefined)\n\t\t{\n\t\t\tnode.innerText = text;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnode[(node.textContent === undefined) ? 'text' : 'textContent'] = text;\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: getInnerHtml\n\t * \n\t * Returns the inner HTML for the given node as a string or an empty string\n\t * if no node was specified. The inner HTML is the text representing all\n\t * children of the node, but not the node itself.\n\t * \n\t * Parameters:\n\t * \n\t * node - DOM node to return the inner HTML for.\n\t */\n\tgetInnerHtml: function()\n\t{\n\t\tif (mxClient.IS_IE)\n\t\t{\n\t\t\treturn function(node)\n\t\t\t{\n\t\t\t\tif (node != null)\n\t\t\t\t{\n\t\t\t\t\treturn node.innerHTML;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn '';\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn function(node)\n\t\t\t{\n\t\t\t\tif (node != null)\n\t\t\t\t{\n\t\t\t\t\tvar serializer = new XMLSerializer();\n\t\t\t\t\treturn serializer.serializeToString(node);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn '';\n\t\t\t};\n\t\t}\n\t}(),\n\n\t/**\n\t * Function: getOuterHtml\n\t * \n\t * Returns the outer HTML for the given node as a string or an empty\n\t * string if no node was specified. The outer HTML is the text representing\n\t * all children of the node including the node itself.\n\t * \n\t * Parameters:\n\t * \n\t * node - DOM node to return the outer HTML for.\n\t */\n\tgetOuterHtml: function()\n\t{\n\t\tif (mxClient.IS_IE)\n\t\t{\n\t\t\treturn function(node)\n\t\t\t{\n\t\t\t\tif (node != null)\n\t\t\t\t{\n\t\t\t\t\tif (node.outerHTML != null)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn node.outerHTML;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar tmp = [];\n\t\t\t\t\t\ttmp.push('<'+node.nodeName);\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar attrs = node.attributes;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (attrs != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (var i = 0; i < attrs.length; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar value = attrs[i].value;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (value != null && value.length > 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttmp.push(' ');\n\t\t\t\t\t\t\t\t\ttmp.push(attrs[i].nodeName);\n\t\t\t\t\t\t\t\t\ttmp.push('=\"');\n\t\t\t\t\t\t\t\t\ttmp.push(value);\n\t\t\t\t\t\t\t\t\ttmp.push('\"');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (node.innerHTML.length == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmp.push('/>');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmp.push('>');\n\t\t\t\t\t\t\ttmp.push(node.innerHTML);\n\t\t\t\t\t\t\ttmp.push('</'+node.nodeName+'>');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn tmp.join('');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn '';\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn function(node)\n\t\t\t{\n\t\t\t\tif (node != null)\n\t\t\t\t{\n\t\t\t\t\tvar serializer = new XMLSerializer();\n\t\t\t\t\treturn serializer.serializeToString(node);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn '';\n\t\t\t};\n\t\t}\n\t}(),\n\t\n\t/**\n\t * Function: write\n\t * \n\t * Creates a text node for the given string and appends it to the given\n\t * parent. Returns the text node.\n\t * \n\t * Parameters:\n\t * \n\t * parent - DOM node to append the text node to.\n\t * text - String representing the text to be added.\n\t */\n\twrite: function(parent, text)\n\t{\n\t\tvar doc = parent.ownerDocument;\n\t\tvar node = doc.createTextNode(text);\n\t\t\n\t\tif (parent != null)\n\t\t{\n\t\t\tparent.appendChild(node);\n\t\t}\n\t\t\n\t\treturn node;\n\t},\n\t\n\t/**\n\t * Function: writeln\n\t * \n\t * Creates a text node for the given string and appends it to the given\n\t * parent with an additional linefeed. Returns the text node.\n\t * \n\t * Parameters:\n\t * \n\t * parent - DOM node to append the text node to.\n\t * text - String representing the text to be added.\n\t */\n\twriteln: function(parent, text)\n\t{\n\t\tvar doc = parent.ownerDocument;\n\t\tvar node = doc.createTextNode(text);\n\t\t\n\t\tif (parent != null)\n\t\t{\n\t\t\tparent.appendChild(node);\n\t\t\tparent.appendChild(document.createElement('br'));\n\t\t}\n\t\t\n\t\treturn node;\n\t},\n\t\n\t/**\n\t * Function: br\n\t * \n\t * Appends a linebreak to the given parent and returns the linebreak.\n\t * \n\t * Parameters:\n\t * \n\t * parent - DOM node to append the linebreak to.\n\t */\n\tbr: function(parent, count)\n\t{\n\t\tcount = count || 1;\n\t\tvar br = null;\n\t\t\n\t\tfor (var i = 0; i < count; i++)\n\t\t{\n\t\t\tif (parent != null)\n\t\t\t{\n\t\t\t\tbr = parent.ownerDocument.createElement('br');\n\t\t\t\tparent.appendChild(br);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn br;\n\t},\n\t\t\n\t/**\n\t * Function: button\n\t * \n\t * Returns a new button with the given level and function as an onclick\n\t * event handler.\n\t * \n\t * (code)\n\t * document.body.appendChild(mxUtils.button('Test', function(evt)\n\t * {\n\t *   alert('Hello, World!');\n\t * }));\n\t * (end)\n\t * \n\t * Parameters:\n\t * \n\t * label - String that represents the label of the button.\n\t * funct - Function to be called if the button is pressed.\n\t * doc - Optional document to be used for creating the button. Default is the\n\t * current document.\n\t */\n\tbutton: function(label, funct, doc)\n\t{\n\t\tdoc = (doc != null) ? doc : document;\n\t\t\n\t\tvar button = doc.createElement('button');\n\t\tmxUtils.write(button, label);\n\n\t\tmxEvent.addListener(button, 'click', function(evt)\n\t\t{\n\t\t\tfunct(evt);\n\t\t});\n\t\t\n\t\treturn button;\n\t},\n\t\n\t/**\n\t * Function: para\n\t * \n\t * Appends a new paragraph with the given text to the specified parent and\n\t * returns the paragraph.\n\t * \n\t * Parameters:\n\t * \n\t * parent - DOM node to append the text node to.\n\t * text - String representing the text for the new paragraph.\n\t */\n\tpara: function(parent, text)\n\t{\n\t\tvar p = document.createElement('p');\n\t\tmxUtils.write(p, text);\n\n\t\tif (parent != null)\n\t\t{\n\t\t\tparent.appendChild(p);\n\t\t}\n\t\t\n\t\treturn p;\n\t},\n\n\t/**\n\t * Function: addTransparentBackgroundFilter\n\t * \n\t * Adds a transparent background to the filter of the given node. This\n\t * background can be used in IE8 standards mode (native IE8 only) to pass\n\t * events through the node.\n\t */\n\taddTransparentBackgroundFilter: function(node)\n\t{\n\t\tnode.style.filter += 'progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\\'' +\n\t\t\tmxClient.imageBasePath + '/transparent.gif\\', sizingMethod=\\'scale\\')';\n\t},\n\n\t/**\n\t * Function: linkAction\n\t * \n\t * Adds a hyperlink to the specified parent that invokes action on the\n\t * specified editor.\n\t * \n\t * Parameters:\n\t * \n\t * parent - DOM node to contain the new link.\n\t * text - String that is used as the link label.\n\t * editor - <mxEditor> that will execute the action.\n\t * action - String that defines the name of the action to be executed.\n\t * pad - Optional left-padding for the link. Default is 0.\n\t */\n\tlinkAction: function(parent, text, editor, action, pad)\n\t{\n\t\treturn mxUtils.link(parent, text, function()\n\t\t{\n\t\t\teditor.execute(action);\n\t\t}, pad);\n\t},\n\n\t/**\n\t * Function: linkInvoke\n\t * \n\t * Adds a hyperlink to the specified parent that invokes the specified\n\t * function on the editor passing along the specified argument. The\n\t * function name is the name of a function of the editor instance,\n\t * not an action name.\n\t * \n\t * Parameters:\n\t * \n\t * parent - DOM node to contain the new link.\n\t * text - String that is used as the link label.\n\t * editor - <mxEditor> instance to execute the function on.\n\t * functName - String that represents the name of the function.\n\t * arg - Object that represents the argument to the function.\n\t * pad - Optional left-padding for the link. Default is 0.\n\t */\n\tlinkInvoke: function(parent, text, editor, functName, arg, pad)\n\t{\n\t\treturn mxUtils.link(parent, text, function()\n\t\t{\n\t\t\teditor[functName](arg);\n\t\t}, pad);\n\t},\n\t\n\t/**\n\t * Function: link\n\t * \n\t * Adds a hyperlink to the specified parent and invokes the given function\n\t * when the link is clicked.\n\t * \n\t * Parameters:\n\t * \n\t * parent - DOM node to contain the new link.\n\t * text - String that is used as the link label.\n\t * funct - Function to execute when the link is clicked.\n\t * pad - Optional left-padding for the link. Default is 0.\n\t */\n\tlink: function(parent, text, funct, pad)\n\t{\n\t\tvar a = document.createElement('span');\n\t\t\n\t\ta.style.color = 'blue';\n\t\ta.style.textDecoration = 'underline';\n\t\ta.style.cursor = 'pointer';\n\t\t\n\t\tif (pad != null)\n\t\t{\n\t\t\ta.style.paddingLeft = pad+'px';\n\t\t}\n\t\t\n\t\tmxEvent.addListener(a, 'click', funct);\n\t\tmxUtils.write(a, text);\n\t\t\n\t\tif (parent != null)\n\t\t{\n\t\t\tparent.appendChild(a);\n\t\t}\n\t\t\n\t\treturn a;\n\t},\n\n\t/**\n\t * Function: getDocumentSize\n\t * \n\t * Returns the client size for the current document as an <mxRectangle>.\n\t */\n\tgetDocumentSize: function()\n\t{\n\t\tvar b = document.body;\n\t\tvar d = document.documentElement;\n\t\t\n\t\ttry\n\t\t{\n\t\t\treturn new mxRectangle(0, 0, b.clientWidth || d.clientWidth, Math.max(b.clientHeight || 0, d.clientHeight));\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\treturn new mxRectangle();\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: fit\n\t * \n\t * Makes sure the given node is inside the visible area of the window. This\n\t * is done by setting the left and top in the style. \n\t */\n\tfit: function(node)\n\t{\n\t\tvar ds = mxUtils.getDocumentSize();\n\t\tvar left = parseInt(node.offsetLeft);\n\t\tvar width = parseInt(node.offsetWidth);\n\t\t\t\n\t\tvar offset = mxUtils.getDocumentScrollOrigin(node.ownerDocument);\n\t\tvar sl = offset.x;\n\t\tvar st = offset.y;\n\n\t\tvar b = document.body;\n\t\tvar d = document.documentElement;\n\t\tvar right = (sl) + ds.width;\n\t\t\n\t\tif (left + width > right)\n\t\t{\n\t\t\tnode.style.left = Math.max(sl, right - width) + 'px';\n\t\t}\n\t\t\n\t\tvar top = parseInt(node.offsetTop);\n\t\tvar height = parseInt(node.offsetHeight);\n\t\t\n\t\tvar bottom = st + ds.height;\n\t\t\n\t\tif (top + height > bottom)\n\t\t{\n\t\t\tnode.style.top = Math.max(st, bottom - height) + 'px';\n\t\t}\n\t},\n\n\t/**\n\t * Function: load\n\t * \n\t * Loads the specified URL *synchronously* and returns the <mxXmlRequest>.\n\t * Throws an exception if the file cannot be loaded. See <mxUtils.get> for\n\t * an asynchronous implementation.\n\t *\n\t * Example:\n\t * \n\t * (code)\n\t * try\n\t * {\n\t *   var req = mxUtils.load(filename);\n\t *   var root = req.getDocumentElement();\n\t *   // Process XML DOM...\n\t * }\n\t * catch (ex)\n\t * {\n\t *   mxUtils.alert('Cannot load '+filename+': '+ex);\n\t * }\n\t * (end)\n\t * \n\t * Parameters:\n\t * \n\t * url - URL to get the data from.\n\t */\n\tload: function(url)\n\t{\n\t\tvar req = new mxXmlRequest(url, null, 'GET', false);\n\t\treq.send();\n\t\t\n\t\treturn req;\n\t},\n\n\t/**\n\t * Function: get\n\t * \n\t * Loads the specified URL *asynchronously* and invokes the given functions\n\t * depending on the request status. Returns the <mxXmlRequest> in use. Both\n\t * functions take the <mxXmlRequest> as the only parameter. See\n\t * <mxUtils.load> for a synchronous implementation.\n\t *\n\t * Example:\n\t * \n\t * (code)\n\t * mxUtils.get(url, function(req)\n\t * {\n\t *    var node = req.getDocumentElement();\n\t *    // Process XML DOM...\n\t * });\n\t * (end)\n\t * \n\t * So for example, to load a diagram into an existing graph model, the\n\t * following code is used.\n\t * \n\t * (code)\n\t * mxUtils.get(url, function(req)\n\t * {\n\t *   var node = req.getDocumentElement();\n\t *   var dec = new mxCodec(node.ownerDocument);\n\t *   dec.decode(node, graph.getModel());\n\t * });\n\t * (end)\n\t * \n\t * Parameters:\n\t * \n\t * url - URL to get the data from.\n\t * onload - Optional function to execute for a successful response.\n\t * onerror - Optional function to execute on error.\n\t * binary - Optional boolean parameter that specifies if the request is\n\t * binary.\n\t * timeout - Optional timeout in ms before calling ontimeout.\n\t * ontimeout - Optional function to execute on timeout.\n\t * headers - Optional with headers, eg. {'Authorization': 'token xyz'}\n\t */\n\tget: function(url, onload, onerror, binary, timeout, ontimeout, headers)\n\t{\n\t\tvar req = new mxXmlRequest(url, null, 'GET');\n\t\tvar setRequestHeaders = req.setRequestHeaders;\n\t\t\n\t\tif (headers)\n\t\t{\n\t\t\treq.setRequestHeaders = function(request, params)\n\t\t\t{\n\t\t\t\tsetRequestHeaders.apply(this, arguments);\n\t\t\t\t\n\t\t\t\tfor (var key in headers)\n\t\t\t\t{\n\t\t\t\t\trequest.setRequestHeader(key, headers[key]);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\t\n\t\tif (binary != null)\n\t\t{\n\t\t\treq.setBinary(binary);\n\t\t}\n\t\t\n\t\treq.send(onload, onerror, timeout, ontimeout);\n\t\t\n\t\treturn req;\n\t},\n\n\t/**\n\t * Function: getAll\n\t * \n\t * Loads the URLs in the given array *asynchronously* and invokes the given function\n\t * if all requests returned with a valid 2xx status. The error handler is invoked\n\t * once on the first error or invalid response.\n\t *\n\t * Parameters:\n\t * \n\t * urls - Array of URLs to be loaded.\n\t * onload - Callback with array of <mxXmlRequests>.\n\t * onerror - Optional function to execute on error.\n\t */\n\tgetAll: function(urls, onload, onerror)\n\t{\n\t\tvar remain = urls.length;\n\t\tvar result = [];\n\t\tvar errors = 0;\n\t\tvar err = function()\n\t\t{\n\t\t\tif (errors == 0 && onerror != null)\n\t\t\t{\n\t\t\t\tonerror();\n\t\t\t}\n\n\t\t\terrors++;\n\t\t};\n\t\t\n\t\tfor (var i = 0; i < urls.length; i++)\n\t\t{\n\t\t\t(function(url, index)\n\t\t\t{\n\t\t\t\tmxUtils.get(url, function(req)\n\t\t\t\t{\n\t\t\t\t\tvar status = req.getStatus();\n\t\t\t\t\t\n\t\t\t\t\tif (status < 200 || status > 299)\n\t\t\t\t\t{\n\t\t\t\t\t\terr();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult[index] = req;\n\t\t\t\t\t\tremain--;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (remain == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tonload(result);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, err);\n\t\t\t})(urls[i], i);\n\t\t}\n\t\t\n\t\tif (remain == 0)\n\t\t{\n\t\t\tonload(result);\t\t\t\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: post\n\t * \n\t * Posts the specified params to the given URL *asynchronously* and invokes\n\t * the given functions depending on the request status. Returns the\n\t * <mxXmlRequest> in use. Both functions take the <mxXmlRequest> as the\n\t * only parameter. Make sure to use encodeURIComponent for the parameter\n\t * values.\n\t *\n\t * Example:\n\t * \n\t * (code)\n\t * mxUtils.post(url, 'key=value', function(req)\n\t * {\n\t * \tmxUtils.alert('Ready: '+req.isReady()+' Status: '+req.getStatus());\n\t *  // Process req.getDocumentElement() using DOM API if OK...\n\t * });\n\t * (end)\n\t * \n\t * Parameters:\n\t * \n\t * url - URL to get the data from.\n\t * params - Parameters for the post request.\n\t * onload - Optional function to execute for a successful response.\n\t * onerror - Optional function to execute on error.\n\t */\n\tpost: function(url, params, onload, onerror)\n\t{\n\t\treturn new mxXmlRequest(url, params).send(onload, onerror);\n\t},\n\t\n\t/**\n\t * Function: submit\n\t * \n\t * Submits the given parameters to the specified URL using\n\t * <mxXmlRequest.simulate> and returns the <mxXmlRequest>.\n\t * Make sure to use encodeURIComponent for the parameter\n\t * values.\n\t * \n\t * Parameters:\n\t * \n\t * url - URL to get the data from.\n\t * params - Parameters for the form.\n\t * doc - Document to create the form in.\n\t * target - Target to send the form result to.\n\t */\n\tsubmit: function(url, params, doc, target)\n\t{\n\t\treturn new mxXmlRequest(url, params).simulate(doc, target);\n\t},\n\t\n\t/**\n\t * Function: loadInto\n\t * \n\t * Loads the specified URL *asynchronously* into the specified document,\n\t * invoking onload after the document has been loaded. This implementation\n\t * does not use <mxXmlRequest>, but the document.load method.\n\t * \n\t * Parameters:\n\t * \n\t * url - URL to get the data from.\n\t * doc - The document to load the URL into.\n\t * onload - Function to execute when the URL has been loaded.\n\t */\n\tloadInto: function(url, doc, onload)\n\t{\n\t\tif (mxClient.IS_IE)\n\t\t{\n\t\t\tdoc.onreadystatechange = function ()\n\t\t\t{\n\t\t\t\tif (doc.readyState == 4)\n\t\t\t\t{\n\t\t\t\t\tonload();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoc.addEventListener('load', onload, false);\n\t\t}\n\t\t\n\t\tdoc.load(url);\n\t},\n\t\n\t/**\n\t * Function: getValue\n\t * \n\t * Returns the value for the given key in the given associative array or\n\t * the given default value if the value is null.\n\t * \n\t * Parameters:\n\t * \n\t * array - Associative array that contains the value for the key.\n\t * key - Key whose value should be returned.\n\t * defaultValue - Value to be returned if the value for the given\n\t * key is null.\n\t */\n\tgetValue: function(array, key, defaultValue)\n\t{\n\t\tvar value = (array != null) ? array[key] : null;\n\n\t\tif (value == null)\n\t\t{\n\t\t\tvalue = defaultValue;\t\t\t\n\t\t}\n\t\t\n\t\treturn value;\n\t},\n\t\n\t/**\n\t * Function: getNumber\n\t * \n\t * Returns the numeric value for the given key in the given associative\n\t * array or the given default value (or 0) if the value is null. The value\n\t * is converted to a numeric value using the Number function.\n\t * \n\t * Parameters:\n\t * \n\t * array - Associative array that contains the value for the key.\n\t * key - Key whose value should be returned.\n\t * defaultValue - Value to be returned if the value for the given\n\t * key is null. Default is 0.\n\t */\n\tgetNumber: function(array, key, defaultValue)\n\t{\n\t\tvar value = (array != null) ? array[key] : null;\n\n\t\tif (value == null)\n\t\t{\n\t\t\tvalue = defaultValue || 0;\t\t\t\n\t\t}\n\t\t\n\t\treturn Number(value);\n\t},\n\t\n\t/**\n\t * Function: getColor\n\t * \n\t * Returns the color value for the given key in the given associative\n\t * array or the given default value if the value is null. If the value\n\t * is <mxConstants.NONE> then null is returned.\n\t * \n\t * Parameters:\n\t * \n\t * array - Associative array that contains the value for the key.\n\t * key - Key whose value should be returned.\n\t * defaultValue - Value to be returned if the value for the given\n\t * key is null. Default is null.\n\t */\n\tgetColor: function(array, key, defaultValue)\n\t{\n\t\tvar value = (array != null) ? array[key] : null;\n\n\t\tif (value == null)\n\t\t{\n\t\t\tvalue = defaultValue;\n\t\t}\n\t\telse if (value == mxConstants.NONE)\n\t\t{\n\t\t\tvalue = null;\n\t\t}\n\t\t\n\t\treturn value;\n\t},\n\n\t/**\n\t * Function: clone\n\t * \n\t * Recursively clones the specified object ignoring all fieldnames in the\n\t * given array of transient fields. <mxObjectIdentity.FIELD_NAME> is always\n\t * ignored by this function.\n\t * \n\t * Parameters:\n\t * \n\t * obj - Object to be cloned.\n\t * transients - Optional array of strings representing the fieldname to be\n\t * ignored.\n\t * shallow - Optional boolean argument to specify if a shallow clone should\n\t * be created, that is, one where all object references are not cloned or,\n\t * in other words, one where only atomic (strings, numbers) values are\n\t * cloned. Default is false.\n\t */\n\tclone: function(obj, transients, shallow)\n\t{\n\t\tshallow = (shallow != null) ? shallow : false;\n\t\tvar clone = null;\n\t\t\n\t\tif (obj != null && typeof(obj.constructor) == 'function')\n\t\t{\n\t\t\tclone = new obj.constructor();\n\t\t\t\n\t\t    for (var i in obj)\n\t\t    {\n\t\t    \tif (i != mxObjectIdentity.FIELD_NAME && (transients == null ||\n\t\t    \t\tmxUtils.indexOf(transients, i) < 0))\n\t\t    \t{\n\t\t\t    \tif (!shallow && typeof(obj[i]) == 'object')\n\t\t\t    \t{\n\t\t\t            clone[i] = mxUtils.clone(obj[i]);\n\t\t\t        }\n\t\t\t        else\n\t\t\t        {\n\t\t\t            clone[i] = obj[i];\n\t\t\t        }\n\t\t\t\t}\n\t\t    }\n\t\t}\n\t\t\n\t    return clone;\n\t},\n\n\t/**\n\t * Function: equalPoints\n\t * \n\t * Compares all mxPoints in the given lists.\n\t * \n\t * Parameters:\n\t * \n\t * a - Array of <mxPoints> to be compared.\n\t * b - Array of <mxPoints> to be compared.\n\t */\n\tequalPoints: function(a, b)\n\t{\n\t\tif ((a == null && b != null) || (a != null && b == null) ||\n\t\t\t(a != null && b != null && a.length != b.length))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse if (a != null && b != null)\n\t\t{\n\t\t\tfor (var i = 0; i < a.length; i++)\n\t\t\t{\n\t\t\t\tif ((a[i] != null && b[i] == null) ||\n\t\t\t\t\t(a[i] == null && b[i] != null) ||\n\t\t\t\t\t(a[i] != null && b[i] != null &&\n\t\t\t\t\t(a[i].x != b[i].x || a[i].y != b[i].y)))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t},\n\n\t/**\n\t * Function: equalEntries\n\t * \n\t * Returns true if all properties of the given objects are equal. Values\n\t * with NaN are equal to NaN and unequal to any other value.\n\t * \n\t * Parameters:\n\t * \n\t * a - First object to be compared.\n\t * b - Second object to be compared.\n\t */\n\tequalEntries: function(a, b)\n\t{\n\t\t// Counts keys in b to check if all values have been compared\n\t\tvar count = 0;\n\n\t\tif ((a == null && b != null) || (a != null && b == null) ||\n\t\t\t(a != null && b != null && a.length != b.length))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse if (a != null && b != null)\n\t\t{\n\t\t\tfor (var key in b)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\t\n\t\t\tfor (var key in a)\n\t\t\t{\n\t\t\t\tcount--\n\t\t\t\t\n\t\t\t\tif ((!mxUtils.isNaN(a[key]) || !mxUtils.isNaN(b[key])) && a[key] != b[key])\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn count == 0;\n\t},\n\t\n\t/**\n\t * Function: removeDuplicates\n\t * \n\t * Removes all duplicates from the given array.\n\t */\n\tremoveDuplicates: function(arr)\n\t{\n\t\tvar dict = new mxDictionary();\n\t\tvar result = [];\n\t\t\n\t\tfor (var i = 0; i < arr.length; i++)\n\t\t{\n\t\t\tif (!dict.get(arr[i]))\n\t\t\t{\n\t\t\t\tresult.push(arr[i]);\n\t\t\t\tdict.put(arr[i], true);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t},\n\t\n\t/**\n\t * Function: isNaN\n\t *\n\t * Returns true if the given value is of type number and isNaN returns true.\n\t */\n\tisNaN: function(value)\n\t{\n\t\treturn typeof(value) == 'number' && isNaN(value);\n\t},\n\t\n\t/**\n\t * Function: extend\n\t *\n\t * Assigns a copy of the superclass prototype to the subclass prototype.\n\t * Note that this does not call the constructor of the superclass at this\n\t * point, the superclass constructor should be called explicitely in the\n\t * subclass constructor. Below is an example.\n\t * \n\t * (code)\n\t * MyGraph = function(container, model, renderHint, stylesheet)\n\t * {\n\t *   mxGraph.call(this, container, model, renderHint, stylesheet);\n\t * }\n\t * \n\t * mxUtils.extend(MyGraph, mxGraph);\n\t * (end)\n\t * \n\t * Parameters:\n\t * \n\t * ctor - Constructor of the subclass.\n\t * superCtor - Constructor of the superclass.\n\t */\n\textend: function(ctor, superCtor)\n\t{\n\t\tvar f = function() {};\n\t\tf.prototype = superCtor.prototype;\n\t\t\n\t\tctor.prototype = new f();\n\t\tctor.prototype.constructor = ctor;\n\t},\n\n\t/**\n\t * Function: toString\n\t * \n\t * Returns a textual representation of the specified object.\n\t * \n\t * Parameters:\n\t * \n\t * obj - Object to return the string representation for.\n\t */\n\ttoString: function(obj)\n\t{\n\t    var output = '';\n\t    \n\t    for (var i in obj)\n\t    {\n\t    \ttry\n\t    \t{\n\t\t\t    if (obj[i] == null)\n\t\t\t    {\n\t\t            output += i + ' = [null]\\n';\n\t\t\t    }\n\t\t\t    else if (typeof(obj[i]) == 'function')\n\t\t\t    {\n\t\t            output += i + ' => [Function]\\n';\n\t\t        }\n\t\t        else if (typeof(obj[i]) == 'object')\n\t\t        {\n\t\t        \tvar ctor = mxUtils.getFunctionName(obj[i].constructor); \n\t\t            output += i + ' => [' + ctor + ']\\n';\n\t\t        }\n\t\t        else\n\t\t        {\n\t\t            output += i + ' = ' + obj[i] + '\\n';\n\t\t        }\n\t    \t}\n\t    \tcatch (e)\n\t    \t{\n\t    \t\toutput += i + '=' + e.message;\n\t    \t}\n\t    }\n\t    \n\t    return output;\n\t},\n\n\t/**\n\t * Function: toRadians\n\t * \n\t * Converts the given degree to radians.\n\t */\n\ttoRadians: function(deg)\n\t{\n\t\treturn Math.PI * deg / 180;\n\t},\n\n\t/**\n\t * Function: toDegree\n\t * \n\t * Converts the given radians to degree.\n\t */\n\ttoDegree: function(rad)\n\t{\n\t\treturn rad * 180 / Math.PI;\n\t},\n\t\n\t/**\n\t * Function: arcToCurves\n\t * \n\t * Converts the given arc to a series of curves.\n\t */\n\tarcToCurves: function(x0, y0, r1, r2, angle, largeArcFlag, sweepFlag, x, y)\n\t{\n\t\tx -= x0;\n\t\ty -= y0;\n\t\t\n        if (r1 === 0 || r2 === 0) \n        {\n        \treturn result;\n        }\n        \n        var fS = sweepFlag;\n        var psai = angle;\n        r1 = Math.abs(r1);\n        r2 = Math.abs(r2);\n        var ctx = -x / 2;\n        var cty = -y / 2;\n        var cpsi = Math.cos(psai * Math.PI / 180);\n        var spsi = Math.sin(psai * Math.PI / 180);\n        var rxd = cpsi * ctx + spsi * cty;\n        var ryd = -1 * spsi * ctx + cpsi * cty;\n        var rxdd = rxd * rxd;\n        var rydd = ryd * ryd;\n        var r1x = r1 * r1;\n        var r2y = r2 * r2;\n        var lamda = rxdd / r1x + rydd / r2y;\n        var sds;\n        \n        if (lamda > 1) \n        {\n        \tr1 = Math.sqrt(lamda) * r1;\n        \tr2 = Math.sqrt(lamda) * r2;\n        \tsds = 0;\n        }  \n        else\n        {\n        \tvar seif = 1;\n            \n        \tif (largeArcFlag === fS) \n        \t{\n        \t\tseif = -1;\n        \t}\n            \n        \tsds = seif * Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));\n        }\n        \n        var txd = sds * r1 * ryd / r2;\n        var tyd = -1 * sds * r2 * rxd / r1;\n        var tx = cpsi * txd - spsi * tyd + x / 2;\n        var ty = spsi * txd + cpsi * tyd + y / 2;\n        var rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);\n        var s1 = (rad >= 0) ? rad : 2 * Math.PI + rad;\n        rad = Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) - Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);\n        var dr = (rad >= 0) ? rad : 2 * Math.PI + rad;\n        \n        if (fS == 0 && dr > 0) \n        {\n        \tdr -= 2 * Math.PI;\n        }\n        else if (fS != 0 && dr < 0) \n        {\n        \tdr += 2 * Math.PI;\n        }\n        \n        var sse = dr * 2 / Math.PI;\n        var seg = Math.ceil(sse < 0 ? -1 * sse : sse);\n        var segr = dr / seg;\n        var t = 8/3 * Math.sin(segr / 4) * Math.sin(segr / 4) / Math.sin(segr / 2);\n        var cpsir1 = cpsi * r1;\n        var cpsir2 = cpsi * r2;\n        var spsir1 = spsi * r1;\n        var spsir2 = spsi * r2;\n        var mc = Math.cos(s1);\n        var ms = Math.sin(s1);\n        var x2 = -t * (cpsir1 * ms + spsir2 * mc);\n        var y2 = -t * (spsir1 * ms - cpsir2 * mc);\n        var x3 = 0;\n        var y3 = 0;\n\n\t\tvar result = [];\n        \n        for (var n = 0; n < seg; ++n) \n        {\n            s1 += segr;\n            mc = Math.cos(s1);\n            ms = Math.sin(s1);\n            \n            x3 = cpsir1 * mc - spsir2 * ms + tx;\n            y3 = spsir1 * mc + cpsir2 * ms + ty;\n            var dx = -t * (cpsir1 * ms + spsir2 * mc);\n            var dy = -t * (spsir1 * ms - cpsir2 * mc);\n            \n            // CurveTo updates x0, y0 so need to restore it\n            var index = n * 6;\n            result[index] = Number(x2 + x0);\n            result[index + 1] = Number(y2 + y0);\n            result[index + 2] = Number(x3 - dx + x0);\n            result[index + 3] = Number(y3 - dy + y0);\n            result[index + 4] = Number(x3 + x0);\n            result[index + 5] = Number(y3 + y0);\n            \n\t\t\tx2 = x3 + dx;\n            y2 = y3 + dy;\n        }\n        \n        return result;\n\t},\n\n\t/**\n\t * Function: getBoundingBox\n\t * \n\t * Returns the bounding box for the rotated rectangle.\n\t * \n\t * Parameters:\n\t * \n\t * rect - <mxRectangle> to be rotated.\n\t * angle - Number that represents the angle (in degrees).\n\t * cx - Optional <mxPoint> that represents the rotation center. If no\n\t * rotation center is given then the center of rect is used.\n\t */\n\tgetBoundingBox: function(rect, rotation, cx)\n\t{\n        var result = null;\n\n        if (rect != null && rotation != null && rotation != 0)\n        {\n            var rad = mxUtils.toRadians(rotation);\n            var cos = Math.cos(rad);\n            var sin = Math.sin(rad);\n\n            cx = (cx != null) ? cx : new mxPoint(rect.x + rect.width / 2, rect.y + rect.height / 2);\n\n            var p1 = new mxPoint(rect.x, rect.y);\n            var p2 = new mxPoint(rect.x + rect.width, rect.y);\n            var p3 = new mxPoint(p2.x, rect.y + rect.height);\n            var p4 = new mxPoint(rect.x, p3.y);\n\n            p1 = mxUtils.getRotatedPoint(p1, cos, sin, cx);\n            p2 = mxUtils.getRotatedPoint(p2, cos, sin, cx);\n            p3 = mxUtils.getRotatedPoint(p3, cos, sin, cx);\n            p4 = mxUtils.getRotatedPoint(p4, cos, sin, cx);\n\n            result = new mxRectangle(p1.x, p1.y, 0, 0);\n            result.add(new mxRectangle(p2.x, p2.y, 0, 0));\n            result.add(new mxRectangle(p3.x, p3.y, 0, 0));\n            result.add(new mxRectangle(p4.x, p4.y, 0, 0));\n        }\n\n        return result;\n\t},\n\n\t/**\n\t * Function: getRotatedPoint\n\t * \n\t * Rotates the given point by the given cos and sin.\n\t */\n\tgetRotatedPoint: function(pt, cos, sin, c)\n\t{\n\t\tc = (c != null) ? c : new mxPoint();\n\t\tvar x = pt.x - c.x;\n\t\tvar y = pt.y - c.y;\n\n\t\tvar x1 = x * cos - y * sin;\n\t\tvar y1 = y * cos + x * sin;\n\n\t\treturn new mxPoint(x1 + c.x, y1 + c.y);\n\t},\n\t\n\t/**\n\t * Returns an integer mask of the port constraints of the given map\n\t * @param dict the style map to determine the port constraints for\n\t * @param defaultValue Default value to return if the key is undefined.\n\t * @return the mask of port constraint directions\n\t * \n\t * Parameters:\n\t * \n\t * terminal - <mxCelState> that represents the terminal.\n\t * edge - <mxCellState> that represents the edge.\n\t * source - Boolean that specifies if the terminal is the source terminal.\n\t * defaultValue - Default value to be returned.\n\t */\n\tgetPortConstraints: function(terminal, edge, source, defaultValue)\n\t{\n\t\tvar value = mxUtils.getValue(terminal.style, mxConstants.STYLE_PORT_CONSTRAINT,\n\t\t\tmxUtils.getValue(edge.style, (source) ? mxConstants.STYLE_SOURCE_PORT_CONSTRAINT :\n\t\t\t\tmxConstants.STYLE_TARGET_PORT_CONSTRAINT, null));\n\t\t\n\t\tif (value == null)\n\t\t{\n\t\t\treturn defaultValue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar directions = value.toString();\n\t\t\tvar returnValue = mxConstants.DIRECTION_MASK_NONE;\n\t\t\tvar constraintRotationEnabled = mxUtils.getValue(terminal.style, mxConstants.STYLE_PORT_CONSTRAINT_ROTATION, 0);\n\t\t\tvar rotation = 0;\n\t\t\t\n\t\t\tif (constraintRotationEnabled == 1)\n\t\t\t{\n\t\t\t\trotation = mxUtils.getValue(terminal.style, mxConstants.STYLE_ROTATION, 0);\n\t\t\t}\n\t\t\t\n\t\t\tvar quad = 0;\n\n\t\t\tif (rotation > 45)\n\t\t\t{\n\t\t\t\tquad = 1;\n\t\t\t\t\n\t\t\t\tif (rotation >= 135)\n\t\t\t\t{\n\t\t\t\t\tquad = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (rotation < -45)\n\t\t\t{\n\t\t\t\tquad = 3;\n\t\t\t\t\n\t\t\t\tif (rotation <= -135)\n\t\t\t\t{\n\t\t\t\t\tquad = 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (directions.indexOf(mxConstants.DIRECTION_NORTH) >= 0)\n\t\t\t{\n\t\t\t\tswitch (quad)\n\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_NORTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_EAST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_SOUTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_WEST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (directions.indexOf(mxConstants.DIRECTION_WEST) >= 0)\n\t\t\t{\n\t\t\t\tswitch (quad)\n\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_WEST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_NORTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_EAST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_SOUTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (directions.indexOf(mxConstants.DIRECTION_SOUTH) >= 0)\n\t\t\t{\n\t\t\t\tswitch (quad)\n\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_SOUTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_WEST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_NORTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_EAST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (directions.indexOf(mxConstants.DIRECTION_EAST) >= 0)\n\t\t\t{\n\t\t\t\tswitch (quad)\n\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_EAST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_SOUTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_WEST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_NORTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn returnValue;\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: reversePortConstraints\n\t * \n\t * Reverse the port constraint bitmask. For example, north | east\n\t * becomes south | west\n\t */\n\treversePortConstraints: function(constraint)\n\t{\n\t\tvar result = 0;\n\t\t\n\t\tresult = (constraint & mxConstants.DIRECTION_MASK_WEST) << 3;\n\t\tresult |= (constraint & mxConstants.DIRECTION_MASK_NORTH) << 1;\n\t\tresult |= (constraint & mxConstants.DIRECTION_MASK_SOUTH) >> 1;\n\t\tresult |= (constraint & mxConstants.DIRECTION_MASK_EAST) >> 3;\n\t\t\n\t\treturn result;\n\t},\n\t\n\t/**\n\t * Function: findNearestSegment\n\t * \n\t * Finds the index of the nearest segment on the given cell state for\n\t * the specified coordinate pair.\n\t */\n\tfindNearestSegment: function(state, x, y)\n\t{\n\t\tvar index = -1;\n\t\t\n\t\tif (state.absolutePoints.length > 0)\n\t\t{\n\t\t\tvar last = state.absolutePoints[0];\n\t\t\tvar min = null;\n\t\t\t\n\t\t\tfor (var i = 1; i < state.absolutePoints.length; i++)\n\t\t\t{\n\t\t\t\tvar current = state.absolutePoints[i];\n\t\t\t\tvar dist = mxUtils.ptSegDistSq(last.x, last.y,\n\t\t\t\t\tcurrent.x, current.y, x, y);\n\t\t\t\t\n\t\t\t\tif (min == null || dist < min)\n\t\t\t\t{\n\t\t\t\t\tmin = dist;\n\t\t\t\t\tindex = i - 1;\n\t\t\t\t}\n\n\t\t\t\tlast = current;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn index;\n\t},\n\n\t/**\n\t * Function: getDirectedBounds\n\t * \n\t * Adds the given margins to the given rectangle and rotates and flips the\n\t * rectangle according to the respective styles in style.\n\t */\n\tgetDirectedBounds: function (rect, m, style, flipH, flipV)\n\t{\n\t\tvar d = mxUtils.getValue(style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);\n\t\tflipH = (flipH != null) ? flipH : mxUtils.getValue(style, mxConstants.STYLE_FLIPH, false);\n\t\tflipV = (flipV != null) ? flipV : mxUtils.getValue(style, mxConstants.STYLE_FLIPV, false);\n\n\t\tm.x = Math.round(Math.max(0, Math.min(rect.width, m.x)));\n\t\tm.y = Math.round(Math.max(0, Math.min(rect.height, m.y)));\n\t\tm.width = Math.round(Math.max(0, Math.min(rect.width, m.width)));\n\t\tm.height = Math.round(Math.max(0, Math.min(rect.height, m.height)));\n\t\t\n\t\tif ((flipV && (d == mxConstants.DIRECTION_SOUTH || d == mxConstants.DIRECTION_NORTH)) ||\n\t\t\t(flipH && (d == mxConstants.DIRECTION_EAST || d == mxConstants.DIRECTION_WEST)))\n\t\t{\n\t\t\tvar tmp = m.x;\n\t\t\tm.x = m.width;\n\t\t\tm.width = tmp;\n\t\t}\n\t\t\t\n\t\tif ((flipH && (d == mxConstants.DIRECTION_SOUTH || d == mxConstants.DIRECTION_NORTH)) ||\n\t\t\t(flipV && (d == mxConstants.DIRECTION_EAST || d == mxConstants.DIRECTION_WEST)))\n\t\t{\n\t\t\tvar tmp = m.y;\n\t\t\tm.y = m.height;\n\t\t\tm.height = tmp;\n\t\t}\n\t\t\n\t\tvar m2 = mxRectangle.fromRectangle(m);\n\t\t\n\t\tif (d == mxConstants.DIRECTION_SOUTH)\n\t\t{\n\t\t\tm2.y = m.x;\n\t\t\tm2.x = m.height;\n\t\t\tm2.width = m.y;\n\t\t\tm2.height = m.width;\n\t\t}\n\t\telse if (d == mxConstants.DIRECTION_WEST)\n\t\t{\n\t\t\tm2.y = m.height;\n\t\t\tm2.x = m.width;\n\t\t\tm2.width = m.x;\n\t\t\tm2.height = m.y;\n\t\t}\n\t\telse if (d == mxConstants.DIRECTION_NORTH)\n\t\t{\n\t\t\tm2.y = m.width;\n\t\t\tm2.x = m.y;\n\t\t\tm2.width = m.height;\n\t\t\tm2.height = m.x;\n\t\t}\n\t\t\n\t\treturn new mxRectangle(rect.x + m2.x, rect.y + m2.y, rect.width - m2.width - m2.x, rect.height - m2.height - m2.y);\n\t},\n\n\t/**\n\t * Function: getPerimeterPoint\n\t * \n\t * Returns the intersection between the polygon defined by the array of\n\t * points and the line between center and point.\n\t */\n\tgetPerimeterPoint: function (pts, center, point)\n\t{\n\t\tvar min = null;\n\t\t\n\t\tfor (var i = 0; i < pts.length - 1; i++)\n\t\t{\n\t\t\tvar pt = mxUtils.intersection(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y,\n\t\t\t\tcenter.x, center.y, point.x, point.y);\n\t\t\t\n\t\t\tif (pt != null)\n\t\t\t{\n\t\t\t\tvar dx = point.x - pt.x;\n\t\t\t\tvar dy = point.y - pt.y;\n\t\t\t\tvar ip = {p: pt, distSq: dy * dy + dx * dx};\n\t\t\t\t\n\t\t\t\tif (ip != null && (min == null || min.distSq > ip.distSq))\n\t\t\t\t{\n\t\t\t\t\tmin = ip;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn (min != null) ? min.p : null;\n\t},\n\n\t/**\n\t * Function: rectangleIntersectsSegment\n\t * \n\t * Returns true if the given rectangle intersects the given segment.\n\t * \n\t * Parameters:\n\t * \n\t * bounds - <mxRectangle> that represents the rectangle.\n\t * p1 - <mxPoint> that represents the first point of the segment.\n\t * p2 - <mxPoint> that represents the second point of the segment.\n\t */\n\trectangleIntersectsSegment: function(bounds, p1, p2)\n\t{\n\t\tvar top = bounds.y;\n\t\tvar left = bounds.x;\n\t\tvar bottom = top + bounds.height;\n\t\tvar right = left + bounds.width;\n\t\t\t\n\t\t// Find min and max X for the segment\n\t\tvar minX = p1.x;\n\t\tvar maxX = p2.x;\n\t\t\n\t\tif (p1.x > p2.x)\n\t\t{\n\t\t  minX = p2.x;\n\t\t  maxX = p1.x;\n\t\t}\n\t\t\n\t\t// Find the intersection of the segment's and rectangle's x-projections\n\t\tif (maxX > right)\n\t\t{\n\t\t  maxX = right;\n\t\t}\n\t\t\n\t\tif (minX < left)\n\t\t{\n\t\t  minX = left;\n\t\t}\n\t\t\n\t\tif (minX > maxX) // If their projections do not intersect return false\n\t\t{\n\t\t  return false;\n\t\t}\n\t\t\n\t\t// Find corresponding min and max Y for min and max X we found before\n\t\tvar minY = p1.y;\n\t\tvar maxY = p2.y;\n\t\tvar dx = p2.x - p1.x;\n\t\t\n\t\tif (Math.abs(dx) > 0.0000001)\n\t\t{\n\t\t  var a = (p2.y - p1.y) / dx;\n\t\t  var b = p1.y - a * p1.x;\n\t\t  minY = a * minX + b;\n\t\t  maxY = a * maxX + b;\n\t\t}\n\t\t\n\t\tif (minY > maxY)\n\t\t{\n\t\t  var tmp = maxY;\n\t\t  maxY = minY;\n\t\t  minY = tmp;\n\t\t}\n\t\t\n\t\t// Find the intersection of the segment's and rectangle's y-projections\n\t\tif (maxY > bottom)\n\t\t{\n\t\t  maxY = bottom;\n\t\t}\n\t\t\n\t\tif (minY < top)\n\t\t{\n\t\t  minY = top;\n\t\t}\n\t\t\n\t\tif (minY > maxY) // If Y-projections do not intersect return false\n\t\t{\n\t\t  return false;\n\t\t}\n\t\t\n\t\treturn true;\n\t},\n\t\n\t/**\n\t * Function: contains\n\t * \n\t * Returns true if the specified point (x, y) is contained in the given rectangle.\n\t * \n\t * Parameters:\n\t * \n\t * bounds - <mxRectangle> that represents the area.\n\t * x - X-coordinate of the point.\n\t * y - Y-coordinate of the point.\n\t */\n\tcontains: function(bounds, x, y)\n\t{\n\t\treturn (bounds.x <= x && bounds.x + bounds.width >= x &&\n\t\t\t\tbounds.y <= y && bounds.y + bounds.height >= y);\n\t},\n\n\t/**\n\t * Function: intersects\n\t * \n\t * Returns true if the two rectangles intersect.\n\t * \n\t * Parameters:\n\t * \n\t * a - <mxRectangle> to be checked for intersection.\n\t * b - <mxRectangle> to be checked for intersection.\n\t */\n\tintersects: function(a, b)\n\t{\n\t\tvar tw = a.width;\n\t\tvar th = a.height;\n\t\tvar rw = b.width;\n\t\tvar rh = b.height;\n\t\t\n\t\tif (rw <= 0 || rh <= 0 || tw <= 0 || th <= 0)\n\t\t{\n\t\t    return false;\n\t\t}\n\t\t\n\t\tvar tx = a.x;\n\t\tvar ty = a.y;\n\t\tvar rx = b.x;\n\t\tvar ry = b.y;\n\t\t\n\t\trw += rx;\n\t\trh += ry;\n\t\ttw += tx;\n\t\tth += ty;\n\n\t\treturn ((rw < rx || rw > tx) &&\n\t\t\t(rh < ry || rh > ty) &&\n\t\t\t(tw < tx || tw > rx) &&\n\t\t\t(th < ty || th > ry));\n\t},\n\n\t/**\n\t * Function: intersectsHotspot\n\t * \n\t * Returns true if the state and the hotspot intersect.\n\t * \n\t * Parameters:\n\t * \n\t * state - <mxCellState>\n\t * x - X-coordinate.\n\t * y - Y-coordinate.\n\t * hotspot - Optional size of the hostpot.\n\t * min - Optional min size of the hostpot.\n\t * max - Optional max size of the hostpot.\n\t */\n\tintersectsHotspot: function(state, x, y, hotspot, min, max)\n\t{\n\t\thotspot = (hotspot != null) ? hotspot : 1;\n\t\tmin = (min != null) ? min : 0;\n\t\tmax = (max != null) ? max : 0;\n\t\t\n\t\tif (hotspot > 0)\n\t\t{\n\t\t\tvar cx = state.getCenterX();\n\t\t\tvar cy = state.getCenterY();\n\t\t\tvar w = state.width;\n\t\t\tvar h = state.height;\n\t\t\t\n\t\t\tvar start = mxUtils.getValue(state.style, mxConstants.STYLE_STARTSIZE) * state.view.scale;\n\n\t\t\tif (start > 0)\n\t\t\t{\n\t\t\t\tif (mxUtils.getValue(state.style, mxConstants.STYLE_HORIZONTAL, true))\n\t\t\t\t{\n\t\t\t\t\tcy = state.y + start / 2;\n\t\t\t\t\th = start;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcx = state.x + start / 2;\n\t\t\t\t\tw = start;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tw = Math.max(min, w * hotspot);\n\t\t\th = Math.max(min, h * hotspot);\n\t\t\t\n\t\t\tif (max > 0)\n\t\t\t{\n\t\t\t\tw = Math.min(w, max);\n\t\t\t\th = Math.min(h, max);\n\t\t\t}\n\t\t\t\n\t\t\tvar rect = new mxRectangle(cx - w / 2, cy - h / 2, w, h);\n\t\t\tvar alpha = mxUtils.toRadians(mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION) || 0);\n\t\t\t\n\t\t\tif (alpha != 0)\n\t\t\t{\n\t\t\t\tvar cos = Math.cos(-alpha);\n\t\t\t\tvar sin = Math.sin(-alpha);\n\t\t\t\tvar cx = new mxPoint(state.getCenterX(), state.getCenterY());\n\t\t\t\tvar pt = mxUtils.getRotatedPoint(new mxPoint(x, y), cos, sin, cx);\n\t\t\t\tx = pt.x;\n\t\t\t\ty = pt.y;\n\t\t\t}\n\t\t\t\n\t\t\treturn mxUtils.contains(rect, x, y);\t\t\t\n\t\t}\n\t\t\n\t\treturn true;\n\t},\n\n\t/**\n\t * Function: getOffset\n\t * \n\t * Returns the offset for the specified container as an <mxPoint>. The\n\t * offset is the distance from the top left corner of the container to the\n\t * top left corner of the document.\n\t * \n\t * Parameters:\n\t * \n\t * container - DOM node to return the offset for.\n\t * scollOffset - Optional boolean to add the scroll offset of the document.\n\t * Default is false.\n\t */\n\tgetOffset: function(container, scrollOffset)\n\t{\n\t\tvar offsetLeft = 0;\n\t\tvar offsetTop = 0;\n\t\t\n\t\t// Ignores document scroll origin for fixed elements\n\t\tvar fixed = false;\n\t\tvar node = container;\n\t\tvar b = document.body;\n\t\tvar d = document.documentElement;\n\n\t\twhile (node != null && node != b && node != d && !fixed)\n\t\t{\n\t\t\tvar style = mxUtils.getCurrentStyle(node);\n\t\t\t\n\t\t\tif (style != null)\n\t\t\t{\n\t\t\t\tfixed = fixed || style.position == 'fixed';\n\t\t\t}\n\t\t\t\n\t\t\tnode = node.parentNode;\n\t\t}\n\t\t\n\t\tif (!scrollOffset && !fixed)\n\t\t{\n\t\t\tvar offset = mxUtils.getDocumentScrollOrigin(container.ownerDocument);\n\t\t\toffsetLeft += offset.x;\n\t\t\toffsetTop += offset.y;\n\t\t}\n\t\t\n\t\tvar r = container.getBoundingClientRect();\n\t\t\n\t\tif (r != null)\n\t\t{\n\t\t\toffsetLeft += r.left;\n\t\t\toffsetTop += r.top;\n\t\t}\n\t\t\n\t\treturn new mxPoint(offsetLeft, offsetTop);\n\t},\n\n\t/**\n\t * Function: getDocumentScrollOrigin\n\t * \n\t * Returns the scroll origin of the given document or the current document\n\t * if no document is given.\n\t */\n\tgetDocumentScrollOrigin: function(doc)\n\t{\n\t\tif (mxClient.IS_QUIRKS)\n\t\t{\n\t\t\treturn new mxPoint(doc.body.scrollLeft, doc.body.scrollTop);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar wnd = doc.defaultView || doc.parentWindow;\n\t\t\t\n\t\t\tvar x = (wnd != null && window.pageXOffset !== undefined) ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;\n\t\t\tvar y = (wnd != null && window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;\n\t\t\t\n\t\t\treturn new mxPoint(x, y);\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: getScrollOrigin\n\t * \n\t * Returns the top, left corner of the viewrect as an <mxPoint>.\n\t * \n\t * Parameters:\n\t * \n\t * node - DOM node whose scroll origin should be returned.\n\t * includeAncestors - Whether the scroll origin of the ancestors should be\n\t * included. Default is false.\n\t * includeDocument - Whether the scroll origin of the document should be\n\t * included. Default is true.\n\t */\n\tgetScrollOrigin: function(node, includeAncestors, includeDocument)\n\t{\n\t\tincludeAncestors = (includeAncestors != null) ? includeAncestors : false;\n\t\tincludeDocument = (includeDocument != null) ? includeDocument : true;\n\t\t\n\t\tvar doc = (node != null) ? node.ownerDocument : document;\n\t\tvar b = doc.body;\n\t\tvar d = doc.documentElement;\n\t\tvar result = new mxPoint();\n\t\tvar fixed = false;\n\n\t\twhile (node != null && node != b && node != d)\n\t\t{\n\t\t\tif (!isNaN(node.scrollLeft) && !isNaN(node.scrollTop))\n\t\t\t{\n\t\t\t\tresult.x += node.scrollLeft;\n\t\t\t\tresult.y += node.scrollTop;\n\t\t\t}\n\t\t\t\n\t\t\tvar style = mxUtils.getCurrentStyle(node);\n\t\t\t\n\t\t\tif (style != null)\n\t\t\t{\n\t\t\t\tfixed = fixed || style.position == 'fixed';\n\t\t\t}\n\n\t\t\tnode = (includeAncestors) ? node.parentNode : null;\n\t\t}\n\n\t\tif (!fixed && includeDocument)\n\t\t{\n\t\t\tvar origin = mxUtils.getDocumentScrollOrigin(doc);\n\n\t\t\tresult.x += origin.x;\n\t\t\tresult.y += origin.y;\n\t\t}\n\t\t\n\t\treturn result;\n\t},\n\n\t/**\n\t * Function: convertPoint\n\t * \n\t * Converts the specified point (x, y) using the offset of the specified\n\t * container and returns a new <mxPoint> with the result.\n\t * \n\t * (code)\n\t * var pt = mxUtils.convertPoint(graph.container,\n\t *   mxEvent.getClientX(evt), mxEvent.getClientY(evt));\n\t * (end)\n\t * \n\t * Parameters:\n\t * \n\t * container - DOM node to use for the offset.\n\t * x - X-coordinate of the point to be converted.\n\t * y - Y-coordinate of the point to be converted.\n\t */\n\tconvertPoint: function(container, x, y)\n\t{\n\t\tvar origin = mxUtils.getScrollOrigin(container, false);\n\t\tvar offset = mxUtils.getOffset(container);\n\n\t\toffset.x -= origin.x;\n\t\toffset.y -= origin.y;\n\t\t\n\t\treturn new mxPoint(x - offset.x, y - offset.y);\n\t},\n\t\n\t/**\n\t * Function: ltrim\n\t * \n\t * Strips all whitespaces from the beginning of the string. Without the\n\t * second parameter, this will trim these characters:\n\t * \n\t * - \" \" (ASCII 32 (0x20)), an ordinary space\n\t * - \"\\t\" (ASCII 9 (0x09)), a tab\n\t * - \"\\n\" (ASCII 10 (0x0A)), a new line (line feed)\n\t * - \"\\r\" (ASCII 13 (0x0D)), a carriage return\n\t * - \"\\0\" (ASCII 0 (0x00)), the NUL-byte\n\t * - \"\\x0B\" (ASCII 11 (0x0B)), a vertical tab\n\t */\n\tltrim: function(str, chars)\n\t{\n\t\tchars = chars || \"\\\\s\";\n\t\t\n\t\treturn (str != null) ? str.replace(new RegExp(\"^[\" + chars + \"]+\", \"g\"), \"\") : null;\n\t},\n\t\n\t/**\n\t * Function: rtrim\n\t * \n\t * Strips all whitespaces from the end of the string. Without the second\n\t * parameter, this will trim these characters:\n\t * \n\t * - \" \" (ASCII 32 (0x20)), an ordinary space\n\t * - \"\\t\" (ASCII 9 (0x09)), a tab\n\t * - \"\\n\" (ASCII 10 (0x0A)), a new line (line feed)\n\t * - \"\\r\" (ASCII 13 (0x0D)), a carriage return\n\t * - \"\\0\" (ASCII 0 (0x00)), the NUL-byte\n\t * - \"\\x0B\" (ASCII 11 (0x0B)), a vertical tab\n\t */\n\trtrim: function(str, chars)\n\t{\n\t\tchars = chars || \"\\\\s\";\n\t\t\n\t\treturn (str != null) ? str.replace(new RegExp(\"[\" + chars + \"]+$\", \"g\"), \"\") : null;\n\t},\n\t\n\t/**\n\t * Function: trim\n\t * \n\t * Strips all whitespaces from both end of the string.\n\t * Without the second parameter, Javascript function will trim these\n\t * characters:\n\t * \n\t * - \" \" (ASCII 32 (0x20)), an ordinary space\n\t * - \"\\t\" (ASCII 9 (0x09)), a tab\n\t * - \"\\n\" (ASCII 10 (0x0A)), a new line (line feed)\n\t * - \"\\r\" (ASCII 13 (0x0D)), a carriage return\n\t * - \"\\0\" (ASCII 0 (0x00)), the NUL-byte\n\t * - \"\\x0B\" (ASCII 11 (0x0B)), a vertical tab\n\t */\n\ttrim: function(str, chars)\n\t{\n\t\treturn mxUtils.ltrim(mxUtils.rtrim(str, chars), chars);\n\t},\n\t\n\t/**\n\t * Function: isNumeric\n\t * \n\t * Returns true if the specified value is numeric, that is, if it is not\n\t * null, not an empty string, not a HEX number and isNaN returns false.\n\t * \n\t * Parameters:\n\t * \n\t * n - String representing the possibly numeric value.\n\t */\n\tisNumeric: function(n)\n\t{\n\t\treturn !isNaN(parseFloat(n)) && isFinite(n) && (typeof(n) != 'string' || n.toLowerCase().indexOf('0x') < 0);\n\t},\n\n\t/**\n\t * Function: isInteger\n\t * \n\t * Returns true if the given value is an valid integer number.\n\t * \n\t * Parameters:\n\t * \n\t * n - String representing the possibly numeric value.\n\t */\n\tisInteger: function(n)\n\t{\n\t\treturn String(parseInt(n)) === String(n);\n\t},\n\n\t/**\n\t * Function: mod\n\t * \n\t * Returns the remainder of division of n by m. You should use this instead\n\t * of the built-in operation as the built-in operation does not properly\n\t * handle negative numbers.\n\t */\n\tmod: function(n, m)\n\t{\n\t\treturn ((n % m) + m) % m;\n\t},\n\n\t/**\n\t * Function: intersection\n\t * \n\t * Returns the intersection of two lines as an <mxPoint>.\n\t * \n\t * Parameters:\n\t * \n\t * x0 - X-coordinate of the first line's startpoint.\n\t * y0 - X-coordinate of the first line's startpoint.\n\t * x1 - X-coordinate of the first line's endpoint.\n\t * y1 - Y-coordinate of the first line's endpoint.\n\t * x2 - X-coordinate of the second line's startpoint.\n\t * y2 - Y-coordinate of the second line's startpoint.\n\t * x3 - X-coordinate of the second line's endpoint.\n\t * y3 - Y-coordinate of the second line's endpoint.\n\t */\n\tintersection: function (x0, y0, x1, y1, x2, y2, x3, y3)\n\t{\n\t\tvar denom = ((y3 - y2) * (x1 - x0)) - ((x3 - x2) * (y1 - y0));\n\t\tvar nume_a = ((x3 - x2) * (y0 - y2)) - ((y3 - y2) * (x0 - x2));\n\t\tvar nume_b = ((x1 - x0) * (y0 - y2)) - ((y1 - y0) * (x0 - x2));\n\n\t\tvar ua = nume_a / denom;\n\t\tvar ub = nume_b / denom;\n\t\t\n\t\tif(ua >= 0.0 && ua <= 1.0 && ub >= 0.0 && ub <= 1.0)\n\t\t{\n\t\t\t// Get the intersection point\n\t\t\tvar x = x0 + ua * (x1 - x0);\n\t\t\tvar y = y0 + ua * (y1 - y0);\n\t\t\t\n\t\t\treturn new mxPoint(x, y);\n\t\t}\n\t\t\n\t\t// No intersection\n\t\treturn null;\n\t},\n\t\n\t/**\n\t * Function: ptSegDistSq\n\t * \n\t * Returns the square distance between a segment and a point. To get the\n\t * distance between a point and a line (with infinite length) use\n\t * <mxUtils.ptLineDist>.\n\t * \n\t * Parameters:\n\t * \n\t * x1 - X-coordinate of the startpoint of the segment.\n\t * y1 - Y-coordinate of the startpoint of the segment.\n\t * x2 - X-coordinate of the endpoint of the segment.\n\t * y2 - Y-coordinate of the endpoint of the segment.\n\t * px - X-coordinate of the point.\n\t * py - Y-coordinate of the point.\n\t */\n\tptSegDistSq: function(x1, y1, x2, y2, px, py)\n    {\n\t\tx2 -= x1;\n\t\ty2 -= y1;\n\n\t\tpx -= x1;\n\t\tpy -= y1;\n\n\t\tvar dotprod = px * x2 + py * y2;\n\t\tvar projlenSq;\n\n\t\tif (dotprod <= 0.0)\n\t\t{\n\t\t    projlenSq = 0.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    px = x2 - px;\n\t\t    py = y2 - py;\n\t\t    dotprod = px * x2 + py * y2;\n\n\t\t    if (dotprod <= 0.0)\n\t\t    {\n\t\t\t\tprojlenSq = 0.0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t\tprojlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\n\t\t    }\n\t\t}\n\n\t\tvar lenSq = px * px + py * py - projlenSq;\n\t\t\n\t\tif (lenSq < 0)\n\t\t{\n\t\t    lenSq = 0;\n\t\t}\n\t\t\n\t\treturn lenSq;\n    },\n\t\n\t/**\n\t * Function: ptLineDist\n\t * \n\t * Returns the distance between a line defined by two points and a point.\n\t * To get the distance between a point and a segment (with a specific\n\t * length) use <mxUtils.ptSeqDistSq>.\n\t * \n\t * Parameters:\n\t * \n\t * x1 - X-coordinate of point 1 of the line.\n\t * y1 - Y-coordinate of point 1 of the line.\n\t * x2 - X-coordinate of point 1 of the line.\n\t * y2 - Y-coordinate of point 1 of the line.\n\t * px - X-coordinate of the point.\n\t * py - Y-coordinate of the point.\n\t */\n    ptLineDist: function(x1, y1, x2, y2, px, py)\n    {\n\t\treturn Math.abs((y2 - y1) * px - (x2 - x1) * py + x2 * y1 - y2 * x1) /\n\t\t\tMath.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));\n    },\n    \t\n\t/**\n\t * Function: relativeCcw\n\t * \n\t * Returns 1 if the given point on the right side of the segment, 0 if its\n\t * on the segment, and -1 if the point is on the left side of the segment.\n\t * \n\t * Parameters:\n\t * \n\t * x1 - X-coordinate of the startpoint of the segment.\n\t * y1 - Y-coordinate of the startpoint of the segment.\n\t * x2 - X-coordinate of the endpoint of the segment.\n\t * y2 - Y-coordinate of the endpoint of the segment.\n\t * px - X-coordinate of the point.\n\t * py - Y-coordinate of the point.\n\t */\n\trelativeCcw: function(x1, y1, x2, y2, px, py)\n    {\n\t\tx2 -= x1;\n\t\ty2 -= y1;\n\t\tpx -= x1;\n\t\tpy -= y1;\n\t\tvar ccw = px * y2 - py * x2;\n\t\t\n\t\tif (ccw == 0.0)\n\t\t{\n\t\t    ccw = px * x2 + py * y2;\n\t\t    \n\t\t    if (ccw > 0.0)\n\t\t    {\n\t\t\t\tpx -= x2;\n\t\t\t\tpy -= y2;\n\t\t\t\tccw = px * x2 + py * y2;\n\t\t\t\t\n\t\t\t\tif (ccw < 0.0)\n\t\t\t\t{\n\t\t\t\t    ccw = 0.0;\n\t\t\t\t}\n\t\t    }\n\t\t}\n\t\t\n\t\treturn (ccw < 0.0) ? -1 : ((ccw > 0.0) ? 1 : 0);\n    },\n    \n\t/**\n\t * Function: animateChanges\n\t * \n\t * See <mxEffects.animateChanges>. This is for backwards compatibility and\n\t * will be removed later.\n\t */\n\tanimateChanges: function(graph, changes)\n\t{\n\t\t// LATER: Deprecated, remove this function\n    \tmxEffects.animateChanges.apply(this, arguments);\n\t},\n    \n\t/**\n\t * Function: cascadeOpacity\n\t * \n\t * See <mxEffects.cascadeOpacity>. This is for backwards compatibility and\n\t * will be removed later.\n\t */\n    cascadeOpacity: function(graph, cell, opacity)\n\t{\n\t\tmxEffects.cascadeOpacity.apply(this, arguments);\n\t},\n\n\t/**\n\t * Function: fadeOut\n\t * \n\t * See <mxEffects.fadeOut>. This is for backwards compatibility and\n\t * will be removed later.\n\t */\n\tfadeOut: function(node, from, remove, step, delay, isEnabled)\n\t{\n\t\tmxEffects.fadeOut.apply(this, arguments);\n\t},\n\t\n\t/**\n\t * Function: setOpacity\n\t * \n\t * Sets the opacity of the specified DOM node to the given value in %.\n\t * \n\t * Parameters:\n\t * \n\t * node - DOM node to set the opacity for.\n\t * value - Opacity in %. Possible values are between 0 and 100.\n\t */\n\tsetOpacity: function(node, value)\n\t{\n\t\tif (mxUtils.isVml(node))\n\t\t{\n\t    \tif (value >= 100)\n\t    \t{\n\t    \t\tnode.style.filter = '';\n\t    \t}\n\t    \telse\n\t    \t{\n\t    \t\t// TODO: Why is the division by 5 needed in VML?\n\t\t\t    node.style.filter = 'alpha(opacity=' + (value/5) + ')';\n\t    \t}\n\t\t}\n\t\telse if (mxClient.IS_IE && (typeof(document.documentMode) === 'undefined' || document.documentMode < 9))\n\t    {\n\t    \tif (value >= 100)\n\t    \t{\n\t    \t\tnode.style.filter = '';\n\t    \t}\n\t    \telse\n\t    \t{\n\t\t\t    node.style.filter = 'alpha(opacity=' + value + ')';\n\t    \t}\n\t\t}\n\t\telse\n\t\t{\n\t\t    node.style.opacity = (value / 100);\n\t\t}\n\t},\n\n\t/**\n\t * Function: createImage\n\t * \n\t * Creates and returns an image (IMG node) or VML image (v:image) in IE6 in\n\t * quirks mode.\n\t * \n\t * Parameters:\n\t * \n\t * src - URL that points to the image to be displayed.\n\t */\n\tcreateImage: function(src)\n\t{\n        var imageNode = null;\n        \n\t\tif (mxClient.IS_IE6 && document.compatMode != 'CSS1Compat')\n\t\t{\n        \timageNode = document.createElement(mxClient.VML_PREFIX + ':image');\n        \timageNode.setAttribute('src', src);\n        \timageNode.style.borderStyle = 'none';\n        }\n\t\telse\n\t\t{\n\t\t\timageNode = document.createElement('img');\n\t\t\timageNode.setAttribute('src', src);\n\t\t\timageNode.setAttribute('border', '0');\n\t\t}\n\t\t\n\t\treturn imageNode;\n\t},\n\n\t/**\n\t * Function: sortCells\n\t * \n\t * Sorts the given cells according to the order in the cell hierarchy.\n\t * Ascending is optional and defaults to true.\n\t */\n\tsortCells: function(cells, ascending)\n\t{\n\t\tascending = (ascending != null) ? ascending : true;\n\t\tvar lookup = new mxDictionary();\n\t\tcells.sort(function(o1, o2)\n\t\t{\n\t\t\tvar p1 = lookup.get(o1);\n\t\t\t\n\t\t\tif (p1 == null)\n\t\t\t{\n\t\t\t\tp1 = mxCellPath.create(o1).split(mxCellPath.PATH_SEPARATOR);\n\t\t\t\tlookup.put(o1, p1);\n\t\t\t}\n\t\t\t\n\t\t\tvar p2 = lookup.get(o2);\n\t\t\t\n\t\t\tif (p2 == null)\n\t\t\t{\n\t\t\t\tp2 = mxCellPath.create(o2).split(mxCellPath.PATH_SEPARATOR);\n\t\t\t\tlookup.put(o2, p2);\n\t\t\t}\n\t\t\t\n\t\t\tvar comp = mxCellPath.compare(p1, p2);\n\t\t\t\n\t\t\treturn (comp == 0) ? 0 : (((comp > 0) == ascending) ? 1 : -1);\n\t\t});\n\t\t\n\t\treturn cells;\n\t},\n\n\t/**\n\t * Function: getStylename\n\t * \n\t * Returns the stylename in a style of the form [(stylename|key=value);] or\n\t * an empty string if the given style does not contain a stylename.\n\t * \n\t * Parameters:\n\t * \n\t * style - String of the form [(stylename|key=value);].\n\t */\n\tgetStylename: function(style)\n\t{\n\t\tif (style != null)\n\t\t{\n\t\t\tvar pairs = style.split(';');\n\t\t\tvar stylename = pairs[0];\n\t\t\t\n\t\t\tif (stylename.indexOf('=') < 0)\n\t\t\t{\n\t\t\t\treturn stylename;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\treturn '';\n\t},\n\n\t/**\n\t * Function: getStylenames\n\t * \n\t * Returns the stylenames in a style of the form [(stylename|key=value);]\n\t * or an empty array if the given style does not contain any stylenames.\n\t * \n\t * Parameters:\n\t * \n\t * style - String of the form [(stylename|key=value);].\n\t */\n\tgetStylenames: function(style)\n\t{\n\t\tvar result = [];\n\t\t\n\t\tif (style != null)\n\t\t{\n\t\t\tvar pairs = style.split(';');\n\t\t\t\n\t\t\tfor (var i = 0; i < pairs.length; i++)\n\t\t\t{\n\t\t\t\tif (pairs[i].indexOf('=') < 0)\n\t\t\t\t{\n\t\t\t\t\tresult.push(pairs[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\treturn result;\n\t},\n\n\t/**\n\t * Function: indexOfStylename\n\t * \n\t * Returns the index of the given stylename in the given style. This\n\t * returns -1 if the given stylename does not occur (as a stylename) in the\n\t * given style, otherwise it returns the index of the first character.\n\t */\n\tindexOfStylename: function(style, stylename)\n\t{\n\t\tif (style != null && stylename != null)\n\t\t{\n\t\t\tvar tokens = style.split(';');\n\t\t\tvar pos = 0;\n\t\t\t\n\t\t\tfor (var i = 0; i < tokens.length; i++)\n\t\t\t{\n\t\t\t\tif (tokens[i] == stylename)\n\t\t\t\t{\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpos += tokens[i].length + 1;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t},\n\t\n\t/**\n\t * Function: addStylename\n\t * \n\t * Adds the specified stylename to the given style if it does not already\n\t * contain the stylename.\n\t */\n\taddStylename: function(style, stylename)\n\t{\n\t\tif (mxUtils.indexOfStylename(style, stylename) < 0)\n\t\t{\n\t\t\tif (style == null)\n\t\t\t{\n\t\t\t\tstyle = '';\n\t\t\t}\n\t\t\telse if (style.length > 0 && style.charAt(style.length - 1) != ';')\n\t\t\t{\n\t\t\t\tstyle += ';';\n\t\t\t}\n\t\t\t\n\t\t\tstyle += stylename;\n\t\t}\n\t\t\n\t\treturn style;\n\t},\n\t\n\t/**\n\t * Function: removeStylename\n\t * \n\t * Removes all occurrences of the specified stylename in the given style\n\t * and returns the updated style. Trailing semicolons are not preserved.\n\t */\n\tremoveStylename: function(style, stylename)\n\t{\n\t\tvar result = [];\n\t\t\n\t\tif (style != null)\n\t\t{\n\t\t\tvar tokens = style.split(';');\n\t\t\t\n\t\t\tfor (var i = 0; i < tokens.length; i++)\n\t\t\t{\n\t\t\t\tif (tokens[i] != stylename)\n\t\t\t\t{\n\t\t\t\t\tresult.push(tokens[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result.join(';');\n\t},\n\t\n\t/**\n\t * Function: removeAllStylenames\n\t * \n\t * Removes all stylenames from the given style and returns the updated\n\t * style.\n\t */\n\tremoveAllStylenames: function(style)\n\t{\n\t\tvar result = [];\n\t\t\n\t\tif (style != null)\n\t\t{\n\t\t\tvar tokens = style.split(';');\n\t\t\t\n\t\t\tfor (var i = 0; i < tokens.length; i++)\n\t\t\t{\n\t\t\t\t// Keeps the key, value assignments\n\t\t\t\tif (tokens[i].indexOf('=') >= 0)\n\t\t\t\t{\n\t\t\t\t\tresult.push(tokens[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result.join(';');\n\t},\n\n\t/**\n\t * Function: setCellStyles\n\t * \n\t * Assigns the value for the given key in the styles of the given cells, or\n\t * removes the key from the styles if the value is null.\n\t * \n\t * Parameters:\n\t * \n\t * model - <mxGraphModel> to execute the transaction in.\n\t * cells - Array of <mxCells> to be updated.\n\t * key - Key of the style to be changed.\n\t * value - New value for the given key.\n\t */\n\tsetCellStyles: function(model, cells, key, value)\n\t{\n\t\tif (cells != null && cells.length > 0)\n\t\t{\n\t\t\tmodel.beginUpdate();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (cells[i] != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar style = mxUtils.setStyle(model.getStyle(cells[i]), key, value);\n\t\t\t\t\t\tmodel.setStyle(cells[i], style);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tmodel.endUpdate();\n\t\t\t}\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: setStyle\n\t * \n\t * Adds or removes the given key, value pair to the style and returns the\n\t * new style. If value is null or zero length then the key is removed from\n\t * the style. This is for cell styles, not for CSS styles.\n\t * \n\t * Parameters:\n\t * \n\t * style - String of the form [(stylename|key=value);].\n\t * key - Key of the style to be changed.\n\t * value - New value for the given key.\n\t */\n\tsetStyle: function(style, key, value)\n\t{\n\t\tvar isValue = value != null && (typeof(value.length) == 'undefined' || value.length > 0);\n\t\t\n\t\tif (style == null || style.length == 0)\n\t\t{\n\t\t\tif (isValue)\n\t\t\t{\n\t\t\t\tstyle = key + '=' + value + ';';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (style.substring(0, key.length + 1) == key + '=')\n\t\t\t{\n\t\t\t\tvar next = style.indexOf(';');\n\t\t\t\t\n\t\t\t\tif (isValue)\n\t\t\t\t{\n\t\t\t\t\tstyle = key + '=' + value + ((next < 0) ? ';' : style.substring(next));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstyle = (next < 0 || next == style.length - 1) ? '' : style.substring(next + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar index = style.indexOf(';' + key + '=');\n\t\t\t\t\n\t\t\t\tif (index < 0)\n\t\t\t\t{\n\t\t\t\t\tif (isValue)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar sep = (style.charAt(style.length - 1) == ';') ? '' : ';';\n\t\t\t\t\t\tstyle = style + sep + key + '=' + value + ';';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar next = style.indexOf(';', index + 1);\n\t\t\t\t\t\n\t\t\t\t\tif (isValue)\n\t\t\t\t\t{\n\t\t\t\t\t\tstyle = style.substring(0, index + 1) + key + '=' + value + ((next < 0) ? ';' : style.substring(next));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tstyle = style.substring(0, index) + ((next < 0) ? ';' : style.substring(next));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn style;\n\t},\n\n\t/**\n\t * Function: setCellStyleFlags\n\t * \n\t * Sets or toggles the flag bit for the given key in the cell's styles.\n\t * If value is null then the flag is toggled.\n\t * \n\t * Example:\n\t * \n\t * (code)\n\t * var cells = graph.getSelectionCells();\n\t * mxUtils.setCellStyleFlags(graph.model,\n\t * \t\t\tcells,\n\t * \t\t\tmxConstants.STYLE_FONTSTYLE,\n\t * \t\t\tmxConstants.FONT_BOLD);\n\t * (end)\n\t * \n\t * Toggles the bold font style.\n\t * \n\t * Parameters:\n\t * \n\t * model - <mxGraphModel> that contains the cells.\n\t * cells - Array of <mxCells> to change the style for.\n\t * key - Key of the style to be changed.\n\t * flag - Integer for the bit to be changed.\n\t * value - Optional boolean value for the flag.\n\t */\n\tsetCellStyleFlags: function(model, cells, key, flag, value)\n\t{\n\t\tif (cells != null && cells.length > 0)\n\t\t{\n\t\t\tmodel.beginUpdate();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (cells[i] != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar style = mxUtils.setStyleFlag(\n\t\t\t\t\t\t\tmodel.getStyle(cells[i]),\n\t\t\t\t\t\t\tkey, flag, value);\n\t\t\t\t\t\tmodel.setStyle(cells[i], style);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tmodel.endUpdate();\n\t\t\t}\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: setStyleFlag\n\t * \n\t * Sets or removes the given key from the specified style and returns the\n\t * new style. If value is null then the flag is toggled.\n\t * \n\t * Parameters:\n\t * \n\t * style - String of the form [(stylename|key=value);].\n\t * key - Key of the style to be changed.\n\t * flag - Integer for the bit to be changed.\n\t * value - Optional boolean value for the given flag.\n\t */\n\tsetStyleFlag: function(style, key, flag, value)\n\t{\n\t\tif (style == null || style.length == 0)\n\t\t{\n\t\t\tif (value || value == null)\n\t\t\t{\n\t\t\t\tstyle = key+'='+flag;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstyle = key+'=0';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar index = style.indexOf(key+'=');\n\t\t\t\n\t\t\tif (index < 0)\n\t\t\t{\n\t\t\t\tvar sep = (style.charAt(style.length-1) == ';') ? '' : ';';\n\n\t\t\t\tif (value || value == null)\n\t\t\t\t{\n\t\t\t\t\tstyle = style + sep + key + '=' + flag;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstyle = style + sep + key + '=0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar cont = style.indexOf(';', index);\n\t\t\t\tvar tmp = '';\n\t\t\t\t\n\t\t\t\tif (cont < 0)\n\t\t\t\t{\n\t\t\t\t\ttmp  = style.substring(index+key.length+1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmp = style.substring(index+key.length+1, cont);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (value == null)\n\t\t\t\t{\n\t\t\t\t\ttmp = parseInt(tmp) ^ flag;\n\t\t\t\t}\n\t\t\t\telse if (value)\n\t\t\t\t{\n\t\t\t\t\ttmp = parseInt(tmp) | flag;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmp = parseInt(tmp) & ~flag;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstyle = style.substring(0, index) + key + '=' + tmp +\n\t\t\t\t\t((cont >= 0) ? style.substring(cont) : '');\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn style;\n\t},\n\t\n\t/**\n\t * Function: getAlignmentAsPoint\n\t * \n\t * Returns an <mxPoint> that represents the horizontal and vertical alignment\n\t * for numeric computations. X is -0.5 for center, -1 for right and 0 for\n\t * left alignment. Y is -0.5 for middle, -1 for bottom and 0 for top\n\t * alignment. Default values for missing arguments is top, left.\n\t */\n\tgetAlignmentAsPoint: function(align, valign)\n\t{\n\t\tvar dx = -0.5;\n\t\tvar dy = -0.5;\n\t\t\n\t\t// Horizontal alignment\n\t\tif (align == mxConstants.ALIGN_LEFT)\n\t\t{\n\t\t\tdx = 0;\n\t\t}\n\t\telse if (align == mxConstants.ALIGN_RIGHT)\n\t\t{\n\t\t\tdx = -1;\n\t\t}\n\n\t\t// Vertical alignment\n\t\tif (valign == mxConstants.ALIGN_TOP)\n\t\t{\n\t\t\tdy = 0;\n\t\t}\n\t\telse if (valign == mxConstants.ALIGN_BOTTOM)\n\t\t{\n\t\t\tdy = -1;\n\t\t}\n\t\t\n\t\treturn new mxPoint(dx, dy);\n\t},\n\t\n\t/**\n\t * Function: getSizeForString\n\t * \n\t * Returns an <mxRectangle> with the size (width and height in pixels) of\n\t * the given string. The string may contain HTML markup. Newlines should be\n\t * converted to <br> before calling this method. The caller is responsible\n\t * for sanitizing the HTML markup.\n\t * \n\t * Example:\n\t * \n\t * (code)\n\t * var label = graph.getLabel(cell).replace(/\\n/g, \"<br>\");\n\t * var size = graph.getSizeForString(label);\n\t * (end)\n\t * \n\t * Parameters:\n\t * \n\t * text - String whose size should be returned.\n\t * fontSize - Integer that specifies the font size in pixels. Default is\n\t * <mxConstants.DEFAULT_FONTSIZE>.\n\t * fontFamily - String that specifies the name of the font family. Default\n\t * is <mxConstants.DEFAULT_FONTFAMILY>.\n\t * textWidth - Optional width for text wrapping.\n\t * fontStyle - Optional font style.\n\t */\n\tgetSizeForString: function(text, fontSize, fontFamily, textWidth, fontStyle)\n\t{\n\t\tfontSize = (fontSize != null) ? fontSize : mxConstants.DEFAULT_FONTSIZE;\n\t\tfontFamily = (fontFamily != null) ? fontFamily : mxConstants.DEFAULT_FONTFAMILY;\n\t\tvar div = document.createElement('div');\n\t\t\n\t\t// Sets the font size and family\n\t\tdiv.style.fontFamily = fontFamily;\n\t\tdiv.style.fontSize = Math.round(fontSize) + 'px';\n\t\tdiv.style.lineHeight = Math.round(fontSize * mxConstants.LINE_HEIGHT) + 'px';\n\t\t\n\t\t// Sets the font style\n\t\tif (fontStyle != null)\n\t\t{\n\t\t\tif ((fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD)\n\t\t\t{\n\t\t\t\tdiv.style.fontWeight = 'bold';\n\t\t\t}\n\t\t\t\n\t\t\tif ((fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC)\n\t\t\t{\n\t\t\t\tdiv.style.fontStyle = 'italic';\n\t\t\t}\n\t\t\t\n\t\t\tvar txtDecor = [];\n\t\t\t\n\t\t\tif ((fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE)\n\t\t\t{\n\t\t\t\ttxtDecor.push('underline');\n\t\t\t}\n\t\t\t\n\t\t\tif ((fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH)\n\t\t\t{\n\t\t\t\ttxtDecor.push('line-through');\n\t\t\t}\n\t\t\t\n\t\t\tif (txtDecor.length > 0)\n\t\t\t{\n\t\t\t\tdiv.style.textDecoration = txtDecor.join(' ');\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Disables block layout and outside wrapping and hides the div\n\t\tdiv.style.position = 'absolute';\n\t\tdiv.style.visibility = 'hidden';\n\t\tdiv.style.display = (mxClient.IS_QUIRKS) ? 'inline' : 'inline-block';\n\t\tdiv.style.zoom = '1';\n\t\t\n\t\tif (textWidth != null)\n\t\t{\n\t\t\tdiv.style.width = textWidth + 'px';\n\t\t\tdiv.style.whiteSpace = 'normal';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdiv.style.whiteSpace = 'nowrap';\n\t\t}\n\t\t\n\t\t// Adds the text and inserts into DOM for updating of size\n\t\tdiv.innerHTML = text;\n\t\tdocument.body.appendChild(div);\n\t\t\n\t\t// Gets the size and removes from DOM\n\t\tvar size = new mxRectangle(0, 0, div.offsetWidth, div.offsetHeight);\n\t\tdocument.body.removeChild(div);\n\t\t\n\t\treturn size;\n\t},\n\t\n\t/**\n\t * Function: getViewXml\n\t */\n\tgetViewXml: function(graph, scale, cells, x0, y0)\n\t{\n\t\tx0 = (x0 != null) ? x0 : 0;\n\t\ty0 = (y0 != null) ? y0 : 0;\n\t\tscale = (scale != null) ? scale : 1;\n\n\t\tif (cells == null)\n\t\t{\n\t\t\tvar model = graph.getModel();\n\t\t\tcells = [model.getRoot()];\n\t\t}\n\t\t\n\t\tvar view = graph.getView();\n\t\tvar result = null;\n\n\t\t// Disables events on the view\n\t\tvar eventsEnabled = view.isEventsEnabled();\n\t\tview.setEventsEnabled(false);\n\n\t\t// Workaround for label bounds not taken into account for image export.\n\t\t// Creates a temporary draw pane which is used for rendering the text.\n\t\t// Text rendering is required for finding the bounds of the labels.\n\t\tvar drawPane = view.drawPane;\n\t\tvar overlayPane = view.overlayPane;\n\n\t\tif (graph.dialect == mxConstants.DIALECT_SVG)\n\t\t{\n\t\t\tview.drawPane = document.createElementNS(mxConstants.NS_SVG, 'g');\n\t\t\tview.canvas.appendChild(view.drawPane);\n\n\t\t\t// Redirects cell overlays into temporary container\n\t\t\tview.overlayPane = document.createElementNS(mxConstants.NS_SVG, 'g');\n\t\t\tview.canvas.appendChild(view.overlayPane);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tview.drawPane = view.drawPane.cloneNode(false);\n\t\t\tview.canvas.appendChild(view.drawPane);\n\t\t\t\n\t\t\t// Redirects cell overlays into temporary container\n\t\t\tview.overlayPane = view.overlayPane.cloneNode(false);\n\t\t\tview.canvas.appendChild(view.overlayPane);\n\t\t}\n\n\t\t// Resets the translation\n\t\tvar translate = view.getTranslate();\n\t\tview.translate = new mxPoint(x0, y0);\n\n\t\t// Creates the temporary cell states in the view\n\t\tvar temp = new mxTemporaryCellStates(graph.getView(), scale, cells);\n\n\t\ttry\n\t\t{\n\t\t\tvar enc = new mxCodec();\n\t\t\tresult = enc.encode(graph.getView());\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttemp.destroy();\n\t\t\tview.translate = translate;\n\t\t\tview.canvas.removeChild(view.drawPane);\n\t\t\tview.canvas.removeChild(view.overlayPane);\n\t\t\tview.drawPane = drawPane;\n\t\t\tview.overlayPane = overlayPane;\n\t\t\tview.setEventsEnabled(eventsEnabled);\n\t\t}\n\n\t\treturn result;\n\t},\n\t\n\t/**\n\t * Function: getScaleForPageCount\n\t * \n\t * Returns the scale to be used for printing the graph with the given\n\t * bounds across the specifies number of pages with the given format. The\n\t * scale is always computed such that it given the given amount or fewer\n\t * pages in the print output. See <mxPrintPreview> for an example.\n\t * \n\t * Parameters:\n\t * \n\t * pageCount - Specifies the number of pages in the print output.\n\t * graph - <mxGraph> that should be printed.\n\t * pageFormat - Optional <mxRectangle> that specifies the page format.\n\t * Default is <mxConstants.PAGE_FORMAT_A4_PORTRAIT>.\n\t * border - The border along each side of every page.\n\t */\n\tgetScaleForPageCount: function(pageCount, graph, pageFormat, border)\n\t{\n\t\tif (pageCount < 1)\n\t\t{\n\t\t\t// We can't work with less than 1 page, return no scale\n\t\t\t// change\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tpageFormat = (pageFormat != null) ? pageFormat : mxConstants.PAGE_FORMAT_A4_PORTRAIT;\n\t\tborder = (border != null) ? border : 0;\n\t\t\n\t\tvar availablePageWidth = pageFormat.width - (border * 2);\n\t\tvar availablePageHeight = pageFormat.height - (border * 2);\n\n\t\t// Work out the number of pages required if the\n\t\t// graph is not scaled.\n\t\tvar graphBounds = graph.getGraphBounds().clone();\n\t\tvar sc = graph.getView().getScale();\n\t\tgraphBounds.width /= sc;\n\t\tgraphBounds.height /= sc;\n\t\tvar graphWidth = graphBounds.width;\n\t\tvar graphHeight = graphBounds.height;\n\n\t\tvar scale = 1;\n\t\t\n\t\t// The ratio of the width/height for each printer page\n\t\tvar pageFormatAspectRatio = availablePageWidth / availablePageHeight;\n\t\t// The ratio of the width/height for the graph to be printer\n\t\tvar graphAspectRatio = graphWidth / graphHeight;\n\t\t\n\t\t// The ratio of horizontal pages / vertical pages for this \n\t\t// graph to maintain its aspect ratio on this page format\n\t\tvar pagesAspectRatio = graphAspectRatio / pageFormatAspectRatio;\n\t\t\n\t\t// Factor the square root of the page count up and down \n\t\t// by the pages aspect ratio to obtain a horizontal and \n\t\t// vertical page count that adds up to the page count\n\t\t// and has the correct aspect ratio\n\t\tvar pageRoot = Math.sqrt(pageCount);\n\t\tvar pagesAspectRatioSqrt = Math.sqrt(pagesAspectRatio);\n\t\tvar numRowPages = pageRoot * pagesAspectRatioSqrt;\n\t\tvar numColumnPages = pageRoot / pagesAspectRatioSqrt;\n\n\t\t// These value are rarely more than 2 rounding downs away from\n\t\t// a total that meets the page count. In cases of one being less \n\t\t// than 1 page, the other value can be too high and take more iterations \n\t\t// In this case, just change that value to be the page count, since \n\t\t// we know the other value is 1\n\t\tif (numRowPages < 1 && numColumnPages > pageCount)\n\t\t{\n\t\t\tvar scaleChange = numColumnPages / pageCount;\n\t\t\tnumColumnPages = pageCount;\n\t\t\tnumRowPages /= scaleChange;\n\t\t}\n\t\t\n\t\tif (numColumnPages < 1 && numRowPages > pageCount)\n\t\t{\n\t\t\tvar scaleChange = numRowPages / pageCount;\n\t\t\tnumRowPages = pageCount;\n\t\t\tnumColumnPages /= scaleChange;\n\t\t}\t\t\n\n\t\tvar currentTotalPages = Math.ceil(numRowPages) * Math.ceil(numColumnPages);\n\n\t\tvar numLoops = 0;\n\t\t\n\t\t// Iterate through while the rounded up number of pages comes to\n\t\t// a total greater than the required number\n\t\twhile (currentTotalPages > pageCount)\n\t\t{\n\t\t\t// Round down the page count (rows or columns) that is\n\t\t\t// closest to its next integer down in percentage terms.\n\t\t\t// i.e. Reduce the page total by reducing the total\n\t\t\t// page area by the least possible amount\n\n\t\t\tvar roundRowDownProportion = Math.floor(numRowPages) / numRowPages;\n\t\t\tvar roundColumnDownProportion = Math.floor(numColumnPages) / numColumnPages;\n\t\t\t\n\t\t\t// If the round down proportion is, work out the proportion to\n\t\t\t// round down to 1 page less\n\t\t\tif (roundRowDownProportion == 1)\n\t\t\t{\n\t\t\t\troundRowDownProportion = Math.floor(numRowPages-1) / numRowPages;\n\t\t\t}\n\t\t\tif (roundColumnDownProportion == 1)\n\t\t\t{\n\t\t\t\troundColumnDownProportion = Math.floor(numColumnPages-1) / numColumnPages;\n\t\t\t}\n\t\t\t\n\t\t\t// Check which rounding down is smaller, but in the case of very small roundings\n\t\t\t// try the other dimension instead\n\t\t\tvar scaleChange = 1;\n\t\t\t\n\t\t\t// Use the higher of the two values\n\t\t\tif (roundRowDownProportion > roundColumnDownProportion)\n\t\t\t{\n\t\t\t\tscaleChange = roundRowDownProportion;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tscaleChange = roundColumnDownProportion;\n\t\t\t}\n\n\t\t\tnumRowPages = numRowPages * scaleChange;\n\t\t\tnumColumnPages = numColumnPages * scaleChange;\n\t\t\tcurrentTotalPages = Math.ceil(numRowPages) * Math.ceil(numColumnPages);\n\t\t\t\n\t\t\tnumLoops++;\n\t\t\t\n\t\t\tif (numLoops > 10)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Work out the scale from the number of row pages required\n\t\t// The column pages will give the same value\n\t\tvar posterWidth = availablePageWidth * numRowPages;\n\t\tscale = posterWidth / graphWidth;\n\t\t\n\t\t// Allow for rounding errors\n\t\treturn scale * 0.99999;\n\t},\n\t\n\t/**\n\t * Function: show\n\t * \n\t * Copies the styles and the markup from the graph's container into the\n\t * given document and removes all cursor styles. The document is returned.\n\t * \n\t * This function should be called from within the document with the graph.\n\t * If you experience problems with missing stylesheets in IE then try adding\n\t * the domain to the trusted sites.\n\t * \n\t * Parameters:\n\t * \n\t * graph - <mxGraph> to be copied.\n\t * doc - Document where the new graph is created.\n\t * x0 - X-coordinate of the graph view origin. Default is 0.\n\t * y0 - Y-coordinate of the graph view origin. Default is 0.\n\t * w - Optional width of the graph view.\n\t * h - Optional height of the graph view.\n\t */\n\tshow: function(graph, doc, x0, y0, w, h)\n\t{\n\t\tx0 = (x0 != null) ? x0 : 0;\n\t\ty0 = (y0 != null) ? y0 : 0;\n\t\t\n\t\tif (doc == null)\n\t\t{\n\t\t\tvar wnd = window.open();\n\t\t\tdoc = wnd.document;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoc.open();\n\t\t}\n\n\t\t// Workaround for missing print output in IE9 standards\n\t\tif (document.documentMode == 9)\n\t\t{\n\t\t\tdoc.writeln('<!--[if IE]><meta http-equiv=\"X-UA-Compatible\" content=\"IE=9\"><![endif]-->');\n\t\t}\n\t\t\n\t\tvar bounds = graph.getGraphBounds();\n\t\tvar dx = Math.ceil(x0 - bounds.x);\n\t\tvar dy = Math.ceil(y0 - bounds.y);\n\t\t\n\t\tif (w == null)\n\t\t{\n\t\t\tw = Math.ceil(bounds.width + x0) + Math.ceil(Math.ceil(bounds.x) - bounds.x);\n\t\t}\n\t\t\n\t\tif (h == null)\n\t\t{\n\t\t\th = Math.ceil(bounds.height + y0) + Math.ceil(Math.ceil(bounds.y) - bounds.y);\n\t\t}\n\t\t\n\t\t// Needs a special way of creating the page so that no click is required\n\t\t// to refresh the contents after the external CSS styles have been loaded.\n\t\t// To avoid a click or programmatic refresh, the styleSheets[].cssText\n\t\t// property is copied over from the original document.\n\t\tif (mxClient.IS_IE || document.documentMode == 11)\n\t\t{\n\t\t\tvar html = '<html><head>';\n\n\t\t\tvar base = document.getElementsByTagName('base');\n\t\t\t\n\t\t\tfor (var i = 0; i < base.length; i++)\n\t\t\t{\n\t\t\t\thtml += base[i].outerHTML;\n\t\t\t}\n\n\t\t\thtml += '<style>';\n\n\t\t\t// Copies the stylesheets without having to load them again\n\t\t\tfor (var i = 0; i < document.styleSheets.length; i++)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\thtml += document.styleSheets[i].cssText;\n\t\t\t\t}\n\t\t\t\tcatch (e)\n\t\t\t\t{\n\t\t\t\t\t// ignore security exception\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thtml += '</style></head><body style=\"margin:0px;\">';\n\t\t\t\n\t\t\t// Copies the contents of the graph container\n\t\t\thtml += '<div style=\"position:absolute;overflow:hidden;width:' + w + 'px;height:' + h + 'px;\"><div style=\"position:relative;left:' + dx + 'px;top:' + dy + 'px;\">';\n\t\t\thtml += graph.container.innerHTML;\n\t\t\thtml += '</div></div></body><html>';\n\n\t\t\tdoc.writeln(html);\n\t\t\tdoc.close();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoc.writeln('<html><head>');\n\t\t\t\n\t\t\tvar base = document.getElementsByTagName('base');\n\t\t\t\n\t\t\tfor (var i = 0; i < base.length; i++)\n\t\t\t{\n\t\t\t\tdoc.writeln(mxUtils.getOuterHtml(base[i]));\n\t\t\t}\n\t\t\t\n\t\t\tvar links = document.getElementsByTagName('link');\n\t\t\t\n\t\t\tfor (var i = 0; i < links.length; i++)\n\t\t\t{\n\t\t\t\tdoc.writeln(mxUtils.getOuterHtml(links[i]));\n\t\t\t}\n\t\n\t\t\tvar styles = document.getElementsByTagName('style');\n\t\t\t\n\t\t\tfor (var i = 0; i < styles.length; i++)\n\t\t\t{\n\t\t\t\tdoc.writeln(mxUtils.getOuterHtml(styles[i]));\n\t\t\t}\n\n\t\t\tdoc.writeln('</head><body style=\"margin:0px;\"></body></html>');\n\t\t\tdoc.close();\n\n\t\t\tvar outer = doc.createElement('div');\n\t\t\touter.position = 'absolute';\n\t\t\touter.overflow = 'hidden';\n\t\t\touter.style.width = w + 'px';\n\t\t\touter.style.height = h + 'px';\n\n\t\t\t// Required for HTML labels if foreignObjects are disabled\n\t\t\tvar div = doc.createElement('div');\n\t\t\tdiv.style.position = 'absolute';\n\t\t\tdiv.style.left = dx + 'px';\n\t\t\tdiv.style.top = dy + 'px';\n\n\t\t\tvar node = graph.container.firstChild;\n\t\t\tvar svg = null;\n\t\t\t\n\t\t\twhile (node != null)\n\t\t\t{\n\t\t\t\tvar clone = node.cloneNode(true);\n\t\t\t\t\n\t\t\t\tif (node == graph.view.drawPane.ownerSVGElement)\n\t\t\t\t{\n\t\t\t\t\touter.appendChild(clone);\n\t\t\t\t\tsvg = clone;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdiv.appendChild(clone);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnode = node.nextSibling;\n\t\t\t}\n\n\t\t\tdoc.body.appendChild(outer);\n\t\t\t\n\t\t\tif (div.firstChild != null)\n\t\t\t{\n\t\t\t\tdoc.body.appendChild(div);\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\tif (svg != null)\n\t\t\t{\n\t\t\t\tsvg.style.minWidth = '';\n\t\t\t\tsvg.style.minHeight = '';\n\t\t\t\tsvg.firstChild.setAttribute('transform', 'translate(' + dx + ',' + dy + ')');\n\t\t\t}\n\t\t}\n\t\t\n\t\tmxUtils.removeCursors(doc.body);\n\t\n\t\treturn doc;\n\t},\n\t\n\t/**\n\t * Function: printScreen\n\t * \n\t * Prints the specified graph using a new window and the built-in print\n\t * dialog.\n\t * \n\t * This function should be called from within the document with the graph.\n\t * \n\t * Parameters:\n\t * \n\t * graph - <mxGraph> to be printed.\n\t */\n\tprintScreen: function(graph)\n\t{\n\t\tvar wnd = window.open();\n\t\tvar bounds = graph.getGraphBounds();\n\t\tmxUtils.show(graph, wnd.document);\n\t\t\n\t\tvar print = function()\n\t\t{\n\t\t\twnd.focus();\n\t\t\twnd.print();\n\t\t\twnd.close();\n\t\t};\n\t\t\n\t\t// Workaround for Google Chrome which needs a bit of a\n\t\t// delay in order to render the SVG contents\n\t\tif (mxClient.IS_GC)\n\t\t{\n\t\t\twnd.setTimeout(print, 500);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprint();\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: popup\n\t * \n\t * Shows the specified text content in a new <mxWindow> or a new browser\n\t * window if isInternalWindow is false.\n\t * \n\t * Parameters:\n\t * \n\t * content - String that specifies the text to be displayed.\n\t * isInternalWindow - Optional boolean indicating if an mxWindow should be\n\t * used instead of a new browser window. Default is false.\n\t */\n\tpopup: function(content, isInternalWindow)\n\t{\n\t   \tif (isInternalWindow)\n\t   \t{\n\t\t\tvar div = document.createElement('div');\n\t\t\t\n\t\t\tdiv.style.overflow = 'scroll';\n\t\t\tdiv.style.width = '636px';\n\t\t\tdiv.style.height = '460px';\n\t\t\t\n\t\t\tvar pre = document.createElement('pre');\n\t\t    pre.innerHTML = mxUtils.htmlEntities(content, false).\n\t\t    \treplace(/\\n/g,'<br>').replace(/ /g, '&nbsp;');\n\t\t\t\n\t\t\tdiv.appendChild(pre);\n\t\t\t\n\t\t\tvar w = document.body.clientWidth;\n\t\t\tvar h = Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight)\n\t\t\tvar wnd = new mxWindow('Popup Window', div,\n\t\t\t\tw/2-320, h/2-240, 640, 480, false, true);\n\n\t\t\twnd.setClosable(true);\n\t\t\twnd.setVisible(true);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Wraps up the XML content in a textarea\n\t\t\tif (mxClient.IS_NS)\n\t\t\t{\n\t\t\t    var wnd = window.open();\n\t\t\t\twnd.document.writeln('<pre>'+mxUtils.htmlEntities(content)+'</pre');\n\t\t\t   \twnd.document.close();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    var wnd = window.open();\n\t\t\t    var pre = wnd.document.createElement('pre');\n\t\t\t    pre.innerHTML = mxUtils.htmlEntities(content, false).\n\t\t\t    \treplace(/\\n/g,'<br>').replace(/ /g, '&nbsp;');\n\t\t\t   \twnd.document.body.appendChild(pre);\n\t\t\t}\n\t   \t}\n\t},\n\t\n\t/**\n\t * Function: alert\n\t * \n\t * Displayss the given alert in a new dialog. This implementation uses the\n\t * built-in alert function. This is used to display validation errors when\n\t * connections cannot be changed or created.\n\t * \n\t * Parameters:\n\t * \n\t * message - String specifying the message to be displayed.\n\t */\n\talert: function(message)\n\t{\n\t\talert(message);\n\t},\n\t\n\t/**\n\t * Function: prompt\n\t * \n\t * Displays the given message in a prompt dialog. This implementation uses\n\t * the built-in prompt function.\n\t * \n\t * Parameters:\n\t * \n\t * message - String specifying the message to be displayed.\n\t * defaultValue - Optional string specifying the default value.\n\t */\n\tprompt: function(message, defaultValue)\n\t{\n\t\treturn prompt(message, (defaultValue != null) ? defaultValue : '');\n\t},\n\t\n\t/**\n\t * Function: confirm\n\t * \n\t * Displays the given message in a confirm dialog. This implementation uses\n\t * the built-in confirm function.\n\t * \n\t * Parameters:\n\t * \n\t * message - String specifying the message to be displayed.\n\t */\n\tconfirm: function(message)\n\t{\n\t\treturn confirm(message);\n\t},\n\n\t/**\n\t * Function: error\n\t * \n\t * Displays the given error message in a new <mxWindow> of the given width.\n\t * If close is true then an additional close button is added to the window.\n\t * The optional icon specifies the icon to be used for the window. Default\n\t * is <mxUtils.errorImage>.\n\t * \n\t * Parameters:\n\t * \n\t * message - String specifying the message to be displayed.\n\t * width - Integer specifying the width of the window.\n\t * close - Optional boolean indicating whether to add a close button.\n\t * icon - Optional icon for the window decoration.\n\t */\n\terror: function(message, width, close, icon)\n\t{\n\t\tvar div = document.createElement('div');\n\t\tdiv.style.padding = '20px';\n\n\t\tvar img = document.createElement('img');\n\t\timg.setAttribute('src', icon || mxUtils.errorImage);\n\t\timg.setAttribute('valign', 'bottom');\n\t\timg.style.verticalAlign = 'middle';\n\t\tdiv.appendChild(img);\n\n\t\tdiv.appendChild(document.createTextNode('\\u00a0')); // &nbsp;\n\t\tdiv.appendChild(document.createTextNode('\\u00a0')); // &nbsp;\n\t\tdiv.appendChild(document.createTextNode('\\u00a0')); // &nbsp;\n\t\tmxUtils.write(div, message);\n\n\t\tvar w = document.body.clientWidth;\n\t\tvar h = (document.body.clientHeight || document.documentElement.clientHeight);\n\t\tvar warn = new mxWindow(mxResources.get(mxUtils.errorResource) ||\n\t\t\tmxUtils.errorResource, div, (w-width)/2, h/4, width, null,\n\t\t\tfalse, true);\n\n\t\tif (close)\n\t\t{\n\t\t\tmxUtils.br(div);\n\t\t\t\n\t\t\tvar tmp = document.createElement('p');\n\t\t\tvar button = document.createElement('button');\n\n\t\t\tif (mxClient.IS_IE)\n\t\t\t{\n\t\t\t\tbutton.style.cssText = 'float:right';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbutton.setAttribute('style', 'float:right');\n\t\t\t}\n\n\t\t\tmxEvent.addListener(button, 'click', function(evt)\n\t\t\t{\n\t\t\t\twarn.destroy();\n\t\t\t});\n\n\t\t\tmxUtils.write(button, mxResources.get(mxUtils.closeResource) ||\n\t\t\t\tmxUtils.closeResource);\n\t\t\t\n\t\t\ttmp.appendChild(button);\n\t\t\tdiv.appendChild(tmp);\n\t\t\t\n\t\t\tmxUtils.br(div);\n\t\t\t\n\t\t\twarn.setClosable(true);\n\t\t}\n\t\t\n\t\twarn.setVisible(true);\n\t\t\n\t\treturn warn;\n\t},\n\n\t/**\n\t * Function: makeDraggable\n\t * \n\t * Configures the given DOM element to act as a drag source for the\n\t * specified graph. Returns a a new <mxDragSource>. If\n\t * <mxDragSource.guideEnabled> is enabled then the x and y arguments must\n\t * be used in funct to match the preview location.\n\t * \n\t * Example:\n\t * \n\t * (code)\n\t * var funct = function(graph, evt, cell, x, y)\n\t * {\n\t *   if (graph.canImportCell(cell))\n\t *   {\n\t *     var parent = graph.getDefaultParent();\n\t *     var vertex = null;\n\t *     \n\t *     graph.getModel().beginUpdate();\n\t *     try\n\t *     {\n\t * \t     vertex = graph.insertVertex(parent, null, 'Hello', x, y, 80, 30);\n\t *     }\n\t *     finally\n\t *     {\n\t *       graph.getModel().endUpdate();\n\t *     }\n\t *\n\t *     graph.setSelectionCell(vertex);\n\t *   }\n\t * }\n\t * \n\t * var img = document.createElement('img');\n\t * img.setAttribute('src', 'editors/images/rectangle.gif');\n\t * img.style.position = 'absolute';\n\t * img.style.left = '0px';\n\t * img.style.top = '0px';\n\t * img.style.width = '16px';\n\t * img.style.height = '16px';\n\t * \n\t * var dragImage = img.cloneNode(true);\n\t * dragImage.style.width = '32px';\n\t * dragImage.style.height = '32px';\n\t * mxUtils.makeDraggable(img, graph, funct, dragImage);\n\t * document.body.appendChild(img);\n\t * (end)\n\t * \n\t * Parameters:\n\t * \n\t * element - DOM element to make draggable.\n\t * graphF - <mxGraph> that acts as the drop target or a function that takes a\n\t * mouse event and returns the current <mxGraph>.\n\t * funct - Function to execute on a successful drop.\n\t * dragElement - Optional DOM node to be used for the drag preview.\n\t * dx - Optional horizontal offset between the cursor and the drag\n\t * preview.\n\t * dy - Optional vertical offset between the cursor and the drag\n\t * preview.\n\t * autoscroll - Optional boolean that specifies if autoscroll should be\n\t * used. Default is mxGraph.autoscroll.\n\t * scalePreview - Optional boolean that specifies if the preview element\n\t * should be scaled according to the graph scale. If this is true, then\n\t * the offsets will also be scaled. Default is false.\n\t * highlightDropTargets - Optional boolean that specifies if dropTargets\n\t * should be highlighted. Default is true.\n\t * getDropTarget - Optional function to return the drop target for a given\n\t * location (x, y). Default is mxGraph.getCellAt.\n\t */\n\tmakeDraggable: function(element, graphF, funct, dragElement, dx, dy, autoscroll,\n\t\t\tscalePreview, highlightDropTargets, getDropTarget)\n\t{\n\t\tvar dragSource = new mxDragSource(element, funct);\n\t\tdragSource.dragOffset = new mxPoint((dx != null) ? dx : 0,\n\t\t\t(dy != null) ? dy : mxConstants.TOOLTIP_VERTICAL_OFFSET);\n\t\tdragSource.autoscroll = autoscroll;\n\t\t\n\t\t// Cannot enable this by default. This needs to be enabled in the caller\n\t\t// if the funct argument uses the new x- and y-arguments.\n\t\tdragSource.setGuidesEnabled(false);\n\t\t\n\t\tif (highlightDropTargets != null)\n\t\t{\n\t\t\tdragSource.highlightDropTargets = highlightDropTargets;\n\t\t}\n\t\t\n\t\t// Overrides function to find drop target cell\n\t\tif (getDropTarget != null)\n\t\t{\n\t\t\tdragSource.getDropTarget = getDropTarget;\n\t\t}\n\t\t\n\t\t// Overrides function to get current graph\n\t\tdragSource.getGraphForEvent = function(evt)\n\t\t{\n\t\t\treturn (typeof(graphF) == 'function') ? graphF(evt) : graphF;\n\t\t};\n\t\t\n\t\t// Translates switches into dragSource customizations\n\t\tif (dragElement != null)\n\t\t{\n\t\t\tdragSource.createDragElement = function()\n\t\t\t{\n\t\t\t\treturn dragElement.cloneNode(true);\n\t\t\t};\n\t\t\t\n\t\t\tif (scalePreview)\n\t\t\t{\n\t\t\t\tdragSource.createPreviewElement = function(graph)\n\t\t\t\t{\n\t\t\t\t\tvar elt = dragElement.cloneNode(true);\n\n\t\t\t\t\tvar w = parseInt(elt.style.width);\n\t\t\t\t\tvar h = parseInt(elt.style.height);\n\t\t\t\t\telt.style.width = Math.round(w * graph.view.scale) + 'px';\n\t\t\t\t\telt.style.height = Math.round(h * graph.view.scale) + 'px';\n\t\t\t\t\t\n\t\t\t\t\treturn elt;\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dragSource;\n\t}\n\n};\n\n__mxOutput.mxUtils = typeof mxUtils !== 'undefined' ? mxUtils : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n var mxConstants =\n {\n\t/**\n\t * Class: mxConstants\n\t * \n\t * Defines various global constants.\n\t * \n\t * Variable: DEFAULT_HOTSPOT\n\t * \n\t * Defines the portion of the cell which is to be used as a connectable\n\t * region. Default is 0.3. Possible values are 0 < x <= 1. \n\t */\n\tDEFAULT_HOTSPOT: 0.3,\n\n\t/**\n\t * Variable: MIN_HOTSPOT_SIZE\n\t * \n\t * Defines the minimum size in pixels of the portion of the cell which is\n\t * to be used as a connectable region. Default is 8.\n\t */\n\tMIN_HOTSPOT_SIZE: 8,\n\n\t/**\n\t * Variable: MAX_HOTSPOT_SIZE\n\t * \n\t * Defines the maximum size in pixels of the portion of the cell which is\n\t * to be used as a connectable region. Use 0 for no maximum. Default is 0.\n\t */\n\tMAX_HOTSPOT_SIZE: 0,\n\n\t/**\n\t * Variable: RENDERING_HINT_EXACT\n\t * \n\t * Defines the exact rendering hint.\n\t */\n\tRENDERING_HINT_EXACT: 'exact',\n\n\t/**\n\t * Variable: RENDERING_HINT_FASTER\n\t * \n\t * Defines the faster rendering hint.\n\t */\n\tRENDERING_HINT_FASTER: 'faster',\n\n\t/**\n\t * Variable: RENDERING_HINT_FASTEST\n\t * \n\t * Defines the fastest rendering hint.\n\t */\n\tRENDERING_HINT_FASTEST: 'fastest',\n\n\t/**\n\t * Variable: DIALECT_SVG\n\t * \n\t * Defines the SVG display dialect name.\n\t */\n\tDIALECT_SVG: 'svg',\n\n\t/**\n\t * Variable: DIALECT_VML\n\t * \n\t * Defines the VML display dialect name.\n\t */\n\tDIALECT_VML: 'vml',\n\n\t/**\n\t * Variable: DIALECT_MIXEDHTML\n\t * \n\t * Defines the mixed HTML display dialect name.\n\t */\n\tDIALECT_MIXEDHTML: 'mixedHtml',\n\n\t/**\n\t * Variable: DIALECT_PREFERHTML\n\t * \n\t * Defines the preferred HTML display dialect name.\n\t */\n\tDIALECT_PREFERHTML: 'preferHtml',\n\n\t/**\n\t * Variable: DIALECT_STRICTHTML\n\t * \n\t * Defines the strict HTML display dialect.\n\t */\n\tDIALECT_STRICTHTML: 'strictHtml',\n\n\t/**\n\t * Variable: NS_SVG\n\t * \n\t * Defines the SVG namespace.\n\t */\n\tNS_SVG: 'http://www.w3.org/2000/svg',\n\n\t/**\n\t * Variable: NS_XHTML\n\t * \n\t * Defines the XHTML namespace.\n\t */\n\tNS_XHTML: 'http://www.w3.org/1999/xhtml',\n\n\t/**\n\t * Variable: NS_XLINK\n\t * \n\t * Defines the XLink namespace.\n\t */\n\tNS_XLINK: 'http://www.w3.org/1999/xlink',\n\n\t/**\n\t * Variable: SHADOWCOLOR\n\t * \n\t * Defines the color to be used to draw shadows in shapes and windows.\n\t * Default is gray.\n\t */\n\tSHADOWCOLOR: 'gray',\n\n\t/**\n\t * Variable: VML_SHADOWCOLOR\n\t * \n\t * Used for shadow color in filters where transparency is not supported\n\t * (Microsoft Internet Explorer). Default is gray.\n\t */\n\tVML_SHADOWCOLOR: 'gray',\n\n\t/**\n\t * Variable: SHADOW_OFFSET_X\n\t * \n\t * Specifies the x-offset of the shadow. Default is 2.\n\t */\n\tSHADOW_OFFSET_X: 2,\n\n\t/**\n\t * Variable: SHADOW_OFFSET_Y\n\t * \n\t * Specifies the y-offset of the shadow. Default is 3.\n\t */\n\tSHADOW_OFFSET_Y: 3,\n\t\n\t/**\n\t * Variable: SHADOW_OPACITY\n\t * \n\t * Defines the opacity for shadows. Default is 1.\n\t */\n\tSHADOW_OPACITY: 1,\n \n\t/**\n\t * Variable: NODETYPE_ELEMENT\n\t * \n\t * DOM node of type ELEMENT.\n\t */\n\tNODETYPE_ELEMENT: 1,\n\n\t/**\n\t * Variable: NODETYPE_ATTRIBUTE\n\t * \n\t * DOM node of type ATTRIBUTE.\n\t */\n\tNODETYPE_ATTRIBUTE: 2,\n\n\t/**\n\t * Variable: NODETYPE_TEXT\n\t * \n\t * DOM node of type TEXT.\n\t */\n\tNODETYPE_TEXT: 3,\n\n\t/**\n\t * Variable: NODETYPE_CDATA\n\t * \n\t * DOM node of type CDATA.\n\t */\n\tNODETYPE_CDATA: 4,\n\t\n\t/**\n\t * Variable: NODETYPE_ENTITY_REFERENCE\n\t * \n\t * DOM node of type ENTITY_REFERENCE.\n\t */\n\tNODETYPE_ENTITY_REFERENCE: 5,\n\n\t/**\n\t * Variable: NODETYPE_ENTITY\n\t * \n\t * DOM node of type ENTITY.\n\t */\n\tNODETYPE_ENTITY: 6,\n\n\t/**\n\t * Variable: NODETYPE_PROCESSING_INSTRUCTION\n\t * \n\t * DOM node of type PROCESSING_INSTRUCTION.\n\t */\n\tNODETYPE_PROCESSING_INSTRUCTION: 7,\n\n\t/**\n\t * Variable: NODETYPE_COMMENT\n\t * \n\t * DOM node of type COMMENT.\n\t */\n\tNODETYPE_COMMENT: 8,\n\t\t\n\t/**\n\t * Variable: NODETYPE_DOCUMENT\n\t * \n\t * DOM node of type DOCUMENT.\n\t */\n\tNODETYPE_DOCUMENT: 9,\n\n\t/**\n\t * Variable: NODETYPE_DOCUMENTTYPE\n\t * \n\t * DOM node of type DOCUMENTTYPE.\n\t */\n\tNODETYPE_DOCUMENTTYPE: 10,\n\n\t/**\n\t * Variable: NODETYPE_DOCUMENT_FRAGMENT\n\t * \n\t * DOM node of type DOCUMENT_FRAGMENT.\n\t */\n\tNODETYPE_DOCUMENT_FRAGMENT: 11,\n\n\t/**\n\t * Variable: NODETYPE_NOTATION\n\t * \n\t * DOM node of type NOTATION.\n\t */\n\tNODETYPE_NOTATION: 12,\n\t\n\t/**\n\t * Variable: TOOLTIP_VERTICAL_OFFSET\n\t * \n\t * Defines the vertical offset for the tooltip.\n\t * Default is 16.\n\t */\n\tTOOLTIP_VERTICAL_OFFSET: 16,\n\n\t/**\n\t * Variable: DEFAULT_VALID_COLOR\n\t * \n\t * Specifies the default valid color. Default is #0000FF.\n\t */\n\tDEFAULT_VALID_COLOR: '#00FF00',\n\n\t/**\n\t * Variable: DEFAULT_INVALID_COLOR\n\t * \n\t * Specifies the default invalid color. Default is #FF0000.\n\t */\n\tDEFAULT_INVALID_COLOR: '#FF0000',\n\n\t/**\n\t * Variable: OUTLINE_HIGHLIGHT_COLOR\n\t * \n\t * Specifies the default highlight color for shape outlines.\n\t * Default is #0000FF. This is used in <mxEdgeHandler>.\n\t */\n\tOUTLINE_HIGHLIGHT_COLOR: '#00FF00',\n\n\t/**\n\t * Variable: OUTLINE_HIGHLIGHT_COLOR\n\t * \n\t * Defines the strokewidth to be used for shape outlines.\n\t * Default is 5. This is used in <mxEdgeHandler>.\n\t */\n\tOUTLINE_HIGHLIGHT_STROKEWIDTH: 5,\n\n\t/**\n\t * Variable: HIGHLIGHT_STROKEWIDTH\n\t * \n\t * Defines the strokewidth to be used for the highlights.\n\t * Default is 3.\n\t */\n\tHIGHLIGHT_STROKEWIDTH: 3,\n\n\t/**\n\t * Variable: CONSTRAINT_HIGHLIGHT_SIZE\n\t * \n\t * Size of the constraint highlight (in px). Default is 2.\n\t */\n\tHIGHLIGHT_SIZE: 2,\n\t\n\t/**\n\t * Variable: HIGHLIGHT_OPACITY\n\t * \n\t * Opacity (in %) used for the highlights (including outline).\n\t * Default is 100.\n\t */\n\tHIGHLIGHT_OPACITY: 100,\n\t\n\t/**\n\t * Variable: CURSOR_MOVABLE_VERTEX\n\t * \n\t * Defines the cursor for a movable vertex. Default is 'move'.\n\t */\n\tCURSOR_MOVABLE_VERTEX: 'move',\n\t\n\t/**\n\t * Variable: CURSOR_MOVABLE_EDGE\n\t * \n\t * Defines the cursor for a movable edge. Default is 'move'.\n\t */\n\tCURSOR_MOVABLE_EDGE: 'move',\n\t\n\t/**\n\t * Variable: CURSOR_LABEL_HANDLE\n\t * \n\t * Defines the cursor for a movable label. Default is 'default'.\n\t */\n\tCURSOR_LABEL_HANDLE: 'default',\n\t\n\t/**\n\t * Variable: CURSOR_TERMINAL_HANDLE\n\t * \n\t * Defines the cursor for a terminal handle. Default is 'pointer'.\n\t */\n\tCURSOR_TERMINAL_HANDLE: 'pointer',\n\t\n\t/**\n\t * Variable: CURSOR_BEND_HANDLE\n\t * \n\t * Defines the cursor for a movable bend. Default is 'crosshair'.\n\t */\n\tCURSOR_BEND_HANDLE: 'crosshair',\n\n\t/**\n\t * Variable: CURSOR_VIRTUAL_BEND_HANDLE\n\t * \n\t * Defines the cursor for a movable bend. Default is 'crosshair'.\n\t */\n\tCURSOR_VIRTUAL_BEND_HANDLE: 'crosshair',\n\t\n\t/**\n\t * Variable: CURSOR_CONNECT\n\t * \n\t * Defines the cursor for a connectable state. Default is 'pointer'.\n\t */\n\tCURSOR_CONNECT: 'pointer',\n\n\t/**\n\t * Variable: HIGHLIGHT_COLOR\n\t * \n\t * Defines the color to be used for the cell highlighting.\n\t * Use 'none' for no color. Default is #00FF00.\n\t */\n\tHIGHLIGHT_COLOR: '#00FF00',\n\n\t/**\n\t * Variable: TARGET_HIGHLIGHT_COLOR\n\t * \n\t * Defines the color to be used for highlighting a target cell for a new\n\t * or changed connection. Note that this may be either a source or\n\t * target terminal in the graph. Use 'none' for no color.\n\t * Default is #0000FF.\n\t */\n\tCONNECT_TARGET_COLOR: '#0000FF',\n\n\t/**\n\t * Variable: INVALID_CONNECT_TARGET_COLOR\n\t * \n\t * Defines the color to be used for highlighting a invalid target cells\n\t * for a new or changed connections. Note that this may be either a source\n\t * or target terminal in the graph. Use 'none' for no color. Default is\n\t * #FF0000.\n\t */\n\tINVALID_CONNECT_TARGET_COLOR: '#FF0000',\n\n\t/**\n\t * Variable: DROP_TARGET_COLOR\n\t * \n\t * Defines the color to be used for the highlighting target parent cells\n\t * (for drag and drop). Use 'none' for no color. Default is #0000FF.\n\t */\n\tDROP_TARGET_COLOR: '#0000FF',\n\n\t/**\n\t * Variable: VALID_COLOR\n\t * \n\t * Defines the color to be used for the coloring valid connection\n\t * previews. Use 'none' for no color. Default is #FF0000.\n\t */\n\tVALID_COLOR: '#00FF00',\n\n\t/**\n\t * Variable: INVALID_COLOR\n\t * \n\t * Defines the color to be used for the coloring invalid connection\n\t * previews. Use 'none' for no color. Default is #FF0000.\n\t */\n\tINVALID_COLOR: '#FF0000',\n\n\t/**\n\t * Variable: EDGE_SELECTION_COLOR\n\t * \n\t * Defines the color to be used for the selection border of edges. Use\n\t * 'none' for no color. Default is #00FF00.\n\t */\n\tEDGE_SELECTION_COLOR: '#00FF00',\n\n\t/**\n\t * Variable: VERTEX_SELECTION_COLOR\n\t * \n\t * Defines the color to be used for the selection border of vertices. Use\n\t * 'none' for no color. Default is #00FF00.\n\t */\n\tVERTEX_SELECTION_COLOR: '#00FF00',\n\n\t/**\n\t * Variable: VERTEX_SELECTION_STROKEWIDTH\n\t * \n\t * Defines the strokewidth to be used for vertex selections.\n\t * Default is 1.\n\t */\n\tVERTEX_SELECTION_STROKEWIDTH: 1,\n\n\t/**\n\t * Variable: EDGE_SELECTION_STROKEWIDTH\n\t * \n\t * Defines the strokewidth to be used for edge selections.\n\t * Default is 1.\n\t */\n\tEDGE_SELECTION_STROKEWIDTH: 1,\n\n\t/**\n\t * Variable: SELECTION_DASHED\n\t * \n\t * Defines the dashed state to be used for the vertex selection\n\t * border. Default is true.\n\t */\n\tVERTEX_SELECTION_DASHED: true,\n\n\t/**\n\t * Variable: SELECTION_DASHED\n\t * \n\t * Defines the dashed state to be used for the edge selection\n\t * border. Default is true.\n\t */\n\tEDGE_SELECTION_DASHED: true,\n\n\t/**\n\t * Variable: GUIDE_COLOR\n\t * \n\t * Defines the color to be used for the guidelines in mxGraphHandler.\n\t * Default is #FF0000.\n\t */\n\tGUIDE_COLOR: '#FF0000',\n\n\t/**\n\t * Variable: GUIDE_STROKEWIDTH\n\t * \n\t * Defines the strokewidth to be used for the guidelines in mxGraphHandler.\n\t * Default is 1.\n\t */\n\tGUIDE_STROKEWIDTH: 1,\n\n\t/**\n\t * Variable: OUTLINE_COLOR\n\t * \n\t * Defines the color to be used for the outline rectangle\n\t * border.  Use 'none' for no color. Default is #0099FF.\n\t */\n\tOUTLINE_COLOR: '#0099FF',\n\n\t/**\n\t * Variable: OUTLINE_STROKEWIDTH\n\t * \n\t * Defines the strokewidth to be used for the outline rectangle\n\t * stroke width. Default is 3.\n\t */\n\tOUTLINE_STROKEWIDTH: (mxClient.IS_IE) ? 2 : 3,\n\n\t/**\n\t * Variable: HANDLE_SIZE\n\t * \n\t * Defines the default size for handles. Default is 6.\n\t */\n\tHANDLE_SIZE: 6,\n\n\t/**\n\t * Variable: LABEL_HANDLE_SIZE\n\t * \n\t * Defines the default size for label handles. Default is 4.\n\t */\n\tLABEL_HANDLE_SIZE: 4,\n\n\t/**\n\t * Variable: HANDLE_FILLCOLOR\n\t * \n\t * Defines the color to be used for the handle fill color. Use 'none' for\n\t * no color. Default is #00FF00 (green).\n\t */\n\tHANDLE_FILLCOLOR: '#00FF00',\n\n\t/**\n\t * Variable: HANDLE_STROKECOLOR\n\t * \n\t * Defines the color to be used for the handle stroke color. Use 'none' for\n\t * no color. Default is black.\n\t */\n\tHANDLE_STROKECOLOR: 'black',\n\n\t/**\n\t * Variable: LABEL_HANDLE_FILLCOLOR\n\t * \n\t * Defines the color to be used for the label handle fill color. Use 'none'\n\t * for no color. Default is yellow.\n\t */\n\tLABEL_HANDLE_FILLCOLOR: 'yellow',\n\n\t/**\n\t * Variable: CONNECT_HANDLE_FILLCOLOR\n\t * \n\t * Defines the color to be used for the connect handle fill color. Use\n\t * 'none' for no color. Default is #0000FF (blue).\n\t */\n\tCONNECT_HANDLE_FILLCOLOR: '#0000FF',\n\n\t/**\n\t * Variable: LOCKED_HANDLE_FILLCOLOR\n\t * \n\t * Defines the color to be used for the locked handle fill color. Use\n\t * 'none' for no color. Default is #FF0000 (red).\n\t */\n\tLOCKED_HANDLE_FILLCOLOR: '#FF0000',\n\n\t/**\n\t * Variable: OUTLINE_HANDLE_FILLCOLOR\n\t * \n\t * Defines the color to be used for the outline sizer fill color. Use\n\t * 'none' for no color. Default is #00FFFF.\n\t */\n\tOUTLINE_HANDLE_FILLCOLOR: '#00FFFF',\n\n\t/**\n\t * Variable: OUTLINE_HANDLE_STROKECOLOR\n\t * \n\t * Defines the color to be used for the outline sizer stroke color. Use\n\t * 'none' for no color. Default is #0033FF.\n\t */\n\tOUTLINE_HANDLE_STROKECOLOR: '#0033FF',\n\n\t/**\n\t * Variable: DEFAULT_FONTFAMILY\n\t * \n\t * Defines the default family for all fonts. Default is Arial,Helvetica.\n\t */\n\tDEFAULT_FONTFAMILY: 'Arial,Helvetica',\n\n\t/**\n\t * Variable: DEFAULT_FONTSIZE\n\t * \n\t * Defines the default size (in px). Default is 11.\n\t */\n\tDEFAULT_FONTSIZE: 11,\n\n\t/**\n\t * Variable: DEFAULT_TEXT_DIRECTION\n\t * \n\t * Defines the default value for the <STYLE_TEXT_DIRECTION> if no value is\n\t * defined for it in the style. Default value is an empty string which means\n\t * the default system setting is used and no direction is set.\n\t */\n\tDEFAULT_TEXT_DIRECTION: '',\n\n\t/**\n\t * Variable: LINE_HEIGHT\n\t * \n\t * Defines the default line height for text labels. Default is 1.2.\n\t */\n\tLINE_HEIGHT: 1.2,\n\n\t/**\n\t * Variable: WORD_WRAP\n\t * \n\t * Defines the CSS value for the word-wrap property. Default is \"normal\".\n\t * Change this to \"break-word\" to allow long words to be able to be broken\n\t * and wrap onto the next line.\n\t */\n\tWORD_WRAP: 'normal',\n\n\t/**\n\t * Variable: ABSOLUTE_LINE_HEIGHT\n\t * \n\t * Specifies if absolute line heights should be used (px) in CSS. Default\n\t * is false. Set this to true for backwards compatibility.\n\t */\n\tABSOLUTE_LINE_HEIGHT: false,\n\n\t/**\n\t * Variable: DEFAULT_FONTSTYLE\n\t * \n\t * Defines the default style for all fonts. Default is 0. This can be set\n\t * to any combination of font styles as follows.\n\t * \n\t * (code)\n\t * mxConstants.DEFAULT_FONTSTYLE = mxConstants.FONT_BOLD | mxConstants.FONT_ITALIC;\n\t * (end)\n\t */\n\tDEFAULT_FONTSTYLE: 0,\n\n\t/**\n\t * Variable: DEFAULT_STARTSIZE\n\t * \n\t * Defines the default start size for swimlanes. Default is 40.\n\t */\n\tDEFAULT_STARTSIZE: 40,\n\n\t/**\n\t * Variable: DEFAULT_MARKERSIZE\n\t * \n\t * Defines the default size for all markers. Default is 6.\n\t */\n\tDEFAULT_MARKERSIZE: 6,\n\n\t/**\n\t * Variable: DEFAULT_IMAGESIZE\n\t * \n\t * Defines the default width and height for images used in the\n\t * label shape. Default is 24.\n\t */\n\tDEFAULT_IMAGESIZE: 24,\n\n\t/**\n\t * Variable: ENTITY_SEGMENT\n\t * \n\t * Defines the length of the horizontal segment of an Entity Relation.\n\t * This can be overridden using <mxConstants.STYLE_SEGMENT> style.\n\t * Default is 30.\n\t */\n\tENTITY_SEGMENT: 30,\n\n\t/**\n\t * Variable: RECTANGLE_ROUNDING_FACTOR\n\t * \n\t * Defines the rounding factor for rounded rectangles in percent between\n\t * 0 and 1. Values should be smaller than 0.5. Default is 0.15.\n\t */\n\tRECTANGLE_ROUNDING_FACTOR: 0.15,\n\n\t/**\n\t * Variable: LINE_ARCSIZE\n\t * \n\t * Defines the size of the arcs for rounded edges. Default is 20.\n\t */\n\tLINE_ARCSIZE: 20,\n\n\t/**\n\t * Variable: ARROW_SPACING\n\t * \n\t * Defines the spacing between the arrow shape and its terminals. Default is 0.\n\t */\n\tARROW_SPACING: 0,\n\n\t/**\n\t * Variable: ARROW_WIDTH\n\t * \n\t * Defines the width of the arrow shape. Default is 30.\n\t */\n\tARROW_WIDTH: 30,\n\n\t/**\n\t * Variable: ARROW_SIZE\n\t * \n\t * Defines the size of the arrowhead in the arrow shape. Default is 30.\n\t */\n\tARROW_SIZE: 30,\n\n\t/**\n\t * Variable: PAGE_FORMAT_A4_PORTRAIT\n\t * \n\t * Defines the rectangle for the A4 portrait page format. The dimensions\n\t * of this page format are 826x1169 pixels.\n\t */\n\tPAGE_FORMAT_A4_PORTRAIT: new mxRectangle(0, 0, 827, 1169),\n\n\t/**\n\t * Variable: PAGE_FORMAT_A4_PORTRAIT\n\t * \n\t * Defines the rectangle for the A4 portrait page format. The dimensions\n\t * of this page format are 826x1169 pixels.\n\t */\n\tPAGE_FORMAT_A4_LANDSCAPE: new mxRectangle(0, 0, 1169, 827),\n\n\t/**\n\t * Variable: PAGE_FORMAT_LETTER_PORTRAIT\n\t * \n\t * Defines the rectangle for the Letter portrait page format. The\n\t * dimensions of this page format are 850x1100 pixels.\n\t */\n\tPAGE_FORMAT_LETTER_PORTRAIT: new mxRectangle(0, 0, 850, 1100),\n\n\t/**\n\t * Variable: PAGE_FORMAT_LETTER_PORTRAIT\n\t * \n\t * Defines the rectangle for the Letter portrait page format. The dimensions\n\t * of this page format are 850x1100 pixels.\n\t */\n\tPAGE_FORMAT_LETTER_LANDSCAPE: new mxRectangle(0, 0, 1100, 850),\n\n\t/**\n\t * Variable: NONE\n\t * \n\t * Defines the value for none. Default is \"none\".\n\t */\n\tNONE: 'none',\n\n\t/**\n\t * Variable: STYLE_PERIMETER\n\t * \n\t * Defines the key for the perimeter style. This is a function that defines\n\t * the perimeter around a particular shape. Possible values are the\n\t * functions defined in <mxPerimeter>. Alternatively, the constants in this\n\t * class that start with \"PERIMETER_\" may be used to access\n\t * perimeter styles in <mxStyleRegistry>. Value is \"perimeter\".\n\t */\n\tSTYLE_PERIMETER: 'perimeter',\n\t\n\t/**\n\t * Variable: STYLE_SOURCE_PORT\n\t * \n\t * Defines the ID of the cell that should be used for computing the\n\t * perimeter point of the source for an edge. This allows for graphically\n\t * connecting to a cell while keeping the actual terminal of the edge.\n\t * Value is \"sourcePort\".\n\t */\n\tSTYLE_SOURCE_PORT: 'sourcePort',\n\t\n\t/**\n\t * Variable: STYLE_TARGET_PORT\n\t * \n\t * Defines the ID of the cell that should be used for computing the\n\t * perimeter point of the target for an edge. This allows for graphically\n\t * connecting to a cell while keeping the actual terminal of the edge.\n\t * Value is \"targetPort\".\n\t */\n\tSTYLE_TARGET_PORT: 'targetPort',\n\n\t/**\n\t * Variable: STYLE_PORT_CONSTRAINT\n\t * \n\t * Defines the direction(s) that edges are allowed to connect to cells in.\n\t * Possible values are \"DIRECTION_NORTH, DIRECTION_SOUTH, \n\t * DIRECTION_EAST\" and \"DIRECTION_WEST\". Value is\n\t * \"portConstraint\".\n\t */\n\tSTYLE_PORT_CONSTRAINT: 'portConstraint',\n\n\t/**\n\t * Variable: STYLE_PORT_CONSTRAINT_ROTATION\n\t * \n\t * Define whether port constraint directions are rotated with vertex\n\t * rotation. 0 (default) causes port constraints to remain absolute, \n\t * relative to the graph, 1 causes the constraints to rotate with\n\t * the vertex. Value is \"portConstraintRotation\".\n\t */\n\tSTYLE_PORT_CONSTRAINT_ROTATION: 'portConstraintRotation',\n\n\t/**\n\t * Variable: STYLE_SOURCE_PORT_CONSTRAINT\n\t * \n\t * Defines the direction(s) that edges are allowed to connect to sources in.\n\t * Possible values are \"DIRECTION_NORTH, DIRECTION_SOUTH, DIRECTION_EAST\"\n\t * and \"DIRECTION_WEST\". Value is \"sourcePortConstraint\".\n\t */\n\tSTYLE_SOURCE_PORT_CONSTRAINT: 'sourcePortConstraint',\n\n\t/**\n\t * Variable: STYLE_TARGET_PORT_CONSTRAINT\n\t * \n\t * Defines the direction(s) that edges are allowed to connect to targets in.\n\t * Possible values are \"DIRECTION_NORTH, DIRECTION_SOUTH, DIRECTION_EAST\"\n\t * and \"DIRECTION_WEST\". Value is \"targetPortConstraint\".\n\t */\n\tSTYLE_TARGET_PORT_CONSTRAINT: 'targetPortConstraint',\n\n\t/**\n\t * Variable: STYLE_OPACITY\n\t * \n\t * Defines the key for the opacity style. The type of the value is \n\t * numeric and the possible range is 0-100. Value is \"opacity\".\n\t */\n\tSTYLE_OPACITY: 'opacity',\n\n\t/**\n\t * Variable: STYLE_FILL_OPACITY\n\t * \n\t * Defines the key for the fill opacity style. The type of the value is \n\t * numeric and the possible range is 0-100. Value is \"fillOpacity\".\n\t */\n\tSTYLE_FILL_OPACITY: 'fillOpacity',\n\n\t/**\n\t * Variable: STYLE_STROKE_OPACITY\n\t * \n\t * Defines the key for the stroke opacity style. The type of the value is \n\t * numeric and the possible range is 0-100. Value is \"strokeOpacity\".\n\t */\n\tSTYLE_STROKE_OPACITY: 'strokeOpacity',\n\n\t/**\n\t * Variable: STYLE_TEXT_OPACITY\n\t * \n\t * Defines the key for the text opacity style. The type of the value is \n\t * numeric and the possible range is 0-100. Value is \"textOpacity\".\n\t */\n\tSTYLE_TEXT_OPACITY: 'textOpacity',\n\n\t/**\n\t * Variable: STYLE_TEXT_DIRECTION\n\t * \n\t * Defines the key for the text direction style. Possible values are\n\t * \"TEXT_DIRECTION_DEFAULT, TEXT_DIRECTION_AUTO, TEXT_DIRECTION_LTR\"\n\t * and \"TEXT_DIRECTION_RTL\". Value is \"textDirection\".\n\t * The default value for the style is defined in <DEFAULT_TEXT_DIRECTION>.\n\t * It is used is no value is defined for this key in a given style. This is\n\t * an experimental style that is currently ignored in the backends.\n\t */\n\tSTYLE_TEXT_DIRECTION: 'textDirection',\n\n\t/**\n\t * Variable: STYLE_OVERFLOW\n\t * \n\t * Defines the key for the overflow style. Possible values are 'visible',\n\t * 'hidden', 'fill' and 'width'. The default value is 'visible'. This value\n\t * specifies how overlapping vertex labels are handled. A value of\n\t * 'visible' will show the complete label. A value of 'hidden' will clip\n\t * the label so that it does not overlap the vertex bounds. A value of\n\t * 'fill' will use the vertex bounds and a value of 'width' will use the\n\t * vertex width for the label. See <mxGraph.isLabelClipped>. Note that\n\t * the vertical alignment is ignored for overflow fill and for horizontal\n\t * alignment, left should be used to avoid pixel offsets in Internet Explorer\n\t * 11 and earlier or if foreignObjects are disabled. Value is \"overflow\".\n\t */\n\tSTYLE_OVERFLOW: 'overflow',\n\n\t/**\n\t * Variable: STYLE_ORTHOGONAL\n\t * \n\t * Defines if the connection points on either end of the edge should be\n\t * computed so that the edge is vertical or horizontal if possible and\n\t * if the point is not at a fixed location. Default is false. This is\n\t * used in <mxGraph.isOrthogonal>, which also returns true if the edgeStyle\n\t * of the edge is an elbow or entity. Value is \"orthogonal\".\n\t */\n\tSTYLE_ORTHOGONAL: 'orthogonal',\n\n\t/**\n\t * Variable: STYLE_EXIT_X\n\t * \n\t * Defines the key for the horizontal relative coordinate connection point\n\t * of an edge with its source terminal. Value is \"exitX\".\n\t */\n\tSTYLE_EXIT_X: 'exitX',\n\n\t/**\n\t * Variable: STYLE_EXIT_Y\n\t * \n\t * Defines the key for the vertical relative coordinate connection point\n\t * of an edge with its source terminal. Value is \"exitY\".\n\t */\n\tSTYLE_EXIT_Y: 'exitY',\n\n\t\n\t/**\n\t* Variable: STYLE_EXIT_DX\n\t* \n\t* Defines the key for the horizontal offset of the connection point\n\t* of an edge with its source terminal. Value is \"exitDx\".\n\t*/\n\tSTYLE_EXIT_DX: 'exitDx',\n\n\t/**\n\t* Variable: STYLE_EXIT_DY\n\t* \n\t* Defines the key for the vertical offset of the connection point\n\t* of an edge with its source terminal. Value is \"exitDy\".\n\t*/\n\tSTYLE_EXIT_DY: 'exitDy',\n\t\n\t/**\n\t * Variable: STYLE_EXIT_PERIMETER\n\t * \n\t * Defines if the perimeter should be used to find the exact entry point\n\t * along the perimeter of the source. Possible values are 0 (false) and\n\t * 1 (true). Default is 1 (true). Value is \"exitPerimeter\".\n\t */\n\tSTYLE_EXIT_PERIMETER: 'exitPerimeter',\n\n\t/**\n\t * Variable: STYLE_ENTRY_X\n\t * \n\t * Defines the key for the horizontal relative coordinate connection point\n\t * of an edge with its target terminal. Value is \"entryX\".\n\t */\n\tSTYLE_ENTRY_X: 'entryX',\n\n\t/**\n\t * Variable: STYLE_ENTRY_Y\n\t * \n\t * Defines the key for the vertical relative coordinate connection point\n\t * of an edge with its target terminal. Value is \"entryY\".\n\t */\n\tSTYLE_ENTRY_Y: 'entryY',\n\n\t/**\n\t * Variable: STYLE_ENTRY_DX\n\t * \n\t* Defines the key for the horizontal offset of the connection point\n\t* of an edge with its target terminal. Value is \"entryDx\".\n\t*/\n\tSTYLE_ENTRY_DX: 'entryDx',\n\n\t/**\n\t * Variable: STYLE_ENTRY_DY\n\t * \n\t* Defines the key for the vertical offset of the connection point\n\t* of an edge with its target terminal. Value is \"entryDy\".\n\t*/\n\tSTYLE_ENTRY_DY: 'entryDy',\n\n\t/**\n\t * Variable: STYLE_ENTRY_PERIMETER\n\t * \n\t * Defines if the perimeter should be used to find the exact entry point\n\t * along the perimeter of the target. Possible values are 0 (false) and\n\t * 1 (true). Default is 1 (true). Value is \"entryPerimeter\".\n\t */\n\tSTYLE_ENTRY_PERIMETER: 'entryPerimeter',\n\n\t/**\n\t * Variable: STYLE_WHITE_SPACE\n\t * \n\t * Defines the key for the white-space style. Possible values are 'nowrap'\n\t * and 'wrap'. The default value is 'nowrap'. This value specifies how\n\t * white-space inside a HTML vertex label should be handled. A value of\n\t * 'nowrap' means the text will never wrap to the next line until a\n\t * linefeed is encountered. A value of 'wrap' means text will wrap when\n\t * necessary. This style is only used for HTML labels.\n\t * See <mxGraph.isWrapping>. Value is \"whiteSpace\".\n\t */\n\tSTYLE_WHITE_SPACE: 'whiteSpace',\n\n\t/**\n\t * Variable: STYLE_ROTATION\n\t * \n\t * Defines the key for the rotation style. The type of the value is \n\t * numeric and the possible range is 0-360. Value is \"rotation\".\n\t */\n\tSTYLE_ROTATION: 'rotation',\n\n\t/**\n\t * Variable: STYLE_FILLCOLOR\n\t * \n\t * Defines the key for the fill color. Possible values are all HTML color\n\t * names or HEX codes, as well as special keywords such as 'swimlane,\n\t * 'inherit' or 'indicated' to use the color code of a related cell or the\n\t * indicator shape. Value is \"fillColor\".\n\t */\n\tSTYLE_FILLCOLOR: 'fillColor',\n\n\t/**\n\t * Variable: STYLE_POINTER_EVENTS\n\t * \n\t * Specifies if pointer events should be fired on transparent backgrounds.\n\t * This style is currently only supported in <mxRectangleShape>. Default\n\t * is true. Value is \"pointerEvents\". This is typically set to\n\t * false in groups where the transparent part should allow any underlying\n\t * cells to be clickable.\n\t */\n\tSTYLE_POINTER_EVENTS: 'pointerEvents',\n\n\t/**\n\t * Variable: STYLE_SWIMLANE_FILLCOLOR\n\t * \n\t * Defines the key for the fill color of the swimlane background. Possible\n\t * values are all HTML color names or HEX codes. Default is no background.\n\t * Value is \"swimlaneFillColor\".\n\t */\n\tSTYLE_SWIMLANE_FILLCOLOR: 'swimlaneFillColor',\n\n\t/**\n\t * Variable: STYLE_MARGIN\n\t * \n\t * Defines the key for the margin between the ellipses in the double ellipse shape.\n\t * Possible values are all positive numbers. Value is \"margin\".\n\t */\n\tSTYLE_MARGIN: 'margin',\n\n\t/**\n\t * Variable: STYLE_GRADIENTCOLOR\n\t * \n\t * Defines the key for the gradient color. Possible values are all HTML color\n\t * names or HEX codes, as well as special keywords such as 'swimlane,\n\t * 'inherit' or 'indicated' to use the color code of a related cell or the\n\t * indicator shape. This is ignored if no fill color is defined. Value is\n\t * \"gradientColor\".\n\t */\n\tSTYLE_GRADIENTCOLOR: 'gradientColor',\n\n\t/**\n\t * Variable: STYLE_GRADIENT_DIRECTION\n\t * \n\t * Defines the key for the gradient direction. Possible values are\n\t * <DIRECTION_EAST>, <DIRECTION_WEST>, <DIRECTION_NORTH> and\n\t * <DIRECTION_SOUTH>. Default is <DIRECTION_SOUTH>. Generally, and by\n\t * default in mxGraph, gradient painting is done from the value of\n\t * <STYLE_FILLCOLOR> to the value of <STYLE_GRADIENTCOLOR>. Taking the\n\t * example of <DIRECTION_NORTH>, this means <STYLE_FILLCOLOR> color at the \n\t * bottom of paint pattern and <STYLE_GRADIENTCOLOR> at top, with a\n\t * gradient in-between. Value is \"gradientDirection\".\n\t */\n\tSTYLE_GRADIENT_DIRECTION: 'gradientDirection',\n\n\t/**\n\t * Variable: STYLE_STROKECOLOR\n\t * \n\t * Defines the key for the strokeColor style. Possible values are all HTML\n\t * color names or HEX codes, as well as special keywords such as 'swimlane,\n\t * 'inherit', 'indicated' to use the color code of a related cell or the\n\t * indicator shape or 'none' for no color. Value is \"strokeColor\".\n\t */\n\tSTYLE_STROKECOLOR: 'strokeColor',\n\n\t/**\n\t * Variable: STYLE_SEPARATORCOLOR\n\t * \n\t * Defines the key for the separatorColor style. Possible values are all\n\t * HTML color names or HEX codes. This style is only used for\n\t * <SHAPE_SWIMLANE> shapes. Value is \"separatorColor\".\n\t */\n\tSTYLE_SEPARATORCOLOR: 'separatorColor',\n\n\t/**\n\t * Variable: STYLE_STROKEWIDTH\n\t * \n\t * Defines the key for the strokeWidth style. The type of the value is \n\t * numeric and the possible range is any non-negative value larger or equal\n\t * to 1. The value defines the stroke width in pixels. Note: To hide a\n\t * stroke use strokeColor none. Value is \"strokeWidth\".\n\t */\n\tSTYLE_STROKEWIDTH: 'strokeWidth',\n\n\t/**\n\t * Variable: STYLE_ALIGN\n\t * \n\t * Defines the key for the align style. Possible values are <ALIGN_LEFT>,\n\t * <ALIGN_CENTER> and <ALIGN_RIGHT>. This value defines how the lines of\n\t * the label are horizontally aligned. <ALIGN_LEFT> mean label text lines\n\t * are aligned to left of the label bounds, <ALIGN_RIGHT> to the right of\n\t * the label bounds and <ALIGN_CENTER> means the center of the text lines\n\t * are aligned in the center of the label bounds. Note this value doesn't\n\t * affect the positioning of the overall label bounds relative to the\n\t * vertex, to move the label bounds horizontally, use\n\t * <STYLE_LABEL_POSITION>. Value is \"align\".\n\t */\n\tSTYLE_ALIGN: 'align',\n\n\t/**\n\t * Variable: STYLE_VERTICAL_ALIGN\n\t * \n\t * Defines the key for the verticalAlign style. Possible values are\n\t * <ALIGN_TOP>, <ALIGN_MIDDLE> and <ALIGN_BOTTOM>. This value defines how\n\t * the lines of the label are vertically aligned. <ALIGN_TOP> means the\n\t * topmost label text line is aligned against the top of the label bounds,\n\t * <ALIGN_BOTTOM> means the bottom-most label text line is aligned against\n\t * the bottom of the label bounds and <ALIGN_MIDDLE> means there is equal\n\t * spacing between the topmost text label line and the top of the label\n\t * bounds and the bottom-most text label line and the bottom of the label\n\t * bounds. Note this value doesn't affect the positioning of the overall\n\t * label bounds relative to the vertex, to move the label bounds\n\t * vertically, use <STYLE_VERTICAL_LABEL_POSITION>. Value is \"verticalAlign\".\n\t */\n\tSTYLE_VERTICAL_ALIGN: 'verticalAlign',\n\n\t/**\n\t * Variable: STYLE_LABEL_WIDTH\n\t * \n\t * Defines the key for the width of the label if the label position is not\n\t * center. Value is \"labelWidth\".\n\t */\n\tSTYLE_LABEL_WIDTH: 'labelWidth',\n\n\t/**\n\t * Variable: STYLE_LABEL_POSITION\n\t * \n\t * Defines the key for the horizontal label position of vertices. Possible\n\t * values are <ALIGN_LEFT>, <ALIGN_CENTER> and <ALIGN_RIGHT>. Default is\n\t * <ALIGN_CENTER>. The label align defines the position of the label\n\t * relative to the cell. <ALIGN_LEFT> means the entire label bounds is\n\t * placed completely just to the left of the vertex, <ALIGN_RIGHT> means\n\t * adjust to the right and <ALIGN_CENTER> means the label bounds are\n\t * vertically aligned with the bounds of the vertex. Note this value\n\t * doesn't affect the positioning of label within the label bounds, to move\n\t * the label horizontally within the label bounds, use <STYLE_ALIGN>.\n\t * Value is \"labelPosition\".\n\t */\n\tSTYLE_LABEL_POSITION: 'labelPosition',\n\n\t/**\n\t * Variable: STYLE_VERTICAL_LABEL_POSITION\n\t * \n\t * Defines the key for the vertical label position of vertices. Possible\n\t * values are <ALIGN_TOP>, <ALIGN_BOTTOM> and <ALIGN_MIDDLE>. Default is\n\t * <ALIGN_MIDDLE>. The label align defines the position of the label\n\t * relative to the cell. <ALIGN_TOP> means the entire label bounds is\n\t * placed completely just on the top of the vertex, <ALIGN_BOTTOM> means\n\t * adjust on the bottom and <ALIGN_MIDDLE> means the label bounds are\n\t * horizontally aligned with the bounds of the vertex. Note this value\n\t * doesn't affect the positioning of label within the label bounds, to move\n\t * the label vertically within the label bounds, use\n\t * <STYLE_VERTICAL_ALIGN>. Value is \"verticalLabelPosition\".\n\t */\n\tSTYLE_VERTICAL_LABEL_POSITION: 'verticalLabelPosition',\n\t\n\t/**\n\t * Variable: STYLE_IMAGE_ASPECT\n\t * \n\t * Defines the key for the image aspect style. Possible values are 0 (do\n\t * not preserve aspect) or 1 (keep aspect). This is only used in\n\t * <mxImageShape>. Default is 1. Value is \"imageAspect\".\n\t */\n\tSTYLE_IMAGE_ASPECT: 'imageAspect',\n\n\t/**\n\t * Variable: STYLE_IMAGE_ALIGN\n\t * \n\t * Defines the key for the align style. Possible values are <ALIGN_LEFT>,\n\t * <ALIGN_CENTER> and <ALIGN_RIGHT>. The value defines how any image in the\n\t * vertex label is aligned horizontally within the label bounds of a\n\t * <SHAPE_LABEL> shape. Value is \"imageAlign\".\n\t */\n\tSTYLE_IMAGE_ALIGN: 'imageAlign',\n\n\t/**\n\t * Variable: STYLE_IMAGE_VERTICAL_ALIGN\n\t * \n\t * Defines the key for the verticalAlign style. Possible values are\n\t * <ALIGN_TOP>, <ALIGN_MIDDLE> and <ALIGN_BOTTOM>. The value defines how\n\t * any image in the vertex label is aligned vertically within the label\n\t * bounds of a <SHAPE_LABEL> shape. Value is \"imageVerticalAlign\".\n\t */\n\tSTYLE_IMAGE_VERTICAL_ALIGN: 'imageVerticalAlign',\n\n\t/**\n\t * Variable: STYLE_GLASS\n\t * \n\t * Defines the key for the glass style. Possible values are 0 (disabled) and\n\t * 1(enabled). The default value is 0. This is used in <mxLabel>. Value is\n\t * \"glass\".\n\t */\n\tSTYLE_GLASS: 'glass',\n\n\t/**\n\t * Variable: STYLE_IMAGE\n\t * \n\t * Defines the key for the image style. Possible values are any image URL,\n\t * the type of the value is String. This is the path to the image that is\n\t * to be displayed within the label of a vertex. Data URLs should use the\n\t * following format: data:image/png,xyz where xyz is the base64 encoded\n\t * data (without the \"base64\"-prefix). Note that Data URLs are only\n\t * supported in modern browsers. Value is \"image\".\n\t */\n\tSTYLE_IMAGE: 'image',\n\n\t/**\n\t * Variable: STYLE_IMAGE_WIDTH\n\t * \n\t * Defines the key for the imageWidth style. The type of this value is\n\t * int, the value is the image width in pixels and must be greater than 0.\n\t * Value is \"imageWidth\".\n\t */\n\tSTYLE_IMAGE_WIDTH: 'imageWidth',\n\n\t/**\n\t * Variable: STYLE_IMAGE_HEIGHT\n\t * \n\t * Defines the key for the imageHeight style. The type of this value is\n\t * int, the value is the image height in pixels and must be greater than 0.\n\t * Value is \"imageHeight\".\n\t */\n\tSTYLE_IMAGE_HEIGHT: 'imageHeight',\n\n\t/**\n\t * Variable: STYLE_IMAGE_BACKGROUND\n\t * \n\t * Defines the key for the image background color. This style is only used\n\t * in <mxImageShape>. Possible values are all HTML color names or HEX\n\t * codes. Value is \"imageBackground\".\n\t */\n\tSTYLE_IMAGE_BACKGROUND: 'imageBackground',\n\n\t/**\n\t * Variable: STYLE_IMAGE_BORDER\n\t * \n\t * Defines the key for the image border color. This style is only used in\n\t * <mxImageShape>. Possible values are all HTML color names or HEX codes.\n\t * Value is \"imageBorder\".\n\t */\n\tSTYLE_IMAGE_BORDER: 'imageBorder',\n\n\t/**\n\t * Variable: STYLE_FLIPH\n\t * \n\t * Defines the key for the horizontal image flip. This style is only used\n\t * in <mxImageShape>. Possible values are 0 and 1. Default is 0. Value is\n\t * \"flipH\".\n\t */\n\tSTYLE_FLIPH: 'flipH',\n\n\t/**\n\t * Variable: STYLE_FLIPV\n\t * \n\t * Defines the key for the vertical flip. Possible values are 0 and 1.\n\t * Default is 0. Value is \"flipV\".\n\t */\n\tSTYLE_FLIPV: 'flipV',\n\n\t/**\n\t * Variable: STYLE_NOLABEL\n\t * \n\t * Defines the key for the noLabel style. If this is true then no label is\n\t * visible for a given cell. Possible values are true or false (1 or 0).\n\t * Default is false. Value is \"noLabel\".\n\t */\n\tSTYLE_NOLABEL: 'noLabel',\n\n\t/**\n\t * Variable: STYLE_NOEDGESTYLE\n\t * \n\t * Defines the key for the noEdgeStyle style. If this is true then no edge\n\t * style is applied for a given edge. Possible values are true or false\n\t * (1 or 0). Default is false. Value is \"noEdgeStyle\".\n\t */\n\tSTYLE_NOEDGESTYLE: 'noEdgeStyle',\n\n\t/**\n\t * Variable: STYLE_LABEL_BACKGROUNDCOLOR\n\t * \n\t * Defines the key for the label background color. Possible values are all\n\t * HTML color names or HEX codes. Value is \"labelBackgroundColor\".\n\t */\n\tSTYLE_LABEL_BACKGROUNDCOLOR: 'labelBackgroundColor',\n\n\t/**\n\t * Variable: STYLE_LABEL_BORDERCOLOR\n\t * \n\t * Defines the key for the label border color. Possible values are all\n\t * HTML color names or HEX codes. Value is \"labelBorderColor\".\n\t */\n\tSTYLE_LABEL_BORDERCOLOR: 'labelBorderColor',\n\n\t/**\n\t * Variable: STYLE_LABEL_PADDING\n\t * \n\t * Defines the key for the label padding, ie. the space between the label\n\t * border and the label. Value is \"labelPadding\".\n\t */\n\tSTYLE_LABEL_PADDING: 'labelPadding',\n\n\t/**\n\t * Variable: STYLE_INDICATOR_SHAPE\n\t * \n\t * Defines the key for the indicator shape used within an <mxLabel>.\n\t * Possible values are all SHAPE_* constants or the names of any new\n\t * shapes. The indicatorShape has precedence over the indicatorImage.\n\t * Value is \"indicatorShape\".\n\t */\n\tSTYLE_INDICATOR_SHAPE: 'indicatorShape',\n\n\t/**\n\t * Variable: STYLE_INDICATOR_IMAGE\n\t * \n\t * Defines the key for the indicator image used within an <mxLabel>.\n\t * Possible values are all image URLs. The indicatorShape has\n\t * precedence over the indicatorImage. Value is \"indicatorImage\".\n\t */\n\tSTYLE_INDICATOR_IMAGE: 'indicatorImage',\n\n\t/**\n\t * Variable: STYLE_INDICATOR_COLOR\n\t * \n\t * Defines the key for the indicatorColor style. Possible values are all\n\t * HTML color names or HEX codes, as well as the special 'swimlane' keyword\n\t * to refer to the color of the parent swimlane if one exists. Value is\n\t * \"indicatorColor\".\n\t */\n\tSTYLE_INDICATOR_COLOR: 'indicatorColor',\n\n\t/**\n\t * Variable: STYLE_INDICATOR_STROKECOLOR\n\t * \n\t * Defines the key for the indicator stroke color in <mxLabel>.\n\t * Possible values are all color codes. Value is \"indicatorStrokeColor\".\n\t */\n\tSTYLE_INDICATOR_STROKECOLOR: 'indicatorStrokeColor',\n\n\t/**\n\t * Variable: STYLE_INDICATOR_GRADIENTCOLOR\n\t * \n\t * Defines the key for the indicatorGradientColor style. Possible values\n\t * are all HTML color names or HEX codes. This style is only supported in\n\t * <SHAPE_LABEL> shapes. Value is \"indicatorGradientColor\".\n\t */\n\tSTYLE_INDICATOR_GRADIENTCOLOR: 'indicatorGradientColor',\n\n\t/**\n\t * Variable: STYLE_INDICATOR_SPACING\n\t * \n\t * The defines the key for the spacing between the label and the\n\t * indicator in <mxLabel>. Possible values are in pixels. Value is\n\t * \"indicatorSpacing\".\n\t */\n\tSTYLE_INDICATOR_SPACING: 'indicatorSpacing',\n\n\t/**\n\t * Variable: STYLE_INDICATOR_WIDTH\n\t * \n\t * Defines the key for the indicator width. Possible values start at 0 (in\n\t * pixels). Value is \"indicatorWidth\".\n\t */\n\tSTYLE_INDICATOR_WIDTH: 'indicatorWidth',\n\n\t/**\n\t * Variable: STYLE_INDICATOR_HEIGHT\n\t * \n\t * Defines the key for the indicator height. Possible values start at 0 (in\n\t * pixels). Value is \"indicatorHeight\".\n\t */\n\tSTYLE_INDICATOR_HEIGHT: 'indicatorHeight',\n\n\t/**\n\t * Variable: STYLE_INDICATOR_DIRECTION\n\t * \n\t * Defines the key for the indicatorDirection style. The direction style is\n\t * used to specify the direction of certain shapes (eg. <mxTriangle>).\n\t * Possible values are <DIRECTION_EAST> (default), <DIRECTION_WEST>,\n\t * <DIRECTION_NORTH> and <DIRECTION_SOUTH>. Value is \"indicatorDirection\".\n\t */\n\tSTYLE_INDICATOR_DIRECTION: 'indicatorDirection',\n\n\t/**\n\t * Variable: STYLE_SHADOW\n\t * \n\t * Defines the key for the shadow style. The type of the value is Boolean.\n\t * Value is \"shadow\".\n\t */\n\tSTYLE_SHADOW: 'shadow',\n\t\n\t/**\n\t * Variable: STYLE_SEGMENT\n\t * \n\t * Defines the key for the segment style. The type of this value is float\n\t * and the value represents the size of the horizontal segment of the\n\t * entity relation style. Default is ENTITY_SEGMENT. Value is \"segment\".\n\t */\n\tSTYLE_SEGMENT: 'segment',\n\t\n\t/**\n\t * Variable: STYLE_ENDARROW\n\t *\n\t * Defines the key for the end arrow marker. Possible values are all\n\t * constants with an ARROW-prefix. This is only used in <mxConnector>.\n\t * Value is \"endArrow\".\n\t *\n\t * Example:\n\t * (code)\n\t * style[mxConstants.STYLE_ENDARROW] = mxConstants.ARROW_CLASSIC;\n\t * (end)\n\t */\n\tSTYLE_ENDARROW: 'endArrow',\n\n\t/**\n\t * Variable: STYLE_STARTARROW\n\t * \n\t * Defines the key for the start arrow marker. Possible values are all\n\t * constants with an ARROW-prefix. This is only used in <mxConnector>.\n\t * See <STYLE_ENDARROW>. Value is \"startArrow\".\n\t */\n\tSTYLE_STARTARROW: 'startArrow',\n\n\t/**\n\t * Variable: STYLE_ENDSIZE\n\t * \n\t * Defines the key for the endSize style. The type of this value is numeric\n\t * and the value represents the size of the end marker in pixels. Value is\n\t * \"endSize\".\n\t */\n\tSTYLE_ENDSIZE: 'endSize',\n\n\t/**\n\t * Variable: STYLE_STARTSIZE\n\t * \n\t * Defines the key for the startSize style. The type of this value is\n\t * numeric and the value represents the size of the start marker or the\n\t * size of the swimlane title region depending on the shape it is used for.\n\t * Value is \"startSize\".\n\t */\n\tSTYLE_STARTSIZE: 'startSize',\n\n\t/**\n\t * Variable: STYLE_SWIMLANE_LINE\n\t * \n\t * Defines the key for the swimlaneLine style. This style specifies whether\n\t * the line between the title regio of a swimlane should be visible. Use 0\n\t * for hidden or 1 (default) for visible. Value is \"swimlaneLine\".\n\t */\n\tSTYLE_SWIMLANE_LINE: 'swimlaneLine',\n\n\t/**\n\t * Variable: STYLE_ENDFILL\n\t * \n\t * Defines the key for the endFill style. Use 0 for no fill or 1 (default)\n\t * for fill. (This style is only exported via <mxImageExport>.) Value is\n\t * \"endFill\".\n\t */\n\tSTYLE_ENDFILL: 'endFill',\n\n\t/**\n\t * Variable: STYLE_STARTFILL\n\t * \n\t * Defines the key for the startFill style. Use 0 for no fill or 1 (default)\n\t * for fill. (This style is only exported via <mxImageExport>.) Value is\n\t * \"startFill\".\n\t */\n\tSTYLE_STARTFILL: 'startFill',\n\n\t/**\n\t * Variable: STYLE_DASHED\n\t * \n\t * Defines the key for the dashed style. Use 0 (default) for non-dashed or 1\n\t * for dashed. Value is \"dashed\".\n\t */\n\tSTYLE_DASHED: 'dashed',\n\n\t/**\n\t * Variable: STYLE_DASH_PATTERN\n\t * \n\t * Defines the key for the dashed pattern style in SVG and image exports.\n\t * The type of this value is a space separated list of numbers that specify\n\t * a custom-defined dash pattern. Dash styles are defined in terms of the\n\t * length of the dash (the drawn part of the stroke) and the length of the\n\t * space between the dashes. The lengths are relative to the line width: a\n\t * length of \"1\" is equal to the line width. VML ignores this style and\n\t * uses dashStyle instead as defined in the VML specification. This style\n\t * is only used in the <mxConnector> shape. Value is \"dashPattern\".\n\t */\n\tSTYLE_DASH_PATTERN: 'dashPattern',\n\n\t/**\n\t * Variable: STYLE_FIX_DASH\n\t * \n\t * Defines the key for the fixDash style. Use 0 (default) for dash patterns\n\t * that depend on the linewidth and 1 for dash patterns that ignore the\n\t * line width. Value is \"fixDash\".\n\t */\n\tSTYLE_FIX_DASH: 'fixDash',\n\n\t/**\n\t * Variable: STYLE_ROUNDED\n\t * \n\t * Defines the key for the rounded style. The type of this value is\n\t * Boolean. For edges this determines whether or not joins between edges\n\t * segments are smoothed to a rounded finish. For vertices that have the\n\t * rectangle shape, this determines whether or not the rectangle is\n\t * rounded. Use 0 (default) for non-rounded or 1 for rounded. Value is\n\t * \"rounded\".\n\t */\n\tSTYLE_ROUNDED: 'rounded',\n\n\t/**\n\t * Variable: STYLE_CURVED\n\t * \n\t * Defines the key for the curved style. The type of this value is\n\t * Boolean. It is only applicable for connector shapes. Use 0 (default)\n\t * for non-curved or 1 for curved. Value is \"curved\".\n\t */\n\tSTYLE_CURVED: 'curved',\n\n\t/**\n\t * Variable: STYLE_ARCSIZE\n\t * \n\t * Defines the rounding factor for a rounded rectangle in percent (without\n\t * the percent sign). Possible values are between 0 and 100. If this value\n\t * is not specified then RECTANGLE_ROUNDING_FACTOR * 100 is used. For\n\t * edges, this defines the absolute size of rounded corners in pixels. If\n\t * this values is not specified then LINE_ARCSIZE is used.\n\t * (This style is only exported via <mxImageExport>.) Value is \"arcSize\".\n\t */\n\tSTYLE_ARCSIZE: 'arcSize',\n\n\t/**\n\t * Variable: STYLE_ABSOLUTE_ARCSIZE\n\t * \n\t * Defines the key for the absolute arc size style. This specifies if\n\t * arcSize for rectangles is abolute or relative. Possible values are 1\n\t * and 0 (default). Value is \"absoluteArcSize\".\n\t */\n\tSTYLE_ABSOLUTE_ARCSIZE: 'absoluteArcSize',\n\n\t/**\n\t * Variable: STYLE_SOURCE_PERIMETER_SPACING\n\t * \n\t * Defines the key for the source perimeter spacing. The type of this value\n\t * is numeric. This is the distance between the source connection point of\n\t * an edge and the perimeter of the source vertex in pixels. This style\n\t * only applies to edges. Value is \"sourcePerimeterSpacing\".\n\t */\n\tSTYLE_SOURCE_PERIMETER_SPACING: 'sourcePerimeterSpacing',\n\n\t/**\n\t * Variable: STYLE_TARGET_PERIMETER_SPACING\n\t * \n\t * Defines the key for the target perimeter spacing. The type of this value\n\t * is numeric. This is the distance between the target connection point of\n\t * an edge and the perimeter of the target vertex in pixels. This style\n\t * only applies to edges. Value is \"targetPerimeterSpacing\".\n\t */\n\tSTYLE_TARGET_PERIMETER_SPACING: 'targetPerimeterSpacing',\n\n\t/**\n\t * Variable: STYLE_PERIMETER_SPACING\n\t * \n\t * Defines the key for the perimeter spacing. This is the distance between\n\t * the connection point and the perimeter in pixels. When used in a vertex\n\t * style, this applies to all incoming edges to floating ports (edges that\n\t * terminate on the perimeter of the vertex). When used in an edge style,\n\t * this spacing applies to the source and target separately, if they\n\t * terminate in floating ports (on the perimeter of the vertex). Value is\n\t * \"perimeterSpacing\".\n\t */\n\tSTYLE_PERIMETER_SPACING: 'perimeterSpacing',\n\n\t/**\n\t * Variable: STYLE_SPACING\n\t * \n\t * Defines the key for the spacing. The value represents the spacing, in\n\t * pixels, added to each side of a label in a vertex (style applies to\n\t * vertices only). Value is \"spacing\".\n\t */\n\tSTYLE_SPACING: 'spacing',\n\n\t/**\n\t * Variable: STYLE_SPACING_TOP\n\t * \n\t * Defines the key for the spacingTop style. The value represents the\n\t * spacing, in pixels, added to the top side of a label in a vertex (style\n\t * applies to vertices only). Value is \"spacingTop\".\n\t */\n\tSTYLE_SPACING_TOP: 'spacingTop',\n\n\t/**\n\t * Variable: STYLE_SPACING_LEFT\n\t * \n\t * Defines the key for the spacingLeft style. The value represents the\n\t * spacing, in pixels, added to the left side of a label in a vertex (style\n\t * applies to vertices only). Value is \"spacingLeft\".\n\t */\n\tSTYLE_SPACING_LEFT: 'spacingLeft',\n\n\t/**\n\t * Variable: STYLE_SPACING_BOTTOM\n\t * \n\t * Defines the key for the spacingBottom style The value represents the\n\t * spacing, in pixels, added to the bottom side of a label in a vertex\n\t * (style applies to vertices only). Value is \"spacingBottom\".\n\t */\n\tSTYLE_SPACING_BOTTOM: 'spacingBottom',\n\n\t/**\n\t * Variable: STYLE_SPACING_RIGHT\n\t * \n\t * Defines the key for the spacingRight style The value represents the\n\t * spacing, in pixels, added to the right side of a label in a vertex (style\n\t * applies to vertices only). Value is \"spacingRight\".\n\t */\n\tSTYLE_SPACING_RIGHT: 'spacingRight',\n\n\t/**\n\t * Variable: STYLE_HORIZONTAL\n\t * \n\t * Defines the key for the horizontal style. Possible values are\n\t * true or false. This value only applies to vertices. If the <STYLE_SHAPE>\n\t * is \"SHAPE_SWIMLANE\" a value of false indicates that the\n\t * swimlane should be drawn vertically, true indicates to draw it\n\t * horizontally. If the shape style does not indicate that this vertex is a\n\t * swimlane, this value affects only whether the label is drawn\n\t * horizontally or vertically. Value is \"horizontal\".\n\t */\n\tSTYLE_HORIZONTAL: 'horizontal',\n\n\t/**\n\t * Variable: STYLE_DIRECTION\n\t * \n\t * Defines the key for the direction style. The direction style is used\n\t * to specify the direction of certain shapes (eg. <mxTriangle>).\n\t * Possible values are <DIRECTION_EAST> (default), <DIRECTION_WEST>,\n\t * <DIRECTION_NORTH> and <DIRECTION_SOUTH>. Value is \"direction\".\n\t */\n\tSTYLE_DIRECTION: 'direction',\n\n\t/**\n\t * Variable: STYLE_ANCHOR_POINT_DIRECTION\n\t * \n\t * Defines the key for the anchorPointDirection style. The defines if the\n\t * direction style should be taken into account when computing the fixed\n\t * point location for connected edges. Default is 1 (yes). Set this to 0\n\t * to ignore the direction style for fixed connection points. Value is\n\t * \"anchorPointDirection\".\n\t */\n\tSTYLE_ANCHOR_POINT_DIRECTION: 'anchorPointDirection',\n\n\t/**\n\t * Variable: STYLE_ELBOW\n\t * \n\t * Defines the key for the elbow style. Possible values are\n\t * <ELBOW_HORIZONTAL> and <ELBOW_VERTICAL>. Default is <ELBOW_HORIZONTAL>.\n\t * This defines how the three segment orthogonal edge style leaves its\n\t * terminal vertices. The vertical style leaves the terminal vertices at\n\t * the top and bottom sides. Value is \"elbow\".\n\t */\n\tSTYLE_ELBOW: 'elbow',\n\n\t/**\n\t * Variable: STYLE_FONTCOLOR\n\t * \n\t * Defines the key for the fontColor style. Possible values are all HTML\n\t * color names or HEX codes. Value is \"fontColor\".\n\t */\n\tSTYLE_FONTCOLOR: 'fontColor',\n\n\t/**\n\t * Variable: STYLE_FONTFAMILY\n\t * \n\t * Defines the key for the fontFamily style. Possible values are names such\n\t * as Arial; Dialog; Verdana; Times New Roman. The value is of type String.\n\t * Value is fontFamily.\n\t */\n\tSTYLE_FONTFAMILY: 'fontFamily',\n\n\t/**\n\t * Variable: STYLE_FONTSIZE\n\t * \n\t * Defines the key for the fontSize style (in px). The type of the value\n\t * is int. Value is \"fontSize\".\n\t */\n\tSTYLE_FONTSIZE: 'fontSize',\n\n\t/**\n\t * Variable: STYLE_FONTSTYLE\n\t * \n\t * Defines the key for the fontStyle style. Values may be any logical AND\n\t * (sum) of <FONT_BOLD>, <FONT_ITALIC> and <FONT_UNDERLINE>.\n\t * The type of the value is int. Value is \"fontStyle\".\n\t */\n\tSTYLE_FONTSTYLE: 'fontStyle',\n\t\n\t/**\n\t * Variable: STYLE_ASPECT\n\t * \n\t * Defines the key for the aspect style. Possible values are empty or fixed.\n\t * If fixed is used then the aspect ratio of the cell will be maintained\n\t * when resizing. Default is empty. Value is \"aspect\".\n\t */\n\tSTYLE_ASPECT: 'aspect',\n\n\t/**\n\t * Variable: STYLE_AUTOSIZE\n\t * \n\t * Defines the key for the autosize style. This specifies if a cell should be\n\t * resized automatically if the value has changed. Possible values are 0 or 1.\n\t * Default is 0. See <mxGraph.isAutoSizeCell>. This is normally combined with\n\t * <STYLE_RESIZABLE> to disable manual sizing. Value is \"autosize\".\n\t */\n\tSTYLE_AUTOSIZE: 'autosize',\n\n\t/**\n\t * Variable: STYLE_FOLDABLE\n\t * \n\t * Defines the key for the foldable style. This specifies if a cell is foldable\n\t * using a folding icon. Possible values are 0 or 1. Default is 1. See\n\t * <mxGraph.isCellFoldable>. Value is \"foldable\".\n\t */\n\tSTYLE_FOLDABLE: 'foldable',\n\n\t/**\n\t * Variable: STYLE_EDITABLE\n\t * \n\t * Defines the key for the editable style. This specifies if the value of\n\t * a cell can be edited using the in-place editor. Possible values are 0 or\n\t * 1. Default is 1. See <mxGraph.isCellEditable>. Value is \"editable\".\n\t */\n\tSTYLE_EDITABLE: 'editable',\n\n\t/**\n\t * Variable: STYLE_BACKGROUND_OUTLINE\n\t * \n\t * Defines the key for the backgroundOutline style. This specifies if a\n\t * only the background of a cell should be painted when it is highlighted.\n\t * Possible values are 0 or 1. Default is 0. Value is \"backgroundOutline\".\n\t */\n\tSTYLE_BACKGROUND_OUTLINE: 'backgroundOutline',\n\n\t/**\n\t * Variable: STYLE_BENDABLE\n\t * \n\t * Defines the key for the bendable style. This specifies if the control\n\t * points of an edge can be moved. Possible values are 0 or 1. Default is\n\t * 1. See <mxGraph.isCellBendable>. Value is \"bendable\".\n\t */\n\tSTYLE_BENDABLE: 'bendable',\n\n\t/**\n\t * Variable: STYLE_MOVABLE\n\t * \n\t * Defines the key for the movable style. This specifies if a cell can\n\t * be moved. Possible values are 0 or 1. Default is 1. See\n\t * <mxGraph.isCellMovable>. Value is \"movable\".\n\t */\n\tSTYLE_MOVABLE: 'movable',\n\n\t/**\n\t * Variable: STYLE_RESIZABLE\n\t * \n\t * Defines the key for the resizable style. This specifies if a cell can\n\t * be resized. Possible values are 0 or 1. Default is 1. See\n\t * <mxGraph.isCellResizable>. Value is \"resizable\".\n\t */\n\tSTYLE_RESIZABLE: 'resizable',\n\n\t/**\n\t * Variable: STYLE_RESIZE_WIDTH\n\t * \n\t * Defines the key for the resizeWidth style. This specifies if a cell's\n\t * width is resized if the parent is resized. If this is 1 then the width\n\t * will be resized even if the cell's geometry is relative. If this is 0\n\t * then the cell's width will not be resized. Default is not defined. Value\n\t * is \"resizeWidth\".\n\t */\n\tSTYLE_RESIZE_WIDTH: 'resizeWidth',\n\n\t/**\n\t * Variable: STYLE_RESIZE_WIDTH\n\t * \n\t * Defines the key for the resizeHeight style. This specifies if a cell's\n\t * height if resize if the parent is resized. If this is 1 then the height\n\t * will be resized even if the cell's geometry is relative. If this is 0\n\t * then the cell's height will not be resized. Default is not defined. Value\n\t * is \"resizeHeight\".\n\t */\n\tSTYLE_RESIZE_HEIGHT: 'resizeHeight',\n\n\t/**\n\t * Variable: STYLE_ROTATABLE\n\t * \n\t * Defines the key for the rotatable style. This specifies if a cell can\n\t * be rotated. Possible values are 0 or 1. Default is 1. See\n\t * <mxGraph.isCellRotatable>. Value is \"rotatable\".\n\t */\n\tSTYLE_ROTATABLE: 'rotatable',\n\n\t/**\n\t * Variable: STYLE_CLONEABLE\n\t * \n\t * Defines the key for the cloneable style. This specifies if a cell can\n\t * be cloned. Possible values are 0 or 1. Default is 1. See\n\t * <mxGraph.isCellCloneable>. Value is \"cloneable\".\n\t */\n\tSTYLE_CLONEABLE: 'cloneable',\n\n\t/**\n\t * Variable: STYLE_DELETABLE\n\t * \n\t * Defines the key for the deletable style. This specifies if a cell can be\n\t * deleted. Possible values are 0 or 1. Default is 1. See\n\t * <mxGraph.isCellDeletable>. Value is \"deletable\".\n\t */\n\tSTYLE_DELETABLE: 'deletable',\n\n\t/**\n\t * Variable: STYLE_SHAPE\n\t * \n\t * Defines the key for the shape. Possible values are all constants with\n\t * a SHAPE-prefix or any newly defined shape names. Value is \"shape\".\n\t */\n\tSTYLE_SHAPE: 'shape',\n\n\t/**\n\t * Variable: STYLE_EDGE\n\t * \n\t * Defines the key for the edge style. Possible values are the functions\n\t * defined in <mxEdgeStyle>. Value is \"edgeStyle\".\n\t */\n\tSTYLE_EDGE: 'edgeStyle',\n\n\t/**\n\t * Variable: STYLE_JETTY_SIZE\n\t * \n\t * Defines the key for the jetty size in <mxEdgeStyle.OrthConnector>.\n\t * Default is 10. Possible values are all numeric values or \"auto\".\n\t * Jetty size is the minimum length of the orthogonal segment before\n\t * it attaches to a shape.\n\t * Value is \"jettySize\".\n\t */\n\tSTYLE_JETTY_SIZE: 'jettySize',\n\n\t/**\n\t * Variable: STYLE_SOURCE_JETTY_SIZE\n\t * \n\t * Defines the key for the jetty size in <mxEdgeStyle.OrthConnector>.\n\t * Default is 10. Possible values are numeric values or \"auto\". This has\n\t * precedence over <STYLE_JETTY_SIZE>. Value is \"sourceJettySize\".\n\t */\n\tSTYLE_SOURCE_JETTY_SIZE: 'sourceJettySize',\n\n\t/**\n\t * Variable: targetJettySize\n\t * \n\t * Defines the key for the jetty size in <mxEdgeStyle.OrthConnector>.\n\t * Default is 10. Possible values are numeric values or \"auto\". This has\n\t * precedence over <STYLE_JETTY_SIZE>. Value is \"targetJettySize\".\n\t */\n\tSTYLE_TARGET_JETTY_SIZE: 'targetJettySize',\n\n\t/**\n\t * Variable: STYLE_LOOP\n\t * \n\t * Defines the key for the loop style. Possible values are the functions\n\t * defined in <mxEdgeStyle>. Value is \"loopStyle\". Default is\n\t * <mxGraph.defaultLoopStylean>.\n\t */\n\tSTYLE_LOOP: 'loopStyle',\n\n\t/**\n\t * Variable: STYLE_ORTHOGONAL_LOOP\n\t * \n\t * Defines the key for the orthogonal loop style. Possible values are 0 and\n\t * 1. Default is 0. Value is \"orthogonalLoop\". Use this style to specify\n\t * if loops with no waypoints and defined anchor points should be routed\n\t * using <STYLE_LOOP> or not routed.\n\t */\n\tSTYLE_ORTHOGONAL_LOOP: 'orthogonalLoop',\n\n\t/**\n\t * Variable: STYLE_ROUTING_CENTER_X\n\t * \n\t * Defines the key for the horizontal routing center. Possible values are\n\t * between -0.5 and 0.5. This is the relative offset from the center used\n\t * for connecting edges. The type of this value is numeric. Value is\n\t * \"routingCenterX\".\n\t */\n\tSTYLE_ROUTING_CENTER_X: 'routingCenterX',\n\n\t/**\n\t * Variable: STYLE_ROUTING_CENTER_Y\n\t * \n\t * Defines the key for the vertical routing center. Possible values are\n\t * between -0.5 and 0.5. This is the relative offset from the center used\n\t * for connecting edges. The type of this value is numeric. Value is\n\t * \"routingCenterY\".\n\t */\n\tSTYLE_ROUTING_CENTER_Y: 'routingCenterY',\n\n\t/**\n\t * Variable: FONT_BOLD\n\t * \n\t * Constant for bold fonts. Default is 1.\n\t */\n\tFONT_BOLD: 1,\n\n\t/**\n\t * Variable: FONT_ITALIC\n\t * \n\t * Constant for italic fonts. Default is 2.\n\t */\n\tFONT_ITALIC: 2,\n\n\t/**\n\t * Variable: FONT_UNDERLINE\n\t * \n\t * Constant for underlined fonts. Default is 4.\n\t */\n\tFONT_UNDERLINE: 4,\n\n\t/**\n\t * Variable: FONT_STRIKETHROUGH\n\t * \n\t * Constant for strikthrough fonts. Default is 8.\n\t */\n\tFONT_STRIKETHROUGH: 8,\n\t\n\t/**\n\t * Variable: SHAPE_RECTANGLE\n\t * \n\t * Name under which <mxRectangleShape> is registered in <mxCellRenderer>.\n\t * Default is rectangle.\n\t */\n\tSHAPE_RECTANGLE: 'rectangle',\n\n\t/**\n\t * Variable: SHAPE_ELLIPSE\n\t * \n\t * Name under which <mxEllipse> is registered in <mxCellRenderer>.\n\t * Default is ellipse.\n\t */\n\tSHAPE_ELLIPSE: 'ellipse',\n\n\t/**\n\t * Variable: SHAPE_DOUBLE_ELLIPSE\n\t * \n\t * Name under which <mxDoubleEllipse> is registered in <mxCellRenderer>.\n\t * Default is doubleEllipse.\n\t */\n\tSHAPE_DOUBLE_ELLIPSE: 'doubleEllipse',\n\n\t/**\n\t * Variable: SHAPE_RHOMBUS\n\t * \n\t * Name under which <mxRhombus> is registered in <mxCellRenderer>.\n\t * Default is rhombus.\n\t */\n\tSHAPE_RHOMBUS: 'rhombus',\n\n\t/**\n\t * Variable: SHAPE_LINE\n\t * \n\t * Name under which <mxLine> is registered in <mxCellRenderer>.\n\t * Default is line.\n\t */\n\tSHAPE_LINE: 'line',\n\n\t/**\n\t * Variable: SHAPE_IMAGE\n\t * \n\t * Name under which <mxImageShape> is registered in <mxCellRenderer>.\n\t * Default is image.\n\t */\n\tSHAPE_IMAGE: 'image',\n\t\n\t/**\n\t * Variable: SHAPE_ARROW\n\t * \n\t * Name under which <mxArrow> is registered in <mxCellRenderer>.\n\t * Default is arrow.\n\t */\n\tSHAPE_ARROW: 'arrow',\n\t\n\t/**\n\t * Variable: SHAPE_ARROW_CONNECTOR\n\t * \n\t * Name under which <mxArrowConnector> is registered in <mxCellRenderer>.\n\t * Default is arrowConnector.\n\t */\n\tSHAPE_ARROW_CONNECTOR: 'arrowConnector',\n\t\n\t/**\n\t * Variable: SHAPE_LABEL\n\t * \n\t * Name under which <mxLabel> is registered in <mxCellRenderer>.\n\t * Default is label.\n\t */\n\tSHAPE_LABEL: 'label',\n\t\n\t/**\n\t * Variable: SHAPE_CYLINDER\n\t * \n\t * Name under which <mxCylinder> is registered in <mxCellRenderer>.\n\t * Default is cylinder.\n\t */\n\tSHAPE_CYLINDER: 'cylinder',\n\t\n\t/**\n\t * Variable: SHAPE_SWIMLANE\n\t * \n\t * Name under which <mxSwimlane> is registered in <mxCellRenderer>.\n\t * Default is swimlane.\n\t */\n\tSHAPE_SWIMLANE: 'swimlane',\n\t\t\n\t/**\n\t * Variable: SHAPE_CONNECTOR\n\t * \n\t * Name under which <mxConnector> is registered in <mxCellRenderer>.\n\t * Default is connector.\n\t */\n\tSHAPE_CONNECTOR: 'connector',\n\n\t/**\n\t * Variable: SHAPE_ACTOR\n\t * \n\t * Name under which <mxActor> is registered in <mxCellRenderer>.\n\t * Default is actor.\n\t */\n\tSHAPE_ACTOR: 'actor',\n\t\t\n\t/**\n\t * Variable: SHAPE_CLOUD\n\t * \n\t * Name under which <mxCloud> is registered in <mxCellRenderer>.\n\t * Default is cloud.\n\t */\n\tSHAPE_CLOUD: 'cloud',\n\t\t\n\t/**\n\t * Variable: SHAPE_TRIANGLE\n\t * \n\t * Name under which <mxTriangle> is registered in <mxCellRenderer>.\n\t * Default is triangle.\n\t */\n\tSHAPE_TRIANGLE: 'triangle',\n\t\t\n\t/**\n\t * Variable: SHAPE_HEXAGON\n\t * \n\t * Name under which <mxHexagon> is registered in <mxCellRenderer>.\n\t * Default is hexagon.\n\t */\n\tSHAPE_HEXAGON: 'hexagon',\n\n\t/**\n\t * Variable: ARROW_CLASSIC\n\t * \n\t * Constant for classic arrow markers.\n\t */\n\tARROW_CLASSIC: 'classic',\n\n\t/**\n\t * Variable: ARROW_CLASSIC_THIN\n\t * \n\t * Constant for thin classic arrow markers.\n\t */\n\tARROW_CLASSIC_THIN: 'classicThin',\n\n\t/**\n\t * Variable: ARROW_BLOCK\n\t * \n\t * Constant for block arrow markers.\n\t */\n\tARROW_BLOCK: 'block',\n\n\t/**\n\t * Variable: ARROW_BLOCK_THIN\n\t * \n\t * Constant for thin block arrow markers.\n\t */\n\tARROW_BLOCK_THIN: 'blockThin',\n\n\t/**\n\t * Variable: ARROW_OPEN\n\t * \n\t * Constant for open arrow markers.\n\t */\n\tARROW_OPEN: 'open',\n\n\t/**\n\t * Variable: ARROW_OPEN_THIN\n\t * \n\t * Constant for thin open arrow markers.\n\t */\n\tARROW_OPEN_THIN: 'openThin',\n\n\t/**\n\t * Variable: ARROW_OVAL\n\t * \n\t * Constant for oval arrow markers.\n\t */\n\tARROW_OVAL: 'oval',\n\n\t/**\n\t * Variable: ARROW_DIAMOND\n\t * \n\t * Constant for diamond arrow markers.\n\t */\n\tARROW_DIAMOND: 'diamond',\n\n\t/**\n\t * Variable: ARROW_DIAMOND_THIN\n\t * \n\t * Constant for thin diamond arrow markers.\n\t */\n\tARROW_DIAMOND_THIN: 'diamondThin',\n\n\t/**\n\t * Variable: ALIGN_LEFT\n\t * \n\t * Constant for left horizontal alignment. Default is left.\n\t */\n\tALIGN_LEFT: 'left',\n\n\t/**\n\t * Variable: ALIGN_CENTER\n\t * \n\t * Constant for center horizontal alignment. Default is center.\n\t */\n\tALIGN_CENTER: 'center',\n\n\t/**\n\t * Variable: ALIGN_RIGHT\n\t * \n\t * Constant for right horizontal alignment. Default is right.\n\t */\n\tALIGN_RIGHT: 'right',\n\n\t/**\n\t * Variable: ALIGN_TOP\n\t * \n\t * Constant for top vertical alignment. Default is top.\n\t */\n\tALIGN_TOP: 'top',\n\n\t/**\n\t * Variable: ALIGN_MIDDLE\n\t * \n\t * Constant for middle vertical alignment. Default is middle.\n\t */\n\tALIGN_MIDDLE: 'middle',\n\n\t/**\n\t * Variable: ALIGN_BOTTOM\n\t * \n\t * Constant for bottom vertical alignment. Default is bottom.\n\t */\n\tALIGN_BOTTOM: 'bottom',\n\n\t/**\n\t * Variable: DIRECTION_NORTH\n\t * \n\t * Constant for direction north. Default is north.\n\t */\n\tDIRECTION_NORTH: 'north',\n\n\t/**\n\t * Variable: DIRECTION_SOUTH\n\t * \n\t * Constant for direction south. Default is south.\n\t */\n\tDIRECTION_SOUTH: 'south',\n\n\t/**\n\t * Variable: DIRECTION_EAST\n\t * \n\t * Constant for direction east. Default is east.\n\t */\n\tDIRECTION_EAST: 'east',\n\n\t/**\n\t * Variable: DIRECTION_WEST\n\t * \n\t * Constant for direction west. Default is west.\n\t */\n\tDIRECTION_WEST: 'west',\n\n\t/**\n\t * Variable: TEXT_DIRECTION_DEFAULT\n\t * \n\t * Constant for text direction default. Default is an empty string. Use\n\t * this value to use the default text direction of the operating system. \n\t */\n\tTEXT_DIRECTION_DEFAULT: '',\n\n\t/**\n\t * Variable: TEXT_DIRECTION_AUTO\n\t * \n\t * Constant for text direction automatic. Default is auto. Use this value\n\t * to find the direction for a given text with <mxText.getAutoDirection>. \n\t */\n\tTEXT_DIRECTION_AUTO: 'auto',\n\n\t/**\n\t * Variable: TEXT_DIRECTION_LTR\n\t * \n\t * Constant for text direction left to right. Default is ltr. Use this\n\t * value for left to right text direction.\n\t */\n\tTEXT_DIRECTION_LTR: 'ltr',\n\n\t/**\n\t * Variable: TEXT_DIRECTION_RTL\n\t * \n\t * Constant for text direction right to left. Default is rtl. Use this\n\t * value for right to left text direction.\n\t */\n\tTEXT_DIRECTION_RTL: 'rtl',\n\n\t/**\n\t * Variable: DIRECTION_MASK_NONE\n\t * \n\t * Constant for no direction.\n\t */\n\tDIRECTION_MASK_NONE: 0,\n\n\t/**\n\t * Variable: DIRECTION_MASK_WEST\n\t * \n\t * Bitwise mask for west direction.\n\t */\n\tDIRECTION_MASK_WEST: 1,\n\t\n\t/**\n\t * Variable: DIRECTION_MASK_NORTH\n\t * \n\t * Bitwise mask for north direction.\n\t */\n\tDIRECTION_MASK_NORTH: 2,\n\n\t/**\n\t * Variable: DIRECTION_MASK_SOUTH\n\t * \n\t * Bitwise mask for south direction.\n\t */\n\tDIRECTION_MASK_SOUTH: 4,\n\n\t/**\n\t * Variable: DIRECTION_MASK_EAST\n\t * \n\t * Bitwise mask for east direction.\n\t */\n\tDIRECTION_MASK_EAST: 8,\n\t\n\t/**\n\t * Variable: DIRECTION_MASK_ALL\n\t * \n\t * Bitwise mask for all directions.\n\t */\n\tDIRECTION_MASK_ALL: 15,\n\n\t/**\n\t * Variable: ELBOW_VERTICAL\n\t * \n\t * Constant for elbow vertical. Default is horizontal.\n\t */\n\tELBOW_VERTICAL: 'vertical',\n\n\t/**\n\t * Variable: ELBOW_HORIZONTAL\n\t * \n\t * Constant for elbow horizontal. Default is horizontal.\n\t */\n\tELBOW_HORIZONTAL: 'horizontal',\n\n\t/**\n\t * Variable: EDGESTYLE_ELBOW\n\t * \n\t * Name of the elbow edge style. Can be used as a string value\n\t * for the STYLE_EDGE style.\n\t */\n\tEDGESTYLE_ELBOW: 'elbowEdgeStyle',\n\n\t/**\n\t * Variable: EDGESTYLE_ENTITY_RELATION\n\t * \n\t * Name of the entity relation edge style. Can be used as a string value\n\t * for the STYLE_EDGE style.\n\t */\n\tEDGESTYLE_ENTITY_RELATION: 'entityRelationEdgeStyle',\n\n\t/**\n\t * Variable: EDGESTYLE_LOOP\n\t * \n\t * Name of the loop edge style. Can be used as a string value\n\t * for the STYLE_EDGE style.\n\t */\n\tEDGESTYLE_LOOP: 'loopEdgeStyle',\n\n\t/**\n\t * Variable: EDGESTYLE_SIDETOSIDE\n\t * \n\t * Name of the side to side edge style. Can be used as a string value\n\t * for the STYLE_EDGE style.\n\t */\n\tEDGESTYLE_SIDETOSIDE: 'sideToSideEdgeStyle',\n\n\t/**\n\t * Variable: EDGESTYLE_TOPTOBOTTOM\n\t * \n\t * Name of the top to bottom edge style. Can be used as a string value\n\t * for the STYLE_EDGE style.\n\t */\n\tEDGESTYLE_TOPTOBOTTOM: 'topToBottomEdgeStyle',\n\n\t/**\n\t * Variable: EDGESTYLE_ORTHOGONAL\n\t * \n\t * Name of the generic orthogonal edge style. Can be used as a string value\n\t * for the STYLE_EDGE style.\n\t */\n\tEDGESTYLE_ORTHOGONAL: 'orthogonalEdgeStyle',\n\n\t/**\n\t * Variable: EDGESTYLE_SEGMENT\n\t * \n\t * Name of the generic segment edge style. Can be used as a string value\n\t * for the STYLE_EDGE style.\n\t */\n\tEDGESTYLE_SEGMENT: 'segmentEdgeStyle',\n \n\t/**\n\t * Variable: PERIMETER_ELLIPSE\n\t * \n\t * Name of the ellipse perimeter. Can be used as a string value\n\t * for the STYLE_PERIMETER style.\n\t */\n\tPERIMETER_ELLIPSE: 'ellipsePerimeter',\n\n\t/**\n\t * Variable: PERIMETER_RECTANGLE\n\t *\n\t * Name of the rectangle perimeter. Can be used as a string value\n\t * for the STYLE_PERIMETER style.\n\t */\n\tPERIMETER_RECTANGLE: 'rectanglePerimeter',\n\n\t/**\n\t * Variable: PERIMETER_RHOMBUS\n\t * \n\t * Name of the rhombus perimeter. Can be used as a string value\n\t * for the STYLE_PERIMETER style.\n\t */\n\tPERIMETER_RHOMBUS: 'rhombusPerimeter',\n\n\t/**\n\t * Variable: PERIMETER_HEXAGON\n\t * \n\t * Name of the hexagon perimeter. Can be used as a string value \n\t * for the STYLE_PERIMETER style.\n\t */\n\tPERIMETER_HEXAGON: 'hexagonPerimeter',\n\n\t/**\n\t * Variable: PERIMETER_TRIANGLE\n\t * \n\t * Name of the triangle perimeter. Can be used as a string value\n\t * for the STYLE_PERIMETER style.\n\t */\n\tPERIMETER_TRIANGLE: 'trianglePerimeter'\n};\n\n__mxOutput.mxConstants = typeof mxConstants !== 'undefined' ? mxConstants : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxEventObject\n * \n * The mxEventObject is a wrapper for all properties of a single event.\n * Additionally, it also offers functions to consume the event and check if it\n * was consumed as follows:\n * \n * (code)\n * evt.consume();\n * INV: evt.isConsumed() == true\n * (end)\n * \n * Constructor: mxEventObject\n *\n * Constructs a new event object with the specified name. An optional\n * sequence of key, value pairs can be appended to define properties.\n * \n * Example:\n *\n * (code)\n * new mxEventObject(\"eventName\", key1, val1, .., keyN, valN)\n * (end)\n */\nfunction mxEventObject(name)\n{\n\tthis.name = name;\n\tthis.properties = [];\n\t\n\tfor (var i = 1; i < arguments.length; i += 2)\n\t{\n\t\tif (arguments[i + 1] != null)\n\t\t{\n\t\t\tthis.properties[arguments[i]] = arguments[i + 1];\n\t\t}\n\t}\n};\n\n/**\n * Variable: name\n *\n * Holds the name.\n */\nmxEventObject.prototype.name = null;\n\n/**\n * Variable: properties\n *\n * Holds the properties as an associative array.\n */\nmxEventObject.prototype.properties = null;\n\n/**\n * Variable: consumed\n *\n * Holds the consumed state. Default is false.\n */\nmxEventObject.prototype.consumed = false;\n\n/**\n * Function: getName\n * \n * Returns <name>.\n */\nmxEventObject.prototype.getName = function()\n{\n\treturn this.name;\n};\n\n/**\n * Function: getProperties\n * \n * Returns <properties>.\n */\nmxEventObject.prototype.getProperties = function()\n{\n\treturn this.properties;\n};\n\n/**\n * Function: getProperty\n * \n * Returns the property for the given key.\n */\nmxEventObject.prototype.getProperty = function(key)\n{\n\treturn this.properties[key];\n};\n\n/**\n * Function: isConsumed\n *\n * Returns true if the event has been consumed.\n */\nmxEventObject.prototype.isConsumed = function()\n{\n\treturn this.consumed;\n};\n\n/**\n * Function: consume\n *\n * Consumes the event.\n */\nmxEventObject.prototype.consume = function()\n{\n\tthis.consumed = true;\n};\n\n__mxOutput.mxEventObject = typeof mxEventObject !== 'undefined' ? mxEventObject : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxMouseEvent\n * \n * Base class for all mouse events in mxGraph. A listener for this event should\n * implement the following methods:\n * \n * (code)\n * graph.addMouseListener(\n * {\n *   mouseDown: function(sender, evt)\n *   {\n *     mxLog.debug('mouseDown');\n *   },\n *   mouseMove: function(sender, evt)\n *   {\n *     mxLog.debug('mouseMove');\n *   },\n *   mouseUp: function(sender, evt)\n *   {\n *     mxLog.debug('mouseUp');\n *   }\n * });\n * (end)\n * \n * Constructor: mxMouseEvent\n *\n * Constructs a new event object for the given arguments.\n * \n * Parameters:\n * \n * evt - Native mouse event.\n * state - Optional <mxCellState> under the mouse.\n * \n */\nfunction mxMouseEvent(evt, state)\n{\n\tthis.evt = evt;\n\tthis.state = state;\n\tthis.sourceState = state;\n};\n\n/**\n * Variable: consumed\n *\n * Holds the consumed state of this event.\n */\nmxMouseEvent.prototype.consumed = false;\n\n/**\n * Variable: evt\n *\n * Holds the inner event object.\n */\nmxMouseEvent.prototype.evt = null;\n\n/**\n * Variable: graphX\n *\n * Holds the x-coordinate of the event in the graph. This value is set in\n * <mxGraph.fireMouseEvent>.\n */\nmxMouseEvent.prototype.graphX = null;\n\n/**\n * Variable: graphY\n *\n * Holds the y-coordinate of the event in the graph. This value is set in\n * <mxGraph.fireMouseEvent>.\n */\nmxMouseEvent.prototype.graphY = null;\n\n/**\n * Variable: state\n *\n * Holds the optional <mxCellState> associated with this event.\n */\nmxMouseEvent.prototype.state = null;\n\n/**\n * Variable: sourceState\n * \n * Holds the <mxCellState> that was passed to the constructor. This can be\n * different from <state> depending on the result of <mxGraph.getEventState>.\n */\nmxMouseEvent.prototype.sourceState = null;\n\n/**\n * Function: getEvent\n * \n * Returns <evt>.\n */\nmxMouseEvent.prototype.getEvent = function()\n{\n\treturn this.evt;\n};\n\n/**\n * Function: getSource\n * \n * Returns the target DOM element using <mxEvent.getSource> for <evt>.\n */\nmxMouseEvent.prototype.getSource = function()\n{\n\treturn mxEvent.getSource(this.evt);\n};\n\n/**\n * Function: isSource\n * \n * Returns true if the given <mxShape> is the source of <evt>.\n */\nmxMouseEvent.prototype.isSource = function(shape)\n{\n\tif (shape != null)\n\t{\n\t\treturn mxUtils.isAncestorNode(shape.node, this.getSource());\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: getX\n * \n * Returns <evt.clientX>.\n */\nmxMouseEvent.prototype.getX = function()\n{\n\treturn mxEvent.getClientX(this.getEvent());\n};\n\n/**\n * Function: getY\n * \n * Returns <evt.clientY>.\n */\nmxMouseEvent.prototype.getY = function()\n{\n\treturn mxEvent.getClientY(this.getEvent());\n};\n\n/**\n * Function: getGraphX\n * \n * Returns <graphX>.\n */\nmxMouseEvent.prototype.getGraphX = function()\n{\n\treturn this.graphX;\n};\n\n/**\n * Function: getGraphY\n * \n * Returns <graphY>.\n */\nmxMouseEvent.prototype.getGraphY = function()\n{\n\treturn this.graphY;\n};\n\n/**\n * Function: getState\n * \n * Returns <state>.\n */\nmxMouseEvent.prototype.getState = function()\n{\n\treturn this.state;\n};\n\n/**\n * Function: getCell\n * \n * Returns the <mxCell> in <state> is not null.\n */\nmxMouseEvent.prototype.getCell = function()\n{\n\tvar state = this.getState();\n\t\n\tif (state != null)\n\t{\n\t\treturn state.cell;\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: isPopupTrigger\n *\n * Returns true if the event is a popup trigger.\n */\nmxMouseEvent.prototype.isPopupTrigger = function()\n{\n\treturn mxEvent.isPopupTrigger(this.getEvent());\n};\n\n/**\n * Function: isConsumed\n *\n * Returns <consumed>.\n */\nmxMouseEvent.prototype.isConsumed = function()\n{\n\treturn this.consumed;\n};\n\n/**\n * Function: consume\n *\n * Sets <consumed> to true and invokes preventDefault on the native event\n * if such a method is defined. This is used mainly to avoid the cursor from\n * being changed to a text cursor in Webkit. You can use the preventDefault\n * flag to disable this functionality.\n * \n * Parameters:\n * \n * preventDefault - Specifies if the native event should be canceled. Default\n * is true.\n */\nmxMouseEvent.prototype.consume = function(preventDefault)\n{\n\tpreventDefault = (preventDefault != null) ? preventDefault :\n\t\t(this.evt.touches != null || mxEvent.isMouseEvent(this.evt));\n\t\n\tif (preventDefault && this.evt.preventDefault)\n\t{\n\t\tthis.evt.preventDefault();\n\t}\n\n\t// Workaround for images being dragged in IE\n\t// Does not change returnValue in Opera\n\tif (mxClient.IS_IE)\n\t{\n\t\tthis.evt.returnValue = true;\n\t}\n\n\t// Sets local consumed state\n\tthis.consumed = true;\n};\n\n__mxOutput.mxMouseEvent = typeof mxMouseEvent !== 'undefined' ? mxMouseEvent : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxEventSource\n *\n * Base class for objects that dispatch named events. To create a subclass that\n * inherits from mxEventSource, the following code is used.\n *\n * (code)\n * function MyClass() { };\n *\n * MyClass.prototype = new mxEventSource();\n * MyClass.prototype.constructor = MyClass;\n * (end)\n *\n * Known Subclasses:\n *\n * <mxGraphModel>, <mxGraph>, <mxGraphView>, <mxEditor>, <mxCellOverlay>,\n * <mxToolbar>, <mxWindow>\n * \n * Constructor: mxEventSource\n *\n * Constructs a new event source.\n */\nfunction mxEventSource(eventSource)\n{\n\tthis.setEventSource(eventSource);\n};\n\n/**\n * Variable: eventListeners\n *\n * Holds the event names and associated listeners in an array. The array\n * contains the event name followed by the respective listener for each\n * registered listener.\n */\nmxEventSource.prototype.eventListeners = null;\n\n/**\n * Variable: eventsEnabled\n *\n * Specifies if events can be fired. Default is true.\n */\nmxEventSource.prototype.eventsEnabled = true;\n\n/**\n * Variable: eventSource\n *\n * Optional source for events. Default is null.\n */\nmxEventSource.prototype.eventSource = null;\n\n/**\n * Function: isEventsEnabled\n * \n * Returns <eventsEnabled>.\n */\nmxEventSource.prototype.isEventsEnabled = function()\n{\n\treturn this.eventsEnabled;\n};\n\n/**\n * Function: setEventsEnabled\n * \n * Sets <eventsEnabled>.\n */\nmxEventSource.prototype.setEventsEnabled = function(value)\n{\n\tthis.eventsEnabled = value;\n};\n\n/**\n * Function: getEventSource\n * \n * Returns <eventSource>.\n */\nmxEventSource.prototype.getEventSource = function()\n{\n\treturn this.eventSource;\n};\n\n/**\n * Function: setEventSource\n * \n * Sets <eventSource>.\n */\nmxEventSource.prototype.setEventSource = function(value)\n{\n\tthis.eventSource = value;\n};\n\n/**\n * Function: addListener\n *\n * Binds the specified function to the given event name. If no event name\n * is given, then the listener is registered for all events.\n * \n * The parameters of the listener are the sender and an <mxEventObject>.\n */\nmxEventSource.prototype.addListener = function(name, funct)\n{\n\tif (this.eventListeners == null)\n\t{\n\t\tthis.eventListeners = [];\n\t}\n\t\n\tthis.eventListeners.push(name);\n\tthis.eventListeners.push(funct);\n};\n\n/**\n * Function: removeListener\n *\n * Removes all occurrences of the given listener from <eventListeners>.\n */\nmxEventSource.prototype.removeListener = function(funct)\n{\n\tif (this.eventListeners != null)\n\t{\n\t\tvar i = 0;\n\t\t\n\t\twhile (i < this.eventListeners.length)\n\t\t{\n\t\t\tif (this.eventListeners[i+1] == funct)\n\t\t\t{\n\t\t\t\tthis.eventListeners.splice(i, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: fireEvent\n *\n * Dispatches the given event to the listeners which are registered for\n * the event. The sender argument is optional. The current execution scope\n * (\"this\") is used for the listener invocation (see <mxUtils.bind>).\n *\n * Example:\n *\n * (code)\n * fireEvent(new mxEventObject(\"eventName\", key1, val1, .., keyN, valN))\n * (end)\n * \n * Parameters:\n *\n * evt - <mxEventObject> that represents the event.\n * sender - Optional sender to be passed to the listener. Default value is\n * the return value of <getEventSource>.\n */\nmxEventSource.prototype.fireEvent = function(evt, sender)\n{\n\tif (this.eventListeners != null && this.isEventsEnabled())\n\t{\n\t\tif (evt == null)\n\t\t{\n\t\t\tevt = new mxEventObject();\n\t\t}\n\t\t\n\t\tif (sender == null)\n\t\t{\n\t\t\tsender = this.getEventSource();\n\t\t}\n\n\t\tif (sender == null)\n\t\t{\n\t\t\tsender = this;\n\t\t}\n\n\t\tvar args = [sender, evt];\n\t\t\n\t\tfor (var i = 0; i < this.eventListeners.length; i += 2)\n\t\t{\n\t\t\tvar listen = this.eventListeners[i];\n\t\t\t\n\t\t\tif (listen == null || listen == evt.getName())\n\t\t\t{\n\t\t\t\tthis.eventListeners[i+1].apply(this, args);\n\t\t\t}\n\t\t}\n\t}\n};\n\n__mxOutput.mxEventSource = typeof mxEventSource !== 'undefined' ? mxEventSource : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxEvent =\n{\n\n\t/**\n\t * Class: mxEvent\n\t * \n\t * Cross-browser DOM event support. For internal event handling,\n\t * <mxEventSource> and the graph event dispatch loop in <mxGraph> are used.\n\t * \n\t * Memory Leaks:\n\t * \n\t * Use this class for adding and removing listeners to/from DOM nodes. The\n\t * <removeAllListeners> function is provided to remove all listeners that\n\t * have been added using <addListener>. The function should be invoked when\n\t * the last reference is removed in the JavaScript code, typically when the\n\t * referenced DOM node is removed from the DOM.\n\t *\n\t * Function: addListener\n\t * \n\t * Binds the function to the specified event on the given element. Use\n\t * <mxUtils.bind> in order to bind the \"this\" keyword inside the function\n\t * to a given execution scope.\n\t */\n\taddListener: function()\n\t{\n\t\tvar updateListenerList = function(element, eventName, funct)\n\t\t{\n\t\t\tif (element.mxListenerList == null)\n\t\t\t{\n\t\t\t\telement.mxListenerList = [];\n\t\t\t}\n\t\t\t\n\t\t\tvar entry = {name: eventName, f: funct};\n\t\t\telement.mxListenerList.push(entry);\n\t\t};\n\t\t\n\t\tif (window.addEventListener)\n\t\t{\n\t\t\treturn function(element, eventName, funct)\n\t\t\t{\n\t\t\t\telement.addEventListener(eventName, funct, false);\n\t\t\t\tupdateListenerList(element, eventName, funct);\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn function(element, eventName, funct)\n\t\t\t{\n\t\t\t\telement.attachEvent('on' + eventName, funct);\n\t\t\t\tupdateListenerList(element, eventName, funct);\t\t\t\t\n\t\t\t};\n\t\t}\n\t}(),\n\n\t/**\n\t * Function: removeListener\n\t *\n\t * Removes the specified listener from the given element.\n\t */\n\tremoveListener: function()\n\t{\n\t\tvar updateListener = function(element, eventName, funct)\n\t\t{\n\t\t\tif (element.mxListenerList != null)\n\t\t\t{\n\t\t\t\tvar listenerCount = element.mxListenerList.length;\n\t\t\t\t\n\t\t\t\tfor (var i = 0; i < listenerCount; i++)\n\t\t\t\t{\n\t\t\t\t\tvar entry = element.mxListenerList[i];\n\t\t\t\t\t\n\t\t\t\t\tif (entry.f == funct)\n\t\t\t\t\t{\n\t\t\t\t\t\telement.mxListenerList.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (element.mxListenerList.length == 0)\n\t\t\t\t{\n\t\t\t\t\telement.mxListenerList = null;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\tif (window.removeEventListener)\n\t\t{\n\t\t\treturn function(element, eventName, funct)\n\t\t\t{\n\t\t\t\telement.removeEventListener(eventName, funct, false);\n\t\t\t\tupdateListener(element, eventName, funct);\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn function(element, eventName, funct)\n\t\t\t{\n\t\t\t\telement.detachEvent('on' + eventName, funct);\n\t\t\t\tupdateListener(element, eventName, funct);\n\t\t\t};\n\t\t}\n\t}(),\n\n\t/**\n\t * Function: removeAllListeners\n\t * \n\t * Removes all listeners from the given element.\n\t */\n\tremoveAllListeners: function(element)\n\t{\n\t\tvar list = element.mxListenerList;\n\n\t\tif (list != null)\n\t\t{\n\t\t\twhile (list.length > 0)\n\t\t\t{\n\t\t\t\tvar entry = list[0];\n\t\t\t\tmxEvent.removeListener(element, entry.name, entry.f);\n\t\t\t}\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: addGestureListeners\n\t * \n\t * Adds the given listeners for touch, mouse and/or pointer events. If\n\t * <mxClient.IS_POINTER> is true then pointer events will be registered,\n\t * else the respective mouse events will be registered. If <mxClient.IS_POINTER>\n\t * is false and <mxClient.IS_TOUCH> is true then the respective touch events\n\t * will be registered as well as the mouse events.\n\t */\n\taddGestureListeners: function(node, startListener, moveListener, endListener)\n\t{\n\t\tif (startListener != null)\n\t\t{\n\t\t\tmxEvent.addListener(node, (mxClient.IS_POINTER) ? 'pointerdown' : 'mousedown', startListener);\n\t\t}\n\t\t\n\t\tif (moveListener != null)\n\t\t{\n\t\t\tmxEvent.addListener(node, (mxClient.IS_POINTER) ? 'pointermove' : 'mousemove', moveListener);\n\t\t}\n\t\t\n\t\tif (endListener != null)\n\t\t{\n\t\t\tmxEvent.addListener(node, (mxClient.IS_POINTER) ? 'pointerup' : 'mouseup', endListener);\n\t\t}\n\t\t\n\t\tif (!mxClient.IS_POINTER && mxClient.IS_TOUCH)\n\t\t{\n\t\t\tif (startListener != null)\n\t\t\t{\n\t\t\t\tmxEvent.addListener(node, 'touchstart', startListener);\n\t\t\t}\n\t\t\t\n\t\t\tif (moveListener != null)\n\t\t\t{\n\t\t\t\tmxEvent.addListener(node, 'touchmove', moveListener);\n\t\t\t}\n\t\t\t\n\t\t\tif (endListener != null)\n\t\t\t{\n\t\t\t\tmxEvent.addListener(node, 'touchend', endListener);\n\t\t\t}\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: removeGestureListeners\n\t * \n\t * Removes the given listeners from mousedown, mousemove, mouseup and the\n\t * respective touch events if <mxClient.IS_TOUCH> is true.\n\t */\n\tremoveGestureListeners: function(node, startListener, moveListener, endListener)\n\t{\n\t\tif (startListener != null)\n\t\t{\n\t\t\tmxEvent.removeListener(node, (mxClient.IS_POINTER) ? 'pointerdown' : 'mousedown', startListener);\n\t\t}\n\t\t\n\t\tif (moveListener != null)\n\t\t{\n\t\t\tmxEvent.removeListener(node, (mxClient.IS_POINTER) ? 'pointermove' : 'mousemove', moveListener);\n\t\t}\n\t\t\n\t\tif (endListener != null)\n\t\t{\n\t\t\tmxEvent.removeListener(node, (mxClient.IS_POINTER) ? 'pointerup' : 'mouseup', endListener);\n\t\t}\n\t\t\n\t\tif (!mxClient.IS_POINTER && mxClient.IS_TOUCH)\n\t\t{\n\t\t\tif (startListener != null)\n\t\t\t{\n\t\t\t\tmxEvent.removeListener(node, 'touchstart', startListener);\n\t\t\t}\n\t\t\t\n\t\t\tif (moveListener != null)\n\t\t\t{\n\t\t\t\tmxEvent.removeListener(node, 'touchmove', moveListener);\n\t\t\t}\n\t\t\t\n\t\t\tif (endListener != null)\n\t\t\t{\n\t\t\t\tmxEvent.removeListener(node, 'touchend', endListener);\n\t\t\t}\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: redirectMouseEvents\n\t *\n\t * Redirects the mouse events from the given DOM node to the graph dispatch\n\t * loop using the event and given state as event arguments. State can\n\t * either be an instance of <mxCellState> or a function that returns an\n\t * <mxCellState>. The down, move, up and dblClick arguments are optional\n\t * functions that take the trigger event as arguments and replace the\n\t * default behaviour.\n\t */\n\tredirectMouseEvents: function(node, graph, state, down, move, up, dblClick)\n\t{\n\t\tvar getState = function(evt)\n\t\t{\n\t\t\treturn (typeof(state) == 'function') ? state(evt) : state;\n\t\t};\n\t\t\n\t\tmxEvent.addGestureListeners(node, function (evt)\n\t\t{\n\t\t\tif (down != null)\n\t\t\t{\n\t\t\t\tdown(evt);\n\t\t\t}\n\t\t\telse if (!mxEvent.isConsumed(evt))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, getState(evt)));\n\t\t\t}\n\t\t},\n\t\tfunction (evt)\n\t\t{\n\t\t\tif (move != null)\n\t\t\t{\n\t\t\t\tmove(evt);\n\t\t\t}\n\t\t\telse if (!mxEvent.isConsumed(evt))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, getState(evt)));\n\t\t\t}\n\t\t},\n\t\tfunction (evt)\n\t\t{\n\t\t\tif (up != null)\n\t\t\t{\n\t\t\t\tup(evt);\n\t\t\t}\n\t\t\telse if (!mxEvent.isConsumed(evt))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, getState(evt)));\n\t\t\t}\n\t\t});\n\n\t\tmxEvent.addListener(node, 'dblclick', function (evt)\n\t\t{\n\t\t\tif (dblClick != null)\n\t\t\t{\n\t\t\t\tdblClick(evt);\n\t\t\t}\n\t\t\telse if (!mxEvent.isConsumed(evt))\n\t\t\t{\n\t\t\t\tvar tmp = getState(evt);\n\t\t\t\tgraph.dblClick(evt, (tmp != null) ? tmp.cell : null);\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Function: release\n\t * \n\t * Removes the known listeners from the given DOM node and its descendants.\n\t * \n\t * Parameters:\n\t * \n\t * element - DOM node to remove the listeners from.\n\t */\n\trelease: function(element)\n\t{\n\t\ttry\n\t\t{\n\t\t\tif (element != null)\n\t\t\t{\n\t\t\t\tmxEvent.removeAllListeners(element);\n\t\t\t\t\n\t\t\t\tvar children = element.childNodes;\n\t\t\t\t\n\t\t\t\tif (children != null)\n\t\t\t\t{\n\t\t\t        var childCount = children.length;\n\t\t\t        \n\t\t\t        for (var i = 0; i < childCount; i += 1)\n\t\t\t        {\n\t\t\t        \tmxEvent.release(children[i]);\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\t// ignores errors as this is typically called in cleanup code\n\t\t}\n\t},\n\n\t/**\n\t * Function: addMouseWheelListener\n\t * \n\t * Installs the given function as a handler for mouse wheel events. The\n\t * function has two arguments: the mouse event and a boolean that specifies\n\t * if the wheel was moved up or down.\n\t * \n\t * This has been tested with IE 6 and 7, Firefox (all versions), Opera and\n\t * Safari. It does currently not work on Safari for Mac.\n\t * \n\t * Example:\n\t * \n\t * (code)\n\t * mxEvent.addMouseWheelListener(function (evt, up, pinch)\n\t * {\n\t *   mxLog.show();\n\t *   mxLog.debug('mouseWheel: up='+up);\n\t * });\n\t *(end)\n\t * \n\t * Parameters:\n\t * \n\t * funct - Handler function that takes the event argument, a boolean argument\n\t * for the mousewheel direction and a boolean to specify if the underlying\n\t * event was a pinch gesture on a touch device.\n\t * target - Target for installing the listener in Google Chrome. See \n\t * https://www.chromestatus.com/features/6662647093133312.\n\t */\n\taddMouseWheelListener: function(funct, target)\n\t{\n\t\tif (funct != null)\n\t\t{\n\t\t\tvar wheelHandler = function(evt)\n\t\t\t{\n\t\t\t\t// IE does not give an event object but the\n\t\t\t\t// global event object is the mousewheel event\n\t\t\t\t// at this point in time.\n\t\t\t\tif (evt == null)\n\t\t\t\t{\n\t\t\t\t\tevt = window.event;\n\t\t\t\t}\n\t\t\t\n\t\t\t\t//To prevent window zoom on trackpad pinch\n\t\t\t\tif (evt.ctrlKey) \n\t\t\t\t{\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t}\n\n\t\t\t\tvar delta = -evt.deltaY;\n\t\t\t\t\n\t\t\t\t// Handles the event using the given function\n\t\t\t\tif (Math.abs(evt.deltaX) > 0.5 || Math.abs(evt.deltaY) > 0.5)\n\t\t\t\t{\n\t\t\t\t\tfunct(evt, (evt.deltaY == 0) ?  -evt.deltaX > 0 : -evt.deltaY > 0);\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\ttarget = target != null ? target : window;\n\t\t\t\t\t\n\t\t\tif (mxClient.IS_SF && !mxClient.IS_TOUCH)\n\t\t\t{\n\t\t\t\tvar scale = 1;\n\t\t\t\t\n\t\t\t\tmxEvent.addListener(target, 'gesturestart', function(evt)\n\t\t\t\t{\n\t\t\t\t\tmxEvent.consume(evt);\n\t\t\t\t\tscale = 1;\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tmxEvent.addListener(target, 'gesturechange', function(evt)\n\t\t\t\t{\n\t\t\t\t\tmxEvent.consume(evt);\n\t\t\t\t\tvar diff = scale - evt.scale;\n\t\t\t\t\t\n\t\t\t\t\tif (Math.abs(diff) > 0.2)\n\t\t\t\t\t{\n\t\t\t\t\t\tfunct(evt, diff < 0, true);\n\t\t\t\t\t\tscale = evt.scale;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tmxEvent.addListener(target, 'gestureend', function(evt)\n\t\t\t\t{\n\t\t\t\t\tmxEvent.consume(evt);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar evtCache = [];\n\t\t\t\tvar dx0 = 0;\n\t\t\t\tvar dy0 = 0;\n\t\t\t\t\n\t\t\t\t// Adds basic listeners for graph event dispatching\n\t\t\t\tmxEvent.addGestureListeners(target, mxUtils.bind(this, function(evt)\n\t\t\t\t{\n\t\t\t\t\tif (!mxEvent.isMouseEvent(evt) && evt.pointerId != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tevtCache.push(evt);\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t\t{\n\t\t\t\t\tif (!mxEvent.isMouseEvent(evt) && evtCache.length == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Find this event in the cache and update its record with this event\n\t\t\t\t\t\tfor (var i = 0; i < evtCache.length; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (evt.pointerId == evtCache[i].pointerId)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tevtCache[i] = evt;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t   \t// Calculate the distance between the two pointers\n\t\t\t\t\t\tvar dx = Math.abs(evtCache[0].clientX - evtCache[1].clientX);\n\t\t\t\t\t\tvar dy = Math.abs(evtCache[0].clientY - evtCache[1].clientY);\n\t\t\t\t\t\tvar tx = Math.abs(dx - dx0);\n\t\t\t\t\t\tvar ty = Math.abs(dy - dy0);\n\t\t\t\t\t\n\t\t\t\t\t\tif (tx > mxEvent.PINCH_THRESHOLD || ty > mxEvent.PINCH_THRESHOLD)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar cx = evtCache[0].clientX + (evtCache[1].clientX - evtCache[0].clientX) / 2;\n\t\t\t\t\t\t\tvar cy = evtCache[0].clientY + (evtCache[1].clientY - evtCache[0].clientY) / 2;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfunct(evtCache[0], (tx > ty) ? dx > dx0 : dy > dy0, true, cx, cy);\n\t\t\t\t\t\t\n\t\t\t\t\t\t   \t// Cache the distance for the next move event \n\t\t\t\t\t\t\tdx0 = dx;\n\t\t\t\t\t\t\tdy0 = dy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t\t{\n\t\t\t\t\tevtCache = [];\n\t\t\t\t\tdx0 = 0;\n\t\t\t\t\tdy0 = 0;\n\t\t\t\t}));\n\t\t\t}\n\t\t\t\n\t\t\tmxEvent.addListener(target, 'wheel', wheelHandler);\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: disableContextMenu\n\t *\n\t * Disables the context menu for the given element.\n\t */\n\tdisableContextMenu: function(element)\n\t{\n\t\tmxEvent.addListener(element, 'contextmenu', function(evt)\n\t\t{\n\t\t\tif (evt.preventDefault)\n\t\t\t{\n\t\t\t\tevt.preventDefault();\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t});\n\t},\n\t\n\t/**\n\t * Function: getSource\n\t * \n\t * Returns the event's target or srcElement depending on the browser.\n\t */\n\tgetSource: function(evt)\n\t{\n\t\treturn (evt.srcElement != null) ? evt.srcElement : evt.target;\n\t},\n\n\t/**\n\t * Function: isConsumed\n\t * \n\t * Returns true if the event has been consumed using <consume>.\n\t */\n\tisConsumed: function(evt)\n\t{\n\t\treturn evt.isConsumed != null && evt.isConsumed;\n\t},\n\n\t/**\n\t * Function: isTouchEvent\n\t * \n\t * Returns true if the event was generated using a touch device (not a pen or mouse).\n\t */\n\tisTouchEvent: function(evt)\n\t{\n\t\treturn (evt.pointerType != null) ? (evt.pointerType == 'touch' || evt.pointerType ===\n\t\t\tevt.MSPOINTER_TYPE_TOUCH) : ((evt.mozInputSource != null) ?\n\t\t\t\t\tevt.mozInputSource == 5 : evt.type.indexOf('touch') == 0);\n\t},\n\n\t/**\n\t * Function: isPenEvent\n\t * \n\t * Returns true if the event was generated using a pen (not a touch device or mouse).\n\t */\n\tisPenEvent: function(evt)\n\t{\n\t\treturn (evt.pointerType != null) ? (evt.pointerType == 'pen' || evt.pointerType ===\n\t\t\tevt.MSPOINTER_TYPE_PEN) : ((evt.mozInputSource != null) ?\n\t\t\t\t\tevt.mozInputSource == 2 : evt.type.indexOf('pen') == 0);\n\t},\n\n\t/**\n\t * Function: isMultiTouchEvent\n\t * \n\t * Returns true if the event was generated using a touch device (not a pen or mouse).\n\t */\n\tisMultiTouchEvent: function(evt)\n\t{\n\t\treturn (evt.type != null && evt.type.indexOf('touch') == 0 && evt.touches != null && evt.touches.length > 1);\n\t},\n\n\t/**\n\t * Function: isMouseEvent\n\t * \n\t * Returns true if the event was generated using a mouse (not a pen or touch device).\n\t */\n\tisMouseEvent: function(evt)\n\t{\n\t\treturn (evt.pointerType != null) ? (evt.pointerType == 'mouse' || evt.pointerType ===\n\t\t\tevt.MSPOINTER_TYPE_MOUSE) : ((evt.mozInputSource != null) ?\n\t\t\t\tevt.mozInputSource == 1 : evt.type.indexOf('mouse') == 0);\n\t},\n\t\n\t/**\n\t * Function: isLeftMouseButton\n\t * \n\t * Returns true if the left mouse button is pressed for the given event.\n\t * To check if a button is pressed during a mouseMove you should use the\n\t * <mxGraph.isMouseDown> property. Note that this returns true in Firefox\n\t * for control+left-click on the Mac.\n\t */\n\tisLeftMouseButton: function(evt)\n\t{\n\t\t// Special case for mousemove and mousedown we check the buttons\n\t\t// if it exists because which is 0 even if no button is pressed\n\t\tif ('buttons' in evt && (evt.type == 'mousedown' || evt.type == 'mousemove'))\n\t\t{\n\t\t\treturn evt.buttons == 1;\n\t\t}\n\t\telse if ('which' in evt)\n\t\t{\n\t        return evt.which === 1;\n\t    }\n\t\telse\n\t\t{\n\t        return evt.button === 1;\n\t    }\n\t},\n\t\n\t/**\n\t * Function: isMiddleMouseButton\n\t * \n\t * Returns true if the middle mouse button is pressed for the given event.\n\t * To check if a button is pressed during a mouseMove you should use the\n\t * <mxGraph.isMouseDown> property.\n\t */\n\tisMiddleMouseButton: function(evt)\n\t{\n\t\tif ('which' in evt)\n\t\t{\n\t        return evt.which === 2;\n\t    }\n\t\telse\n\t\t{\n\t        return evt.button === 4;\n\t    }\n\t},\n\t\n\t/**\n\t * Function: isRightMouseButton\n\t * \n\t * Returns true if the right mouse button was pressed. Note that this\n\t * button might not be available on some systems. For handling a popup\n\t * trigger <isPopupTrigger> should be used.\n\t */\n\tisRightMouseButton: function(evt)\n\t{\n\t\tif ('which' in evt)\n\t\t{\n\t        return evt.which === 3;\n\t    }\n\t\telse\n\t\t{\n\t        return evt.button === 2;\n\t    }\n\t},\n\n\t/**\n\t * Function: isPopupTrigger\n\t * \n\t * Returns true if the event is a popup trigger. This implementation\n\t * returns true if the right button or the left button and control was\n\t * pressed on a Mac.\n\t */\n\tisPopupTrigger: function(evt)\n\t{\n\t\treturn mxEvent.isRightMouseButton(evt) || (mxClient.IS_MAC && mxEvent.isControlDown(evt) &&\n\t\t\t!mxEvent.isShiftDown(evt) && !mxEvent.isMetaDown(evt) && !mxEvent.isAltDown(evt));\n\t},\n\n\t/**\n\t * Function: isShiftDown\n\t * \n\t * Returns true if the shift key is pressed for the given event.\n\t */\n\tisShiftDown: function(evt)\n\t{\n\t\treturn (evt != null) ? evt.shiftKey : false;\n\t},\n\n\t/**\n\t * Function: isAltDown\n\t * \n\t * Returns true if the alt key is pressed for the given event.\n\t */\n\tisAltDown: function(evt)\n\t{\n\t\treturn (evt != null) ? evt.altKey : false;\n\t},\n\n\t/**\n\t * Function: isControlDown\n\t * \n\t * Returns true if the control key is pressed for the given event.\n\t */\n\tisControlDown: function(evt)\n\t{\n\t\treturn (evt != null) ? evt.ctrlKey : false;\n\t},\n\n\t/**\n\t * Function: isMetaDown\n\t * \n\t * Returns true if the meta key is pressed for the given event.\n\t */\n\tisMetaDown: function(evt)\n\t{\n\t\treturn (evt != null) ? evt.metaKey : false;\n\t},\n\n\t/**\n\t * Function: getMainEvent\n\t * \n\t * Returns the touch or mouse event that contains the mouse coordinates.\n\t */\n\tgetMainEvent: function(e)\n\t{\n\t\tif ((e.type == 'touchstart' || e.type == 'touchmove') && e.touches != null && e.touches[0] != null)\n\t\t{\n\t\t\te = e.touches[0];\n\t\t}\n\t\telse if (e.type == 'touchend' && e.changedTouches != null && e.changedTouches[0] != null)\n\t\t{\n\t\t\te = e.changedTouches[0];\n\t\t}\n\t\t\n\t\treturn e;\n\t},\n\t\n\t/**\n\t * Function: getClientX\n\t * \n\t * Returns true if the meta key is pressed for the given event.\n\t */\n\tgetClientX: function(e)\n\t{\n\t\treturn mxEvent.getMainEvent(e).clientX;\n\t},\n\n\t/**\n\t * Function: getClientY\n\t * \n\t * Returns true if the meta key is pressed for the given event.\n\t */\n\tgetClientY: function(e)\n\t{\n\t\treturn mxEvent.getMainEvent(e).clientY;\n\t},\n\n\t/**\n\t * Function: consume\n\t * \n\t * Consumes the given event.\n\t * \n\t * Parameters:\n\t * \n\t * evt - Native event to be consumed.\n\t * preventDefault - Optional boolean to prevent the default for the event.\n\t * Default is true.\n\t * stopPropagation - Option boolean to stop event propagation. Default is\n\t * true.\n\t */\n\tconsume: function(evt, preventDefault, stopPropagation)\n\t{\n\t\tpreventDefault = (preventDefault != null) ? preventDefault : true;\n\t\tstopPropagation = (stopPropagation != null) ? stopPropagation : true;\n\t\t\n\t\tif (preventDefault)\n\t\t{\n\t\t\tif (evt.preventDefault)\n\t\t\t{\n\t\t\t\tif (stopPropagation)\n\t\t\t\t{\n\t\t\t\t\tevt.stopPropagation();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tevt.preventDefault();\n\t\t\t}\n\t\t\telse if (stopPropagation)\n\t\t\t{\n\t\t\t\tevt.cancelBubble = true;\n\t\t\t}\n\t\t}\n\n\t\t// Opera\n\t\tevt.isConsumed = true;\n\n\t\t// Other browsers\n\t\tif (!evt.preventDefault)\n\t\t{\n\t\t\tevt.returnValue = false;\n\t\t}\n\t},\n\t\n\t//\n\t// Special handles in mouse events\n\t//\n\t\n\t/**\n\t * Variable: LABEL_HANDLE\n\t * \n\t * Index for the label handle in an mxMouseEvent. This should be a negative\n\t * value that does not interfere with any possible handle indices. Default\n\t * is -1.\n\t */\n\tLABEL_HANDLE: -1,\n\t\n\t/**\n\t * Variable: ROTATION_HANDLE\n\t * \n\t * Index for the rotation handle in an mxMouseEvent. This should be a\n\t * negative value that does not interfere with any possible handle indices.\n\t * Default is -2.\n\t */\n\tROTATION_HANDLE: -2,\n\t\n\t/**\n\t * Variable: CUSTOM_HANDLE\n\t * \n\t * Start index for the custom handles in an mxMouseEvent. This should be a\n\t * negative value and is the start index which is decremented for each\n\t * custom handle. Default is -100.\n\t */\n\tCUSTOM_HANDLE: -100,\n\t\n\t/**\n\t * Variable: VIRTUAL_HANDLE\n\t * \n\t * Start index for the virtual handles in an mxMouseEvent. This should be a\n\t * negative value and is the start index which is decremented for each\n\t * virtual handle. Default is -100000. This assumes that there are no more\n\t * than VIRTUAL_HANDLE - CUSTOM_HANDLE custom handles.\n\t * \n\t */\n\tVIRTUAL_HANDLE: -100000,\n\t\n\t//\n\t// Event names\n\t//\n\t\n\t/**\n\t * Variable: MOUSE_DOWN\n\t *\n\t * Specifies the event name for mouseDown.\n\t */\n\tMOUSE_DOWN: 'mouseDown',\n\t\n\t/**\n\t * Variable: MOUSE_MOVE\n\t *\n\t * Specifies the event name for mouseMove. \n\t */\n\tMOUSE_MOVE: 'mouseMove',\n\t\n\t/**\n\t * Variable: MOUSE_UP\n\t *\n\t * Specifies the event name for mouseUp. \n\t */\n\tMOUSE_UP: 'mouseUp',\n\n\t/**\n\t * Variable: ACTIVATE\n\t *\n\t * Specifies the event name for activate.\n\t */\n\tACTIVATE: 'activate',\n\n\t/**\n\t * Variable: RESIZE_START\n\t *\n\t * Specifies the event name for resizeStart.\n\t */\n\tRESIZE_START: 'resizeStart',\n\n\t/**\n\t * Variable: RESIZE\n\t *\n\t * Specifies the event name for resize.\n\t */\n\tRESIZE: 'resize',\n\n\t/**\n\t * Variable: RESIZE_END\n\t *\n\t * Specifies the event name for resizeEnd.\n\t */\n\tRESIZE_END: 'resizeEnd',\n\n\t/**\n\t * Variable: MOVE_START\n\t *\n\t * Specifies the event name for moveStart.\n\t */\n\tMOVE_START: 'moveStart',\n\n\t/**\n\t * Variable: MOVE\n\t *\n\t * Specifies the event name for move.\n\t */\n\tMOVE: 'move',\n\n\t/**\n\t * Variable: MOVE_END\n\t *\n\t * Specifies the event name for moveEnd.\n\t */\n\tMOVE_END: 'moveEnd',\n\n\t/**\n\t * Variable: PAN_START\n\t *\n\t * Specifies the event name for panStart.\n\t */\n\tPAN_START: 'panStart',\n\n\t/**\n\t * Variable: PAN\n\t *\n\t * Specifies the event name for pan.\n\t */\n\tPAN: 'pan',\n\n\t/**\n\t * Variable: PAN_END\n\t *\n\t * Specifies the event name for panEnd.\n\t */\n\tPAN_END: 'panEnd',\n\n\t/**\n\t * Variable: MINIMIZE\n\t *\n\t * Specifies the event name for minimize.\n\t */\n\tMINIMIZE: 'minimize',\n\n\t/**\n\t * Variable: NORMALIZE\n\t *\n\t * Specifies the event name for normalize.\n\t */\n\tNORMALIZE: 'normalize',\n\n\t/**\n\t * Variable: MAXIMIZE\n\t *\n\t * Specifies the event name for maximize.\n\t */\n\tMAXIMIZE: 'maximize',\n\n\t/**\n\t * Variable: HIDE\n\t *\n\t * Specifies the event name for hide.\n\t */\n\tHIDE: 'hide',\n\n\t/**\n\t * Variable: SHOW\n\t *\n\t * Specifies the event name for show.\n\t */\n\tSHOW: 'show',\n\n\t/**\n\t * Variable: CLOSE\n\t *\n\t * Specifies the event name for close.\n\t */\n\tCLOSE: 'close',\n\n\t/**\n\t * Variable: DESTROY\n\t *\n\t * Specifies the event name for destroy.\n\t */\n\tDESTROY: 'destroy',\n\n\t/**\n\t * Variable: REFRESH\n\t *\n\t * Specifies the event name for refresh.\n\t */\n\tREFRESH: 'refresh',\n\n\t/**\n\t * Variable: SIZE\n\t *\n\t * Specifies the event name for size.\n\t */\n\tSIZE: 'size',\n\t\n\t/**\n\t * Variable: SELECT\n\t *\n\t * Specifies the event name for select.\n\t */\n\tSELECT: 'select',\n\n\t/**\n\t * Variable: FIRED\n\t *\n\t * Specifies the event name for fired.\n\t */\n\tFIRED: 'fired',\n\n\t/**\n\t * Variable: FIRE_MOUSE_EVENT\n\t *\n\t * Specifies the event name for fireMouseEvent.\n\t */\n\tFIRE_MOUSE_EVENT: 'fireMouseEvent',\n\n\t/**\n\t * Variable: GESTURE\n\t *\n\t * Specifies the event name for gesture.\n\t */\n\tGESTURE: 'gesture',\n\n\t/**\n\t * Variable: TAP_AND_HOLD\n\t *\n\t * Specifies the event name for tapAndHold.\n\t */\n\tTAP_AND_HOLD: 'tapAndHold',\n\n\t/**\n\t * Variable: GET\n\t *\n\t * Specifies the event name for get.\n\t */\n\tGET: 'get',\n\n\t/**\n\t * Variable: RECEIVE\n\t *\n\t * Specifies the event name for receive.\n\t */\n\tRECEIVE: 'receive',\n\n\t/**\n\t * Variable: CONNECT\n\t *\n\t * Specifies the event name for connect.\n\t */\n\tCONNECT: 'connect',\n\n\t/**\n\t * Variable: DISCONNECT\n\t *\n\t * Specifies the event name for disconnect.\n\t */\n\tDISCONNECT: 'disconnect',\n\n\t/**\n\t * Variable: SUSPEND\n\t *\n\t * Specifies the event name for suspend.\n\t */\n\tSUSPEND: 'suspend',\n\n\t/**\n\t * Variable: RESUME\n\t *\n\t * Specifies the event name for suspend.\n\t */\n\tRESUME: 'resume',\n\n\t/**\n\t * Variable: MARK\n\t *\n\t * Specifies the event name for mark.\n\t */\n\tMARK: 'mark',\n\n\t/**\n\t * Variable: ROOT\n\t *\n\t * Specifies the event name for root.\n\t */\n\tROOT: 'root',\n\n\t/**\n\t * Variable: POST\n\t *\n\t * Specifies the event name for post.\n\t */\n\tPOST: 'post',\n\n\t/**\n\t * Variable: OPEN\n\t *\n\t * Specifies the event name for open.\n\t */\n\tOPEN: 'open',\n\n\t/**\n\t * Variable: SAVE\n\t *\n\t * Specifies the event name for open.\n\t */\n\tSAVE: 'save',\n\n\t/**\n\t * Variable: BEFORE_ADD_VERTEX\n\t *\n\t * Specifies the event name for beforeAddVertex.\n\t */\n\tBEFORE_ADD_VERTEX: 'beforeAddVertex',\n\n\t/**\n\t * Variable: ADD_VERTEX\n\t *\n\t * Specifies the event name for addVertex.\n\t */\n\tADD_VERTEX: 'addVertex',\n\n\t/**\n\t * Variable: AFTER_ADD_VERTEX\n\t *\n\t * Specifies the event name for afterAddVertex.\n\t */\n\tAFTER_ADD_VERTEX: 'afterAddVertex',\n\n\t/**\n\t * Variable: DONE\n\t *\n\t * Specifies the event name for done.\n\t */\n\tDONE: 'done',\n\n\t/**\n\t * Variable: EXECUTE\n\t *\n\t * Specifies the event name for execute.\n\t */\n\tEXECUTE: 'execute',\n\n\t/**\n\t * Variable: EXECUTED\n\t *\n\t * Specifies the event name for executed.\n\t */\n\tEXECUTED: 'executed',\n\n\t/**\n\t * Variable: BEGIN_UPDATE\n\t *\n\t * Specifies the event name for beginUpdate.\n\t */\n\tBEGIN_UPDATE: 'beginUpdate',\n\n\t/**\n\t * Variable: START_EDIT\n\t *\n\t * Specifies the event name for startEdit.\n\t */\n\tSTART_EDIT: 'startEdit',\n\n\t/**\n\t * Variable: END_UPDATE\n\t *\n\t * Specifies the event name for endUpdate.\n\t */\n\tEND_UPDATE: 'endUpdate',\n\n\t/**\n\t * Variable: END_EDIT\n\t *\n\t * Specifies the event name for endEdit.\n\t */\n\tEND_EDIT: 'endEdit',\n\n\t/**\n\t * Variable: BEFORE_UNDO\n\t *\n\t * Specifies the event name for beforeUndo.\n\t */\n\tBEFORE_UNDO: 'beforeUndo',\n\n\t/**\n\t * Variable: UNDO\n\t *\n\t * Specifies the event name for undo.\n\t */\n\tUNDO: 'undo',\n\n\t/**\n\t * Variable: REDO\n\t *\n\t * Specifies the event name for redo.\n\t */\n\tREDO: 'redo',\n\n\t/**\n\t * Variable: CHANGE\n\t *\n\t * Specifies the event name for change.\n\t */\n\tCHANGE: 'change',\n\n\t/**\n\t * Variable: NOTIFY\n\t *\n\t * Specifies the event name for notify.\n\t */\n\tNOTIFY: 'notify',\n\n\t/**\n\t * Variable: LAYOUT_CELLS\n\t *\n\t * Specifies the event name for layoutCells.\n\t */\n\tLAYOUT_CELLS: 'layoutCells',\n\n\t/**\n\t * Variable: CLICK\n\t *\n\t * Specifies the event name for click.\n\t */\n\tCLICK: 'click',\n\n\t/**\n\t * Variable: SCALE\n\t *\n\t * Specifies the event name for scale.\n\t */\n\tSCALE: 'scale',\n\n\t/**\n\t * Variable: TRANSLATE\n\t *\n\t * Specifies the event name for translate.\n\t */\n\tTRANSLATE: 'translate',\n\n\t/**\n\t * Variable: SCALE_AND_TRANSLATE\n\t *\n\t * Specifies the event name for scaleAndTranslate.\n\t */\n\tSCALE_AND_TRANSLATE: 'scaleAndTranslate',\n\n\t/**\n\t * Variable: UP\n\t *\n\t * Specifies the event name for up.\n\t */\n\tUP: 'up',\n\n\t/**\n\t * Variable: DOWN\n\t *\n\t * Specifies the event name for down.\n\t */\n\tDOWN: 'down',\n\n\t/**\n\t * Variable: ADD\n\t *\n\t * Specifies the event name for add.\n\t */\n\tADD: 'add',\n\n\t/**\n\t * Variable: REMOVE\n\t *\n\t * Specifies the event name for remove.\n\t */\n\tREMOVE: 'remove',\n\t\n\t/**\n\t * Variable: CLEAR\n\t *\n\t * Specifies the event name for clear.\n\t */\n\tCLEAR: 'clear',\n\n\t/**\n\t * Variable: ADD_CELLS\n\t *\n\t * Specifies the event name for addCells.\n\t */\n\tADD_CELLS: 'addCells',\n\n\t/**\n\t * Variable: CELLS_ADDED\n\t *\n\t * Specifies the event name for cellsAdded.\n\t */\n\tCELLS_ADDED: 'cellsAdded',\n\n\t/**\n\t * Variable: MOVE_CELLS\n\t *\n\t * Specifies the event name for moveCells.\n\t */\n\tMOVE_CELLS: 'moveCells',\n\n\t/**\n\t * Variable: CELLS_MOVED\n\t *\n\t * Specifies the event name for cellsMoved.\n\t */\n\tCELLS_MOVED: 'cellsMoved',\n\n\t/**\n\t * Variable: RESIZE_CELLS\n\t *\n\t * Specifies the event name for resizeCells.\n\t */\n\tRESIZE_CELLS: 'resizeCells',\n\n\t/**\n\t * Variable: CELLS_RESIZED\n\t *\n\t * Specifies the event name for cellsResized.\n\t */\n\tCELLS_RESIZED: 'cellsResized',\n\n\t/**\n\t * Variable: TOGGLE_CELLS\n\t *\n\t * Specifies the event name for toggleCells.\n\t */\n\tTOGGLE_CELLS: 'toggleCells',\n\n\t/**\n\t * Variable: CELLS_TOGGLED\n\t *\n\t * Specifies the event name for cellsToggled.\n\t */\n\tCELLS_TOGGLED: 'cellsToggled',\n\n\t/**\n\t * Variable: ORDER_CELLS\n\t *\n\t * Specifies the event name for orderCells.\n\t */\n\tORDER_CELLS: 'orderCells',\n\n\t/**\n\t * Variable: CELLS_ORDERED\n\t *\n\t * Specifies the event name for cellsOrdered.\n\t */\n\tCELLS_ORDERED: 'cellsOrdered',\n\n\t/**\n\t * Variable: REMOVE_CELLS\n\t *\n\t * Specifies the event name for removeCells.\n\t */\n\tREMOVE_CELLS: 'removeCells',\n\n\t/**\n\t * Variable: CELLS_REMOVED\n\t *\n\t * Specifies the event name for cellsRemoved.\n\t */\n\tCELLS_REMOVED: 'cellsRemoved',\n\n\t/**\n\t * Variable: GROUP_CELLS\n\t *\n\t * Specifies the event name for groupCells.\n\t */\n\tGROUP_CELLS: 'groupCells',\n\n\t/**\n\t * Variable: UNGROUP_CELLS\n\t *\n\t * Specifies the event name for ungroupCells.\n\t */\n\tUNGROUP_CELLS: 'ungroupCells',\n\n\t/**\n\t * Variable: REMOVE_CELLS_FROM_PARENT\n\t *\n\t * Specifies the event name for removeCellsFromParent.\n\t */\n\tREMOVE_CELLS_FROM_PARENT: 'removeCellsFromParent',\n\n\t/**\n\t * Variable: FOLD_CELLS\n\t *\n\t * Specifies the event name for foldCells.\n\t */\n\tFOLD_CELLS: 'foldCells',\n\n\t/**\n\t * Variable: CELLS_FOLDED\n\t *\n\t * Specifies the event name for cellsFolded.\n\t */\n\tCELLS_FOLDED: 'cellsFolded',\n\n\t/**\n\t * Variable: ALIGN_CELLS\n\t *\n\t * Specifies the event name for alignCells.\n\t */\n\tALIGN_CELLS: 'alignCells',\n\n\t/**\n\t * Variable: LABEL_CHANGED\n\t *\n\t * Specifies the event name for labelChanged.\n\t */\n\tLABEL_CHANGED: 'labelChanged',\n\n\t/**\n\t * Variable: CONNECT_CELL\n\t *\n\t * Specifies the event name for connectCell.\n\t */\n\tCONNECT_CELL: 'connectCell',\n\n\t/**\n\t * Variable: CELL_CONNECTED\n\t *\n\t * Specifies the event name for cellConnected.\n\t */\n\tCELL_CONNECTED: 'cellConnected',\n\n\t/**\n\t * Variable: SPLIT_EDGE\n\t *\n\t * Specifies the event name for splitEdge.\n\t */\n\tSPLIT_EDGE: 'splitEdge',\n\n\t/**\n\t * Variable: FLIP_EDGE\n\t *\n\t * Specifies the event name for flipEdge.\n\t */\n\tFLIP_EDGE: 'flipEdge',\n\n\t/**\n\t * Variable: START_EDITING\n\t *\n\t * Specifies the event name for startEditing.\n\t */\n\tSTART_EDITING: 'startEditing',\n\n\t/**\n\t * Variable: EDITING_STARTED\n\t *\n\t * Specifies the event name for editingStarted.\n\t */\n\tEDITING_STARTED: 'editingStarted',\n\n\t/**\n\t * Variable: EDITING_STOPPED\n\t *\n\t * Specifies the event name for editingStopped.\n\t */\n\tEDITING_STOPPED: 'editingStopped',\n\n\t/**\n\t * Variable: ADD_OVERLAY\n\t *\n\t * Specifies the event name for addOverlay.\n\t */\n\tADD_OVERLAY: 'addOverlay',\n\n\t/**\n\t * Variable: REMOVE_OVERLAY\n\t *\n\t * Specifies the event name for removeOverlay.\n\t */\n\tREMOVE_OVERLAY: 'removeOverlay',\n\n\t/**\n\t * Variable: UPDATE_CELL_SIZE\n\t *\n\t * Specifies the event name for updateCellSize.\n\t */\n\tUPDATE_CELL_SIZE: 'updateCellSize',\n\n\t/**\n\t * Variable: ESCAPE\n\t *\n\t * Specifies the event name for escape.\n\t */\n\tESCAPE: 'escape',\n\n\t/**\n\t * Variable: DOUBLE_CLICK\n\t *\n\t * Specifies the event name for doubleClick.\n\t */\n\tDOUBLE_CLICK: 'doubleClick',\n\n\t/**\n\t * Variable: START\n\t *\n\t * Specifies the event name for start.\n\t */\n\tSTART: 'start',\n\n\t/**\n\t * Variable: RESET\n\t *\n\t * Specifies the event name for reset.\n\t */\n\tRESET: 'reset',\n\n\t/**\n\t * Variable: PINCH_THRESHOLD\n\t *\n\t * Threshold for pinch gestures to fire a mouse wheel event.\n\t * Default value is 10.\n\t */\n\tPINCH_THRESHOLD: 10\n\n};\n\n__mxOutput.mxEvent = typeof mxEvent !== 'undefined' ? mxEvent : undefined;\n\n/**\n * Copyright (c) 2006-2020, JGraph Ltd\n * Copyright (c) 2006-2020, draw.io AG\n */\n/**\n * Class: mxXmlRequest\n * \n * XML HTTP request wrapper. See also: <mxUtils.get>, <mxUtils.post> and\n * <mxUtils.load>. This class provides a cross-browser abstraction for Ajax\n * requests.\n * \n * Encoding:\n * \n * For encoding parameter values, the built-in encodeURIComponent JavaScript\n * method must be used. For automatic encoding of post data in <mxEditor> the\n * <mxEditor.escapePostData> switch can be set to true (default). The encoding\n * will be carried out using the conte type of the page. That is, the page\n * containting the editor should contain a meta tag in the header, eg.\n * <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n * \n * Example:\n * \n * (code)\n * var onload = function(req)\n * {\n *   mxUtils.alert(req.getDocumentElement());\n * }\n * \n * var onerror = function(req)\n * {\n *   mxUtils.alert('Error');\n * }\n * new mxXmlRequest(url, 'key=value').send(onload, onerror);\n * (end)\n * \n * Sends an asynchronous POST request to the specified URL.\n * \n * Example:\n * \n * (code)\n * var req = new mxXmlRequest(url, 'key=value', 'POST', false);\n * req.send();\n * mxUtils.alert(req.getDocumentElement());\n * (end)\n * \n * Sends a synchronous POST request to the specified URL.\n * \n * Example:\n * \n * (code)\n * var encoder = new mxCodec();\n * var result = encoder.encode(graph.getModel());\n * var xml = encodeURIComponent(mxUtils.getXml(result));\n * new mxXmlRequest(url, 'xml='+xml).send();\n * (end)\n * \n * Sends an encoded graph model to the specified URL using xml as the\n * parameter name. The parameter can then be retrieved in C# as follows:\n * \n * (code)\n * string xml = HttpUtility.UrlDecode(context.Request.Params[\"xml\"]);\n * (end)\n * \n * Or in Java as follows:\n * \n * (code)\n * String xml = URLDecoder.decode(request.getParameter(\"xml\"), \"UTF-8\").replace(\"\\n\", \"&#xa;\");\n * (end)\n *\n * Note that the linefeeds should only be replaced if the XML is\n * processed in Java, for example when creating an image.\n * \n * Constructor: mxXmlRequest\n * \n * Constructs an XML HTTP request.\n * \n * Parameters:\n * \n * url - Target URL of the request.\n * params - Form encoded parameters to send with a POST request.\n * method - String that specifies the request method. Possible values are\n * POST and GET. Default is POST.\n * async - Boolean specifying if an asynchronous request should be used.\n * Default is true.\n * username - String specifying the username to be used for the request.\n * password - String specifying the password to be used for the request.\n */\nfunction mxXmlRequest(url, params, method, async, username, password)\n{\n\tthis.url = url;\n\tthis.params = params;\n\tthis.method = method || 'POST';\n\tthis.async = (async != null) ? async : true;\n\tthis.username = username;\n\tthis.password = password;\n};\n\n/**\n * Variable: url\n * \n * Holds the target URL of the request.\n */\nmxXmlRequest.prototype.url = null;\n\n/**\n * Variable: params\n * \n * Holds the form encoded data for the POST request.\n */\nmxXmlRequest.prototype.params = null;\n\n/**\n * Variable: method\n * \n * Specifies the request method. Possible values are POST and GET. Default\n * is POST.\n */\nmxXmlRequest.prototype.method = null;\n\n/**\n * Variable: async\n * \n * Boolean indicating if the request is asynchronous.\n */\nmxXmlRequest.prototype.async = null;\n\n/**\n * Variable: binary\n * \n * Boolean indicating if the request is binary. This option is ignored in IE.\n * In all other browsers the requested mime type is set to\n * text/plain; charset=x-user-defined. Default is false.\n */\nmxXmlRequest.prototype.binary = false;\n\n/**\n * Variable: withCredentials\n * \n * Specifies if withCredentials should be used in HTML5-compliant browsers. Default is\n * false.\n */\nmxXmlRequest.prototype.withCredentials = false;\n\n/**\n * Variable: username\n * \n * Specifies the username to be used for authentication.\n */\nmxXmlRequest.prototype.username = null;\n\n/**\n * Variable: password\n * \n * Specifies the password to be used for authentication.\n */\nmxXmlRequest.prototype.password = null;\n\n/**\n * Variable: request\n * \n * Holds the inner, browser-specific request object.\n */\nmxXmlRequest.prototype.request = null;\n\n/**\n * Variable: decodeSimulateValues\n * \n * Specifies if request values should be decoded as URIs before setting the\n * textarea value in <simulate>. Defaults to false for backwards compatibility,\n * to avoid another decode on the server this should be set to true.\n */\nmxXmlRequest.prototype.decodeSimulateValues = false;\n\n/**\n * Function: isBinary\n * \n * Returns <binary>.\n */\nmxXmlRequest.prototype.isBinary = function()\n{\n\treturn this.binary;\n};\n\n/**\n * Function: setBinary\n * \n * Sets <binary>.\n */\nmxXmlRequest.prototype.setBinary = function(value)\n{\n\tthis.binary = value;\n};\n\n/**\n * Function: getText\n * \n * Returns the response as a string.\n */\nmxXmlRequest.prototype.getText = function()\n{\n\treturn this.request.responseText;\n};\n\n/**\n * Function: isReady\n * \n * Returns true if the response is ready.\n */\nmxXmlRequest.prototype.isReady = function()\n{\n\treturn this.request.readyState == 4;\n};\n\n/**\n * Function: getDocumentElement\n * \n * Returns the document element of the response XML document.\n */\nmxXmlRequest.prototype.getDocumentElement = function()\n{\n\tvar doc = this.getXml();\n\t\n\tif (doc != null)\n\t{\n\t\treturn doc.documentElement;\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: getXml\n * \n * Returns the response as an XML document. Use <getDocumentElement> to get\n * the document element of the XML document.\n */\nmxXmlRequest.prototype.getXml = function()\n{\n\tvar xml = this.request.responseXML;\n\t\n\t// Handles missing response headers in IE, the first condition handles\n\t// the case where responseXML is there, but using its nodes leads to\n\t// type errors in the mxCellCodec when putting the nodes into a new\n\t// document. This happens in IE9 standards mode and with XML user\n\t// objects only, as they are used directly as values in cells.\n\tif (document.documentMode >= 9 || xml == null || xml.documentElement == null)\n\t{\n\t\txml = mxUtils.parseXml(this.request.responseText);\n\t}\n\t\n\treturn xml;\n};\n\n/**\n * Function: getStatus\n * \n * Returns the status as a number, eg. 404 for \"Not found\" or 200 for \"OK\".\n * Note: The NS_ERROR_NOT_AVAILABLE for invalid responses cannot be cought.\n */\nmxXmlRequest.prototype.getStatus = function()\n{\n\treturn (this.request != null) ? this.request.status : null;\n};\n\n/**\n * Function: create\n * \n * Creates and returns the inner <request> object.\n */\nmxXmlRequest.prototype.create = function()\n{\n\tif (window.XMLHttpRequest)\n\t{\n\t\treturn function()\n\t\t{\n\t\t\tvar req = new XMLHttpRequest();\n\t\t\t\n\t\t\t// TODO: Check for overrideMimeType required here?\n\t\t\tif (this.isBinary() && req.overrideMimeType)\n\t\t\t{\n\t\t\t\treq.overrideMimeType('text/plain; charset=x-user-defined');\n\t\t\t}\n\n\t\t\treturn req;\n\t\t};\n\t}\n\telse if (typeof(ActiveXObject) != 'undefined')\n\t{\n\t\treturn function()\n\t\t{\n\t\t\t// TODO: Implement binary option\n\t\t\treturn new ActiveXObject('Microsoft.XMLHTTP');\n\t\t};\n\t}\n}();\n\n/**\n * Function: send\n * \n * Send the <request> to the target URL using the specified functions to\n * process the response asychronously.\n * \n * Note: Due to technical limitations, onerror is currently ignored.\n * \n * Parameters:\n * \n * onload - Function to be invoked if a successful response was received.\n * onerror - Function to be called on any error. Unused in this implementation, intended for overriden function.\n * timeout - Optional timeout in ms before calling ontimeout.\n * ontimeout - Optional function to execute on timeout.\n */\nmxXmlRequest.prototype.send = function(onload, onerror, timeout, ontimeout)\n{\n\tthis.request = this.create();\n\t\n\tif (this.request != null)\n\t{\n\t\tif (onload != null)\n\t\t{\n\t\t\tthis.request.onreadystatechange = mxUtils.bind(this, function()\n\t\t\t{\n\t\t\t\tif (this.isReady())\n\t\t\t\t{\n\t\t\t\t\tonload(this);\n\t\t\t\t\tthis.request.onreadystatechange = null;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.request.open(this.method, this.url, this.async,\n\t\t\tthis.username, this.password);\n\t\tthis.setRequestHeaders(this.request, this.params);\n\t\t\n\t\tif (window.XMLHttpRequest && this.withCredentials)\n\t\t{\n\t\t\tthis.request.withCredentials = 'true';\n\t\t}\n\t\t\n\t\tif (!mxClient.IS_QUIRKS && (document.documentMode == null || document.documentMode > 9) &&\n\t\t\twindow.XMLHttpRequest && timeout != null && ontimeout != null)\n\t\t{\n\t\t\tthis.request.timeout = timeout;\n\t\t\tthis.request.ontimeout = ontimeout;\n\t\t}\n\t\t\t\t\n\t\tthis.request.send(this.params);\n\t}\n};\n\n/**\n * Function: setRequestHeaders\n * \n * Sets the headers for the given request and parameters. This sets the\n * content-type to application/x-www-form-urlencoded if any params exist.\n * \n * Example:\n * \n * (code)\n * request.setRequestHeaders = function(request, params)\n * {\n *   if (params != null)\n *   {\n *     request.setRequestHeader('Content-Type',\n *             'multipart/form-data');\n *     request.setRequestHeader('Content-Length',\n *             params.length);\n *   }\n * };\n * (end)\n * \n * Use the code above before calling <send> if you require a\n * multipart/form-data request.   \n */\nmxXmlRequest.prototype.setRequestHeaders = function(request, params)\n{\n\tif (params != null)\n\t{\n\t\trequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\t}\n};\n\n/**\n * Function: simulate\n * \n * Creates and posts a request to the given target URL using a dynamically\n * created form inside the given document.\n * \n * Parameters:\n * \n * docs - Document that contains the form element.\n * target - Target to send the form result to.\n */\nmxXmlRequest.prototype.simulate = function(doc, target)\n{\n\tdoc = doc || document;\n\tvar old = null;\n\n\tif (doc == document)\n\t{\n\t\told = window.onbeforeunload;\t\t\n\t\twindow.onbeforeunload = null;\n\t}\n\t\t\t\n\tvar form = doc.createElement('form');\n\tform.setAttribute('method', this.method);\n\tform.setAttribute('action', this.url);\n\n\tif (target != null)\n\t{\n\t\tform.setAttribute('target', target);\n\t}\n\n\tform.style.display = 'none';\n\tform.style.visibility = 'hidden';\n\t\n\tvar pars = (this.params.indexOf('&') > 0) ?\n\t\tthis.params.split('&') :\n\t\tthis.params.split();\n\n\t// Adds the parameters as textareas to the form\n\tfor (var i=0; i<pars.length; i++)\n\t{\n\t\tvar pos = pars[i].indexOf('=');\n\t\t\n\t\tif (pos > 0)\n\t\t{\n\t\t\tvar name = pars[i].substring(0, pos);\n\t\t\tvar value = pars[i].substring(pos+1);\n\t\t\t\n\t\t\tif (this.decodeSimulateValues)\n\t\t\t{\n\t\t\t\tvalue = decodeURIComponent(value);\n\t\t\t}\n\t\t\t\n\t\t\tvar textarea = doc.createElement('textarea');\n\t\t\ttextarea.setAttribute('wrap', 'off');\n\t\t\ttextarea.setAttribute('name', name);\n\t\t\tmxUtils.write(textarea, value);\n\t\t\tform.appendChild(textarea);\n\t\t}\n\t}\n\t\n\tdoc.body.appendChild(form);\n\tform.submit();\n\t\n\tif (form.parentNode != null)\n\t{\n\t\tform.parentNode.removeChild(form);\n\t}\n\n\tif (old != null)\n\t{\t\t\n\t\twindow.onbeforeunload = old;\n\t}\n};\n\n__mxOutput.mxXmlRequest = typeof mxXmlRequest !== 'undefined' ? mxXmlRequest : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxClipboard =\n{\n\t/**\n\t * Class: mxClipboard\n\t * \n\t * Singleton that implements a clipboard for graph cells.\n\t *\n\t * Example:\n\t * \n\t * (code)\n\t * mxClipboard.copy(graph);\n\t * mxClipboard.paste(graph2);\n\t * (end)\n\t *\n\t * This copies the selection cells from the graph to the clipboard and\n\t * pastes them into graph2.\n\t * \n\t * For fine-grained control of the clipboard data the <mxGraph.canExportCell>\n\t * and <mxGraph.canImportCell> functions can be overridden.\n\t * \n\t * To restore previous parents for pasted cells, the implementation for\n\t * <copy> and <paste> can be changed as follows.\n\t * \n\t * (code)\n\t * mxClipboard.copy = function(graph, cells)\n\t * {\n\t *   cells = cells || graph.getSelectionCells();\n\t *   var result = graph.getExportableCells(cells);\n\t *   \n\t *   mxClipboard.parents = new Object();\n\t *   \n\t *   for (var i = 0; i < result.length; i++)\n\t *   {\n\t *     mxClipboard.parents[i] = graph.model.getParent(cells[i]);\n\t *   }\n\t *   \n\t *   mxClipboard.insertCount = 1;\n\t *   mxClipboard.setCells(graph.cloneCells(result));\n\t *   \n\t *   return result;\n\t * };\n\t * \n\t * mxClipboard.paste = function(graph)\n\t * {\n\t *   if (!mxClipboard.isEmpty())\n\t *   {\n\t *     var cells = graph.getImportableCells(mxClipboard.getCells());\n\t *     var delta = mxClipboard.insertCount * mxClipboard.STEPSIZE;\n\t *     var parent = graph.getDefaultParent();\n\t *     \n\t *     graph.model.beginUpdate();\n\t *     try\n\t *     {\n\t *       for (var i = 0; i < cells.length; i++)\n\t *       {\n\t *         var tmp = (mxClipboard.parents != null && graph.model.contains(mxClipboard.parents[i])) ?\n\t *              mxClipboard.parents[i] : parent;\n\t *         cells[i] = graph.importCells([cells[i]], delta, delta, tmp)[0];\n\t *       }\n\t *     }\n\t *     finally\n\t *     {\n\t *       graph.model.endUpdate();\n\t *     }\n\t *     \n\t *     // Increments the counter and selects the inserted cells\n\t *     mxClipboard.insertCount++;\n\t *     graph.setSelectionCells(cells);\n\t *   }\n\t * };\n\t * (end)\n\t * \n\t * Variable: STEPSIZE\n\t * \n\t * Defines the step size to offset the cells after each paste operation.\n\t * Default is 10.\n\t */\n\tSTEPSIZE: 10,\n\n\t/**\n\t * Variable: insertCount\n\t * \n\t * Counts the number of times the clipboard data has been inserted.\n\t */\n\tinsertCount: 1,\n\n\t/**\n\t * Variable: cells\n\t * \n\t * Holds the array of <mxCells> currently in the clipboard.\n\t */\n\tcells: null,\n\n\t/**\n\t * Function: setCells\n\t * \n\t * Sets the cells in the clipboard. Fires a <mxEvent.CHANGE> event.\n\t */\n\tsetCells: function(cells)\n\t{\n\t\tmxClipboard.cells = cells;\n\t},\n\n\t/**\n\t * Function: getCells\n\t * \n\t * Returns  the cells in the clipboard.\n\t */\n\tgetCells: function()\n\t{\n\t\treturn mxClipboard.cells;\n\t},\n\t\n\t/**\n\t * Function: isEmpty\n\t * \n\t * Returns true if the clipboard currently has not data stored.\n\t */\n\tisEmpty: function()\n\t{\n\t\treturn mxClipboard.getCells() == null;\n\t},\n\t\n\t/**\n\t * Function: cut\n\t * \n\t * Cuts the given array of <mxCells> from the specified graph.\n\t * If cells is null then the selection cells of the graph will\n\t * be used. Returns the cells that have been cut from the graph.\n\t *\n\t * Parameters:\n\t * \n\t * graph - <mxGraph> that contains the cells to be cut.\n\t * cells - Optional array of <mxCells> to be cut.\n\t */\n\tcut: function(graph, cells)\n\t{\n\t\tcells = mxClipboard.copy(graph, cells);\n\t\tmxClipboard.insertCount = 0;\n\t\tmxClipboard.removeCells(graph, cells);\n\t\t\n\t\treturn cells;\n\t},\n\n\t/**\n\t * Function: removeCells\n\t * \n\t * Hook to remove the given cells from the given graph after\n\t * a cut operation.\n\t *\n\t * Parameters:\n\t * \n\t * graph - <mxGraph> that contains the cells to be cut.\n\t * cells - Array of <mxCells> to be cut.\n\t */\n\tremoveCells: function(graph, cells)\n\t{\n\t\tgraph.removeCells(cells);\n\t},\n\n\t/**\n\t * Function: copy\n\t * \n\t * Copies the given array of <mxCells> from the specified\n\t * graph to <cells>. Returns the original array of cells that has\n\t * been cloned. Descendants of cells in the array are ignored.\n\t * \n\t * Parameters:\n\t * \n\t * graph - <mxGraph> that contains the cells to be copied.\n\t * cells - Optional array of <mxCells> to be copied.\n\t */\n\tcopy: function(graph, cells)\n\t{\n\t\tcells = cells || graph.getSelectionCells();\n\t\tvar result = graph.getExportableCells(graph.model.getTopmostCells(cells));\n\t\tmxClipboard.insertCount = 1;\n\t\tmxClipboard.setCells(graph.cloneCells(result));\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Function: paste\n\t * \n\t * Pastes the <cells> into the specified graph restoring\n\t * the relation to <parents>, if possible. If the parents\n\t * are no longer in the graph or invisible then the\n\t * cells are added to the graph's default or into the\n\t * swimlane under the cell's new location if one exists.\n\t * The cells are added to the graph using <mxGraph.importCells>\n\t * and returned.\n\t * \n\t * Parameters:\n\t * \n\t * graph - <mxGraph> to paste the <cells> into.\n\t */\n\tpaste: function(graph)\n\t{\n\t\tvar cells = null;\n\t\t\n\t\tif (!mxClipboard.isEmpty())\n\t\t{\n\t\t\tcells = graph.getImportableCells(mxClipboard.getCells());\n\t\t\tvar delta = mxClipboard.insertCount * mxClipboard.STEPSIZE;\n\t\t\tvar parent = graph.getDefaultParent();\n\t\t\tcells = graph.importCells(cells, delta, delta, parent);\n\t\t\t\n\t\t\t// Increments the counter and selects the inserted cells\n\t\t\tmxClipboard.insertCount++;\n\t\t\tgraph.setSelectionCells(cells);\n\t\t}\n\t\t\n\t\treturn cells;\n\t}\n\n};\n\n__mxOutput.mxClipboard = typeof mxClipboard !== 'undefined' ? mxClipboard : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxWindow\n * \n * Basic window inside a document.\n * \n * Examples:\n * \n * Creating a simple window.\n *\n * (code)\n * var tb = document.createElement('div');\n * var wnd = new mxWindow('Title', tb, 100, 100, 200, 200, true, true);\n * wnd.setVisible(true); \n * (end)\n *\n * Creating a window that contains an iframe. \n * \n * (code)\n * var frame = document.createElement('iframe');\n * frame.setAttribute('width', '192px');\n * frame.setAttribute('height', '172px');\n * frame.setAttribute('src', 'http://www.example.com/');\n * frame.style.backgroundColor = 'white';\n * \n * var w = document.body.clientWidth;\n * var h = (document.body.clientHeight || document.documentElement.clientHeight);\n * var wnd = new mxWindow('Title', frame, (w-200)/2, (h-200)/3, 200, 200);\n * wnd.setVisible(true);\n * (end)\n * \n * To limit the movement of a window, eg. to keep it from being moved beyond\n * the top, left corner the following method can be overridden (recommended):\n * \n * (code)\n * wnd.setLocation = function(x, y)\n * {\n *   x = Math.max(0, x);\n *   y = Math.max(0, y);\n *   mxWindow.prototype.setLocation.apply(this, arguments);\n * };\n * (end)\n * \n * Or the following event handler can be used:\n * \n * (code)\n * wnd.addListener(mxEvent.MOVE, function(e)\n * {\n *   wnd.setLocation(Math.max(0, wnd.getX()), Math.max(0, wnd.getY()));\n * });\n * (end)\n * \n * To keep a window inside the current window:\n * \n * (code)\n * mxEvent.addListener(window, 'resize', mxUtils.bind(this, function()\n * {\n *   var iw = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n *   var ih = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n *   \n *   var x = this.window.getX();\n *   var y = this.window.getY();\n *   \n *   if (x + this.window.table.clientWidth > iw)\n *   {\n *     x = Math.max(0, iw - this.window.table.clientWidth);\n *   }\n *   \n *   if (y + this.window.table.clientHeight > ih)\n *   {\n *     y = Math.max(0, ih - this.window.table.clientHeight);\n *   }\n *   \n *   if (this.window.getX() != x || this.window.getY() != y)\n *   {\n *     this.window.setLocation(x, y);\n *   }\n * }));\n * (end)\n *\n * Event: mxEvent.MOVE_START\n *\n * Fires before the window is moved. The <code>event</code> property contains\n * the corresponding mouse event.\n *\n * Event: mxEvent.MOVE\n *\n * Fires while the window is being moved. The <code>event</code> property\n * contains the corresponding mouse event.\n *\n * Event: mxEvent.MOVE_END\n *\n * Fires after the window is moved. The <code>event</code> property contains\n * the corresponding mouse event.\n *\n * Event: mxEvent.RESIZE_START\n *\n * Fires before the window is resized. The <code>event</code> property contains\n * the corresponding mouse event.\n *\n * Event: mxEvent.RESIZE\n *\n * Fires while the window is being resized. The <code>event</code> property\n * contains the corresponding mouse event.\n *\n * Event: mxEvent.RESIZE_END\n *\n * Fires after the window is resized. The <code>event</code> property contains\n * the corresponding mouse event.\n *\n * Event: mxEvent.MAXIMIZE\n * \n * Fires after the window is maximized. The <code>event</code> property\n * contains the corresponding mouse event.\n * \n * Event: mxEvent.MINIMIZE\n * \n * Fires after the window is minimized. The <code>event</code> property\n * contains the corresponding mouse event.\n * \n * Event: mxEvent.NORMALIZE\n * \n * Fires after the window is normalized, that is, it returned from\n * maximized or minimized state. The <code>event</code> property contains the\n * corresponding mouse event.\n *  \n * Event: mxEvent.ACTIVATE\n * \n * Fires after a window is activated. The <code>previousWindow</code> property\n * contains the previous window. The event sender is the active window.\n * \n * Event: mxEvent.SHOW\n * \n * Fires after the window is shown. This event has no properties.\n * \n * Event: mxEvent.HIDE\n * \n * Fires after the window is hidden. This event has no properties.\n * \n * Event: mxEvent.CLOSE\n * \n * Fires before the window is closed. The <code>event</code> property contains\n * the corresponding mouse event.\n * \n * Event: mxEvent.DESTROY\n * \n * Fires before the window is destroyed. This event has no properties.\n * \n * Constructor: mxWindow\n * \n * Constructs a new window with the given dimension and title to display\n * the specified content. The window elements use the given style as a\n * prefix for the classnames of the respective window elements, namely,\n * the window title and window pane. The respective postfixes are appended\n * to the given stylename as follows:\n * \n *   style - Base style for the window.\n *   style+Title - Style for the window title.\n *   style+Pane - Style for the window pane.\n * \n * The default value for style is mxWindow, resulting in the following\n * classnames for the window elements: mxWindow, mxWindowTitle and\n * mxWindowPane.\n * \n * If replaceNode is given then the window replaces the given DOM node in\n * the document.\n * \n * Parameters:\n * \n * title - String that represents the title of the new window.\n * content - DOM node that is used as the window content.\n * x - X-coordinate of the window location.\n * y - Y-coordinate of the window location.\n * width - Width of the window.\n * height - Optional height of the window. Default is to match the height\n * of the content at the specified width.\n * minimizable - Optional boolean indicating if the window is minimizable.\n * Default is true.\n * movable - Optional boolean indicating if the window is movable. Default\n * is true.\n * replaceNode - Optional DOM node that the window should replace.\n * style - Optional base classname for the window elements. Default is\n * mxWindow.\n */\nfunction mxWindow(title, content, x, y, width, height, minimizable, movable, replaceNode, style)\n{\n\tif (content != null)\n\t{\n\t\tminimizable = (minimizable != null) ? minimizable : true;\n\t\tthis.content = content;\n\t\tthis.init(x, y, width, height, style);\n\t\t\n\t\tthis.installMaximizeHandler();\n\t\tthis.installMinimizeHandler();\n\t\tthis.installCloseHandler();\n\t\tthis.setMinimizable(minimizable);\n\t\tthis.setTitle(title);\n\t\t\n\t\tif (movable == null || movable)\n\t\t{\n\t\t\tthis.installMoveHandler();\n\t\t}\n\n\t\tif (replaceNode != null && replaceNode.parentNode != null)\n\t\t{\n\t\t\treplaceNode.parentNode.replaceChild(this.div, replaceNode);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdocument.body.appendChild(this.div);\n\t\t}\n\t}\n};\n\n/**\n * Extends mxEventSource.\n */\nmxWindow.prototype = new mxEventSource();\nmxWindow.prototype.constructor = mxWindow;\n\n/**\n * Variable: closeImage\n * \n * URL of the image to be used for the close icon in the titlebar.\n */\nmxWindow.prototype.closeImage = mxClient.imageBasePath + '/close.gif';\n\n/**\n * Variable: minimizeImage\n * \n * URL of the image to be used for the minimize icon in the titlebar.\n */\nmxWindow.prototype.minimizeImage = mxClient.imageBasePath + '/minimize.gif';\n\t\n/**\n * Variable: normalizeImage\n * \n * URL of the image to be used for the normalize icon in the titlebar.\n */\nmxWindow.prototype.normalizeImage = mxClient.imageBasePath + '/normalize.gif';\n\t\n/**\n * Variable: maximizeImage\n * \n * URL of the image to be used for the maximize icon in the titlebar.\n */\nmxWindow.prototype.maximizeImage = mxClient.imageBasePath + '/maximize.gif';\n\n/**\n * Variable: resizeImage\n * \n * URL of the image to be used for the resize icon.\n */\nmxWindow.prototype.resizeImage = mxClient.imageBasePath + '/resize.gif';\n\n/**\n * Variable: visible\n * \n * Boolean flag that represents the visible state of the window.\n */\nmxWindow.prototype.visible = false;\n\n/**\n * Variable: minimumSize\n * \n * <mxRectangle> that specifies the minimum width and height of the window.\n * Default is (50, 40).\n */\nmxWindow.prototype.minimumSize = new mxRectangle(0, 0, 50, 40);\n\n/**\n * Variable: destroyOnClose\n * \n * Specifies if the window should be destroyed when it is closed. If this\n * is false then the window is hidden using <setVisible>. Default is true.\n */\nmxWindow.prototype.destroyOnClose = true;\n\n/**\n * Variable: contentHeightCorrection\n * \n * Defines the correction factor for computing the height of the contentWrapper.\n * Default is 6 for IE 7/8 standards mode and 2 for all other browsers and modes.\n */\nmxWindow.prototype.contentHeightCorrection = (document.documentMode == 8 || document.documentMode == 7) ? 6 : 2;\n\n/**\n * Variable: title\n * \n * Reference to the DOM node (TD) that contains the title.\n */\nmxWindow.prototype.title = null;\n\n/**\n * Variable: content\n * \n * Reference to the DOM node that represents the window content.\n */\nmxWindow.prototype.content = null;\n\n/**\n * Function: init\n * \n * Initializes the DOM tree that represents the window.\n */\nmxWindow.prototype.init = function(x, y, width, height, style)\n{\n\tstyle = (style != null) ? style : 'mxWindow';\n\t\n\tthis.div = document.createElement('div');\n\tthis.div.className = style;\n\n\tthis.div.style.left = x + 'px';\n\tthis.div.style.top = y + 'px';\n\tthis.table = document.createElement('table');\n\tthis.table.className = style;\n\n\t// Disables built-in pan and zoom in IE10 and later\n\tif (mxClient.IS_POINTER)\n\t{\n\t\tthis.div.style.touchAction = 'none';\n\t}\n\t\n\t// Workaround for table size problems in FF\n\tif (width != null)\n\t{\n\t\tif (!mxClient.IS_QUIRKS)\n\t\t{\n\t\t\tthis.div.style.width = width + 'px'; \n\t\t}\n\t\t\n\t\tthis.table.style.width = width + 'px';\n\t} \n\t\n\tif (height != null)\n\t{\n\t\tif (!mxClient.IS_QUIRKS)\n\t\t{\n\t\t\tthis.div.style.height = height + 'px';\n\t\t}\n\t\t\n\t\tthis.table.style.height = height + 'px';\n\t}\t\t\n\t\n\t// Creates title row\n\tvar tbody = document.createElement('tbody');\n\tvar tr = document.createElement('tr');\n\t\n\tthis.title = document.createElement('td');\n\tthis.title.className = style + 'Title';\n\t\n\tthis.buttons = document.createElement('div');\n\tthis.buttons.style.position = 'absolute';\n\tthis.buttons.style.display = 'inline-block';\n\tthis.buttons.style.right = '4px';\n\tthis.buttons.style.top = '5px';\n\tthis.title.appendChild(this.buttons);\n\t\n\ttr.appendChild(this.title);\n\ttbody.appendChild(tr);\n\t\n\t// Creates content row and table cell\n\ttr = document.createElement('tr');\n\tthis.td = document.createElement('td');\n\tthis.td.className = style + 'Pane';\n\t\n\tif (document.documentMode == 7)\n\t{\n\t\tthis.td.style.height = '100%';\n\t}\n\n\tthis.contentWrapper = document.createElement('div');\n\tthis.contentWrapper.className = style + 'Pane';\n\tthis.contentWrapper.style.width = '100%';\n\tthis.contentWrapper.appendChild(this.content);\n\n\t// Workaround for div around div restricts height\n\t// of inner div if outerdiv has hidden overflow\n\tif (mxClient.IS_QUIRKS || this.content.nodeName.toUpperCase() != 'DIV')\n\t{\n\t\tthis.contentWrapper.style.height = '100%';\n\t}\n\n\t// Puts all content into the DOM\n\tthis.td.appendChild(this.contentWrapper);\n\ttr.appendChild(this.td);\n\ttbody.appendChild(tr);\n\tthis.table.appendChild(tbody);\n\tthis.div.appendChild(this.table);\n\t\n\t// Puts the window on top of other windows when clicked\n\tvar activator = mxUtils.bind(this, function(evt)\n\t{\n\t\tthis.activate();\n\t});\n\t\n\tmxEvent.addGestureListeners(this.title, activator);\n\tmxEvent.addGestureListeners(this.table, activator);\n\n\tthis.hide();\n};\n\n/**\n * Function: setTitle\n * \n * Sets the window title to the given string. HTML markup inside the title\n * will be escaped.\n */\nmxWindow.prototype.setTitle = function(title)\n{\n\t// Removes all text content nodes (normally just one)\n\tvar child = this.title.firstChild;\n\t\n\twhile (child != null)\n\t{\n\t\tvar next = child.nextSibling;\n\t\t\n\t\tif (child.nodeType == mxConstants.NODETYPE_TEXT)\n\t\t{\n\t\t\tchild.parentNode.removeChild(child);\n\t\t}\n\t\t\n\t\tchild = next;\n\t}\n\t\n\tmxUtils.write(this.title, title || '');\n\tthis.title.appendChild(this.buttons);\n};\n\n/**\n * Function: setScrollable\n * \n * Sets if the window contents should be scrollable.\n */\nmxWindow.prototype.setScrollable = function(scrollable)\n{\n\t// Workaround for hang in Presto 2.5.22 (Opera 10.5)\n\tif (navigator.userAgent == null ||\n\t\tnavigator.userAgent.indexOf('Presto/2.5') < 0)\n\t{\n\t\tif (scrollable)\n\t\t{\n\t\t\tthis.contentWrapper.style.overflow = 'auto';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.contentWrapper.style.overflow = 'hidden';\n\t\t}\n\t}\n};\n\n/**\n * Function: activate\n * \n * Puts the window on top of all other windows.\n */\nmxWindow.prototype.activate = function()\n{\n\tif (mxWindow.activeWindow != this)\n\t{\n\t\tvar style = mxUtils.getCurrentStyle(this.getElement());\n\t\tvar index = (style != null) ? style.zIndex : 3;\n\n\t\tif (mxWindow.activeWindow)\n\t\t{\n\t\t\tvar elt = mxWindow.activeWindow.getElement();\n\t\t\t\n\t\t\tif (elt != null && elt.style != null)\n\t\t\t{\n\t\t\t\telt.style.zIndex = index;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar previousWindow = mxWindow.activeWindow;\n\t\tthis.getElement().style.zIndex = parseInt(index) + 1;\n\t\tmxWindow.activeWindow = this;\n\t\t\n\t\tthis.fireEvent(new mxEventObject(mxEvent.ACTIVATE, 'previousWindow', previousWindow));\n\t}\n};\n\n/**\n * Function: getElement\n * \n * Returuns the outermost DOM node that makes up the window.\n */\nmxWindow.prototype.getElement = function()\n{\n\treturn this.div;\n};\n\n/**\n * Function: fit\n * \n * Makes sure the window is inside the client area of the window.\n */\nmxWindow.prototype.fit = function()\n{\n\tmxUtils.fit(this.div);\n};\n\n/**\n * Function: isResizable\n * \n * Returns true if the window is resizable.\n */\nmxWindow.prototype.isResizable = function()\n{\n\tif (this.resize != null)\n\t{\n\t\treturn this.resize.style.display != 'none';\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: setResizable\n * \n * Sets if the window should be resizable. To avoid interference with some\n * built-in features of IE10 and later, the use of the following code is\n * recommended if there are resizable <mxWindow>s in the page:\n * \n * (code)\n * if (mxClient.IS_POINTER)\n * {\n *   document.body.style.msTouchAction = 'none';\n * }\n * (end)\n */\nmxWindow.prototype.setResizable = function(resizable)\n{\n\tif (resizable)\n\t{\n\t\tif (this.resize == null)\n\t\t{\n\t\t\tthis.resize = document.createElement('img');\n\t\t\tthis.resize.style.position = 'absolute';\n\t\t\tthis.resize.style.bottom = '2px';\n\t\t\tthis.resize.style.right = '2px';\n\n\t\t\tthis.resize.setAttribute('src', this.resizeImage);\n\t\t\tthis.resize.style.cursor = 'nw-resize';\n\t\t\t\n\t\t\tvar startX = null;\n\t\t\tvar startY = null;\n\t\t\tvar width = null;\n\t\t\tvar height = null;\n\t\t\t\n\t\t\tvar start = mxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\t// LATER: pointerdown starting on border of resize does start\n\t\t\t\t// the drag operation but does not fire consecutive events via\n\t\t\t\t// one of the listeners below (does pan instead).\n\t\t\t\t// Workaround: document.body.style.msTouchAction = 'none'\n\t\t\t\tthis.activate();\n\t\t\t\tstartX = mxEvent.getClientX(evt);\n\t\t\t\tstartY = mxEvent.getClientY(evt);\n\t\t\t\twidth = this.div.offsetWidth;\n\t\t\t\theight = this.div.offsetHeight;\n\t\t\t\t\n\t\t\t\tmxEvent.addGestureListeners(document, null, dragHandler, dropHandler);\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.RESIZE_START, 'event', evt));\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t});\n\n\t\t\t// Adds a temporary pair of listeners to intercept\n\t\t\t// the gesture event in the document\n\t\t\tvar dragHandler = mxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tif (startX != null && startY != null)\n\t\t\t\t{\n\t\t\t\t\tvar dx = mxEvent.getClientX(evt) - startX;\n\t\t\t\t\tvar dy = mxEvent.getClientY(evt) - startY;\n\t\n\t\t\t\t\tthis.setSize(width + dx, height + dy);\n\t\n\t\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.RESIZE, 'event', evt));\n\t\t\t\t\tmxEvent.consume(evt);\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tvar dropHandler = mxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tif (startX != null && startY != null)\n\t\t\t\t{\n\t\t\t\t\tstartX = null;\n\t\t\t\t\tstartY = null;\n\t\t\t\t\tmxEvent.removeGestureListeners(document, null, dragHandler, dropHandler);\n\t\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.RESIZE_END, 'event', evt));\n\t\t\t\t\tmxEvent.consume(evt);\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tmxEvent.addGestureListeners(this.resize, start, dragHandler, dropHandler);\n\t\t\tthis.div.appendChild(this.resize);\n\t\t}\n\t\telse \n\t\t{\n\t\t\tthis.resize.style.display = 'inline';\n\t\t}\n\t}\n\telse if (this.resize != null)\n\t{\n\t\tthis.resize.style.display = 'none';\n\t}\n};\n\t\n/**\n * Function: setSize\n * \n * Sets the size of the window.\n */\nmxWindow.prototype.setSize = function(width, height)\n{\n\twidth = Math.max(this.minimumSize.width, width);\n\theight = Math.max(this.minimumSize.height, height);\n\n\t// Workaround for table size problems in FF\n\tif (!mxClient.IS_QUIRKS)\n\t{\n\t\tthis.div.style.width =  width + 'px';\n\t\tthis.div.style.height = height + 'px';\n\t}\n\t\n\tthis.table.style.width =  width + 'px';\n\tthis.table.style.height = height + 'px';\n\n\tif (!mxClient.IS_QUIRKS)\n\t{\n\t\tthis.contentWrapper.style.height = (this.div.offsetHeight -\n\t\t\tthis.title.offsetHeight - this.contentHeightCorrection) + 'px';\n\t}\n};\n\t\n/**\n * Function: setMinimizable\n * \n * Sets if the window is minimizable.\n */\nmxWindow.prototype.setMinimizable = function(minimizable)\n{\n\tthis.minimize.style.display = (minimizable) ? '' : 'none';\n};\n\n/**\n * Function: getMinimumSize\n * \n * Returns an <mxRectangle> that specifies the size for the minimized window.\n * A width or height of 0 means keep the existing width or height. This\n * implementation returns the height of the window title and keeps the width.\n */\nmxWindow.prototype.getMinimumSize = function()\n{\n\treturn new mxRectangle(0, 0, 0, this.title.offsetHeight);\n};\n\n/**\n * Function: installMinimizeHandler\n * \n * Installs the event listeners required for minimizing the window.\n */\nmxWindow.prototype.installMinimizeHandler = function()\n{\n\tthis.minimize = document.createElement('img');\n\t\n\tthis.minimize.setAttribute('src', this.minimizeImage);\n\tthis.minimize.setAttribute('title', 'Minimize');\n\tthis.minimize.style.cursor = 'pointer';\n\tthis.minimize.style.marginLeft = '2px';\n\tthis.minimize.style.display = 'none';\n\t\n\tthis.buttons.appendChild(this.minimize);\n\t\n\tvar minimized = false;\n\tvar maxDisplay = null;\n\tvar height = null;\n\n\tvar funct = mxUtils.bind(this, function(evt)\n\t{\n\t\tthis.activate();\n\t\t\n\t\tif (!minimized)\n\t\t{\n\t\t\tminimized = true;\n\t\t\t\n\t\t\tthis.minimize.setAttribute('src', this.normalizeImage);\n\t\t\tthis.minimize.setAttribute('title', 'Normalize');\n\t\t\tthis.contentWrapper.style.display = 'none';\n\t\t\tmaxDisplay = this.maximize.style.display;\n\t\t\t\n\t\t\tthis.maximize.style.display = 'none';\n\t\t\theight = this.table.style.height;\n\t\t\t\n\t\t\tvar minSize = this.getMinimumSize();\n\t\t\t\n\t\t\tif (minSize.height > 0)\n\t\t\t{\n\t\t\t\tif (!mxClient.IS_QUIRKS)\n\t\t\t\t{\n\t\t\t\t\tthis.div.style.height = minSize.height + 'px';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.table.style.height = minSize.height + 'px';\n\t\t\t}\n\t\t\t\n\t\t\tif (minSize.width > 0)\n\t\t\t{\n\t\t\t\tif (!mxClient.IS_QUIRKS)\n\t\t\t\t{\n\t\t\t\t\tthis.div.style.width = minSize.width + 'px';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.table.style.width = minSize.width + 'px';\n\t\t\t}\n\t\t\t\n\t\t\tif (this.resize != null)\n\t\t\t{\n\t\t\t\tthis.resize.style.visibility = 'hidden';\n\t\t\t}\n\t\t\t\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.MINIMIZE, 'event', evt));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tminimized = false;\n\t\t\t\n\t\t\tthis.minimize.setAttribute('src', this.minimizeImage);\n\t\t\tthis.minimize.setAttribute('title', 'Minimize');\n\t\t\tthis.contentWrapper.style.display = ''; // default\n\t\t\tthis.maximize.style.display = maxDisplay;\n\t\t\t\n\t\t\tif (!mxClient.IS_QUIRKS)\n\t\t\t{\n\t\t\t\tthis.div.style.height = height;\n\t\t\t}\n\t\t\t\n\t\t\tthis.table.style.height = height;\n\n\t\t\tif (this.resize != null)\n\t\t\t{\n\t\t\t\tthis.resize.style.visibility = '';\n\t\t\t}\n\t\t\t\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.NORMALIZE, 'event', evt));\n\t\t}\n\t\t\n\t\tmxEvent.consume(evt);\n\t});\n\t\n\tmxEvent.addGestureListeners(this.minimize, funct);\n};\n\t\n/**\n * Function: setMaximizable\n * \n * Sets if the window is maximizable.\n */\nmxWindow.prototype.setMaximizable = function(maximizable)\n{\n\tthis.maximize.style.display = (maximizable) ? '' : 'none';\n};\n\n/**\n * Function: installMaximizeHandler\n * \n * Installs the event listeners required for maximizing the window.\n */\nmxWindow.prototype.installMaximizeHandler = function()\n{\n\tthis.maximize = document.createElement('img');\n\t\n\tthis.maximize.setAttribute('src', this.maximizeImage);\n\tthis.maximize.setAttribute('title', 'Maximize');\n\tthis.maximize.style.cursor = 'default';\n\tthis.maximize.style.marginLeft = '2px';\n\tthis.maximize.style.cursor = 'pointer';\n\tthis.maximize.style.display = 'none';\n\t\n\tthis.buttons.appendChild(this.maximize);\n\t\n\tvar maximized = false;\n\tvar x = null;\n\tvar y = null;\n\tvar height = null;\n\tvar width = null;\n\tvar minDisplay = null;\n\n\tvar funct = mxUtils.bind(this, function(evt)\n\t{\n\t\tthis.activate();\n\t\t\n\t\tif (this.maximize.style.display != 'none')\n\t\t{\n\t\t\tif (!maximized)\n\t\t\t{\n\t\t\t\tmaximized = true;\n\t\t\t\t\n\t\t\t\tthis.maximize.setAttribute('src', this.normalizeImage);\n\t\t\t\tthis.maximize.setAttribute('title', 'Normalize');\n\t\t\t\tthis.contentWrapper.style.display = '';\n\t\t\t\tminDisplay = this.minimize.style.display;\n\t\t\t\tthis.minimize.style.display = 'none';\n\t\t\t\t\n\t\t\t\t// Saves window state\n\t\t\t\tx = parseInt(this.div.style.left);\n\t\t\t\ty = parseInt(this.div.style.top);\n\t\t\t\theight = this.table.style.height;\n\t\t\t\twidth = this.table.style.width;\n\n\t\t\t\tthis.div.style.left = '0px';\n\t\t\t\tthis.div.style.top = '0px';\n\t\t\t\tvar docHeight = Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight || 0);\n\n\t\t\t\tif (!mxClient.IS_QUIRKS)\n\t\t\t\t{\n\t\t\t\t\tthis.div.style.width = (document.body.clientWidth - 2) + 'px';\n\t\t\t\t\tthis.div.style.height = (docHeight - 2) + 'px';\n\t\t\t\t}\n\n\t\t\t\tthis.table.style.width = (document.body.clientWidth - 2) + 'px';\n\t\t\t\tthis.table.style.height = (docHeight - 2) + 'px';\n\t\t\t\t\n\t\t\t\tif (this.resize != null)\n\t\t\t\t{\n\t\t\t\t\tthis.resize.style.visibility = 'hidden';\n\t\t\t\t}\n\n\t\t\t\tif (!mxClient.IS_QUIRKS)\n\t\t\t\t{\n\t\t\t\t\tvar style = mxUtils.getCurrentStyle(this.contentWrapper);\n\t\t\n\t\t\t\t\tif (style.overflow == 'auto' || this.resize != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.contentWrapper.style.height = (this.div.offsetHeight -\n\t\t\t\t\t\t\tthis.title.offsetHeight - this.contentHeightCorrection) + 'px';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.MAXIMIZE, 'event', evt));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmaximized = false;\n\t\t\t\t\n\t\t\t\tthis.maximize.setAttribute('src', this.maximizeImage);\n\t\t\t\tthis.maximize.setAttribute('title', 'Maximize');\n\t\t\t\tthis.contentWrapper.style.display = '';\n\t\t\t\tthis.minimize.style.display = minDisplay;\n\n\t\t\t\t// Restores window state\n\t\t\t\tthis.div.style.left = x+'px';\n\t\t\t\tthis.div.style.top = y+'px';\n\t\t\t\t\n\t\t\t\tif (!mxClient.IS_QUIRKS)\n\t\t\t\t{\n\t\t\t\t\tthis.div.style.height = height;\n\t\t\t\t\tthis.div.style.width = width;\n\n\t\t\t\t\tvar style = mxUtils.getCurrentStyle(this.contentWrapper);\n\t\t\n\t\t\t\t\tif (style.overflow == 'auto' || this.resize != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.contentWrapper.style.height = (this.div.offsetHeight -\n\t\t\t\t\t\t\tthis.title.offsetHeight - this.contentHeightCorrection) + 'px';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.table.style.height = height;\n\t\t\t\tthis.table.style.width = width;\n\n\t\t\t\tif (this.resize != null)\n\t\t\t\t{\n\t\t\t\t\tthis.resize.style.visibility = '';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.NORMALIZE, 'event', evt));\n\t\t\t}\n\t\t\t\n\t\t\tmxEvent.consume(evt);\n\t\t}\n\t});\n\t\n\tmxEvent.addGestureListeners(this.maximize, funct);\n\tmxEvent.addListener(this.title, 'dblclick', funct);\n};\n\t\n/**\n * Function: installMoveHandler\n * \n * Installs the event listeners required for moving the window.\n */\nmxWindow.prototype.installMoveHandler = function()\n{\n\tthis.title.style.cursor = 'move';\n\t\n\tmxEvent.addGestureListeners(this.title,\n\t\tmxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tvar startX = mxEvent.getClientX(evt);\n\t\t\tvar startY = mxEvent.getClientY(evt);\n\t\t\tvar x = this.getX();\n\t\t\tvar y = this.getY();\n\t\t\t\t\t\t\n\t\t\t// Adds a temporary pair of listeners to intercept\n\t\t\t// the gesture event in the document\n\t\t\tvar dragHandler = mxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tvar dx = mxEvent.getClientX(evt) - startX;\n\t\t\t\tvar dy = mxEvent.getClientY(evt) - startY;\n\t\t\t\tthis.setLocation(x + dx, y + dy);\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.MOVE, 'event', evt));\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t});\n\t\t\t\n\t\t\tvar dropHandler = mxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tmxEvent.removeGestureListeners(document, null, dragHandler, dropHandler);\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.MOVE_END, 'event', evt));\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t});\n\t\t\t\n\t\t\tmxEvent.addGestureListeners(document, null, dragHandler, dropHandler);\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.MOVE_START, 'event', evt));\n\t\t\tmxEvent.consume(evt);\n\t\t}));\n\t\n\t// Disables built-in pan and zoom in IE10 and later\n\tif (mxClient.IS_POINTER)\n\t{\n\t\tthis.title.style.touchAction = 'none';\n\t}\n};\n\n/**\n * Function: setLocation\n * \n * Sets the upper, left corner of the window.\n */\n mxWindow.prototype.setLocation = function(x, y)\n {\n\tthis.div.style.left = x + 'px';\n\tthis.div.style.top = y + 'px';\n };\n\n/**\n * Function: getX\n *\n * Returns the current position on the x-axis.\n */\nmxWindow.prototype.getX = function()\n{\n\treturn parseInt(this.div.style.left);\n};\n\n/**\n * Function: getY\n *\n * Returns the current position on the y-axis.\n */\nmxWindow.prototype.getY = function()\n{\n\treturn parseInt(this.div.style.top);\n};\n\n/**\n * Function: installCloseHandler\n *\n * Adds the <closeImage> as a new image node in <closeImg> and installs the\n * <close> event.\n */\nmxWindow.prototype.installCloseHandler = function()\n{\n\tthis.closeImg = document.createElement('img');\n\t\n\tthis.closeImg.setAttribute('src', this.closeImage);\n\tthis.closeImg.setAttribute('title', 'Close');\n\tthis.closeImg.style.marginLeft = '2px';\n\tthis.closeImg.style.cursor = 'pointer';\n\tthis.closeImg.style.display = 'none';\n\t\n\tthis.buttons.appendChild(this.closeImg);\n\n\tmxEvent.addGestureListeners(this.closeImg,\n\t\tmxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CLOSE, 'event', evt));\n\t\t\t\n\t\t\tif (this.destroyOnClose)\n\t\t\t{\n\t\t\t\tthis.destroy();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.setVisible(false);\n\t\t\t}\n\t\t\t\n\t\t\tmxEvent.consume(evt);\n\t\t}));\n};\n\n/**\n * Function: setImage\n * \n * Sets the image associated with the window.\n * \n * Parameters:\n * \n * image - URL of the image to be used.\n */\nmxWindow.prototype.setImage = function(image)\n{\n\tthis.image = document.createElement('img');\n\tthis.image.setAttribute('src', image);\n\tthis.image.setAttribute('align', 'left');\n\tthis.image.style.marginRight = '4px';\n\tthis.image.style.marginLeft = '0px';\n\tthis.image.style.marginTop = '-2px';\n\t\n\tthis.title.insertBefore(this.image, this.title.firstChild);\n};\n\n/**\n * Function: setClosable\n * \n * Sets the image associated with the window.\n * \n * Parameters:\n * \n * closable - Boolean specifying if the window should be closable.\n */\nmxWindow.prototype.setClosable = function(closable)\n{\n\tthis.closeImg.style.display = (closable) ? '' : 'none';\n};\n\n/**\n * Function: isVisible\n * \n * Returns true if the window is visible.\n */\nmxWindow.prototype.isVisible = function()\n{\n\tif (this.div != null)\n\t{\n\t\treturn this.div.style.display != 'none';\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: setVisible\n *\n * Shows or hides the window depending on the given flag.\n * \n * Parameters:\n * \n * visible - Boolean indicating if the window should be made visible.\n */\nmxWindow.prototype.setVisible = function(visible)\n{\n\tif (this.div != null && this.isVisible() != visible)\n\t{\n\t\tif (visible)\n\t\t{\n\t\t\tthis.show();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.hide();\n\t\t}\n\t}\n};\n\n/**\n * Function: show\n *\n * Shows the window.\n */\nmxWindow.prototype.show = function()\n{\n\tthis.div.style.display = '';\n\tthis.activate();\n\t\n\tvar style = mxUtils.getCurrentStyle(this.contentWrapper);\n\t\n\tif (!mxClient.IS_QUIRKS && (style.overflow == 'auto' || this.resize != null) &&\n\t\tthis.contentWrapper.style.display != 'none')\n\t{\n\t\tthis.contentWrapper.style.height = (this.div.offsetHeight -\n\t\t\t\tthis.title.offsetHeight - this.contentHeightCorrection) + 'px';\n\t}\n\t\n\tthis.fireEvent(new mxEventObject(mxEvent.SHOW));\n};\n\n/**\n * Function: hide\n *\n * Hides the window.\n */\nmxWindow.prototype.hide = function()\n{\n\tthis.div.style.display = 'none';\n\tthis.fireEvent(new mxEventObject(mxEvent.HIDE));\n};\n\n/**\n * Function: destroy\n *\n * Destroys the window and removes all associated resources. Fires a\n * <destroy> event prior to destroying the window.\n */\nmxWindow.prototype.destroy = function()\n{\n\tthis.fireEvent(new mxEventObject(mxEvent.DESTROY));\n\t\n\tif (this.div != null)\n\t{\n\t\tmxEvent.release(this.div);\n\t\tthis.div.parentNode.removeChild(this.div);\n\t\tthis.div = null;\n\t}\n\t\n\tthis.title = null;\n\tthis.content = null;\n\tthis.contentWrapper = null;\n};\n\n__mxOutput.mxWindow = typeof mxWindow !== 'undefined' ? mxWindow : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxForm\n * \n * A simple class for creating HTML forms.\n * \n * Constructor: mxForm\n * \n * Creates a HTML table using the specified classname.\n */\nfunction mxForm(className)\n{\n\tthis.table = document.createElement('table');\n\tthis.table.className = className;\n\tthis.body = document.createElement('tbody');\n\t\n\tthis.table.appendChild(this.body);\n};\n\n/**\n * Variable: table\n * \n * Holds the DOM node that represents the table.\n */\nmxForm.prototype.table = null;\n\n/**\n * Variable: body\n * \n * Holds the DOM node that represents the tbody (table body). New rows\n * can be added to this object using DOM API.\n */\nmxForm.prototype.body = false;\n\n/**\n * Function: getTable\n * \n * Returns the table that contains this form.\n */\nmxForm.prototype.getTable = function()\n{\n\treturn this.table;\n};\n\n/**\n * Function: addButtons\n * \n * Helper method to add an OK and Cancel button using the respective\n * functions.\n */\nmxForm.prototype.addButtons = function(okFunct, cancelFunct)\n{\n\tvar tr = document.createElement('tr');\n\tvar td = document.createElement('td');\n\ttr.appendChild(td);\n\ttd = document.createElement('td');\n\n\t// Adds the ok button\n\tvar button = document.createElement('button');\n\tmxUtils.write(button, mxResources.get('ok') || 'OK');\n\ttd.appendChild(button);\n\n\tmxEvent.addListener(button, 'click', function()\n\t{\n\t\tokFunct();\n\t});\n\t\n\t// Adds the cancel button\n\tbutton = document.createElement('button');\n\tmxUtils.write(button, mxResources.get('cancel') || 'Cancel');\n\ttd.appendChild(button);\n\t\n\tmxEvent.addListener(button, 'click', function()\n\t{\n\t\tcancelFunct();\n\t});\n\t\n\ttr.appendChild(td);\n\tthis.body.appendChild(tr);\n};\n\n/**\n * Function: addText\n * \n * Adds an input for the given name, type and value and returns it.\n */\nmxForm.prototype.addText = function(name, value, type)\n{\n\tvar input = document.createElement('input');\n\t\n\tinput.setAttribute('type', type || 'text');\n\tinput.value = value;\n\t\n\treturn this.addField(name, input);\n};\n\n/**\n * Function: addCheckbox\n * \n * Adds a checkbox for the given name and value and returns the textfield.\n */\nmxForm.prototype.addCheckbox = function(name, value)\n{\n\tvar input = document.createElement('input');\n\t\n\tinput.setAttribute('type', 'checkbox');\n\tthis.addField(name, input);\n\n\t// IE can only change the checked value if the input is inside the DOM\n\tif (value)\n\t{\n\t\tinput.checked = true;\n\t}\n\n\treturn input;\n};\n\n/**\n * Function: addTextarea\n * \n * Adds a textarea for the given name and value and returns the textarea.\n */\nmxForm.prototype.addTextarea = function(name, value, rows)\n{\n\tvar input = document.createElement('textarea');\n\t\n\tif (mxClient.IS_NS)\n\t{\n\t\trows--;\n\t}\n\t\n\tinput.setAttribute('rows', rows || 2);\n\tinput.value = value;\n\t\n\treturn this.addField(name, input);\n};\n\n/**\n * Function: addCombo\n * \n * Adds a combo for the given name and returns the combo.\n */\nmxForm.prototype.addCombo = function(name, isMultiSelect, size)\n{\n\tvar select = document.createElement('select');\n\t\n\tif (size != null)\n\t{\n\t\tselect.setAttribute('size', size);\n\t}\n\t\n\tif (isMultiSelect)\n\t{\n\t\tselect.setAttribute('multiple', 'true');\n\t}\n\t\n\treturn this.addField(name, select);\n};\n\n/**\n * Function: addOption\n * \n * Adds an option for the given label to the specified combo.\n */\nmxForm.prototype.addOption = function(combo, label, value, isSelected)\n{\n\tvar option = document.createElement('option');\n\t\n\tmxUtils.writeln(option, label);\n\toption.setAttribute('value', value);\n\t\n\tif (isSelected)\n\t{\n\t\toption.setAttribute('selected', isSelected);\n\t}\n\t\n\tcombo.appendChild(option);\n};\n\n/**\n * Function: addField\n * \n * Adds a new row with the name and the input field in two columns and\n * returns the given input.\n */\nmxForm.prototype.addField = function(name, input)\n{\n\tvar tr = document.createElement('tr');\n\tvar td = document.createElement('td');\n\tmxUtils.write(td, name);\n\ttr.appendChild(td);\n\t\n\ttd = document.createElement('td');\n\ttd.appendChild(input);\n\ttr.appendChild(td);\n\tthis.body.appendChild(tr);\n\t\n\treturn input;\n};\n\n__mxOutput.mxForm = typeof mxForm !== 'undefined' ? mxForm : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxImage\n *\n * Encapsulates the URL, width and height of an image.\n * \n * Constructor: mxImage\n * \n * Constructs a new image.\n */\nfunction mxImage(src, width, height)\n{\n\tthis.src = src;\n\tthis.width = width;\n\tthis.height = height;\n};\n\n/**\n * Variable: src\n *\n * String that specifies the URL of the image.\n */\nmxImage.prototype.src = null;\n\n/**\n * Variable: width\n *\n * Integer that specifies the width of the image.\n */\nmxImage.prototype.width = null;\n\n/**\n * Variable: height\n *\n * Integer that specifies the height of the image.\n */\nmxImage.prototype.height = null;\n\n__mxOutput.mxImage = typeof mxImage !== 'undefined' ? mxImage : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxDivResizer\n * \n * Maintains the size of a div element in Internet Explorer. This is a\n * workaround for the right and bottom style being ignored in IE.\n * \n * If you need a div to cover the scrollwidth and -height of a document,\n * then you can use this class as follows:\n * \n * (code)\n * var resizer = new mxDivResizer(background);\n * resizer.getDocumentHeight = function()\n * {\n *   return document.body.scrollHeight;\n * }\n * resizer.getDocumentWidth = function()\n * {\n *   return document.body.scrollWidth;\n * }\n * resizer.resize();\n * (end)\n * \n * Constructor: mxDivResizer\n * \n * Constructs an object that maintains the size of a div\n * element when the window is being resized. This is only\n * required for Internet Explorer as it ignores the respective\n * stylesheet information for DIV elements.\n * \n * Parameters:\n * \n * div - Reference to the DOM node whose size should be maintained.\n * container - Optional Container that contains the div. Default is the\n * window.\n */\nfunction mxDivResizer(div, container)\n{\n\tif (div.nodeName.toLowerCase() == 'div')\n\t{\n\t\tif (container == null)\n\t\t{\n\t\t\tcontainer = window;\n\t\t}\n\n\t\tthis.div = div;\n\t\tvar style = mxUtils.getCurrentStyle(div);\n\t\t\n\t\tif (style != null)\n\t\t{\n\t\t\tthis.resizeWidth = style.width == 'auto';\n\t\t\tthis.resizeHeight = style.height == 'auto';\n\t\t}\n\t\t\n\t\tmxEvent.addListener(container, 'resize',\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tif (!this.handlingResize)\n\t\t\t\t{\n\t\t\t\t\tthis.handlingResize = true;\n\t\t\t\t\tthis.resize();\n\t\t\t\t\tthis.handlingResize = false;\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t\t\n\t\tthis.resize();\n\t}\n};\n\n/**\n * Function: resizeWidth\n * \n * Boolean specifying if the width should be updated.\n */\nmxDivResizer.prototype.resizeWidth = true;\n\n/**\n * Function: resizeHeight\n * \n * Boolean specifying if the height should be updated.\n */\nmxDivResizer.prototype.resizeHeight = true;\n\n/**\n * Function: handlingResize\n * \n * Boolean specifying if the width should be updated.\n */\nmxDivResizer.prototype.handlingResize = false;\n\n/**\n * Function: resize\n * \n * Updates the style of the DIV after the window has been resized.\n */\nmxDivResizer.prototype.resize = function()\n{\n\tvar w = this.getDocumentWidth();\n\tvar h = this.getDocumentHeight();\n\n\tvar l = parseInt(this.div.style.left);\n\tvar r = parseInt(this.div.style.right);\n\tvar t = parseInt(this.div.style.top);\n\tvar b = parseInt(this.div.style.bottom);\n\t\n\tif (this.resizeWidth &&\n\t\t!isNaN(l) &&\n\t\t!isNaN(r) &&\n\t\tl >= 0 &&\n\t\tr >= 0 &&\n\t\tw - r - l > 0)\n\t{\n\t\tthis.div.style.width = (w - r - l)+'px';\n\t}\n\t\n\tif (this.resizeHeight &&\n\t\t!isNaN(t) &&\n\t\t!isNaN(b) &&\n\t\tt >= 0 &&\n\t\tb >= 0 &&\n\t\th - t - b > 0)\n\t{\n\t\tthis.div.style.height = (h - t - b)+'px';\n\t}\n};\n\n/**\n * Function: getDocumentWidth\n * \n * Hook for subclassers to return the width of the document (without\n * scrollbars).\n */\nmxDivResizer.prototype.getDocumentWidth = function()\n{\n\treturn document.body.clientWidth;\n};\n\n/**\n * Function: getDocumentHeight\n * \n * Hook for subclassers to return the height of the document (without\n * scrollbars).\n */\nmxDivResizer.prototype.getDocumentHeight = function()\n{\n\treturn document.body.clientHeight;\n};\n\n__mxOutput.mxDivResizer = typeof mxDivResizer !== 'undefined' ? mxDivResizer : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxDragSource\n * \n * Wrapper to create a drag source from a DOM element so that the element can\n * be dragged over a graph and dropped into the graph as a new cell.\n * \n * Problem is that in the dropHandler the current preview location is not\n * available, so the preview and the dropHandler must match.\n * \n * Constructor: mxDragSource\n * \n * Constructs a new drag source for the given element.\n */\nfunction mxDragSource(element, dropHandler)\n{\n\tthis.element = element;\n\tthis.dropHandler = dropHandler;\n\t\n\t// Handles a drag gesture on the element\n\tmxEvent.addGestureListeners(element, mxUtils.bind(this, function(evt)\n\t{\n\t\tthis.mouseDown(evt);\n\t}));\n\t\n\t// Prevents native drag and drop\n\tmxEvent.addListener(element, 'dragstart', function(evt)\n\t{\n\t\tmxEvent.consume(evt);\n\t});\n\t\n\tthis.eventConsumer = function(sender, evt)\n\t{\n\t\tvar evtName = evt.getProperty('eventName');\n\t\tvar me = evt.getProperty('event');\n\t\t\n\t\tif (evtName != mxEvent.MOUSE_DOWN)\n\t\t{\n\t\t\tme.consume();\n\t\t}\n\t};\n};\n\n/**\n * Variable: element\n *\n * Reference to the DOM node which was made draggable.\n */\nmxDragSource.prototype.element = null;\n\n/**\n * Variable: dropHandler\n *\n * Holds the DOM node that is used to represent the drag preview. If this is\n * null then the source element will be cloned and used for the drag preview.\n */\nmxDragSource.prototype.dropHandler = null;\n\n/**\n * Variable: dragOffset\n *\n * <mxPoint> that specifies the offset of the <dragElement>. Default is null.\n */\nmxDragSource.prototype.dragOffset = null;\n\n/**\n * Variable: dragElement\n *\n * Holds the DOM node that is used to represent the drag preview. If this is\n * null then the source element will be cloned and used for the drag preview.\n */\nmxDragSource.prototype.dragElement = null;\n\n/**\n * Variable: previewElement\n *\n * Optional <mxRectangle> that specifies the unscaled size of the preview.\n */\nmxDragSource.prototype.previewElement = null;\n\n/**\n * Variable: previewOffset\n *\n * Optional <mxPoint> that specifies the offset of the preview in pixels.\n */\nmxDragSource.prototype.previewOffset = null;\n\n/**\n * Variable: enabled\n *\n * Specifies if this drag source is enabled. Default is true.\n */\nmxDragSource.prototype.enabled = true;\n\n/**\n * Variable: currentGraph\n *\n * Reference to the <mxGraph> that is the current drop target.\n */\nmxDragSource.prototype.currentGraph = null;\n\n/**\n * Variable: currentDropTarget\n *\n * Holds the current drop target under the mouse.\n */\nmxDragSource.prototype.currentDropTarget = null;\n\n/**\n * Variable: currentPoint\n *\n * Holds the current drop location.\n */\nmxDragSource.prototype.currentPoint = null;\n\n/**\n * Variable: currentGuide\n *\n * Holds an <mxGuide> for the <currentGraph> if <dragPreview> is not null.\n */\nmxDragSource.prototype.currentGuide = null;\n\n/**\n * Variable: currentGuide\n *\n * Holds an <mxGuide> for the <currentGraph> if <dragPreview> is not null.\n */\nmxDragSource.prototype.currentHighlight = null;\n\n/**\n * Variable: autoscroll\n *\n * Specifies if the graph should scroll automatically. Default is true.\n */\nmxDragSource.prototype.autoscroll = true;\n\n/**\n * Variable: guidesEnabled\n *\n * Specifies if <mxGuide> should be enabled. Default is true.\n */\nmxDragSource.prototype.guidesEnabled = true;\n\n/**\n * Variable: gridEnabled\n *\n * Specifies if the grid should be allowed. Default is true.\n */\nmxDragSource.prototype.gridEnabled = true;\n\n/**\n * Variable: highlightDropTargets\n *\n * Specifies if drop targets should be highlighted. Default is true.\n */\nmxDragSource.prototype.highlightDropTargets = true;\n\n/**\n * Variable: dragElementZIndex\n * \n * ZIndex for the drag element. Default is 100.\n */\nmxDragSource.prototype.dragElementZIndex = 100;\n\n/**\n * Variable: dragElementOpacity\n * \n * Opacity of the drag element in %. Default is 70.\n */\nmxDragSource.prototype.dragElementOpacity = 70;\n\n/**\n * Variable: checkEventSource\n * \n * Whether the event source should be checked in <graphContainerEvent>. Default\n * is true.\n */\nmxDragSource.prototype.checkEventSource = true;\n\n/**\n * Function: isEnabled\n * \n * Returns <enabled>.\n */\nmxDragSource.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n * \n * Sets <enabled>.\n */\nmxDragSource.prototype.setEnabled = function(value)\n{\n\tthis.enabled = value;\n};\n\n/**\n * Function: isGuidesEnabled\n * \n * Returns <guidesEnabled>.\n */\nmxDragSource.prototype.isGuidesEnabled = function()\n{\n\treturn this.guidesEnabled;\n};\n\n/**\n * Function: setGuidesEnabled\n * \n * Sets <guidesEnabled>.\n */\nmxDragSource.prototype.setGuidesEnabled = function(value)\n{\n\tthis.guidesEnabled = value;\n};\n\n/**\n * Function: isGridEnabled\n * \n * Returns <gridEnabled>.\n */\nmxDragSource.prototype.isGridEnabled = function()\n{\n\treturn this.gridEnabled;\n};\n\n/**\n * Function: setGridEnabled\n * \n * Sets <gridEnabled>.\n */\nmxDragSource.prototype.setGridEnabled = function(value)\n{\n\tthis.gridEnabled = value;\n};\n\n/**\n * Function: getGraphForEvent\n * \n * Returns the graph for the given mouse event. This implementation returns\n * null.\n */\nmxDragSource.prototype.getGraphForEvent = function(evt)\n{\n\treturn null;\n};\n\n/**\n * Function: getDropTarget\n * \n * Returns the drop target for the given graph and coordinates. This\n * implementation uses <mxGraph.getCellAt>.\n */\nmxDragSource.prototype.getDropTarget = function(graph, x, y, evt)\n{\n\treturn graph.getCellAt(x, y);\n};\n\n/**\n * Function: createDragElement\n * \n * Creates and returns a clone of the <dragElementPrototype> or the <element>\n * if the former is not defined.\n */\nmxDragSource.prototype.createDragElement = function(evt)\n{\n\treturn this.element.cloneNode(true);\n};\n\n/**\n * Function: createPreviewElement\n * \n * Creates and returns an element which can be used as a preview in the given\n * graph.\n */\nmxDragSource.prototype.createPreviewElement = function(graph)\n{\n\treturn null;\n};\n\n/**\n * Function: isActive\n * \n * Returns true if this drag source is active.\n */\nmxDragSource.prototype.isActive = function()\n{\n\treturn this.mouseMoveHandler != null;\n};\n\n/**\n * Function: reset\n * \n * Stops and removes everything and restores the state of the object.\n */\nmxDragSource.prototype.reset = function()\n{\n\tif (this.currentGraph != null)\n\t{\n\t\tthis.dragExit(this.currentGraph);\n\t\tthis.currentGraph = null;\n\t}\n\t\n\tthis.removeDragElement();\n\tthis.removeListeners();\n\tthis.stopDrag();\n};\n\n/**\n * Function: mouseDown\n * \n * Returns the drop target for the given graph and coordinates. This\n * implementation uses <mxGraph.getCellAt>.\n * \n * To ignore popup menu events for a drag source, this function can be\n * overridden as follows.\n * \n * (code)\n * var mouseDown = dragSource.mouseDown;\n * \n * dragSource.mouseDown = function(evt)\n * {\n *   if (!mxEvent.isPopupTrigger(evt))\n *   {\n *     mouseDown.apply(this, arguments);\n *   }\n * };\n * (end)\n */\nmxDragSource.prototype.mouseDown = function(evt)\n{\n\tif (this.enabled && !mxEvent.isConsumed(evt) && this.mouseMoveHandler == null)\n\t{\n\t\tthis.startDrag(evt);\n\t\tthis.mouseMoveHandler = mxUtils.bind(this, this.mouseMove);\n\t\tthis.mouseUpHandler = mxUtils.bind(this, this.mouseUp);\t\t\n\t\tmxEvent.addGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);\n\t\t\n\t\tif (mxClient.IS_TOUCH && !mxEvent.isMouseEvent(evt))\n\t\t{\n\t\t\tthis.eventSource = mxEvent.getSource(evt);\n\t\t\tmxEvent.addGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);\n\t\t}\n\t}\n};\n\n/**\n * Function: startDrag\n * \n * Creates the <dragElement> using <createDragElement>.\n */\nmxDragSource.prototype.startDrag = function(evt)\n{\n\tthis.dragElement = this.createDragElement(evt);\n\tthis.dragElement.style.position = 'absolute';\n\tthis.dragElement.style.zIndex = this.dragElementZIndex;\n\tmxUtils.setOpacity(this.dragElement, this.dragElementOpacity);\n\n\tif (this.checkEventSource && mxClient.IS_SVG)\n\t{\n\t\tthis.dragElement.style.pointerEvents = 'none';\n\t}\n};\n\n/**\n * Function: stopDrag\n * \n * Invokes <removeDragElement>.\n */\nmxDragSource.prototype.stopDrag = function()\n{\n\t// LATER: This used to have a mouse event. If that is still needed we need to add another\n\t// final call to the DnD protocol to add a cleanup step in the case of escape press, which\n\t// is not associated with a mouse event and which currently calles this method.\n\tthis.removeDragElement();\n};\n\n/**\n * Function: removeDragElement\n * \n * Removes and destroys the <dragElement>.\n */\nmxDragSource.prototype.removeDragElement = function()\n{\n\tif (this.dragElement != null)\n\t{\n\t\tif (this.dragElement.parentNode != null)\n\t\t{\n\t\t\tthis.dragElement.parentNode.removeChild(this.dragElement);\n\t\t}\n\t\t\n\t\tthis.dragElement = null;\n\t}\n};\n\n/**\n * Function: getElementForEvent\n * \n * Returns the topmost element under the given event.\n */\nmxDragSource.prototype.getElementForEvent = function(evt)\n{\n\treturn ((mxEvent.isTouchEvent(evt) || mxEvent.isPenEvent(evt)) ?\n\t\t\tdocument.elementFromPoint(mxEvent.getClientX(evt), mxEvent.getClientY(evt)) :\n\t\t\t\tmxEvent.getSource(evt));\n};\n\n/**\n * Function: graphContainsEvent\n * \n * Returns true if the given graph contains the given event.\n */\nmxDragSource.prototype.graphContainsEvent = function(graph, evt)\n{\n\tvar x = mxEvent.getClientX(evt);\n\tvar y = mxEvent.getClientY(evt);\n\tvar offset = mxUtils.getOffset(graph.container);\n\tvar origin = mxUtils.getScrollOrigin();\n\tvar elt = this.getElementForEvent(evt);\n\t\n\tif (this.checkEventSource)\n\t{\n\t\twhile (elt != null && elt != graph.container)\n\t\t{\n\t\t\telt = elt.parentNode;\n\t\t}\n\t}\n\n\t// Checks if event is inside the bounds of the graph container\n\treturn elt != null && x >= offset.x - origin.x && y >= offset.y - origin.y &&\n\t\tx <= offset.x - origin.x + graph.container.offsetWidth &&\n\t\ty <= offset.y - origin.y + graph.container.offsetHeight;\n};\n\n/**\n * Function: mouseMove\n * \n * Gets the graph for the given event using <getGraphForEvent>, updates the\n * <currentGraph>, calling <dragEnter> and <dragExit> on the new and old graph,\n * respectively, and invokes <dragOver> if <currentGraph> is not null.\n */\nmxDragSource.prototype.mouseMove = function(evt)\n{\n\tvar graph = this.getGraphForEvent(evt);\n\t\n\t// Checks if event is inside the bounds of the graph container\n\tif (graph != null && !this.graphContainsEvent(graph, evt))\n\t{\n\t\tgraph = null;\n\t}\n\n\tif (graph != this.currentGraph)\n\t{\n\t\tif (this.currentGraph != null)\n\t\t{\n\t\t\tthis.dragExit(this.currentGraph, evt);\n\t\t}\n\t\t\n\t\tthis.currentGraph = graph;\n\t\t\n\t\tif (this.currentGraph != null)\n\t\t{\n\t\t\tthis.dragEnter(this.currentGraph, evt);\n\t\t}\n\t}\n\t\n\tif (this.currentGraph != null)\n\t{\n\t\tthis.dragOver(this.currentGraph, evt);\n\t}\n\n\tif (this.dragElement != null && (this.previewElement == null || this.previewElement.style.visibility != 'visible'))\n\t{\n\t\tvar x = mxEvent.getClientX(evt);\n\t\tvar y = mxEvent.getClientY(evt);\n\t\t\n\t\tif (this.dragElement.parentNode == null)\n\t\t{\n\t\t\tdocument.body.appendChild(this.dragElement);\n\t\t}\n\n\t\tthis.dragElement.style.visibility = 'visible';\n\t\t\n\t\tif (this.dragOffset != null)\n\t\t{\n\t\t\tx += this.dragOffset.x;\n\t\t\ty += this.dragOffset.y;\n\t\t}\n\t\t\n\t\tvar offset = mxUtils.getDocumentScrollOrigin(document);\n\t\t\n\t\tthis.dragElement.style.left = (x + offset.x) + 'px';\n\t\tthis.dragElement.style.top = (y + offset.y) + 'px';\n\t}\n\telse if (this.dragElement != null)\n\t{\n\t\tthis.dragElement.style.visibility = 'hidden';\n\t}\n\t\n\tmxEvent.consume(evt);\n};\n\n/**\n * Function: mouseUp\n * \n * Processes the mouse up event and invokes <drop>, <dragExit> and <stopDrag>\n * as required.\n */\nmxDragSource.prototype.mouseUp = function(evt)\n{\n\tif (this.currentGraph != null)\n\t{\n\t\tif (this.currentPoint != null && (this.previewElement == null ||\n\t\t\tthis.previewElement.style.visibility != 'hidden'))\n\t\t{\n\t\t\tvar scale = this.currentGraph.view.scale;\n\t\t\tvar tr = this.currentGraph.view.translate;\n\t\t\tvar x = this.currentPoint.x / scale - tr.x;\n\t\t\tvar y = this.currentPoint.y / scale - tr.y;\n\t\t\t\n\t\t\tthis.drop(this.currentGraph, evt, this.currentDropTarget, x, y);\n\t\t}\n\t\t\n\t\tthis.dragExit(this.currentGraph);\n\t\tthis.currentGraph = null;\n\t}\n\n\tthis.stopDrag();\n\tthis.removeListeners();\n\t\n\tmxEvent.consume(evt);\n};\n\n/**\n * Function: removeListeners\n * \n * Actives the given graph as a drop target.\n */\nmxDragSource.prototype.removeListeners = function()\n{\n\tif (this.eventSource != null)\n\t{\n\t\tmxEvent.removeGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);\n\t\tthis.eventSource = null;\n\t}\n\t\n\tmxEvent.removeGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);\n\tthis.mouseMoveHandler = null;\n\tthis.mouseUpHandler = null;\n};\n\n/**\n * Function: dragEnter\n * \n * Actives the given graph as a drop target.\n */\nmxDragSource.prototype.dragEnter = function(graph, evt)\n{\n\tgraph.isMouseDown = true;\n\tgraph.isMouseTrigger = mxEvent.isMouseEvent(evt);\n\tthis.previewElement = this.createPreviewElement(graph);\n\t\n\tif (this.previewElement != null && this.checkEventSource && mxClient.IS_SVG)\n\t{\n\t\tthis.previewElement.style.pointerEvents = 'none';\n\t}\n\t\n\t// Guide is only needed if preview element is used\n\tif (this.isGuidesEnabled() && this.previewElement != null)\n\t{\n\t\tthis.currentGuide = new mxGuide(graph, graph.graphHandler.getGuideStates());\n\t}\n\t\n\tif (this.highlightDropTargets)\n\t{\n\t\tthis.currentHighlight = new mxCellHighlight(graph, mxConstants.DROP_TARGET_COLOR);\n\t}\n\t\n\t// Consumes all events in the current graph before they are fired\n\tgraph.addListener(mxEvent.FIRE_MOUSE_EVENT, this.eventConsumer);\n};\n\n/**\n * Function: dragExit\n * \n * Deactivates the given graph as a drop target.\n */\nmxDragSource.prototype.dragExit = function(graph, evt)\n{\n\tthis.currentDropTarget = null;\n\tthis.currentPoint = null;\n\tgraph.isMouseDown = false;\n\t\n\t// Consumes all events in the current graph before they are fired\n\tgraph.removeListener(this.eventConsumer);\n\t\n\tif (this.previewElement != null)\n\t{\n\t\tif (this.previewElement.parentNode != null)\n\t\t{\n\t\t\tthis.previewElement.parentNode.removeChild(this.previewElement);\n\t\t}\n\t\t\n\t\tthis.previewElement = null;\n\t}\n\t\n\tif (this.currentGuide != null)\n\t{\n\t\tthis.currentGuide.destroy();\n\t\tthis.currentGuide = null;\n\t}\n\t\n\tif (this.currentHighlight != null)\n\t{\n\t\tthis.currentHighlight.destroy();\n\t\tthis.currentHighlight = null;\n\t}\n};\n\n/**\n * Function: dragOver\n * \n * Implements autoscroll, updates the <currentPoint>, highlights any drop\n * targets and updates the preview.\n */\nmxDragSource.prototype.dragOver = function(graph, evt)\n{\n\tvar offset = mxUtils.getOffset(graph.container);\n\tvar origin = mxUtils.getScrollOrigin(graph.container);\n\tvar x = mxEvent.getClientX(evt) - offset.x + origin.x - graph.panDx;\n\tvar y = mxEvent.getClientY(evt) - offset.y + origin.y - graph.panDy;\n\n\tif (graph.autoScroll && (this.autoscroll == null || this.autoscroll))\n\t{\n\t\tgraph.scrollPointToVisible(x, y, graph.autoExtend);\n\t}\n\n\t// Highlights the drop target under the mouse\n\tif (this.currentHighlight != null && graph.isDropEnabled())\n\t{\n\t\tthis.currentDropTarget = this.getDropTarget(graph, x, y, evt);\n\t\tvar state = graph.getView().getState(this.currentDropTarget);\n\t\tthis.currentHighlight.highlight(state);\n\t}\n\n\t// Updates the location of the preview\n\tif (this.previewElement != null)\n\t{\n\t\tif (this.previewElement.parentNode == null)\n\t\t{\n\t\t\tgraph.container.appendChild(this.previewElement);\n\t\t\t\n\t\t\tthis.previewElement.style.zIndex = '3';\n\t\t\tthis.previewElement.style.position = 'absolute';\n\t\t}\n\t\t\n\t\tvar gridEnabled = this.isGridEnabled() && graph.isGridEnabledEvent(evt);\n\t\tvar hideGuide = true;\n\n\t\t// Grid and guides\n\t\tif (this.currentGuide != null && this.currentGuide.isEnabledForEvent(evt))\n\t\t{\n\t\t\t// LATER: HTML preview appears smaller than SVG preview\n\t\t\tvar w = parseInt(this.previewElement.style.width);\n\t\t\tvar h = parseInt(this.previewElement.style.height);\n\t\t\tvar bounds = new mxRectangle(0, 0, w, h);\n\t\t\tvar delta = new mxPoint(x, y);\n\t\t\tdelta = this.currentGuide.move(bounds, delta, gridEnabled, true);\n\t\t\thideGuide = false;\n\t\t\tx = delta.x;\n\t\t\ty = delta.y;\n\t\t}\n\t\telse if (gridEnabled)\n\t\t{\n\t\t\tvar scale = graph.view.scale;\n\t\t\tvar tr = graph.view.translate;\n\t\t\tvar off = graph.gridSize / 2;\n\t\t\tx = (graph.snap(x / scale - tr.x - off) + tr.x) * scale;\n\t\t\ty = (graph.snap(y / scale - tr.y - off) + tr.y) * scale;\n\t\t}\n\t\t\n\t\tif (this.currentGuide != null && hideGuide)\n\t\t{\n\t\t\tthis.currentGuide.hide();\n\t\t}\n\t\t\n\t\tif (this.previewOffset != null)\n\t\t{\n\t\t\tx += this.previewOffset.x;\n\t\t\ty += this.previewOffset.y;\n\t\t}\n\n\t\tthis.previewElement.style.left = Math.round(x) + 'px';\n\t\tthis.previewElement.style.top = Math.round(y) + 'px';\n\t\tthis.previewElement.style.visibility = 'visible';\n\t}\n\t\n\tthis.currentPoint = new mxPoint(x, y);\n};\n\n/**\n * Function: drop\n * \n * Returns the drop target for the given graph and coordinates. This\n * implementation uses <mxGraph.getCellAt>.\n */\nmxDragSource.prototype.drop = function(graph, evt, dropTarget, x, y)\n{\n\tthis.dropHandler.apply(this, arguments);\n\t\n\t// Had to move this to after the insert because it will\n\t// affect the scrollbars of the window in IE to try and\n\t// make the complete container visible.\n\t// LATER: Should be made optional.\n\tif (graph.container.style.visibility != 'hidden')\n\t{\n\t\tgraph.container.focus();\n\t}\n};\n\n__mxOutput.mxDragSource = typeof mxDragSource !== 'undefined' ? mxDragSource : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxToolbar\n * \n * Creates a toolbar inside a given DOM node. The toolbar may contain icons,\n * buttons and combo boxes.\n * \n * Event: mxEvent.SELECT\n * \n * Fires when an item was selected in the toolbar. The <code>function</code>\n * property contains the function that was selected in <selectMode>.\n * \n * Constructor: mxToolbar\n * \n * Constructs a toolbar in the specified container.\n *\n * Parameters:\n *\n * container - DOM node that contains the toolbar.\n */\nfunction mxToolbar(container)\n{\n\tthis.container = container;\n};\n\n/**\n * Extends mxEventSource.\n */\nmxToolbar.prototype = new mxEventSource();\nmxToolbar.prototype.constructor = mxToolbar;\n\n/**\n * Variable: container\n * \n * Reference to the DOM nodes that contains the toolbar.\n */\nmxToolbar.prototype.container = null;\n\n/**\n * Variable: enabled\n * \n * Specifies if events are handled. Default is true.\n */\nmxToolbar.prototype.enabled = true;\n\n/**\n * Variable: noReset\n * \n * Specifies if <resetMode> requires a forced flag of true for resetting\n * the current mode in the toolbar. Default is false. This is set to true\n * if the toolbar item is double clicked to avoid a reset after a single\n * use of the item.\n */\nmxToolbar.prototype.noReset = false;\n\n/**\n * Variable: updateDefaultMode\n * \n * Boolean indicating if the default mode should be the last selected\n * switch mode or the first inserted switch mode. Default is true, that\n * is the last selected switch mode is the default mode. The default mode\n * is the mode to be selected after a reset of the toolbar. If this is\n * false, then the default mode is the first inserted mode item regardless\n * of what was last selected. Otherwise, the selected item after a reset is\n * the previously selected item.\n */\nmxToolbar.prototype.updateDefaultMode = true;\n\n/**\n * Function: addItem\n * \n * Adds the given function as an image with the specified title and icon\n * and returns the new image node.\n * \n * Parameters:\n * \n * title - Optional string that is used as the tooltip.\n * icon - Optional URL of the image to be used. If no URL is given, then a\n * button is created.\n * funct - Function to execute on a mouse click.\n * pressedIcon - Optional URL of the pressed image. Default is a gray\n * background.\n * style - Optional style classname. Default is mxToolbarItem.\n * factoryMethod - Optional factory method for popup menu, eg.\n * function(menu, evt, cell) { menu.addItem('Hello, World!'); }\n */\nmxToolbar.prototype.addItem = function(title, icon, funct, pressedIcon, style, factoryMethod)\n{\n\tvar img = document.createElement((icon != null) ? 'img' : 'button');\n\tvar initialClassName = style || ((factoryMethod != null) ?\n\t\t\t'mxToolbarMode' : 'mxToolbarItem');\n\timg.className = initialClassName;\n\timg.setAttribute('src', icon);\n\t\n\tif (title != null)\n\t{\n\t\tif (icon != null)\n\t\t{\n\t\t\timg.setAttribute('title', title);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmxUtils.write(img, title);\n\t\t}\n\t}\n\t\n\tthis.container.appendChild(img);\n\n\t// Invokes the function on a click on the toolbar item\n\tif (funct != null)\n\t{\n\t\tmxEvent.addListener(img, 'click', funct);\n\t\t\n\t\tif (mxClient.IS_TOUCH)\n\t\t{\n\t\t\tmxEvent.addListener(img, 'touchend', funct);\n\t\t}\n\t}\n\n\tvar mouseHandler = mxUtils.bind(this, function(evt)\n\t{\n\t\tif (pressedIcon != null)\n\t\t{\n\t\t\timg.setAttribute('src', icon);\n\t\t}\n\t\telse\n\t\t{\n\t\t\timg.style.backgroundColor = '';\n\t\t}\n\t});\n\n\t// Highlights the toolbar item with a gray background\n\t// while it is being clicked with the mouse\n\tmxEvent.addGestureListeners(img, mxUtils.bind(this, function(evt)\n\t{\n\t\tif (pressedIcon != null)\n\t\t{\n\t\t\timg.setAttribute('src', pressedIcon);\n\t\t}\n\t\telse\n\t\t{\n\t\t\timg.style.backgroundColor = 'gray';\n\t\t}\n\t\t\n\t\t// Popup Menu\n\t\tif (factoryMethod != null)\n\t\t{\n\t\t\tif (this.menu == null)\n\t\t\t{\n\t\t\t\tthis.menu = new mxPopupMenu();\n\t\t\t\tthis.menu.init();\n\t\t\t}\n\t\t\t\n\t\t\tvar last = this.currentImg;\n\t\t\t\n\t\t\tif (this.menu.isMenuShowing())\n\t\t\t{\n\t\t\t\tthis.menu.hideMenu();\n\t\t\t}\n\t\t\t\n\t\t\tif (last != img)\n\t\t\t{\n\t\t\t\t// Redirects factory method to local factory method\n\t\t\t\tthis.currentImg = img;\n\t\t\t\tthis.menu.factoryMethod = factoryMethod;\n\t\t\t\t\n\t\t\t\tvar point = new mxPoint(\n\t\t\t\t\timg.offsetLeft,\n\t\t\t\t\timg.offsetTop + img.offsetHeight);\n\t\t\t\tthis.menu.popup(point.x, point.y, null, evt);\n\n\t\t\t\t// Sets and overrides to restore classname\n\t\t\t\tif (this.menu.isMenuShowing())\n\t\t\t\t{\n\t\t\t\t\timg.className = initialClassName + 'Selected';\n\t\t\t\t\t\n\t\t\t\t\tthis.menu.hideMenu = function()\n\t\t\t\t\t{\n\t\t\t\t\t\tmxPopupMenu.prototype.hideMenu.apply(this);\n\t\t\t\t\t\timg.className = initialClassName;\n\t\t\t\t\t\tthis.currentImg = null;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}), null, mouseHandler);\n\n\tmxEvent.addListener(img, 'mouseout', mouseHandler);\n\t\n\treturn img;\n};\n\n/**\n * Function: addCombo\n * \n * Adds and returns a new SELECT element using the given style. The element\n * is placed inside a DIV with the mxToolbarComboContainer style classname.\n * \n * Parameters:\n * \n * style - Optional style classname. Default is mxToolbarCombo.\n */\nmxToolbar.prototype.addCombo = function(style)\n{\n\tvar div = document.createElement('div');\n\tdiv.style.display = 'inline';\n\tdiv.className = 'mxToolbarComboContainer';\n\t\n\tvar select = document.createElement('select');\n\tselect.className = style || 'mxToolbarCombo';\n\tdiv.appendChild(select);\n\t\n\tthis.container.appendChild(div);\n\t\n\treturn select;\n};\n\n/**\n * Function: addActionCombo\n * \n * Adds and returns a new SELECT element using the given title as the\n * default element. The selection is reset to this element after each\n * change.\n * \n * Parameters:\n * \n * title - String that specifies the title of the default element.\n * style - Optional style classname. Default is mxToolbarCombo.\n */\nmxToolbar.prototype.addActionCombo = function(title, style)\n{\n\tvar select = document.createElement('select');\n\tselect.className = style || 'mxToolbarCombo';\n\tthis.addOption(select, title, null);\n\t\n\tmxEvent.addListener(select, 'change', function(evt)\n\t{\n\t\tvar value = select.options[select.selectedIndex];\n\t\tselect.selectedIndex = 0;\n\t\t\n\t\tif (value.funct != null)\n\t\t{\n\t\t\tvalue.funct(evt);\n\t\t}\n\t});\n\t\n\tthis.container.appendChild(select);\n\t\n\treturn select;\n};\n\n/**\n * Function: addOption\n * \n * Adds and returns a new OPTION element inside the given SELECT element.\n * If the given value is a function then it is stored in the option's funct\n * field.\n * \n * Parameters:\n * \n * combo - SELECT element that will contain the new entry.\n * title - String that specifies the title of the option.\n * value - Specifies the value associated with this option.\n */\nmxToolbar.prototype.addOption = function(combo, title, value)\n{\n\tvar option = document.createElement('option');\n\tmxUtils.writeln(option, title);\n\t\n\tif (typeof(value) == 'function')\n\t{\n\t\toption.funct = value;\n\t}\n\telse\n\t{\n\t\toption.setAttribute('value', value);\n\t}\n\t\n\tcombo.appendChild(option);\n\t\n\treturn option;\n};\n\n/**\n * Function: addSwitchMode\n * \n * Adds a new selectable item to the toolbar. Only one switch mode item may\n * be selected at a time. The currently selected item is the default item\n * after a reset of the toolbar.\n */\nmxToolbar.prototype.addSwitchMode = function(title, icon, funct, pressedIcon, style)\n{\n\tvar img = document.createElement('img');\n\timg.initialClassName = style || 'mxToolbarMode';\n\timg.className = img.initialClassName;\n\timg.setAttribute('src', icon);\n\timg.altIcon = pressedIcon;\n\t\n\tif (title != null)\n\t{\n\t\timg.setAttribute('title', title);\n\t}\n\t\n\tmxEvent.addListener(img, 'click', mxUtils.bind(this, function(evt)\n\t{\n\t\tvar tmp = this.selectedMode.altIcon;\n\t\t\n\t\tif (tmp != null)\n\t\t{\n\t\t\tthis.selectedMode.altIcon = this.selectedMode.getAttribute('src');\n\t\t\tthis.selectedMode.setAttribute('src', tmp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.selectedMode.className = this.selectedMode.initialClassName;\n\t\t}\n\t\t\n\t\tif (this.updateDefaultMode)\n\t\t{\n\t\t\tthis.defaultMode = img;\n\t\t}\n\t\t\n\t\tthis.selectedMode = img;\n\t\t\n\t\tvar tmp = img.altIcon;\n\t\t\n\t\tif (tmp != null)\n\t\t{\n\t\t\timg.altIcon = img.getAttribute('src');\n\t\t\timg.setAttribute('src', tmp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\timg.className = img.initialClassName+'Selected';\n\t\t}\n\t\t\n\t\tthis.fireEvent(new mxEventObject(mxEvent.SELECT));\n\t\tfunct();\n\t}));\n\t\n\tthis.container.appendChild(img);\n\t\n\tif (this.defaultMode == null)\n\t{\n\t\tthis.defaultMode = img;\n\t\t\n\t\t// Function should fire only once so\n\t\t// do not pass it with the select event\n\t\tthis.selectMode(img);\n\t\tfunct();\n\t}\n\t\n\treturn img;\n};\n\n/**\n * Function: addMode\n * \n * Adds a new item to the toolbar. The selection is typically reset after\n * the item has been consumed, for example by adding a new vertex to the\n * graph. The reset is not carried out if the item is double clicked.\n * \n * The function argument uses the following signature: funct(evt, cell) where\n * evt is the native mouse event and cell is the cell under the mouse.\n */\nmxToolbar.prototype.addMode = function(title, icon, funct, pressedIcon, style, toggle)\n{\n\ttoggle = (toggle != null) ? toggle : true;\n\tvar img = document.createElement((icon != null) ? 'img' : 'button');\n\t\n\timg.initialClassName = style || 'mxToolbarMode';\n\timg.className = img.initialClassName;\n\timg.setAttribute('src', icon);\n\timg.altIcon = pressedIcon;\n\n\tif (title != null)\n\t{\n\t\timg.setAttribute('title', title);\n\t}\n\t\n\tif (this.enabled && toggle)\n\t{\n\t\tmxEvent.addListener(img, 'click', mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tthis.selectMode(img, funct);\n\t\t\tthis.noReset = false;\n\t\t}));\n\t\t\n\t\tmxEvent.addListener(img, 'dblclick', mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tthis.selectMode(img, funct);\n\t\t\tthis.noReset = true;\n\t\t}));\n\t\t\n\t\tif (this.defaultMode == null)\n\t\t{\n\t\t\tthis.defaultMode = img;\n\t\t\tthis.defaultFunction = funct;\n\t\t\tthis.selectMode(img, funct);\n\t\t}\n\t}\n\n\tthis.container.appendChild(img);\t\t\t\t\t\n\n\treturn img;\n};\n\n/**\n * Function: selectMode\n * \n * Resets the state of the previously selected mode and displays the given\n * DOM node as selected. This function fires a select event with the given\n * function as a parameter.\n */\nmxToolbar.prototype.selectMode = function(domNode, funct)\n{\n\tif (this.selectedMode != domNode)\n\t{\n\t\tif (this.selectedMode != null)\n\t\t{\n\t\t\tvar tmp = this.selectedMode.altIcon;\n\t\t\t\n\t\t\tif (tmp != null)\n\t\t\t{\n\t\t\t\tthis.selectedMode.altIcon = this.selectedMode.getAttribute('src');\n\t\t\t\tthis.selectedMode.setAttribute('src', tmp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.selectedMode.className = this.selectedMode.initialClassName;\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.selectedMode = domNode;\n\t\tvar tmp = this.selectedMode.altIcon;\n\t\t\n\t\tif (tmp != null)\n\t\t{\n\t\t\tthis.selectedMode.altIcon = this.selectedMode.getAttribute('src');\n\t\t\tthis.selectedMode.setAttribute('src', tmp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.selectedMode.className = this.selectedMode.initialClassName+'Selected';\n\t\t}\n\t\t\n\t\tthis.fireEvent(new mxEventObject(mxEvent.SELECT, \"function\", funct));\n\t}\n};\n\n/**\n * Function: resetMode\n * \n * Selects the default mode and resets the state of the previously selected\n * mode.\n */\nmxToolbar.prototype.resetMode = function(forced)\n{\n\tif ((forced || !this.noReset) && this.selectedMode != this.defaultMode)\n\t{\n\t\t// The last selected switch mode will be activated\n\t\t// so the function was already executed and is\n\t\t// no longer required here\n\t\tthis.selectMode(this.defaultMode, this.defaultFunction);\n\t}\n};\n\n/**\n * Function: addSeparator\n * \n * Adds the specifies image as a separator.\n * \n * Parameters:\n * \n * icon - URL of the separator icon.\n */\nmxToolbar.prototype.addSeparator = function(icon)\n{\n\treturn this.addItem(null, icon, null);\n};\n\n/**\n * Function: addBreak\n * \n * Adds a break to the container.\n */\nmxToolbar.prototype.addBreak = function()\n{\n\tmxUtils.br(this.container);\n};\n\n/**\n * Function: addLine\n * \n * Adds a horizontal line to the container.\n */\nmxToolbar.prototype.addLine = function()\n{\n\tvar hr = document.createElement('hr');\n\t\n\thr.style.marginRight = '6px';\n\thr.setAttribute('size', '1');\n\t\n\tthis.container.appendChild(hr);\n};\n\n/**\n * Function: destroy\n * \n * Removes the toolbar and all its associated resources.\n */\nmxToolbar.prototype.destroy = function ()\n{\n\tmxEvent.release(this.container);\n\tthis.container = null;\n\tthis.defaultMode = null;\n\tthis.defaultFunction = null;\n\tthis.selectedMode = null;\n\t\n\tif (this.menu != null)\n\t{\n\t\tthis.menu.destroy();\n\t}\n};\n\n__mxOutput.mxToolbar = typeof mxToolbar !== 'undefined' ? mxToolbar : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxUndoableEdit\n * \n * Implements a composite undoable edit. Here is an example for a custom change\n * which gets executed via the model:\n * \n * (code)\n * function CustomChange(model, name)\n * {\n *   this.model = model;\n *   this.name = name;\n *   this.previous = name;\n * };\n * \n * CustomChange.prototype.execute = function()\n * {\n *   var tmp = this.model.name;\n *   this.model.name = this.previous;\n *   this.previous = tmp;\n * };\n * \n * var name = prompt('Enter name');\n * graph.model.execute(new CustomChange(graph.model, name));\n * (end)\n * \n * Event: mxEvent.EXECUTED\n * \n * Fires between START_EDIT and END_EDIT after an atomic change was executed.\n * The <code>change</code> property contains the change that was executed.\n * \n * Event: mxEvent.START_EDIT\n * \n * Fires before a set of changes will be executed in <undo> or <redo>.\n * This event contains no properties.\n * \n * Event: mxEvent.END_EDIT\n *\n * Fires after a set of changeswas executed in <undo> or <redo>.\n * This event contains no properties.\n * \n * Constructor: mxUndoableEdit\n * \n * Constructs a new undoable edit for the given source.\n */\nfunction mxUndoableEdit(source, significant)\n{\n\tthis.source = source;\n\tthis.changes = [];\n\tthis.significant = (significant != null) ? significant : true;\n};\n\n/**\n * Variable: source\n * \n * Specifies the source of the edit.\n */\nmxUndoableEdit.prototype.source = null;\n\n/**\n * Variable: changes\n * \n * Array that contains the changes that make up this edit. The changes are\n * expected to either have an undo and redo function, or an execute\n * function. Default is an empty array.\n */\nmxUndoableEdit.prototype.changes = null;\n\n/**\n * Variable: significant\n * \n * Specifies if the undoable change is significant.\n * Default is true.\n */\nmxUndoableEdit.prototype.significant = null;\n\n/**\n * Variable: undone\n * \n * Specifies if this edit has been undone. Default is false.\n */\nmxUndoableEdit.prototype.undone = false;\n\n/**\n * Variable: redone\n * \n * Specifies if this edit has been redone. Default is false.\n */\nmxUndoableEdit.prototype.redone = false;\n\n/**\n * Function: isEmpty\n * \n * Returns true if the this edit contains no changes.\n */\nmxUndoableEdit.prototype.isEmpty = function()\n{\n\treturn this.changes.length == 0;\n};\n\n/**\n * Function: isSignificant\n * \n * Returns <significant>.\n */\nmxUndoableEdit.prototype.isSignificant = function()\n{\n\treturn this.significant;\n};\n\n/**\n * Function: add\n * \n * Adds the specified change to this edit. The change is an object that is\n * expected to either have an undo and redo, or an execute function.\n */\nmxUndoableEdit.prototype.add = function(change)\n{\n\tthis.changes.push(change);\n};\n\n/**\n * Function: notify\n * \n * Hook to notify any listeners of the changes after an <undo> or <redo>\n * has been carried out. This implementation is empty.\n */\nmxUndoableEdit.prototype.notify = function() { };\n\n/**\n * Function: die\n * \n * Hook to free resources after the edit has been removed from the command\n * history. This implementation is empty.\n */\nmxUndoableEdit.prototype.die = function() { };\n\n/**\n * Function: undo\n * \n * Undoes all changes in this edit.\n */\nmxUndoableEdit.prototype.undo = function()\n{\n\tif (!this.undone)\n\t{\n\t\tthis.source.fireEvent(new mxEventObject(mxEvent.START_EDIT));\n\t\tvar count = this.changes.length;\n\t\t\n\t\tfor (var i = count - 1; i >= 0; i--)\n\t\t{\n\t\t\tvar change = this.changes[i];\n\t\t\t\n\t\t\tif (change.execute != null)\n\t\t\t{\n\t\t\t\tchange.execute();\n\t\t\t}\n\t\t\telse if (change.undo != null)\n\t\t\t{\n\t\t\t\tchange.undo();\n\t\t\t}\n\t\t\t\n\t\t\t// New global executed event\n\t\t\tthis.source.fireEvent(new mxEventObject(mxEvent.EXECUTED, 'change', change));\n\t\t}\n\t\t\n\t\tthis.undone = true;\n\t\tthis.redone = false;\n\t\tthis.source.fireEvent(new mxEventObject(mxEvent.END_EDIT));\n\t}\n\t\n\tthis.notify();\n};\n\n/**\n * Function: redo\n * \n * Redoes all changes in this edit.\n */\nmxUndoableEdit.prototype.redo = function()\n{\n\tif (!this.redone)\n\t{\n\t\tthis.source.fireEvent(new mxEventObject(mxEvent.START_EDIT));\n\t\tvar count = this.changes.length;\n\t\t\n\t\tfor (var i = 0; i < count; i++)\n\t\t{\n\t\t\tvar change = this.changes[i];\n\t\t\t\n\t\t\tif (change.execute != null)\n\t\t\t{\n\t\t\t\tchange.execute();\n\t\t\t}\n\t\t\telse if (change.redo != null)\n\t\t\t{\n\t\t\t\tchange.redo();\n\t\t\t}\n\t\t\t\n\t\t\t// New global executed event\n\t\t\tthis.source.fireEvent(new mxEventObject(mxEvent.EXECUTED, 'change', change));\n\t\t}\n\t\t\n\t\tthis.undone = false;\n\t\tthis.redone = true;\n\t\tthis.source.fireEvent(new mxEventObject(mxEvent.END_EDIT));\n\t}\n\t\n\tthis.notify();\n};\n\n__mxOutput.mxUndoableEdit = typeof mxUndoableEdit !== 'undefined' ? mxUndoableEdit : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxUndoManager\n *\n * Implements a command history. When changing the graph model, an\n * <mxUndoableChange> object is created at the start of the transaction (when\n * model.beginUpdate is called). All atomic changes are then added to this\n * object until the last model.endUpdate call, at which point the\n * <mxUndoableEdit> is dispatched in an event, and added to the history inside\n * <mxUndoManager>. This is done by an event listener in\n * <mxEditor.installUndoHandler>.\n * \n * Each atomic change of the model is represented by an object (eg.\n * <mxRootChange>, <mxChildChange>, <mxTerminalChange> etc) which contains the\n * complete undo information. The <mxUndoManager> also listens to the\n * <mxGraphView> and stores it's changes to the current root as insignificant\n * undoable changes, so that drilling (step into, step up) is undone.\n * \n * This means when you execute an atomic change on the model, then change the\n * current root on the view and click undo, the change of the root will be\n * undone together with the change of the model so that the display represents\n * the state at which the model was changed. However, these changes are not\n * transmitted for sharing as they do not represent a state change.\n *\n * Example:\n * \n * When adding an undo manager to a graph, make sure to add it\n * to the model and the view as well to maintain a consistent\n * display across multiple undo/redo steps.\n *\n * (code)\n * var undoManager = new mxUndoManager();\n * var listener = function(sender, evt)\n * {\n *   undoManager.undoableEditHappened(evt.getProperty('edit'));\n * };\n * graph.getModel().addListener(mxEvent.UNDO, listener);\n * graph.getView().addListener(mxEvent.UNDO, listener);\n * (end)\n * \n * The code creates a function that informs the undoManager\n * of an undoable edit and binds it to the undo event of\n * <mxGraphModel> and <mxGraphView> using\n * <mxEventSource.addListener>.\n * \n * Event: mxEvent.CLEAR\n * \n * Fires after <clear> was invoked. This event has no properties.\n * \n * Event: mxEvent.UNDO\n * \n * Fires afer a significant edit was undone in <undo>. The <code>edit</code>\n * property contains the <mxUndoableEdit> that was undone.\n * \n * Event: mxEvent.REDO\n * \n * Fires afer a significant edit was redone in <redo>. The <code>edit</code>\n * property contains the <mxUndoableEdit> that was redone.\n * \n * Event: mxEvent.ADD\n * \n * Fires after an undoable edit was added to the history. The <code>edit</code>\n * property contains the <mxUndoableEdit> that was added.\n * \n * Constructor: mxUndoManager\n *\n * Constructs a new undo manager with the given history size. If no history\n * size is given, then a default size of 100 steps is used.\n */\nfunction mxUndoManager(size)\n{\n\tthis.size = (size != null) ? size : 100;\n\tthis.clear();\n};\n\n/**\n * Extends mxEventSource.\n */\nmxUndoManager.prototype = new mxEventSource();\nmxUndoManager.prototype.constructor = mxUndoManager;\n\n/**\n * Variable: size\n * \n * Maximum command history size. 0 means unlimited history. Default is\n * 100.\n */\nmxUndoManager.prototype.size = null;\n\n/**\n * Variable: history\n * \n * Array that contains the steps of the command history.\n */\nmxUndoManager.prototype.history = null;\n\n/**\n * Variable: indexOfNextAdd\n * \n * Index of the element to be added next.\n */\nmxUndoManager.prototype.indexOfNextAdd = 0;\n\n/**\n * Function: isEmpty\n * \n * Returns true if the history is empty.\n */\nmxUndoManager.prototype.isEmpty = function()\n{\n\treturn this.history.length == 0;\n};\n\n/**\n * Function: clear\n * \n * Clears the command history.\n */\nmxUndoManager.prototype.clear = function()\n{\n\tthis.history = [];\n\tthis.indexOfNextAdd = 0;\n\tthis.fireEvent(new mxEventObject(mxEvent.CLEAR));\n};\n\n/**\n * Function: canUndo\n * \n * Returns true if an undo is possible.\n */\nmxUndoManager.prototype.canUndo = function()\n{\n\treturn this.indexOfNextAdd > 0;\n};\n\n/**\n * Function: undo\n * \n * Undoes the last change.\n */\nmxUndoManager.prototype.undo = function()\n{\n    while (this.indexOfNextAdd > 0)\n    {\n        var edit = this.history[--this.indexOfNextAdd];\n        edit.undo();\n\n\t\tif (edit.isSignificant())\n        {\n        \tthis.fireEvent(new mxEventObject(mxEvent.UNDO, 'edit', edit));\n            break;\n        }\n    }\n};\n\n/**\n * Function: canRedo\n * \n * Returns true if a redo is possible.\n */\nmxUndoManager.prototype.canRedo = function()\n{\n\treturn this.indexOfNextAdd < this.history.length;\n};\n\n/**\n * Function: redo\n * \n * Redoes the last change.\n */\nmxUndoManager.prototype.redo = function()\n{\n    var n = this.history.length;\n    \n    while (this.indexOfNextAdd < n)\n    {\n        var edit =  this.history[this.indexOfNextAdd++];\n        edit.redo();\n        \n        if (edit.isSignificant())\n        {\n        \tthis.fireEvent(new mxEventObject(mxEvent.REDO, 'edit', edit));\n            break;\n        }\n    }\n};\n\n/**\n * Function: undoableEditHappened\n * \n * Method to be called to add new undoable edits to the <history>.\n */\nmxUndoManager.prototype.undoableEditHappened = function(undoableEdit)\n{\n\tthis.trim();\n\t\n\tif (this.size > 0 &&\n\t\tthis.size == this.history.length)\n\t{\n\t\tthis.history.shift();\n\t}\n\t\n\tthis.history.push(undoableEdit);\n\tthis.indexOfNextAdd = this.history.length;\n\tthis.fireEvent(new mxEventObject(mxEvent.ADD, 'edit', undoableEdit));\n};\n\n/**\n * Function: trim\n * \n * Removes all pending steps after <indexOfNextAdd> from the history,\n * invoking die on each edit. This is called from <undoableEditHappened>.\n */\nmxUndoManager.prototype.trim = function()\n{\n\tif (this.history.length > this.indexOfNextAdd)\n\t{\n\t\tvar edits = this.history.splice(this.indexOfNextAdd,\n\t\t\tthis.history.length - this.indexOfNextAdd);\n\t\t\t\n\t\tfor (var i = 0; i < edits.length; i++)\n\t\t{\n\t\t\tedits[i].die();\n\t\t}\n\t}\n};\n\n__mxOutput.mxUndoManager = typeof mxUndoManager !== 'undefined' ? mxUndoManager : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n *\n * Class: mxUrlConverter\n * \n * Converts relative and absolute URLs to absolute URLs with protocol and domain.\n */\nvar mxUrlConverter = function()\n{\n\t// Empty constructor\n};\n\n/**\n * Variable: enabled\n * \n * Specifies if the converter is enabled. Default is true.\n */\nmxUrlConverter.prototype.enabled = true;\n\n/**\n * Variable: baseUrl\n * \n * Specifies the base URL to be used as a prefix for relative URLs.\n */\nmxUrlConverter.prototype.baseUrl = null;\n\n/**\n * Variable: baseDomain\n * \n * Specifies the base domain to be used as a prefix for absolute URLs.\n */\nmxUrlConverter.prototype.baseDomain = null;\n\n/**\n * Function: updateBaseUrl\n * \n * Private helper function to update the base URL.\n */\nmxUrlConverter.prototype.updateBaseUrl = function()\n{\n\tthis.baseDomain = location.protocol + '//' + location.host;\n\tthis.baseUrl = this.baseDomain + location.pathname;\n\tvar tmp = this.baseUrl.lastIndexOf('/');\n\t\n\t// Strips filename etc\n\tif (tmp > 0)\n\t{\n\t\tthis.baseUrl = this.baseUrl.substring(0, tmp + 1);\n\t}\n};\n\n/**\n * Function: isEnabled\n * \n * Returns <enabled>.\n */\nmxUrlConverter.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n * \n * Sets <enabled>.\n */\nmxUrlConverter.prototype.setEnabled = function(value)\n{\n\tthis.enabled = value;\n};\n\n/**\n * Function: getBaseUrl\n * \n * Returns <baseUrl>.\n */\nmxUrlConverter.prototype.getBaseUrl = function()\n{\n\treturn this.baseUrl;\n};\n\n/**\n * Function: setBaseUrl\n * \n * Sets <baseUrl>.\n */\nmxUrlConverter.prototype.setBaseUrl = function(value)\n{\n\tthis.baseUrl = value;\n};\n\n/**\n * Function: getBaseDomain\n * \n * Returns <baseDomain>.\n */\nmxUrlConverter.prototype.getBaseDomain = function()\n{\n\treturn this.baseDomain;\n};\n\n/**\n * Function: setBaseDomain\n * \n * Sets <baseDomain>.\n */\nmxUrlConverter.prototype.setBaseDomain = function(value)\n{\n\tthis.baseDomain = value;\n};\n\n/**\n * Function: isRelativeUrl\n * \n * Returns true if the given URL is relative.\n */\nmxUrlConverter.prototype.isRelativeUrl = function(url)\n{\n\treturn url != null && url.substring(0, 2) != '//' && url.substring(0, 7) != 'http://' &&\n\t\turl.substring(0, 8) != 'https://' && url.substring(0, 10) != 'data:image' &&\n\t\turl.substring(0, 7) != 'file://';\n};\n\n/**\n * Function: convert\n * \n * Converts the given URL to an absolute URL with protol and domain.\n * Relative URLs are first converted to absolute URLs.\n */\nmxUrlConverter.prototype.convert = function(url)\n{\n\tif (this.isEnabled() && this.isRelativeUrl(url))\n\t{\n\t\tif (this.getBaseUrl() == null)\n\t\t{\n\t\t\tthis.updateBaseUrl();\n\t\t}\n\t\t\n\t\tif (url.charAt(0) == '/')\n\t\t{\n\t\t\turl = this.getBaseDomain() + url;\n\t\t}\n\t\telse\n\t\t{\n\t\t\turl = this.getBaseUrl() + url;\n\t\t}\n\t}\n\t\n\treturn url;\n};\n\n__mxOutput.mxUrlConverter = typeof mxUrlConverter !== 'undefined' ? mxUrlConverter : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxPanningManager\n *\n * Implements a handler for panning.\n */\nfunction mxPanningManager(graph)\n{\n\tthis.thread = null;\n\tthis.active = false;\n\tthis.tdx = 0;\n\tthis.tdy = 0;\n\tthis.t0x = 0;\n\tthis.t0y = 0;\n\tthis.dx = 0;\n\tthis.dy = 0;\n\tthis.scrollbars = false;\n\tthis.scrollLeft = 0;\n\tthis.scrollTop = 0;\n\t\n\tthis.mouseListener =\n\t{\n\t    mouseDown: function(sender, me) { },\n\t    mouseMove: function(sender, me) { },\n\t    mouseUp: mxUtils.bind(this, function(sender, me)\n\t    {\n\t    \tif (this.active)\n\t    \t{\n\t    \t\tthis.stop();\n\t    \t}\n\t    })\n\t};\n\t\n\tgraph.addMouseListener(this.mouseListener);\n\t\n\tthis.mouseUpListener = mxUtils.bind(this, function()\n\t{\n\t    \tif (this.active)\n\t    \t{\n\t    \t\tthis.stop();\n\t    \t}\n\t});\n\t\n\t// Stops scrolling on every mouseup anywhere in the document\n\tmxEvent.addListener(document, 'mouseup', this.mouseUpListener);\n\t\n\tvar createThread = mxUtils.bind(this, function()\n\t{\n\t    \tthis.scrollbars = mxUtils.hasScrollbars(graph.container);\n\t    \tthis.scrollLeft = graph.container.scrollLeft;\n\t    \tthis.scrollTop = graph.container.scrollTop;\n\t\n\t    \treturn window.setInterval(mxUtils.bind(this, function()\n\t\t{\n\t\t\tthis.tdx -= this.dx;\n\t\t\tthis.tdy -= this.dy;\n\n\t\t\tif (this.scrollbars)\n\t\t\t{\n\t\t\t\tvar left = -graph.container.scrollLeft - Math.ceil(this.dx);\n\t\t\t\tvar top = -graph.container.scrollTop - Math.ceil(this.dy);\n\t\t\t\tgraph.panGraph(left, top);\n\t\t\t\tgraph.panDx = this.scrollLeft - graph.container.scrollLeft;\n\t\t\t\tgraph.panDy = this.scrollTop - graph.container.scrollTop;\n\t\t\t\tgraph.fireEvent(new mxEventObject(mxEvent.PAN));\n\t\t\t\t// TODO: Implement graph.autoExtend\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgraph.panGraph(this.getDx(), this.getDy());\n\t\t\t}\n\t\t}), this.delay);\n\t});\n\t\n\tthis.isActive = function()\n\t{\n\t\treturn active;\n\t};\n\t\n\tthis.getDx = function()\n\t{\n\t\treturn Math.round(this.tdx);\n\t};\n\t\n\tthis.getDy = function()\n\t{\n\t\treturn Math.round(this.tdy);\n\t};\n\t\n\tthis.start = function()\n\t{\n\t\tthis.t0x = graph.view.translate.x;\n\t\tthis.t0y = graph.view.translate.y;\n\t\tthis.active = true;\n\t};\n\t\n\tthis.panTo = function(x, y, w, h)\n\t{\n\t\tif (!this.active)\n\t\t{\n\t\t\tthis.start();\n\t\t}\n\t\t\n    \tthis.scrollLeft = graph.container.scrollLeft;\n    \tthis.scrollTop = graph.container.scrollTop;\n\t\t\n\t\tw = (w != null) ? w : 0;\n\t\th = (h != null) ? h : 0;\n\t\t\n\t\tvar c = graph.container;\n\t\tthis.dx = x + w - c.scrollLeft - c.clientWidth;\n\t\t\n\t\tif (this.dx < 0 && Math.abs(this.dx) < this.border)\n\t\t{\n\t\t\tthis.dx = this.border + this.dx;\n\t\t}\n\t\telse if (this.handleMouseOut)\n\t\t{\n\t\t\tthis.dx = Math.max(this.dx, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.dx = 0;\n\t\t}\n\t\t\n\t\tif (this.dx == 0)\n\t\t{\n\t\t\tthis.dx = x - c.scrollLeft;\n\t\t\t\n\t\t\tif (this.dx > 0 && this.dx < this.border)\n\t\t\t{\n\t\t\t\tthis.dx = this.dx - this.border;\n\t\t\t}\n\t\t\telse if (this.handleMouseOut)\n\t\t\t{\n\t\t\t\tthis.dx = Math.min(0, this.dx);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.dx = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.dy = y + h - c.scrollTop - c.clientHeight;\n\n\t\tif (this.dy < 0 && Math.abs(this.dy) < this.border)\n\t\t{\n\t\t\tthis.dy = this.border + this.dy;\n\t\t}\n\t\telse if (this.handleMouseOut)\n\t\t{\n\t\t\tthis.dy = Math.max(this.dy, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.dy = 0;\n\t\t}\n\t\t\n\t\tif (this.dy == 0)\n\t\t{\n\t\t\tthis.dy = y - c.scrollTop;\n\t\t\t\n\t\t\tif (this.dy > 0 && this.dy < this.border)\n\t\t\t{\n\t\t\t\tthis.dy = this.dy - this.border;\n\t\t\t}\n\t\t\telse if (this.handleMouseOut)\n\t\t\t{\n\t\t\t\tthis.dy = Math.min(0, this.dy);\n\t\t\t} \n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.dy = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (this.dx != 0 || this.dy != 0)\n\t\t{\n\t\t\tthis.dx *= this.damper;\n\t\t\tthis.dy *= this.damper;\n\t\t\t\n\t\t\tif (this.thread == null)\n\t\t\t{\n\t\t\t\tthis.thread = createThread();\n\t\t\t}\n\t\t}\n\t\telse if (this.thread != null)\n\t\t{\n\t\t\twindow.clearInterval(this.thread);\n\t\t\tthis.thread = null;\n\t\t}\n\t};\n\t\n\tthis.stop = function()\n\t{\n\t\tif (this.active)\n\t\t{\n\t\t\tthis.active = false;\n\t\t\n\t\t\tif (this.thread != null)\n\t    \t{\n\t\t\t\twindow.clearInterval(this.thread);\n\t\t\t\tthis.thread = null;\n\t    \t}\n\t\t\t\n\t\t\tthis.tdx = 0;\n\t\t\tthis.tdy = 0;\n\t\t\t\n\t\t\tif (!this.scrollbars)\n\t\t\t{\n\t\t\t\tvar px = graph.panDx;\n\t\t\t\tvar py = graph.panDy;\n\t\t    \t\n\t\t    \tif (px != 0 || py != 0)\n\t\t    \t{\n\t\t    \t\tgraph.panGraph(0, 0);\n\t\t\t    \tgraph.view.setTranslate(this.t0x + px / graph.view.scale, this.t0y + py / graph.view.scale);\n\t\t    \t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgraph.panDx = 0;\n\t\t\t\tgraph.panDy = 0;\n\t\t\t\tgraph.fireEvent(new mxEventObject(mxEvent.PAN));\n\t\t\t}\n\t\t}\n\t};\n\t\n\tthis.destroy = function()\n\t{\n\t\tgraph.removeMouseListener(this.mouseListener);\n\t\tmxEvent.removeListener(document, 'mouseup', this.mouseUpListener);\n\t};\n};\n\n/**\n * Variable: damper\n * \n * Damper value for the panning. Default is 1/6.\n */\nmxPanningManager.prototype.damper = 1/6;\n\n/**\n * Variable: delay\n * \n * Delay in milliseconds for the panning. Default is 10.\n */\nmxPanningManager.prototype.delay = 10;\n\n/**\n * Variable: handleMouseOut\n * \n * Specifies if mouse events outside of the component should be handled. Default is true. \n */\nmxPanningManager.prototype.handleMouseOut = true;\n\n/**\n * Variable: border\n * \n * Border to handle automatic panning inside the component. Default is 0 (disabled).\n */\nmxPanningManager.prototype.border = 0;\n\n__mxOutput.mxPanningManager = typeof mxPanningManager !== 'undefined' ? mxPanningManager : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxPopupMenu\n * \n * Basic popup menu. To add a vertical scrollbar to a given submenu, the\n * following code can be used.\n * \n * (code)\n * var mxPopupMenuShowMenu = mxPopupMenu.prototype.showMenu;\n * mxPopupMenu.prototype.showMenu = function()\n * {\n *   mxPopupMenuShowMenu.apply(this, arguments);\n *   \n *   this.div.style.overflowY = 'auto';\n *   this.div.style.overflowX = 'hidden';\n *   this.div.style.maxHeight = '160px';\n * };\n * (end)\n * \n * Constructor: mxPopupMenu\n * \n * Constructs a popupmenu.\n * \n * Event: mxEvent.SHOW\n *\n * Fires after the menu has been shown in <popup>.\n */\nfunction mxPopupMenu(factoryMethod)\n{\n\tthis.factoryMethod = factoryMethod;\n\t\n\tif (factoryMethod != null)\n\t{\n\t\tthis.init();\n\t}\n};\n\n/**\n * Extends mxEventSource.\n */\nmxPopupMenu.prototype = new mxEventSource();\nmxPopupMenu.prototype.constructor = mxPopupMenu;\n\n/**\n * Variable: submenuImage\n * \n * URL of the image to be used for the submenu icon.\n */\nmxPopupMenu.prototype.submenuImage = mxClient.imageBasePath + '/submenu.gif';\n\n/**\n * Variable: zIndex\n * \n * Specifies the zIndex for the popupmenu and its shadow. Default is 10006.\n */\nmxPopupMenu.prototype.zIndex = 10006;\n\n/**\n * Variable: factoryMethod\n * \n * Function that is used to create the popup menu. The function takes the\n * current panning handler, the <mxCell> under the mouse and the mouse\n * event that triggered the call as arguments.\n */\nmxPopupMenu.prototype.factoryMethod = null;\n\n/**\n * Variable: useLeftButtonForPopup\n * \n * Specifies if popupmenus should be activated by clicking the left mouse\n * button. Default is false.\n */\nmxPopupMenu.prototype.useLeftButtonForPopup = false;\n\n/**\n * Variable: enabled\n * \n * Specifies if events are handled. Default is true.\n */\nmxPopupMenu.prototype.enabled = true;\n\n/**\n * Variable: itemCount\n * \n * Contains the number of times <addItem> has been called for a new menu.\n */\nmxPopupMenu.prototype.itemCount = 0;\n\n/**\n * Variable: autoExpand\n * \n * Specifies if submenus should be expanded on mouseover. Default is false.\n */\nmxPopupMenu.prototype.autoExpand = false;\n\n/**\n * Variable: smartSeparators\n * \n * Specifies if separators should only be added if a menu item follows them.\n * Default is false.\n */\nmxPopupMenu.prototype.smartSeparators = false;\n\n/**\n * Variable: labels\n * \n * Specifies if any labels should be visible. Default is true.\n */\nmxPopupMenu.prototype.labels = true;\n\n/**\n * Function: init\n * \n * Initializes the shapes required for this vertex handler.\n */\nmxPopupMenu.prototype.init = function()\n{\n\t// Adds the inner table\n\tthis.table = document.createElement('table');\n\tthis.table.className = 'mxPopupMenu';\n\t\n\tthis.tbody = document.createElement('tbody');\n\tthis.table.appendChild(this.tbody);\n\n\t// Adds the outer div\n\tthis.div = document.createElement('div');\n\tthis.div.className = 'mxPopupMenu';\n\tthis.div.style.display = 'inline';\n\tthis.div.style.zIndex = this.zIndex;\n\tthis.div.appendChild(this.table);\n\n\t// Disables the context menu on the outer div\n\tmxEvent.disableContextMenu(this.div);\n};\n\n/**\n * Function: isEnabled\n * \n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxPopupMenu.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\t\n/**\n * Function: setEnabled\n * \n * Enables or disables event handling. This implementation\n * updates <enabled>.\n */\nmxPopupMenu.prototype.setEnabled = function(enabled)\n{\n\tthis.enabled = enabled;\n};\n\n/**\n * Function: isPopupTrigger\n * \n * Returns true if the given event is a popupmenu trigger for the optional\n * given cell.\n * \n * Parameters:\n * \n * me - <mxMouseEvent> that represents the mouse event.\n */\nmxPopupMenu.prototype.isPopupTrigger = function(me)\n{\n\treturn me.isPopupTrigger() || (this.useLeftButtonForPopup && mxEvent.isLeftMouseButton(me.getEvent()));\n};\n\n/**\n * Function: addItem\n * \n * Adds the given item to the given parent item. If no parent item is specified\n * then the item is added to the top-level menu. The return value may be used\n * as the parent argument, ie. as a submenu item. The return value is the table\n * row that represents the item.\n * \n * Paramters:\n * \n * title - String that represents the title of the menu item.\n * image - Optional URL for the image icon.\n * funct - Function associated that takes a mouseup or touchend event.\n * parent - Optional item returned by <addItem>.\n * iconCls - Optional string that represents the CSS class for the image icon.\n * IconsCls is ignored if image is given.\n * enabled - Optional boolean indicating if the item is enabled. Default is true.\n * active - Optional boolean indicating if the menu should implement any event handling.\n * Default is true.\n * noHover - Optional boolean to disable hover state.\n */\nmxPopupMenu.prototype.addItem = function(title, image, funct, parent, iconCls, enabled, active, noHover)\n{\n\tparent = parent || this;\n\tthis.itemCount++;\n\t\n\t// Smart separators only added if element contains items\n\tif (parent.willAddSeparator)\n\t{\n\t\tif (parent.containsItems)\n\t\t{\n\t\t\tthis.addSeparator(parent, true);\n\t\t}\n\n\t\tparent.willAddSeparator = false;\n\t}\n\n\tparent.containsItems = true;\n\tvar tr = document.createElement('tr');\n\ttr.className = 'mxPopupMenuItem';\n\tvar col1 = document.createElement('td');\n\tcol1.className = 'mxPopupMenuIcon';\n\n\t// Adds the given image into the first column\n\tif (image != null)\n\t{\n\t\tvar img = document.createElement('img');\n\t\timg.src = image;\n\t\tcol1.appendChild(img);\n\t}\n\telse if (iconCls != null)\n\t{\n\t\tvar div = document.createElement('div');\n\t\tdiv.className = iconCls;\n\t\tcol1.appendChild(div);\n\t}\n\t\n\ttr.appendChild(col1);\n\t\n\tif (this.labels)\n\t{\n\t\tvar col2 = document.createElement('td');\n\t\tcol2.className = 'mxPopupMenuItem' +\n\t\t\t((enabled != null && !enabled) ? ' mxDisabled' : '');\n\t\t\n\t\tmxUtils.write(col2, title);\n\t\tcol2.align = 'left';\n\t\ttr.appendChild(col2);\n\t\n\t\tvar col3 = document.createElement('td');\n\t\tcol3.className = 'mxPopupMenuItem' +\n\t\t\t((enabled != null && !enabled) ? ' mxDisabled' : '');\n\t\tcol3.style.paddingRight = '6px';\n\t\tcol3.style.textAlign = 'right';\n\t\t\n\t\ttr.appendChild(col3);\n\t\t\n\t\tif (parent.div == null)\n\t\t{\n\t\t\tthis.createSubmenu(parent);\n\t\t}\n\t}\n\t\n\tparent.tbody.appendChild(tr);\n\n\tif (active != false && enabled != false)\n\t{\n\t\tvar currentSelection = null;\n\t\t\n\t\tmxEvent.addGestureListeners(tr,\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tthis.eventReceiver = tr;\n\t\t\t\t\n\t\t\t\tif (parent.activeRow != tr && parent.activeRow != parent)\n\t\t\t\t{\n\t\t\t\t\tif (parent.activeRow != null && parent.activeRow.div.parentNode != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.hideSubmenu(parent);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (tr.div != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.showSubmenu(parent, tr);\n\t\t\t\t\t\tparent.activeRow = tr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Workaround for lost current selection in page because of focus in IE\n\t\t\t\tif (document.selection != null && (mxClient.IS_QUIRKS || document.documentMode == 8))\n\t\t\t\t{\n\t\t\t\t\tcurrentSelection = document.selection.createRange();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t}),\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tif (parent.activeRow != tr && parent.activeRow != parent)\n\t\t\t\t{\n\t\t\t\t\tif (parent.activeRow != null && parent.activeRow.div.parentNode != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.hideSubmenu(parent);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (this.autoExpand && tr.div != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.showSubmenu(parent, tr);\n\t\t\t\t\t\tparent.activeRow = tr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n\t\t\t\t// Sets hover style because TR in IE doesn't have hover\n\t\t\t\tif (!noHover)\n\t\t\t\t{\n\t\t\t\t\ttr.className = 'mxPopupMenuItemHover';\n\t\t\t\t}\n\t\t\t}),\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\t// EventReceiver avoids clicks on a submenu item\n\t\t\t\t// which has just been shown in the mousedown\n\t\t\t\tif (this.eventReceiver == tr)\n\t\t\t\t{\n\t\t\t\t\tif (parent.activeRow != tr)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.hideMenu();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Workaround for lost current selection in page because of focus in IE\n\t\t\t\t\tif (currentSelection != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Workaround for \"unspecified error\" in IE8 standards\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurrentSelection.select();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentSelection = null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (funct != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tfunct(evt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.eventReceiver = null;\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t})\n\t\t);\n\t\n\t\t// Resets hover style because TR in IE doesn't have hover\n\t\tif (!noHover)\n\t\t{\n\t\t\tmxEvent.addListener(tr, 'mouseout',\n\t\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t\t{\n\t\t\t\t\ttr.className = 'mxPopupMenuItem';\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t}\n\t\n\treturn tr;\n};\n\n/**\n * Adds a checkmark to the given menuitem.\n */\nmxPopupMenu.prototype.addCheckmark = function(item, img)\n{\n\tvar td = item.firstChild.nextSibling;\n\ttd.style.backgroundImage = 'url(\\'' + img + '\\')';\n\ttd.style.backgroundRepeat = 'no-repeat';\n\ttd.style.backgroundPosition = '2px 50%';\n};\n\n/**\n * Function: createSubmenu\n * \n * Creates the nodes required to add submenu items inside the given parent\n * item. This is called in <addItem> if a parent item is used for the first\n * time. This adds various DOM nodes and a <submenuImage> to the parent.\n * \n * Parameters:\n * \n * parent - An item returned by <addItem>.\n */\nmxPopupMenu.prototype.createSubmenu = function(parent)\n{\n\tparent.table = document.createElement('table');\n\tparent.table.className = 'mxPopupMenu';\n\n\tparent.tbody = document.createElement('tbody');\n\tparent.table.appendChild(parent.tbody);\n\n\tparent.div = document.createElement('div');\n\tparent.div.className = 'mxPopupMenu';\n\n\tparent.div.style.position = 'absolute';\n\tparent.div.style.display = 'inline';\n\tparent.div.style.zIndex = this.zIndex;\n\t\n\tparent.div.appendChild(parent.table);\n\t\n\tvar img = document.createElement('img');\n\timg.setAttribute('src', this.submenuImage);\n\t\n\t// Last column of the submenu item in the parent menu\n\ttd = parent.firstChild.nextSibling.nextSibling;\n\ttd.appendChild(img);\n};\n\n/**\n * Function: showSubmenu\n * \n * Shows the submenu inside the given parent row.\n */\nmxPopupMenu.prototype.showSubmenu = function(parent, row)\n{\n\tif (row.div != null)\n\t{\n\t\trow.div.style.left = (parent.div.offsetLeft +\n\t\t\trow.offsetLeft+row.offsetWidth - 1) + 'px';\n\t\trow.div.style.top = (parent.div.offsetTop+row.offsetTop) + 'px';\n\t\tdocument.body.appendChild(row.div);\n\t\t\n\t\t// Moves the submenu to the left side if there is no space\n\t\tvar left = parseInt(row.div.offsetLeft);\n\t\tvar width = parseInt(row.div.offsetWidth);\n\t\tvar offset = mxUtils.getDocumentScrollOrigin(document);\n\t\t\n\t\tvar b = document.body;\n\t\tvar d = document.documentElement;\n\t\t\n\t\tvar right = offset.x + (b.clientWidth || d.clientWidth);\n\t\t\n\t\tif (left + width > right)\n\t\t{\n\t\t\trow.div.style.left = Math.max(0, (parent.div.offsetLeft - width + ((mxClient.IS_IE) ? 6 : -6))) + 'px';\n\t\t}\n\t\t\n\t\tmxUtils.fit(row.div);\n\t}\n};\n\n/**\n * Function: addSeparator\n * \n * Adds a horizontal separator in the given parent item or the top-level menu\n * if no parent is specified.\n * \n * Parameters:\n * \n * parent - Optional item returned by <addItem>.\n * force - Optional boolean to ignore <smartSeparators>. Default is false.\n */\nmxPopupMenu.prototype.addSeparator = function(parent, force)\n{\n\tparent = parent || this;\n\t\n\tif (this.smartSeparators && !force)\n\t{\n\t\tparent.willAddSeparator = true;\n\t}\n\telse if (parent.tbody != null)\n\t{\n\t\tparent.willAddSeparator = false;\n\t\tvar tr = document.createElement('tr');\n\t\t\n\t\tvar col1 = document.createElement('td');\n\t\tcol1.className = 'mxPopupMenuIcon';\n\t\tcol1.style.padding = '0 0 0 0px';\n\t\t\n\t\ttr.appendChild(col1);\n\t\t\n\t\tvar col2 = document.createElement('td');\n\t\tcol2.style.padding = '0 0 0 0px';\n\t\tcol2.setAttribute('colSpan', '2');\n\t\n\t\tvar hr = document.createElement('hr');\n\t\thr.setAttribute('size', '1');\n\t\tcol2.appendChild(hr);\n\t\t\n\t\ttr.appendChild(col2);\n\t\t\n\t\tparent.tbody.appendChild(tr);\n\t}\n};\n\n/**\n * Function: popup\n * \n * Shows the popup menu for the given event and cell.\n * \n * Example:\n * \n * (code)\n * graph.panningHandler.popup = function(x, y, cell, evt)\n * {\n *   mxUtils.alert('Hello, World!');\n * }\n * (end)\n */\nmxPopupMenu.prototype.popup = function(x, y, cell, evt)\n{\n\tif (this.div != null && this.tbody != null && this.factoryMethod != null)\n\t{\n\t\tthis.div.style.left = x + 'px';\n\t\tthis.div.style.top = y + 'px';\n\t\t\n\t\t// Removes all child nodes from the existing menu\n\t\twhile (this.tbody.firstChild != null)\n\t\t{\n\t\t\tmxEvent.release(this.tbody.firstChild);\n\t\t\tthis.tbody.removeChild(this.tbody.firstChild);\n\t\t}\n\t\t\n\t\tthis.itemCount = 0;\n\t\tthis.factoryMethod(this, cell, evt);\n\t\t\n\t\tif (this.itemCount > 0)\n\t\t{\n\t\t\tthis.showMenu();\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.SHOW));\n\t\t}\n\t}\n};\n\n/**\n * Function: isMenuShowing\n * \n * Returns true if the menu is showing.\n */\nmxPopupMenu.prototype.isMenuShowing = function()\n{\n\treturn this.div != null && this.div.parentNode == document.body;\n};\n\n/**\n * Function: showMenu\n * \n * Shows the menu.\n */\nmxPopupMenu.prototype.showMenu = function()\n{\n\t// Disables filter-based shadow in IE9 standards mode\n\tif (document.documentMode >= 9)\n\t{\n\t\tthis.div.style.filter = 'none';\n\t}\n\t\n\t// Fits the div inside the viewport\n\tdocument.body.appendChild(this.div);\n\tmxUtils.fit(this.div);\n};\n\n/**\n * Function: hideMenu\n * \n * Removes the menu and all submenus.\n */\nmxPopupMenu.prototype.hideMenu = function()\n{\n\tif (this.div != null)\n\t{\n\t\tif (this.div.parentNode != null)\n\t\t{\n\t\t\tthis.div.parentNode.removeChild(this.div);\n\t\t}\n\t\t\n\t\tthis.hideSubmenu(this);\n\t\tthis.containsItems = false;\n\t\tthis.fireEvent(new mxEventObject(mxEvent.HIDE));\n\t}\n};\n\n/**\n * Function: hideSubmenu\n * \n * Removes all submenus inside the given parent.\n * \n * Parameters:\n * \n * parent - An item returned by <addItem>.\n */\nmxPopupMenu.prototype.hideSubmenu = function(parent)\n{\n\tif (parent.activeRow != null)\n\t{\n\t\tthis.hideSubmenu(parent.activeRow);\n\t\t\n\t\tif (parent.activeRow.div.parentNode != null)\n\t\t{\n\t\t\tparent.activeRow.div.parentNode.removeChild(parent.activeRow.div);\n\t\t}\n\t\t\n\t\tparent.activeRow = null;\n\t}\n};\n\n/**\n * Function: destroy\n * \n * Destroys the handler and all its resources and DOM nodes.\n */\nmxPopupMenu.prototype.destroy = function()\n{\n\tif (this.div != null)\n\t{\n\t\tmxEvent.release(this.div);\n\t\t\n\t\tif (this.div.parentNode != null)\n\t\t{\n\t\t\tthis.div.parentNode.removeChild(this.div);\n\t\t}\n\t\t\n\t\tthis.div = null;\n\t}\n};\n\n__mxOutput.mxPopupMenu = typeof mxPopupMenu !== 'undefined' ? mxPopupMenu : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxAutoSaveManager\n * \n * Manager for automatically saving diagrams. The <save> hook must be\n * implemented.\n * \n * Example:\n * \n * (code)\n * var mgr = new mxAutoSaveManager(editor.graph);\n * mgr.save = function()\n * {\n *   mxLog.show();\n *   mxLog.debug('save');\n * };\n * (end)\n * \n * Constructor: mxAutoSaveManager\n *\n * Constructs a new automatic layout for the given graph.\n *\n * Arguments:\n * \n * graph - Reference to the enclosing graph. \n */\nfunction mxAutoSaveManager(graph)\n{\n\t// Notifies the manager of a change\n\tthis.changeHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tif (this.isEnabled())\n\t\t{\n\t\t\tthis.graphModelChanged(evt.getProperty('edit').changes);\n\t\t}\n\t});\n\n\tthis.setGraph(graph);\n};\n\n/**\n * Extends mxEventSource.\n */\nmxAutoSaveManager.prototype = new mxEventSource();\nmxAutoSaveManager.prototype.constructor = mxAutoSaveManager;\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxAutoSaveManager.prototype.graph = null;\n\n/**\n * Variable: autoSaveDelay\n * \n * Minimum amount of seconds between two consecutive autosaves. Eg. a\n * value of 1 (s) means the graph is not stored more than once per second.\n * Default is 10.\n */\nmxAutoSaveManager.prototype.autoSaveDelay = 10;\n\n/**\n * Variable: autoSaveThrottle\n * \n * Minimum amount of seconds between two consecutive autosaves triggered by\n * more than <autoSaveThreshhold> changes within a timespan of less than\n * <autoSaveDelay> seconds. Eg. a value of 1 (s) means the graph is not\n * stored more than once per second even if there are more than\n * <autoSaveThreshold> changes within that timespan. Default is 2.\n */\nmxAutoSaveManager.prototype.autoSaveThrottle = 2;\n\n/**\n * Variable: autoSaveThreshold\n * \n * Minimum amount of ignored changes before an autosave. Eg. a value of 2\n * means after 2 change of the graph model the autosave will trigger if the\n * condition below is true. Default is 5.\n */\nmxAutoSaveManager.prototype.autoSaveThreshold = 5;\n\n/**\n * Variable: ignoredChanges\n * \n * Counter for ignored changes in autosave.\n */\nmxAutoSaveManager.prototype.ignoredChanges = 0;\n\n/**\n * Variable: lastSnapshot\n * \n * Used for autosaving. See <autosave>.\n */\nmxAutoSaveManager.prototype.lastSnapshot = 0;\n\n/**\n * Variable: enabled\n * \n * Specifies if event handling is enabled. Default is true.\n */\nmxAutoSaveManager.prototype.enabled = true;\n\n/**\n * Variable: changeHandler\n * \n * Holds the function that handles graph model changes.\n */\nmxAutoSaveManager.prototype.changeHandler = null;\n\n/**\n * Function: isEnabled\n * \n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxAutoSaveManager.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n * \n * Enables or disables event handling. This implementation\n * updates <enabled>.\n * \n * Parameters:\n * \n * enabled - Boolean that specifies the new enabled state.\n */\nmxAutoSaveManager.prototype.setEnabled = function(value)\n{\n\tthis.enabled = value;\n};\n\n/**\n * Function: setGraph\n * \n * Sets the graph that the layouts operate on.\n */\nmxAutoSaveManager.prototype.setGraph = function(graph)\n{\n\tif (this.graph != null)\n\t{\n\t\tthis.graph.getModel().removeListener(this.changeHandler);\n\t}\n\t\n\tthis.graph = graph;\n\t\n\tif (this.graph != null)\n\t{\n\t\tthis.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);\n\t}\n};\n\n/**\n * Function: save\n * \n * Empty hook that is called if the graph should be saved.\n */\nmxAutoSaveManager.prototype.save = function()\n{\n\t// empty\n};\n\n/**\n * Function: graphModelChanged\n * \n * Invoked when the graph model has changed.\n */\nmxAutoSaveManager.prototype.graphModelChanged = function(changes)\n{\n\tvar now = new Date().getTime();\n\tvar dt = (now - this.lastSnapshot) / 1000;\n\t\n\tif (dt > this.autoSaveDelay ||\n\t\t(this.ignoredChanges >= this.autoSaveThreshold &&\n\t\t dt > this.autoSaveThrottle))\n\t{\n\t\tthis.save();\n\t\tthis.reset();\n\t}\n\telse\n\t{\n\t\t// Increments the number of ignored changes\n\t\tthis.ignoredChanges++;\n\t}\n};\n\n/**\n * Function: reset\n * \n * Resets all counters.\n */\nmxAutoSaveManager.prototype.reset = function()\n{\n\tthis.lastSnapshot = new Date().getTime();\n\tthis.ignoredChanges = 0;\n};\n\n/**\n * Function: destroy\n * \n * Removes all handlers from the <graph> and deletes the reference to it.\n */\nmxAutoSaveManager.prototype.destroy = function()\n{\n\tthis.setGraph(null);\n};\n\n__mxOutput.mxAutoSaveManager = typeof mxAutoSaveManager !== 'undefined' ? mxAutoSaveManager : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n *\n * Class: mxAnimation\n * \n * Implements a basic animation in JavaScript.\n * \n * Constructor: mxAnimation\n * \n * Constructs an animation.\n * \n * Parameters:\n * \n * graph - Reference to the enclosing <mxGraph>.\n */\nfunction mxAnimation(delay)\n{\n\tthis.delay = (delay != null) ? delay : 20;\n};\n\n/**\n * Extends mxEventSource.\n */\nmxAnimation.prototype = new mxEventSource();\nmxAnimation.prototype.constructor = mxAnimation;\n\n/**\n * Variable: delay\n * \n * Specifies the delay between the animation steps. Defaul is 30ms.\n */\nmxAnimation.prototype.delay = null;\n\n/**\n * Variable: thread\n * \n * Reference to the thread while the animation is running.\n */\nmxAnimation.prototype.thread = null;\n\n/**\n * Function: isRunning\n * \n * Returns true if the animation is running.\n */\nmxAnimation.prototype.isRunning = function()\n{\n\treturn this.thread != null;\n};\n\n/**\n * Function: startAnimation\n *\n * Starts the animation by repeatedly invoking updateAnimation.\n */\nmxAnimation.prototype.startAnimation = function()\n{\n\tif (this.thread == null)\n\t{\n\t\tthis.thread = window.setInterval(mxUtils.bind(this, this.updateAnimation), this.delay);\n\t}\n};\n\n/**\n * Function: updateAnimation\n *\n * Hook for subclassers to implement the animation. Invoke stopAnimation\n * when finished, startAnimation to resume. This is called whenever the\n * timer fires and fires an mxEvent.EXECUTE event with no properties.\n */\nmxAnimation.prototype.updateAnimation = function()\n{\n\tthis.fireEvent(new mxEventObject(mxEvent.EXECUTE));\n};\n\n/**\n * Function: stopAnimation\n *\n * Stops the animation by deleting the timer and fires an <mxEvent.DONE>.\n */\nmxAnimation.prototype.stopAnimation = function()\n{\n\tif (this.thread != null)\n\t{\n\t\twindow.clearInterval(this.thread);\n\t\tthis.thread = null;\n\t\tthis.fireEvent(new mxEventObject(mxEvent.DONE));\n\t}\n};\n\n__mxOutput.mxAnimation = typeof mxAnimation !== 'undefined' ? mxAnimation : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n *\n * Class: mxMorphing\n * \n * Implements animation for morphing cells. Here is an example of\n * using this class for animating the result of a layout algorithm:\n * \n * (code)\n * graph.getModel().beginUpdate();\n * try\n * {\n *   var circleLayout = new mxCircleLayout(graph);\n *   circleLayout.execute(graph.getDefaultParent());\n * }\n * finally\n * {\n *   var morph = new mxMorphing(graph);\n *   morph.addListener(mxEvent.DONE, function()\n *   {\n *     graph.getModel().endUpdate();\n *   });\n *   \n *   morph.startAnimation();\n * }\n * (end)\n * \n * Constructor: mxMorphing\n * \n * Constructs an animation.\n * \n * Parameters:\n * \n * graph - Reference to the enclosing <mxGraph>.\n * steps - Optional number of steps in the morphing animation. Default is 6.\n * ease - Optional easing constant for the animation. Default is 1.5.\n * delay - Optional delay between the animation steps. Passed to <mxAnimation>.\n */\nfunction mxMorphing(graph, steps, ease, delay)\n{\n\tmxAnimation.call(this, delay);\n\tthis.graph = graph;\n\tthis.steps = (steps != null) ? steps : 6;\n\tthis.ease = (ease != null) ? ease : 1.5;\n};\n\n/**\n * Extends mxEventSource.\n */\nmxMorphing.prototype = new mxAnimation();\nmxMorphing.prototype.constructor = mxMorphing;\n\n/**\n * Variable: graph\n * \n * Specifies the delay between the animation steps. Defaul is 30ms.\n */\nmxMorphing.prototype.graph = null;\n\n/**\n * Variable: steps\n * \n * Specifies the maximum number of steps for the morphing.\n */\nmxMorphing.prototype.steps = null;\n\n/**\n * Variable: step\n * \n * Contains the current step.\n */\nmxMorphing.prototype.step = 0;\n\n/**\n * Variable: ease\n * \n * Ease-off for movement towards the given vector. Larger values are\n * slower and smoother. Default is 4.\n */\nmxMorphing.prototype.ease = null;\n\n/**\n * Variable: cells\n * \n * Optional array of cells to be animated. If this is not specified\n * then all cells are checked and animated if they have been moved\n * in the current transaction.\n */\nmxMorphing.prototype.cells = null;\n\n/**\n * Function: updateAnimation\n *\n * Animation step.\n */\nmxMorphing.prototype.updateAnimation = function()\n{\n\tmxAnimation.prototype.updateAnimation.apply(this, arguments);\n\tvar move = new mxCellStatePreview(this.graph);\n\n\tif (this.cells != null)\n\t{\n\t\t// Animates the given cells individually without recursion\n\t\tfor (var i = 0; i < this.cells.length; i++)\n\t\t{\n\t\t\tthis.animateCell(this.cells[i], move, false);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Animates all changed cells by using recursion to find\n\t\t// the changed cells but not for the animation itself\n\t\tthis.animateCell(this.graph.getModel().getRoot(), move, true);\n\t}\n\t\n\tthis.show(move);\n\t\n\tif (move.isEmpty() || this.step++ >= this.steps)\n\t{\n\t\tthis.stopAnimation();\n\t}\n};\n\n/**\n * Function: show\n *\n * Shows the changes in the given <mxCellStatePreview>.\n */\nmxMorphing.prototype.show = function(move)\n{\n\tmove.show();\n};\n\n/**\n * Function: animateCell\n *\n * Animates the given cell state using <mxCellStatePreview.moveState>.\n */\nmxMorphing.prototype.animateCell = function(cell, move, recurse)\n{\n\tvar state = this.graph.getView().getState(cell);\n\tvar delta = null;\n\n\tif (state != null)\n\t{\n\t\t// Moves the animated state from where it will be after the model\n\t\t// change by subtracting the given delta vector from that location\n\t\tdelta = this.getDelta(state);\n\n\t\tif (this.graph.getModel().isVertex(cell) && (delta.x != 0 || delta.y != 0))\n\t\t{\n\t\t\tvar translate = this.graph.view.getTranslate();\n\t\t\tvar scale = this.graph.view.getScale();\n\t\t\t\n\t\t\tdelta.x += translate.x * scale;\n\t\t\tdelta.y += translate.y * scale;\n\t\t\t\n\t\t\tmove.moveState(state, -delta.x / this.ease, -delta.y / this.ease);\n\t\t}\n\t}\n\t\n\tif (recurse && !this.stopRecursion(state, delta))\n\t{\n\t\tvar childCount = this.graph.getModel().getChildCount(cell);\n\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tthis.animateCell(this.graph.getModel().getChildAt(cell, i), move, recurse);\n\t\t}\n\t}\n};\n\n/**\n * Function: stopRecursion\n *\n * Returns true if the animation should not recursively find more\n * deltas for children if the given parent state has been animated.\n */\nmxMorphing.prototype.stopRecursion = function(state, delta)\n{\n\treturn delta != null && (delta.x != 0 || delta.y != 0);\n};\n\n/**\n * Function: getDelta\n *\n * Returns the vector between the current rendered state and the future\n * location of the state after the display will be updated.\n */\nmxMorphing.prototype.getDelta = function(state)\n{\n\tvar origin = this.getOriginForCell(state.cell);\n\tvar translate = this.graph.getView().getTranslate();\n\tvar scale = this.graph.getView().getScale();\n\tvar x = state.x / scale - translate.x;\n\tvar y = state.y / scale - translate.y;\n\n\treturn new mxPoint((origin.x - x) * scale, (origin.y - y) * scale);\n};\n\n/**\n * Function: getOriginForCell\n *\n * Returns the top, left corner of the given cell. TODO: Improve performance\n * by using caching inside this method as the result per cell never changes\n * during the lifecycle of this object.\n */\nmxMorphing.prototype.getOriginForCell = function(cell)\n{\n\tvar result = null;\n\t\n\tif (cell != null)\n\t{\n\t\tvar parent = this.graph.getModel().getParent(cell);\n\t\tvar geo = this.graph.getCellGeometry(cell);\n\t\tresult = this.getOriginForCell(parent);\n\t\t\n\t\t// TODO: Handle offsets\n\t\tif (geo != null)\n\t\t{\n\t\t\tif (geo.relative)\n\t\t\t{\n\t\t\t\tvar pgeo = this.graph.getCellGeometry(parent);\n\t\t\t\t\n\t\t\t\tif (pgeo != null)\n\t\t\t\t{\n\t\t\t\t\tresult.x += geo.x * pgeo.width;\n\t\t\t\t\tresult.y += geo.y * pgeo.height;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.x += geo.x;\n\t\t\t\tresult.y += geo.y;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (result == null)\n\t{\n\t\tvar t = this.graph.view.getTranslate();\n\t\tresult = new mxPoint(-t.x, -t.y);\n\t}\n\t\n\treturn result;\n};\n\n__mxOutput.mxMorphing = typeof mxMorphing !== 'undefined' ? mxMorphing : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxImageBundle\n *\n * Maps from keys to base64 encoded images or file locations. All values must\n * be URLs or use the format data:image/format followed by a comma and the base64\n * encoded image data, eg. \"data:image/gif,XYZ\", where XYZ is the base64 encoded\n * image data.\n * \n * To add a new image bundle to an existing graph, the following code is used:\n * \n * (code)\n * var bundle = new mxImageBundle(alt);\n * bundle.putImage('myImage', 'data:image/gif,R0lGODlhEAAQAMIGAAAAAICAAICAgP' +\n *   '//AOzp2O3r2////////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAh+QQBCgAHACwAAAAA' +\n *   'EAAQAAADTXi63AowynnAMDfjPUDlnAAJhmeBFxAEloliKltWmiYCQvfVr6lBPB1ggxN1hi' +\n *   'laSSASFQpIV5HJBDyHpqK2ejVRm2AAgZCdmCGO9CIBADs=', fallback);\n * bundle.putImage('mySvgImage', 'data:image/svg+xml,' + encodeURIComponent(\n *   '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\">' +\n *   '<linearGradient id=\"gradient\"><stop offset=\"10%\" stop-color=\"#F00\"/>' +\n *   '<stop offset=\"90%\" stop-color=\"#fcc\"/></linearGradient>' +\n *   '<rect fill=\"url(#gradient)\" width=\"100%\" height=\"100%\"/></svg>'), fallback);\n * graph.addImageBundle(bundle);\n * (end);\n * \n * Alt is an optional boolean (default is false) that specifies if the value\n * or the fallback should be returned in <getImage>.\n * \n * The image can then be referenced in any cell style using image=myImage.\n * If you are using mxOutline, you should use the same image bundles in the\n * graph that renders the outline.\n * \n * The keys for images are resolved in <mxGraph.postProcessCellStyle> and\n * turned into a data URI if the returned value has a short data URI format\n * as specified above.\n * \n * A typical value for the fallback is a MTHML link as defined in RFC 2557.\n * Note that this format requires a file to be dynamically created on the\n * server-side, or the page that contains the graph to be modified to contain\n * the resources, this can be done by adding a comment that contains the\n * resource in the HEAD section of the page after the title tag.\n * \n * This type of fallback mechanism should be used in IE6 and IE7. IE8 does\n * support data URIs, but the maximum size is limited to 32 KB, which means\n * all data URIs should be limited to 32 KB.\n */\nfunction mxImageBundle(alt)\n{\n\tthis.images = [];\n\tthis.alt = (alt != null) ? alt : false;\n};\n\n/**\n * Variable: images\n * \n * Maps from keys to images.\n */\nmxImageBundle.prototype.images = null;\n\n/**\n * Variable: alt\n * \n * Specifies if the fallback representation should be returned.\n */\nmxImageBundle.prototype.alt = null;\n\n/**\n * Function: putImage\n * \n * Adds the specified entry to the map. The entry is an object with a value and\n * fallback property as specified in the arguments.\n */\nmxImageBundle.prototype.putImage = function(key, value, fallback)\n{\n\tthis.images[key] = {value: value, fallback: fallback};\n};\n\n/**\n * Function: getImage\n * \n * Returns the value for the given key. This returns the value\n * or fallback, depending on <alt>. The fallback is returned if\n * <alt> is true, the value is returned otherwise.\n */\nmxImageBundle.prototype.getImage = function(key)\n{\n\tvar result = null;\n\t\n\tif (key != null)\n\t{\n\t\tvar img = this.images[key];\n\t\t\n\t\tif (img != null)\n\t\t{\n\t\t\tresult = (this.alt) ? img.fallback : img.value;\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n__mxOutput.mxImageBundle = typeof mxImageBundle !== 'undefined' ? mxImageBundle : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxImageExport\n * \n * Creates a new image export instance to be used with an export canvas. Here\n * is an example that uses this class to create an image via a backend using\n * <mxXmlExportCanvas>.\n * \n * (code)\n * var xmlDoc = mxUtils.createXmlDocument();\n * var root = xmlDoc.createElement('output');\n * xmlDoc.appendChild(root);\n * \n * var xmlCanvas = new mxXmlCanvas2D(root);\n * var imgExport = new mxImageExport();\n * imgExport.drawState(graph.getView().getState(graph.model.root), xmlCanvas);\n * \n * var bounds = graph.getGraphBounds();\n * var w = Math.ceil(bounds.x + bounds.width);\n * var h = Math.ceil(bounds.y + bounds.height);\n * \n * var xml = mxUtils.getXml(root);\n * new mxXmlRequest('export', 'format=png&w=' + w +\n * \t\t'&h=' + h + '&bg=#F9F7ED&xml=' + encodeURIComponent(xml))\n * \t\t.simulate(document, '_blank');\n * (end)\n * \n * Constructor: mxImageExport\n * \n * Constructs a new image export.\n */\nfunction mxImageExport() { };\n\n/**\n * Variable: includeOverlays\n * \n * Specifies if overlays should be included in the export. Default is false.\n */\nmxImageExport.prototype.includeOverlays = false;\n\n/**\n * Function: drawState\n * \n * Draws the given state and all its descendants to the given canvas.\n */\nmxImageExport.prototype.drawState = function(state, canvas)\n{\n\tif (state != null)\n\t{\n\t\tthis.visitStatesRecursive(state, canvas, mxUtils.bind(this, function()\n\t\t{\n\t\t\tthis.drawCellState.apply(this, arguments);\n\t\t}));\n\t\t\t\t\n\t\t// Paints the overlays\n\t\tif (this.includeOverlays)\n\t\t{\n\t\t\tthis.visitStatesRecursive(state, canvas, mxUtils.bind(this, function()\n\t\t\t{\n\t\t\t\tthis.drawOverlays.apply(this, arguments);\n\t\t\t}));\n\t\t}\n\t}\n};\n\n/**\n * Function: visitStatesRecursive\n * \n * Visits the given state and all its descendants to the given canvas recursively.\n */\nmxImageExport.prototype.visitStatesRecursive = function(state, canvas, visitor)\n{\n\tif (state != null)\n\t{\n\t\tvisitor(state, canvas);\n\t\t\n\t\tvar graph = state.view.graph;\n\t\tvar childCount = graph.model.getChildCount(state.cell);\n\t\t\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar childState = graph.view.getState(graph.model.getChildAt(state.cell, i));\n\t\t\tthis.visitStatesRecursive(childState, canvas, visitor);\n\t\t}\n\t}\n};\n\n/**\n * Function: getLinkForCellState\n * \n * Returns the link for the given cell state and canvas. This returns null.\n */\nmxImageExport.prototype.getLinkForCellState = function(state, canvas)\n{\n\treturn null;\n};\n\n/**\n * Function: drawCellState\n * \n * Draws the given state to the given canvas.\n */\nmxImageExport.prototype.drawCellState = function(state, canvas)\n{\n\t// Experimental feature\n\tvar link = this.getLinkForCellState(state, canvas);\n\t\n\tif (link != null)\n\t{\n\t\tcanvas.setLink(link);\n\t}\n\t\n\t// Paints the shape and text\n\tthis.drawShape(state, canvas);\n\tthis.drawText(state, canvas);\n\n\tif (link != null)\n\t{\n\t\tcanvas.setLink(null);\n\t}\n};\n\n/**\n * Function: drawShape\n * \n * Draws the shape of the given state.\n */\nmxImageExport.prototype.drawShape = function(state, canvas)\n{\n\tif (state.shape instanceof mxShape && state.shape.checkBounds())\n\t{\n\t\tcanvas.save();\n\t\t\n\t\tstate.shape.beforePaint(canvas);\n\t\tstate.shape.paint(canvas);\n\t\tstate.shape.afterPaint(canvas);\n\t\t\n\t\tcanvas.restore();\n\t}\n};\n\n/**\n * Function: drawText\n * \n * Draws the text of the given state.\n */\nmxImageExport.prototype.drawText = function(state, canvas)\n{\n\tif (state.text != null && state.text.checkBounds())\n\t{\n\t\tcanvas.save();\n\t\t\n\t\tstate.text.beforePaint(canvas);\n\t\tstate.text.paint(canvas);\n\t\tstate.text.afterPaint(canvas);\n\t\t\n\t\tcanvas.restore();\n\t}\n};\n\n/**\n * Function: drawOverlays\n * \n * Draws the overlays for the given state. This is called if <includeOverlays>\n * is true.\n */\nmxImageExport.prototype.drawOverlays = function(state, canvas)\n{\n\tif (state.overlays != null)\n\t{\n\t\tstate.overlays.visit(function(id, shape)\n\t\t{\n\t\t\tif (shape instanceof mxShape)\n\t\t\t{\n\t\t\t\tshape.paint(canvas);\n\t\t\t}\n\t\t});\n\t}\n};\n\n\n__mxOutput.mxImageExport = typeof mxImageExport !== 'undefined' ? mxImageExport : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxAbstractCanvas2D\n *\n * Base class for all canvases. A description of the public API is available in <mxXmlCanvas2D>.\n * All color values of <mxConstants.NONE> will be converted to null in the state.\n * \n * Constructor: mxAbstractCanvas2D\n *\n * Constructs a new abstract canvas.\n */\nfunction mxAbstractCanvas2D()\n{\n\t/**\n\t * Variable: converter\n\t * \n\t * Holds the <mxUrlConverter> to convert image URLs.\n\t */\n\tthis.converter = this.createUrlConverter();\n\t\n\tthis.reset();\n};\n\n/**\n * Variable: state\n * \n * Holds the current state.\n */\nmxAbstractCanvas2D.prototype.state = null;\n\n/**\n * Variable: states\n * \n * Stack of states.\n */\nmxAbstractCanvas2D.prototype.states = null;\n\n/**\n * Variable: path\n * \n * Holds the current path as an array.\n */\nmxAbstractCanvas2D.prototype.path = null;\n\n/**\n * Variable: rotateHtml\n * \n * Switch for rotation of HTML. Default is false.\n */\nmxAbstractCanvas2D.prototype.rotateHtml = true;\n\n/**\n * Variable: lastX\n * \n * Holds the last x coordinate.\n */\nmxAbstractCanvas2D.prototype.lastX = 0;\n\n/**\n * Variable: lastY\n * \n * Holds the last y coordinate.\n */\nmxAbstractCanvas2D.prototype.lastY = 0;\n\n/**\n * Variable: moveOp\n * \n * Contains the string used for moving in paths. Default is 'M'.\n */\nmxAbstractCanvas2D.prototype.moveOp = 'M';\n\n/**\n * Variable: lineOp\n * \n * Contains the string used for moving in paths. Default is 'L'.\n */\nmxAbstractCanvas2D.prototype.lineOp = 'L';\n\n/**\n * Variable: quadOp\n * \n * Contains the string used for quadratic paths. Default is 'Q'.\n */\nmxAbstractCanvas2D.prototype.quadOp = 'Q';\n\n/**\n * Variable: curveOp\n * \n * Contains the string used for bezier curves. Default is 'C'.\n */\nmxAbstractCanvas2D.prototype.curveOp = 'C';\n\n/**\n * Variable: closeOp\n * \n * Holds the operator for closing curves. Default is 'Z'.\n */\nmxAbstractCanvas2D.prototype.closeOp = 'Z';\n\n/**\n * Variable: pointerEvents\n * \n * Boolean value that specifies if events should be handled. Default is false.\n */\nmxAbstractCanvas2D.prototype.pointerEvents = false;\n\n/**\n * Function: createUrlConverter\n * \n * Create a new <mxUrlConverter> and returns it.\n */\nmxAbstractCanvas2D.prototype.createUrlConverter = function()\n{\n\treturn new mxUrlConverter();\n};\n\n/**\n * Function: reset\n * \n * Resets the state of this canvas.\n */\nmxAbstractCanvas2D.prototype.reset = function()\n{\n\tthis.state = this.createState();\n\tthis.states = [];\n};\n\n/**\n * Function: createState\n * \n * Creates the state of the this canvas.\n */\nmxAbstractCanvas2D.prototype.createState = function()\n{\n\treturn {\n\t\tdx: 0,\n\t\tdy: 0,\n\t\tscale: 1,\n\t\talpha: 1,\n\t\tfillAlpha: 1,\n\t\tstrokeAlpha: 1,\n\t\tfillColor: null,\n\t\tgradientFillAlpha: 1,\n\t\tgradientColor: null,\n\t\tgradientAlpha: 1,\n\t\tgradientDirection: null,\n\t\tstrokeColor: null,\n\t\tstrokeWidth: 1,\n\t\tdashed: false,\n\t\tdashPattern: '3 3',\n\t\tfixDash: false,\n\t\tlineCap: 'flat',\n\t\tlineJoin: 'miter',\n\t\tmiterLimit: 10,\n\t\tfontColor: '#000000',\n\t\tfontBackgroundColor: null,\n\t\tfontBorderColor: null,\n\t\tfontSize: mxConstants.DEFAULT_FONTSIZE,\n\t\tfontFamily: mxConstants.DEFAULT_FONTFAMILY,\n\t\tfontStyle: 0,\n\t\tshadow: false,\n\t\tshadowColor: mxConstants.SHADOWCOLOR,\n\t\tshadowAlpha: mxConstants.SHADOW_OPACITY,\n\t\tshadowDx: mxConstants.SHADOW_OFFSET_X,\n\t\tshadowDy: mxConstants.SHADOW_OFFSET_Y,\n\t\trotation: 0,\n\t\trotationCx: 0,\n\t\trotationCy: 0\n\t};\n};\n\n/**\n * Function: format\n * \n * Rounds all numbers to integers.\n */\nmxAbstractCanvas2D.prototype.format = function(value)\n{\n\treturn Math.round(parseFloat(value));\n};\n\n/**\n * Function: addOp\n * \n * Adds the given operation to the path.\n */\nmxAbstractCanvas2D.prototype.addOp = function()\n{\n\tif (this.path != null)\n\t{\n\t\tthis.path.push(arguments[0]);\n\t\t\n\t\tif (arguments.length > 2)\n\t\t{\n\t\t\tvar s = this.state;\n\n\t\t\tfor (var i = 2; i < arguments.length; i += 2)\n\t\t\t{\n\t\t\t\tthis.lastX = arguments[i - 1];\n\t\t\t\tthis.lastY = arguments[i];\n\t\t\t\t\n\t\t\t\tthis.path.push(this.format((this.lastX + s.dx) * s.scale));\n\t\t\t\tthis.path.push(this.format((this.lastY + s.dy) * s.scale));\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: rotatePoint\n * \n * Rotates the given point and returns the result as an <mxPoint>.\n */\nmxAbstractCanvas2D.prototype.rotatePoint = function(x, y, theta, cx, cy)\n{\n\tvar rad = theta * (Math.PI / 180);\n\t\n\treturn mxUtils.getRotatedPoint(new mxPoint(x, y), Math.cos(rad),\n\t\tMath.sin(rad), new mxPoint(cx, cy));\n};\n\n/**\n * Function: save\n * \n * Saves the current state.\n */\nmxAbstractCanvas2D.prototype.save = function()\n{\n\tthis.states.push(this.state);\n\tthis.state = mxUtils.clone(this.state);\n};\n\n/**\n * Function: restore\n * \n * Restores the current state.\n */\nmxAbstractCanvas2D.prototype.restore = function()\n{\n\tif (this.states.length > 0)\n\t{\n\t\tthis.state = this.states.pop();\n\t}\n};\n\n/**\n * Function: setLink\n * \n * Sets the current link. Hook for subclassers.\n */\nmxAbstractCanvas2D.prototype.setLink = function(link)\n{\n\t// nop\n};\n\n/**\n * Function: scale\n * \n * Scales the current state.\n */\nmxAbstractCanvas2D.prototype.scale = function(value)\n{\n\tthis.state.scale *= value;\n\tthis.state.strokeWidth *= value;\n};\n\n/**\n * Function: translate\n * \n * Translates the current state.\n */\nmxAbstractCanvas2D.prototype.translate = function(dx, dy)\n{\n\tthis.state.dx += dx;\n\tthis.state.dy += dy;\n};\n\n/**\n * Function: rotate\n * \n * Rotates the current state.\n */\nmxAbstractCanvas2D.prototype.rotate = function(theta, flipH, flipV, cx, cy)\n{\n\t// nop\n};\n\n/**\n * Function: setAlpha\n * \n * Sets the current alpha.\n */\nmxAbstractCanvas2D.prototype.setAlpha = function(value)\n{\n\tthis.state.alpha = value;\n};\n\n/**\n * Function: setFillAlpha\n * \n * Sets the current solid fill alpha.\n */\nmxAbstractCanvas2D.prototype.setFillAlpha = function(value)\n{\n\tthis.state.fillAlpha = value;\n};\n\n/**\n * Function: setStrokeAlpha\n * \n * Sets the current stroke alpha.\n */\nmxAbstractCanvas2D.prototype.setStrokeAlpha = function(value)\n{\n\tthis.state.strokeAlpha = value;\n};\n\n/**\n * Function: setFillColor\n * \n * Sets the current fill color.\n */\nmxAbstractCanvas2D.prototype.setFillColor = function(value)\n{\n\tif (value == mxConstants.NONE)\n\t{\n\t\tvalue = null;\n\t}\n\t\n\tthis.state.fillColor = value;\n\tthis.state.gradientColor = null;\n};\n\n/**\n * Function: setGradient\n * \n * Sets the current gradient.\n */\nmxAbstractCanvas2D.prototype.setGradient = function(color1, color2, x, y, w, h, direction, alpha1, alpha2)\n{\n\tvar s = this.state;\n\ts.fillColor = color1;\n\ts.gradientFillAlpha = (alpha1 != null) ? alpha1 : 1;\n\ts.gradientColor = color2;\n\ts.gradientAlpha = (alpha2 != null) ? alpha2 : 1;\n\ts.gradientDirection = direction;\n};\n\n/**\n * Function: setStrokeColor\n * \n * Sets the current stroke color.\n */\nmxAbstractCanvas2D.prototype.setStrokeColor = function(value)\n{\n\tif (value == mxConstants.NONE)\n\t{\n\t\tvalue = null;\n\t}\n\t\n\tthis.state.strokeColor = value;\n};\n\n/**\n * Function: setStrokeWidth\n * \n * Sets the current stroke width.\n */\nmxAbstractCanvas2D.prototype.setStrokeWidth = function(value)\n{\n\tthis.state.strokeWidth = value;\n};\n\n/**\n * Function: setDashed\n * \n * Enables or disables dashed lines.\n */\nmxAbstractCanvas2D.prototype.setDashed = function(value, fixDash)\n{\n\tthis.state.dashed = value;\n\tthis.state.fixDash = fixDash;\n};\n\n/**\n * Function: setDashPattern\n * \n * Sets the current dash pattern.\n */\nmxAbstractCanvas2D.prototype.setDashPattern = function(value)\n{\n\tthis.state.dashPattern = value;\n};\n\n/**\n * Function: setLineCap\n * \n * Sets the current line cap.\n */\nmxAbstractCanvas2D.prototype.setLineCap = function(value)\n{\n\tthis.state.lineCap = value;\n};\n\n/**\n * Function: setLineJoin\n * \n * Sets the current line join.\n */\nmxAbstractCanvas2D.prototype.setLineJoin = function(value)\n{\n\tthis.state.lineJoin = value;\n};\n\n/**\n * Function: setMiterLimit\n * \n * Sets the current miter limit.\n */\nmxAbstractCanvas2D.prototype.setMiterLimit = function(value)\n{\n\tthis.state.miterLimit = value;\n};\n\n/**\n * Function: setFontColor\n * \n * Sets the current font color.\n */\nmxAbstractCanvas2D.prototype.setFontColor = function(value)\n{\n\tif (value == mxConstants.NONE)\n\t{\n\t\tvalue = null;\n\t}\n\t\n\tthis.state.fontColor = value;\n};\n\n/**\n * Function: setFontBackgroundColor\n * \n * Sets the current font background color.\n */\nmxAbstractCanvas2D.prototype.setFontBackgroundColor = function(value)\n{\n\tif (value == mxConstants.NONE)\n\t{\n\t\tvalue = null;\n\t}\n\t\n\tthis.state.fontBackgroundColor = value;\n};\n\n/**\n * Function: setFontBorderColor\n * \n * Sets the current font border color.\n */\nmxAbstractCanvas2D.prototype.setFontBorderColor = function(value)\n{\n\tif (value == mxConstants.NONE)\n\t{\n\t\tvalue = null;\n\t}\n\t\n\tthis.state.fontBorderColor = value;\n};\n\n/**\n * Function: setFontSize\n * \n * Sets the current font size.\n */\nmxAbstractCanvas2D.prototype.setFontSize = function(value)\n{\n\tthis.state.fontSize = parseFloat(value);\n};\n\n/**\n * Function: setFontFamily\n * \n * Sets the current font family.\n */\nmxAbstractCanvas2D.prototype.setFontFamily = function(value)\n{\n\tthis.state.fontFamily = value;\n};\n\n/**\n * Function: setFontStyle\n * \n * Sets the current font style.\n */\nmxAbstractCanvas2D.prototype.setFontStyle = function(value)\n{\n\tif (value == null)\n\t{\n\t\tvalue = 0;\n\t}\n\t\n\tthis.state.fontStyle = value;\n};\n\n/**\n * Function: setShadow\n * \n * Enables or disables and configures the current shadow.\n */\nmxAbstractCanvas2D.prototype.setShadow = function(enabled)\n{\n\tthis.state.shadow = enabled;\n};\n\n/**\n * Function: setShadowColor\n * \n * Enables or disables and configures the current shadow.\n */\nmxAbstractCanvas2D.prototype.setShadowColor = function(value)\n{\n\tif (value == mxConstants.NONE)\n\t{\n\t\tvalue = null;\n\t}\n\t\n\tthis.state.shadowColor = value;\n};\n\n/**\n * Function: setShadowAlpha\n * \n * Enables or disables and configures the current shadow.\n */\nmxAbstractCanvas2D.prototype.setShadowAlpha = function(value)\n{\n\tthis.state.shadowAlpha = value;\n};\n\n/**\n * Function: setShadowOffset\n * \n * Enables or disables and configures the current shadow.\n */\nmxAbstractCanvas2D.prototype.setShadowOffset = function(dx, dy)\n{\n\tthis.state.shadowDx = dx;\n\tthis.state.shadowDy = dy;\n};\n\n/**\n * Function: begin\n * \n * Starts a new path.\n */\nmxAbstractCanvas2D.prototype.begin = function()\n{\n\tthis.lastX = 0;\n\tthis.lastY = 0;\n\tthis.path = [];\n};\n\n/**\n * Function: moveTo\n * \n *  Moves the current path the given coordinates.\n */\nmxAbstractCanvas2D.prototype.moveTo = function(x, y)\n{\n\tthis.addOp(this.moveOp, x, y);\n};\n\n/**\n * Function: lineTo\n * \n * Draws a line to the given coordinates. Uses moveTo with the op argument.\n */\nmxAbstractCanvas2D.prototype.lineTo = function(x, y)\n{\n\tthis.addOp(this.lineOp, x, y);\n};\n\n/**\n * Function: quadTo\n * \n * Adds a quadratic curve to the current path.\n */\nmxAbstractCanvas2D.prototype.quadTo = function(x1, y1, x2, y2)\n{\n\tthis.addOp(this.quadOp, x1, y1, x2, y2);\n};\n\n/**\n * Function: curveTo\n * \n * Adds a bezier curve to the current path.\n */\nmxAbstractCanvas2D.prototype.curveTo = function(x1, y1, x2, y2, x3, y3)\n{\n\tthis.addOp(this.curveOp, x1, y1, x2, y2, x3, y3);\n};\n\n/**\n * Function: arcTo\n * \n * Adds the given arc to the current path. This is a synthetic operation that\n * is broken down into curves.\n */\nmxAbstractCanvas2D.prototype.arcTo = function(rx, ry, angle, largeArcFlag, sweepFlag, x, y)\n{\n\tvar curves = mxUtils.arcToCurves(this.lastX, this.lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y);\n\t\n\tif (curves != null)\n\t{\n\t\tfor (var i = 0; i < curves.length; i += 6) \n\t\t{\n\t\t\tthis.curveTo(curves[i], curves[i + 1], curves[i + 2],\n\t\t\t\tcurves[i + 3], curves[i + 4], curves[i + 5]);\n\t\t}\n\t}\n};\n\n/**\n * Function: close\n * \n * Closes the current path.\n */\nmxAbstractCanvas2D.prototype.close = function(x1, y1, x2, y2, x3, y3)\n{\n\tthis.addOp(this.closeOp);\n};\n\n/**\n * Function: end\n * \n * Empty implementation for backwards compatibility. This will be removed.\n */\nmxAbstractCanvas2D.prototype.end = function() { };\n\n__mxOutput.mxAbstractCanvas2D = typeof mxAbstractCanvas2D !== 'undefined' ? mxAbstractCanvas2D : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxXmlCanvas2D\n *\n * Base class for all canvases. The following methods make up the public\n * interface of the canvas 2D for all painting in mxGraph:\n * \n * - <save>, <restore>\n * - <scale>, <translate>, <rotate>\n * - <setAlpha>, <setFillAlpha>, <setStrokeAlpha>, <setFillColor>, <setGradient>,\n *   <setStrokeColor>, <setStrokeWidth>, <setDashed>, <setDashPattern>, <setLineCap>, \n *   <setLineJoin>, <setMiterLimit>\n * - <setFontColor>, <setFontBackgroundColor>, <setFontBorderColor>, <setFontSize>,\n *   <setFontFamily>, <setFontStyle>\n * - <setShadow>, <setShadowColor>, <setShadowAlpha>, <setShadowOffset>\n * - <rect>, <roundrect>, <ellipse>, <image>, <text>\n * - <begin>, <moveTo>, <lineTo>, <quadTo>, <curveTo>\n * - <stroke>, <fill>, <fillAndStroke>\n * \n * <mxAbstractCanvas2D.arcTo> is an additional method for drawing paths. This is\n * a synthetic method, meaning that it is turned into a sequence of curves by\n * default. Subclassers may add native support for arcs.\n * \n * Constructor: mxXmlCanvas2D\n *\n * Constructs a new abstract canvas.\n */\nfunction mxXmlCanvas2D(root)\n{\n\tmxAbstractCanvas2D.call(this);\n\n\t/**\n\t * Variable: root\n\t * \n\t * Reference to the container for the SVG content.\n\t */\n\tthis.root = root;\n\n\t// Writes default settings;\n\tthis.writeDefaults();\n};\n\n/**\n * Extends mxAbstractCanvas2D\n */\nmxUtils.extend(mxXmlCanvas2D, mxAbstractCanvas2D);\n\n/**\n * Variable: textEnabled\n * \n * Specifies if text output should be enabled. Default is true.\n */\nmxXmlCanvas2D.prototype.textEnabled = true;\n\n/**\n * Variable: compressed\n * \n * Specifies if the output should be compressed by removing redundant calls.\n * Default is true.\n */\nmxXmlCanvas2D.prototype.compressed = true;\n\n/**\n * Function: writeDefaults\n * \n * Writes the rendering defaults to <root>:\n */\nmxXmlCanvas2D.prototype.writeDefaults = function()\n{\n\tvar elem;\n\t\n\t// Writes font defaults\n\telem = this.createElement('fontfamily');\n\telem.setAttribute('family', mxConstants.DEFAULT_FONTFAMILY);\n\tthis.root.appendChild(elem);\n\t\n\telem = this.createElement('fontsize');\n\telem.setAttribute('size', mxConstants.DEFAULT_FONTSIZE);\n\tthis.root.appendChild(elem);\n\t\n\t// Writes shadow defaults\n\telem = this.createElement('shadowcolor');\n\telem.setAttribute('color', mxConstants.SHADOWCOLOR);\n\tthis.root.appendChild(elem);\n\t\n\telem = this.createElement('shadowalpha');\n\telem.setAttribute('alpha', mxConstants.SHADOW_OPACITY);\n\tthis.root.appendChild(elem);\n\t\n\telem = this.createElement('shadowoffset');\n\telem.setAttribute('dx', mxConstants.SHADOW_OFFSET_X);\n\telem.setAttribute('dy', mxConstants.SHADOW_OFFSET_Y);\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: format\n * \n * Returns a formatted number with 2 decimal places.\n */\nmxXmlCanvas2D.prototype.format = function(value)\n{\n\treturn parseFloat(parseFloat(value).toFixed(2));\n};\n\n/**\n * Function: createElement\n * \n * Creates the given element using the owner document of <root>.\n */\nmxXmlCanvas2D.prototype.createElement = function(name)\n{\n\treturn this.root.ownerDocument.createElement(name);\n};\n\n/**\n * Function: save\n * \n * Saves the drawing state.\n */\nmxXmlCanvas2D.prototype.save = function()\n{\n\tif (this.compressed)\n\t{\n\t\tmxAbstractCanvas2D.prototype.save.apply(this, arguments);\n\t}\n\t\n\tthis.root.appendChild(this.createElement('save'));\n};\n\n/**\n * Function: restore\n * \n * Restores the drawing state.\n */\nmxXmlCanvas2D.prototype.restore = function()\n{\n\tif (this.compressed)\n\t{\n\t\tmxAbstractCanvas2D.prototype.restore.apply(this, arguments);\n\t}\n\t\n\tthis.root.appendChild(this.createElement('restore'));\n};\n\n/**\n * Function: scale\n * \n * Scales the output.\n * \n * Parameters:\n * \n * scale - Number that represents the scale where 1 is equal to 100%.\n */\nmxXmlCanvas2D.prototype.scale = function(value)\n{\n        var elem = this.createElement('scale');\n        elem.setAttribute('scale', value);\n        this.root.appendChild(elem);\n};\n\n/**\n * Function: translate\n * \n * Translates the output.\n * \n * Parameters:\n * \n * dx - Number that specifies the horizontal translation.\n * dy - Number that specifies the vertical translation.\n */\nmxXmlCanvas2D.prototype.translate = function(dx, dy)\n{\n\tvar elem = this.createElement('translate');\n\telem.setAttribute('dx', this.format(dx));\n\telem.setAttribute('dy', this.format(dy));\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: rotate\n * \n * Rotates and/or flips the output around a given center. (Note: Due to\n * limitations in VML, the rotation cannot be concatenated.)\n * \n * Parameters:\n * \n * theta - Number that represents the angle of the rotation (in degrees).\n * flipH - Boolean indicating if the output should be flipped horizontally.\n * flipV - Boolean indicating if the output should be flipped vertically.\n * cx - Number that represents the x-coordinate of the rotation center.\n * cy - Number that represents the y-coordinate of the rotation center.\n */\nmxXmlCanvas2D.prototype.rotate = function(theta, flipH, flipV, cx, cy)\n{\n\tvar elem = this.createElement('rotate');\n\t\n\tif (theta != 0 || flipH || flipV)\n\t{\n\t\telem.setAttribute('theta', this.format(theta));\n\t\telem.setAttribute('flipH', (flipH) ? '1' : '0');\n\t\telem.setAttribute('flipV', (flipV) ? '1' : '0');\n\t\telem.setAttribute('cx', this.format(cx));\n\t\telem.setAttribute('cy', this.format(cy));\n\t\tthis.root.appendChild(elem);\n\t}\n};\n\n/**\n * Function: setAlpha\n * \n * Sets the current alpha.\n * \n * Parameters:\n * \n * value - Number that represents the new alpha. Possible values are between\n * 1 (opaque) and 0 (transparent).\n */\nmxXmlCanvas2D.prototype.setAlpha = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.alpha == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmxAbstractCanvas2D.prototype.setAlpha.apply(this, arguments);\n\t}\n\t\n\tvar elem = this.createElement('alpha');\n\telem.setAttribute('alpha', this.format(value));\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setFillAlpha\n * \n * Sets the current fill alpha.\n * \n * Parameters:\n * \n * value - Number that represents the new fill alpha. Possible values are between\n * 1 (opaque) and 0 (transparent).\n */\nmxXmlCanvas2D.prototype.setFillAlpha = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.fillAlpha == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmxAbstractCanvas2D.prototype.setFillAlpha.apply(this, arguments);\n\t}\n\t\n\tvar elem = this.createElement('fillalpha');\n\telem.setAttribute('alpha', this.format(value));\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setStrokeAlpha\n * \n * Sets the current stroke alpha.\n * \n * Parameters:\n * \n * value - Number that represents the new stroke alpha. Possible values are between\n * 1 (opaque) and 0 (transparent).\n */\nmxXmlCanvas2D.prototype.setStrokeAlpha = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.strokeAlpha == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmxAbstractCanvas2D.prototype.setStrokeAlpha.apply(this, arguments);\n\t}\n\t\n\tvar elem = this.createElement('strokealpha');\n\telem.setAttribute('alpha', this.format(value));\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setFillColor\n * \n * Sets the current fill color.\n * \n * Parameters:\n * \n * value - Hexadecimal representation of the color or 'none'.\n */\nmxXmlCanvas2D.prototype.setFillColor = function(value)\n{\n\tif (value == mxConstants.NONE)\n\t{\n\t\tvalue = null;\n\t}\n\t\n\tif (this.compressed)\n\t{\n\t\tif (this.state.fillColor == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmxAbstractCanvas2D.prototype.setFillColor.apply(this, arguments);\n\t}\n\t\n\tvar elem = this.createElement('fillcolor');\n\telem.setAttribute('color', (value != null) ? value : mxConstants.NONE);\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setGradient\n * \n * Sets the gradient. Note that the coordinates may be ignored by some implementations.\n * \n * Parameters:\n * \n * color1 - Hexadecimal representation of the start color.\n * color2 - Hexadecimal representation of the end color.\n * x - X-coordinate of the gradient region.\n * y - y-coordinate of the gradient region.\n * w - Width of the gradient region.\n * h - Height of the gradient region.\n * direction - One of <mxConstants.DIRECTION_NORTH>, <mxConstants.DIRECTION_EAST>,\n * <mxConstants.DIRECTION_SOUTH> or <mxConstants.DIRECTION_WEST>.\n * alpha1 - Optional alpha of the start color. Default is 1. Possible values\n * are between 1 (opaque) and 0 (transparent).\n * alpha2 - Optional alpha of the end color. Default is 1. Possible values\n * are between 1 (opaque) and 0 (transparent).\n */\nmxXmlCanvas2D.prototype.setGradient = function(color1, color2, x, y, w, h, direction, alpha1, alpha2)\n{\n\tif (color1 != null && color2 != null)\n\t{\n\t\tmxAbstractCanvas2D.prototype.setGradient.apply(this, arguments);\n\t\t\n\t\tvar elem = this.createElement('gradient');\n\t\telem.setAttribute('c1', color1);\n\t\telem.setAttribute('c2', color2);\n\t\telem.setAttribute('x', this.format(x));\n\t\telem.setAttribute('y', this.format(y));\n\t\telem.setAttribute('w', this.format(w));\n\t\telem.setAttribute('h', this.format(h));\n\t\t\n\t\t// Default direction is south\n\t\tif (direction != null)\n\t\t{\n\t\t\telem.setAttribute('direction', direction);\n\t\t}\n\t\t\n\t\tif (alpha1 != null)\n\t\t{\n\t\t\telem.setAttribute('alpha1', alpha1);\n\t\t}\n\t\t\n\t\tif (alpha2 != null)\n\t\t{\n\t\t\telem.setAttribute('alpha2', alpha2);\n\t\t}\n\t\t\n\t\tthis.root.appendChild(elem);\n\t}\n};\n\n/**\n * Function: setStrokeColor\n * \n * Sets the current stroke color.\n * \n * Parameters:\n * \n * value - Hexadecimal representation of the color or 'none'.\n */\nmxXmlCanvas2D.prototype.setStrokeColor = function(value)\n{\n\tif (value == mxConstants.NONE)\n\t{\n\t\tvalue = null;\n\t}\n\t\n\tif (this.compressed)\n\t{\n\t\tif (this.state.strokeColor == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmxAbstractCanvas2D.prototype.setStrokeColor.apply(this, arguments);\n\t}\n\t\n\tvar elem = this.createElement('strokecolor');\n\telem.setAttribute('color', (value != null) ? value : mxConstants.NONE);\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setStrokeWidth\n * \n * Sets the current stroke width.\n * \n * Parameters:\n * \n * value - Numeric representation of the stroke width.\n */\nmxXmlCanvas2D.prototype.setStrokeWidth = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.strokeWidth == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmxAbstractCanvas2D.prototype.setStrokeWidth.apply(this, arguments);\n\t}\n\t\n\tvar elem = this.createElement('strokewidth');\n\telem.setAttribute('width', this.format(value));\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setDashed\n * \n * Enables or disables dashed lines.\n * \n * Parameters:\n * \n * value - Boolean that specifies if dashed lines should be enabled.\n * value - Boolean that specifies if the stroke width should be ignored\n * for the dash pattern. Default is false.\n */\nmxXmlCanvas2D.prototype.setDashed = function(value, fixDash)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.dashed == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmxAbstractCanvas2D.prototype.setDashed.apply(this, arguments);\n\t}\n\t\n\tvar elem = this.createElement('dashed');\n\telem.setAttribute('dashed', (value) ? '1' : '0');\n\t\n\tif (fixDash != null)\n\t{\n\t\telem.setAttribute('fixDash', (fixDash) ? '1' : '0');\n\t}\n\t\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setDashPattern\n * \n * Sets the current dash pattern. Default is '3 3'.\n * \n * Parameters:\n * \n * value - String that represents the dash pattern, which is a sequence of\n * numbers defining the length of the dashes and the length of the spaces\n * between the dashes. The lengths are relative to the line width - a length\n * of 1 is equals to the line width.\n */\nmxXmlCanvas2D.prototype.setDashPattern = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.dashPattern == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmxAbstractCanvas2D.prototype.setDashPattern.apply(this, arguments);\n\t}\n\t\n\tvar elem = this.createElement('dashpattern');\n\telem.setAttribute('pattern', value);\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setLineCap\n * \n * Sets the line cap. Default is 'flat' which corresponds to 'butt' in SVG.\n * \n * Parameters:\n * \n * value - String that represents the line cap. Possible values are flat, round\n * and square.\n */\nmxXmlCanvas2D.prototype.setLineCap = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.lineCap == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmxAbstractCanvas2D.prototype.setLineCap.apply(this, arguments);\n\t}\n\t\n\tvar elem = this.createElement('linecap');\n\telem.setAttribute('cap', value);\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setLineJoin\n * \n * Sets the line join. Default is 'miter'.\n * \n * Parameters:\n * \n * value - String that represents the line join. Possible values are miter,\n * round and bevel.\n */\nmxXmlCanvas2D.prototype.setLineJoin = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.lineJoin == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmxAbstractCanvas2D.prototype.setLineJoin.apply(this, arguments);\n\t}\n\t\n\tvar elem = this.createElement('linejoin');\n\telem.setAttribute('join', value);\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setMiterLimit\n * \n * Sets the miter limit. Default is 10.\n * \n * Parameters:\n * \n * value - Number that represents the miter limit.\n */\nmxXmlCanvas2D.prototype.setMiterLimit = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.miterLimit == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmxAbstractCanvas2D.prototype.setMiterLimit.apply(this, arguments);\n\t}\n\t\n\tvar elem = this.createElement('miterlimit');\n\telem.setAttribute('limit', value);\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setFontColor\n * \n * Sets the current font color. Default is '#000000'.\n * \n * Parameters:\n * \n * value - Hexadecimal representation of the color or 'none'.\n */\nmxXmlCanvas2D.prototype.setFontColor = function(value)\n{\n\tif (this.textEnabled)\n\t{\n\t\tif (value == mxConstants.NONE)\n\t\t{\n\t\t\tvalue = null;\n\t\t}\n\t\t\n\t\tif (this.compressed)\n\t\t{\n\t\t\tif (this.state.fontColor == value)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tmxAbstractCanvas2D.prototype.setFontColor.apply(this, arguments);\n\t\t}\n\t\t\n\t\tvar elem = this.createElement('fontcolor');\n\t\telem.setAttribute('color', (value != null) ? value : mxConstants.NONE);\n\t\tthis.root.appendChild(elem);\n\t}\n};\n\n/**\n * Function: setFontBackgroundColor\n * \n * Sets the current font background color.\n * \n * Parameters:\n * \n * value - Hexadecimal representation of the color or 'none'.\n */\nmxXmlCanvas2D.prototype.setFontBackgroundColor = function(value)\n{\n\tif (this.textEnabled)\n\t{\n\t\tif (value == mxConstants.NONE)\n\t\t{\n\t\t\tvalue = null;\n\t\t}\n\t\t\n\t\tif (this.compressed)\n\t\t{\n\t\t\tif (this.state.fontBackgroundColor == value)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tmxAbstractCanvas2D.prototype.setFontBackgroundColor.apply(this, arguments);\n\t\t}\n\n\t\tvar elem = this.createElement('fontbackgroundcolor');\n\t\telem.setAttribute('color', (value != null) ? value : mxConstants.NONE);\n\t\tthis.root.appendChild(elem);\n\t}\n};\n\n/**\n * Function: setFontBorderColor\n * \n * Sets the current font border color.\n * \n * Parameters:\n * \n * value - Hexadecimal representation of the color or 'none'.\n */\nmxXmlCanvas2D.prototype.setFontBorderColor = function(value)\n{\n\tif (this.textEnabled)\n\t{\n\t\tif (value == mxConstants.NONE)\n\t\t{\n\t\t\tvalue = null;\n\t\t}\n\t\t\n\t\tif (this.compressed)\n\t\t{\n\t\t\tif (this.state.fontBorderColor == value)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tmxAbstractCanvas2D.prototype.setFontBorderColor.apply(this, arguments);\n\t\t}\n\t\t\n\t\tvar elem = this.createElement('fontbordercolor');\n\t\telem.setAttribute('color', (value != null) ? value : mxConstants.NONE);\n\t\tthis.root.appendChild(elem);\n\t}\n};\n\n/**\n * Function: setFontSize\n * \n * Sets the current font size. Default is <mxConstants.DEFAULT_FONTSIZE>.\n * \n * Parameters:\n * \n * value - Numeric representation of the font size.\n */\nmxXmlCanvas2D.prototype.setFontSize = function(value)\n{\n\tif (this.textEnabled)\n\t{\n\t\tif (this.compressed)\n\t\t{\n\t\t\tif (this.state.fontSize == value)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tmxAbstractCanvas2D.prototype.setFontSize.apply(this, arguments);\n\t\t}\n\t\t\n\t\tvar elem = this.createElement('fontsize');\n\t\telem.setAttribute('size', value);\n\t\tthis.root.appendChild(elem);\n\t}\n};\n\n/**\n * Function: setFontFamily\n * \n * Sets the current font family. Default is <mxConstants.DEFAULT_FONTFAMILY>.\n * \n * Parameters:\n * \n * value - String representation of the font family. This handles the same\n * values as the CSS font-family property.\n */\nmxXmlCanvas2D.prototype.setFontFamily = function(value)\n{\n\tif (this.textEnabled)\n\t{\n\t\tif (this.compressed)\n\t\t{\n\t\t\tif (this.state.fontFamily == value)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tmxAbstractCanvas2D.prototype.setFontFamily.apply(this, arguments);\n\t\t}\n\t\t\n\t\tvar elem = this.createElement('fontfamily');\n\t\telem.setAttribute('family', value);\n\t\tthis.root.appendChild(elem);\n\t}\n};\n\n/**\n * Function: setFontStyle\n * \n * Sets the current font style.\n * \n * Parameters:\n * \n * value - Numeric representation of the font family. This is the sum of the\n * font styles from <mxConstants>.\n */\nmxXmlCanvas2D.prototype.setFontStyle = function(value)\n{\n\tif (this.textEnabled)\n\t{\n\t\tif (value == null)\n\t\t{\n\t\t\tvalue = 0;\n\t\t}\n\t\t\n\t\tif (this.compressed)\n\t\t{\n\t\t\tif (this.state.fontStyle == value)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tmxAbstractCanvas2D.prototype.setFontStyle.apply(this, arguments);\n\t\t}\n\t\t\n\t\tvar elem = this.createElement('fontstyle');\n\t\telem.setAttribute('style', value);\n\t\tthis.root.appendChild(elem);\n\t}\n};\n\n/**\n * Function: setShadow\n * \n * Enables or disables shadows.\n * \n * Parameters:\n * \n * value - Boolean that specifies if shadows should be enabled.\n */\nmxXmlCanvas2D.prototype.setShadow = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.shadow == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmxAbstractCanvas2D.prototype.setShadow.apply(this, arguments);\n\t}\n\t\n\tvar elem = this.createElement('shadow');\n\telem.setAttribute('enabled', (value) ? '1' : '0');\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setShadowColor\n * \n * Sets the current shadow color. Default is <mxConstants.SHADOWCOLOR>.\n * \n * Parameters:\n * \n * value - Hexadecimal representation of the color or 'none'.\n */\nmxXmlCanvas2D.prototype.setShadowColor = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (value == mxConstants.NONE)\n\t\t{\n\t\t\tvalue = null;\n\t\t}\n\t\t\n\t\tif (this.state.shadowColor == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmxAbstractCanvas2D.prototype.setShadowColor.apply(this, arguments);\n\t}\n\t\n\tvar elem = this.createElement('shadowcolor');\n\telem.setAttribute('color', (value != null) ? value : mxConstants.NONE);\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setShadowAlpha\n * \n * Sets the current shadows alpha. Default is <mxConstants.SHADOW_OPACITY>.\n * \n * Parameters:\n * \n * value - Number that represents the new alpha. Possible values are between\n * 1 (opaque) and 0 (transparent).\n */\nmxXmlCanvas2D.prototype.setShadowAlpha = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.shadowAlpha == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmxAbstractCanvas2D.prototype.setShadowAlpha.apply(this, arguments);\n\t}\n\t\n\tvar elem = this.createElement('shadowalpha');\n\telem.setAttribute('alpha', value);\n\tthis.root.appendChild(elem);\n\t\n};\n\n/**\n * Function: setShadowOffset\n * \n * Sets the current shadow offset.\n * \n * Parameters:\n * \n * dx - Number that represents the horizontal offset of the shadow.\n * dy - Number that represents the vertical offset of the shadow.\n */\nmxXmlCanvas2D.prototype.setShadowOffset = function(dx, dy)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.shadowDx == dx && this.state.shadowDy == dy)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmxAbstractCanvas2D.prototype.setShadowOffset.apply(this, arguments);\n\t}\n\t\n\tvar elem = this.createElement('shadowoffset');\n\telem.setAttribute('dx', dx);\n\telem.setAttribute('dy', dy);\n\tthis.root.appendChild(elem);\n\t\n};\n\n/**\n * Function: rect\n * \n * Puts a rectangle into the drawing buffer.\n * \n * Parameters:\n * \n * x - Number that represents the x-coordinate of the rectangle.\n * y - Number that represents the y-coordinate of the rectangle.\n * w - Number that represents the width of the rectangle.\n * h - Number that represents the height of the rectangle.\n */\nmxXmlCanvas2D.prototype.rect = function(x, y, w, h)\n{\n\tvar elem = this.createElement('rect');\n\telem.setAttribute('x', this.format(x));\n\telem.setAttribute('y', this.format(y));\n\telem.setAttribute('w', this.format(w));\n\telem.setAttribute('h', this.format(h));\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: roundrect\n * \n * Puts a rounded rectangle into the drawing buffer.\n * \n * Parameters:\n * \n * x - Number that represents the x-coordinate of the rectangle.\n * y - Number that represents the y-coordinate of the rectangle.\n * w - Number that represents the width of the rectangle.\n * h - Number that represents the height of the rectangle.\n * dx - Number that represents the horizontal rounding.\n * dy - Number that represents the vertical rounding.\n */\nmxXmlCanvas2D.prototype.roundrect = function(x, y, w, h, dx, dy)\n{\n\tvar elem = this.createElement('roundrect');\n\telem.setAttribute('x', this.format(x));\n\telem.setAttribute('y', this.format(y));\n\telem.setAttribute('w', this.format(w));\n\telem.setAttribute('h', this.format(h));\n\telem.setAttribute('dx', this.format(dx));\n\telem.setAttribute('dy', this.format(dy));\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: ellipse\n * \n * Puts an ellipse into the drawing buffer.\n * \n * Parameters:\n * \n * x - Number that represents the x-coordinate of the ellipse.\n * y - Number that represents the y-coordinate of the ellipse.\n * w - Number that represents the width of the ellipse.\n * h - Number that represents the height of the ellipse.\n */\nmxXmlCanvas2D.prototype.ellipse = function(x, y, w, h)\n{\n\tvar elem = this.createElement('ellipse');\n\telem.setAttribute('x', this.format(x));\n\telem.setAttribute('y', this.format(y));\n\telem.setAttribute('w', this.format(w));\n\telem.setAttribute('h', this.format(h));\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: image\n * \n * Paints an image.\n * \n * Parameters:\n * \n * x - Number that represents the x-coordinate of the image.\n * y - Number that represents the y-coordinate of the image.\n * w - Number that represents the width of the image.\n * h - Number that represents the height of the image.\n * src - String that specifies the URL of the image.\n * aspect - Boolean indicating if the aspect of the image should be preserved.\n * flipH - Boolean indicating if the image should be flipped horizontally.\n * flipV - Boolean indicating if the image should be flipped vertically.\n */\nmxXmlCanvas2D.prototype.image = function(x, y, w, h, src, aspect, flipH, flipV)\n{\n\tsrc = this.converter.convert(src);\n\t\n\t// LATER: Add option for embedding images as base64.\n\tvar elem = this.createElement('image');\n\telem.setAttribute('x', this.format(x));\n\telem.setAttribute('y', this.format(y));\n\telem.setAttribute('w', this.format(w));\n\telem.setAttribute('h', this.format(h));\n\telem.setAttribute('src', src);\n\telem.setAttribute('aspect', (aspect) ? '1' : '0');\n\telem.setAttribute('flipH', (flipH) ? '1' : '0');\n\telem.setAttribute('flipV', (flipV) ? '1' : '0');\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: begin\n * \n * Starts a new path and puts it into the drawing buffer.\n */\nmxXmlCanvas2D.prototype.begin = function()\n{\n\tthis.root.appendChild(this.createElement('begin'));\n\tthis.lastX = 0;\n\tthis.lastY = 0;\n};\n\n/**\n * Function: moveTo\n * \n * Moves the current path the given point.\n * \n * Parameters:\n * \n * x - Number that represents the x-coordinate of the point.\n * y - Number that represents the y-coordinate of the point.\n */\nmxXmlCanvas2D.prototype.moveTo = function(x, y)\n{\n\tvar elem = this.createElement('move');\n\telem.setAttribute('x', this.format(x));\n\telem.setAttribute('y', this.format(y));\n\tthis.root.appendChild(elem);\n\tthis.lastX = x;\n\tthis.lastY = y;\n};\n\n/**\n * Function: lineTo\n * \n * Draws a line to the given coordinates.\n * \n * Parameters:\n * \n * x - Number that represents the x-coordinate of the endpoint.\n * y - Number that represents the y-coordinate of the endpoint.\n */\nmxXmlCanvas2D.prototype.lineTo = function(x, y)\n{\n\tvar elem = this.createElement('line');\n\telem.setAttribute('x', this.format(x));\n\telem.setAttribute('y', this.format(y));\n\tthis.root.appendChild(elem);\n\tthis.lastX = x;\n\tthis.lastY = y;\n};\n\n/**\n * Function: quadTo\n * \n * Adds a quadratic curve to the current path.\n * \n * Parameters:\n * \n * x1 - Number that represents the x-coordinate of the control point.\n * y1 - Number that represents the y-coordinate of the control point.\n * x2 - Number that represents the x-coordinate of the endpoint.\n * y2 - Number that represents the y-coordinate of the endpoint.\n */\nmxXmlCanvas2D.prototype.quadTo = function(x1, y1, x2, y2)\n{\n\tvar elem = this.createElement('quad');\n\telem.setAttribute('x1', this.format(x1));\n\telem.setAttribute('y1', this.format(y1));\n\telem.setAttribute('x2', this.format(x2));\n\telem.setAttribute('y2', this.format(y2));\n\tthis.root.appendChild(elem);\n\tthis.lastX = x2;\n\tthis.lastY = y2;\n};\n\n/**\n * Function: curveTo\n * \n * Adds a bezier curve to the current path.\n * \n * Parameters:\n * \n * x1 - Number that represents the x-coordinate of the first control point.\n * y1 - Number that represents the y-coordinate of the first control point.\n * x2 - Number that represents the x-coordinate of the second control point.\n * y2 - Number that represents the y-coordinate of the second control point.\n * x3 - Number that represents the x-coordinate of the endpoint.\n * y3 - Number that represents the y-coordinate of the endpoint.\n */\nmxXmlCanvas2D.prototype.curveTo = function(x1, y1, x2, y2, x3, y3)\n{\n\tvar elem = this.createElement('curve');\n\telem.setAttribute('x1', this.format(x1));\n\telem.setAttribute('y1', this.format(y1));\n\telem.setAttribute('x2', this.format(x2));\n\telem.setAttribute('y2', this.format(y2));\n\telem.setAttribute('x3', this.format(x3));\n\telem.setAttribute('y3', this.format(y3));\n\tthis.root.appendChild(elem);\n\tthis.lastX = x3;\n\tthis.lastY = y3;\n};\n\n/**\n * Function: close\n * \n * Closes the current path.\n */\nmxXmlCanvas2D.prototype.close = function()\n{\n\tthis.root.appendChild(this.createElement('close'));\n};\n\n/**\n * Function: text\n * \n * Paints the given text. Possible values for format are empty string for\n * plain text and html for HTML markup. Background and border color as well\n * as clipping is not available in plain text labels for VML. HTML labels\n * are not available as part of shapes with no foreignObject support in SVG\n * (eg. IE9, IE10).\n * \n * Parameters:\n * \n * x - Number that represents the x-coordinate of the text.\n * y - Number that represents the y-coordinate of the text.\n * w - Number that represents the available width for the text or 0 for automatic width.\n * h - Number that represents the available height for the text or 0 for automatic height.\n * str - String that specifies the text to be painted.\n * align - String that represents the horizontal alignment.\n * valign - String that represents the vertical alignment.\n * wrap - Boolean that specifies if word-wrapping is enabled. Requires w > 0.\n * format - Empty string for plain text or 'html' for HTML markup.\n * overflow - Specifies the overflow behaviour of the label. Requires w > 0 and/or h > 0.\n * clip - Boolean that specifies if the label should be clipped. Requires w > 0 and/or h > 0.\n * rotation - Number that specifies the angle of the rotation around the anchor point of the text.\n * dir - Optional string that specifies the text direction. Possible values are rtl and lrt.\n */\nmxXmlCanvas2D.prototype.text = function(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir)\n{\n\tif (this.textEnabled && str != null)\n\t{\n\t\tif (mxUtils.isNode(str))\n\t\t{\n\t\t\tstr = mxUtils.getOuterHtml(str);\n\t\t}\n\t\t\n\t\tvar elem = this.createElement('text');\n\t\telem.setAttribute('x', this.format(x));\n\t\telem.setAttribute('y', this.format(y));\n\t\telem.setAttribute('w', this.format(w));\n\t\telem.setAttribute('h', this.format(h));\n\t\telem.setAttribute('str', str);\n\t\t\n\t\tif (align != null)\n\t\t{\n\t\t\telem.setAttribute('align', align);\n\t\t}\n\t\t\n\t\tif (valign != null)\n\t\t{\n\t\t\telem.setAttribute('valign', valign);\n\t\t}\n\t\t\n\t\telem.setAttribute('wrap', (wrap) ? '1' : '0');\n\t\t\n\t\tif (format == null)\n\t\t{\n\t\t\tformat = '';\n\t\t}\n\t\t\n\t\telem.setAttribute('format', format);\n\t\t\n\t\tif (overflow != null)\n\t\t{\n\t\t\telem.setAttribute('overflow', overflow);\n\t\t}\n\t\t\n\t\tif (clip != null)\n\t\t{\n\t\t\telem.setAttribute('clip', (clip) ? '1' : '0');\n\t\t}\n\t\t\n\t\tif (rotation != null)\n\t\t{\n\t\t\telem.setAttribute('rotation', rotation);\n\t\t}\n\t\t\n\t\tif (dir != null)\n\t\t{\n\t\t\telem.setAttribute('dir', dir);\n\t\t}\n\t\t\n\t\tthis.root.appendChild(elem);\n\t}\n};\n\n/**\n * Function: stroke\n * \n * Paints the outline of the current drawing buffer.\n */\nmxXmlCanvas2D.prototype.stroke = function()\n{\n\tthis.root.appendChild(this.createElement('stroke'));\n};\n\n/**\n * Function: fill\n * \n * Fills the current drawing buffer.\n */\nmxXmlCanvas2D.prototype.fill = function()\n{\n\tthis.root.appendChild(this.createElement('fill'));\n};\n\n/**\n * Function: fillAndStroke\n * \n * Fills the current drawing buffer and its outline.\n */\nmxXmlCanvas2D.prototype.fillAndStroke = function()\n{\n\tthis.root.appendChild(this.createElement('fillstroke'));\n};\n\n__mxOutput.mxXmlCanvas2D = typeof mxXmlCanvas2D !== 'undefined' ? mxXmlCanvas2D : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxSvgCanvas2D\n *\n * Extends <mxAbstractCanvas2D> to implement a canvas for SVG. This canvas writes all\n * calls as SVG output to the given SVG root node.\n * \n * (code)\n * var svgDoc = mxUtils.createXmlDocument();\n * var root = (svgDoc.createElementNS != null) ?\n * \t\tsvgDoc.createElementNS(mxConstants.NS_SVG, 'svg') : svgDoc.createElement('svg');\n * \n * if (svgDoc.createElementNS == null)\n * {\n *   root.setAttribute('xmlns', mxConstants.NS_SVG);\n *   root.setAttribute('xmlns:xlink', mxConstants.NS_XLINK);\n * }\n * else\n * {\n *   root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', mxConstants.NS_XLINK);\n * }\n * \n * var bounds = graph.getGraphBounds();\n * root.setAttribute('width', (bounds.x + bounds.width + 4) + 'px');\n * root.setAttribute('height', (bounds.y + bounds.height + 4) + 'px');\n * root.setAttribute('version', '1.1');\n * \n * svgDoc.appendChild(root);\n * \n * var svgCanvas = new mxSvgCanvas2D(root);\n * (end)\n * \n * A description of the public API is available in <mxXmlCanvas2D>.\n * \n * To disable anti-aliasing in the output, use the following code.\n * \n * (code)\n * graph.view.canvas.ownerSVGElement.setAttribute('shape-rendering', 'crispEdges');\n * (end)\n * \n * Or set the respective attribute in the SVG element directly.\n * \n * Constructor: mxSvgCanvas2D\n *\n * Constructs a new SVG canvas.\n * \n * Parameters:\n * \n * root - SVG container for the output.\n * styleEnabled - Optional boolean that specifies if a style section should be\n * added. The style section sets the default font-size, font-family and\n * stroke-miterlimit globally. Default is false.\n */\nfunction mxSvgCanvas2D(root, styleEnabled)\n{\n\tmxAbstractCanvas2D.call(this);\n\n\t/**\n\t * Variable: root\n\t * \n\t * Reference to the container for the SVG content.\n\t */\n\tthis.root = root;\n\n\t/**\n\t * Variable: gradients\n\t * \n\t * Local cache of gradients for quick lookups.\n\t */\n\tthis.gradients = [];\n\n\t/**\n\t * Variable: defs\n\t * \n\t * Reference to the defs section of the SVG document. Only for export.\n\t */\n\tthis.defs = null;\n\t\n\t/**\n\t * Variable: styleEnabled\n\t * \n\t * Stores the value of styleEnabled passed to the constructor.\n\t */\n\tthis.styleEnabled = (styleEnabled != null) ? styleEnabled : false;\n\t\n\tvar svg = null;\n\t\n\t// Adds optional defs section for export\n\tif (root.ownerDocument != document)\n\t{\n\t\tvar node = root;\n\n\t\t// Finds owner SVG element in XML DOM\n\t\twhile (node != null && node.nodeName != 'svg')\n\t\t{\n\t\t\tnode = node.parentNode;\n\t\t}\n\t\t\n\t\tsvg = node;\n\t}\n\n\tif (svg != null)\n\t{\n\t\t// Tries to get existing defs section\n\t\tvar tmp = svg.getElementsByTagName('defs');\n\t\t\n\t\tif (tmp.length > 0)\n\t\t{\n\t\t\tthis.defs = svg.getElementsByTagName('defs')[0];\n\t\t}\n\t\t\n\t\t// Adds defs section if none exists\n\t\tif (this.defs == null)\n\t\t{\n\t\t\tthis.defs = this.createElement('defs');\n\t\t\t\n\t\t\tif (svg.firstChild != null)\n\t\t\t{\n\t\t\t\tsvg.insertBefore(this.defs, svg.firstChild);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsvg.appendChild(this.defs);\n\t\t\t}\n\t\t}\n\n\t\t// Adds stylesheet\n\t\tif (this.styleEnabled)\n\t\t{\n\t\t\tthis.defs.appendChild(this.createStyle());\n\t\t}\n\t}\n};\n\n/**\n * Extends mxAbstractCanvas2D\n */\nmxUtils.extend(mxSvgCanvas2D, mxAbstractCanvas2D);\n\n/**\n * Capability check for DOM parser and checks if base tag is used.\n */\n(function()\n{\n\tmxSvgCanvas2D.prototype.useDomParser = !mxClient.IS_IE && typeof DOMParser === 'function' && typeof XMLSerializer === 'function';\n\t\n\tif (mxSvgCanvas2D.prototype.useDomParser)\n\t{\n\t\t// Checks using a generic test text if the parsing actually works. This is a workaround\n\t\t// for older browsers where the capability check returns true but the parsing fails.\n\t\ttry\n\t\t{\n\t\t\tvar doc = new DOMParser().parseFromString('test text', 'text/html');\n\t\t\tmxSvgCanvas2D.prototype.useDomParser = doc != null;\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\tmxSvgCanvas2D.prototype.useDomParser = false;\n\t\t}\n\t}\n\t\n\t// Activates workaround for gradient ID resolution if base tag is used.\n\tmxSvgCanvas2D.prototype.useAbsoluteIds = !mxClient.IS_CHROMEAPP && !mxClient.IS_IE && !mxClient.IS_IE11 &&\n\t\t!mxClient.IS_EDGE && document.getElementsByTagName('base').length > 0;\n})();\n\n/**\n * Variable: path\n * \n * Holds the current DOM node.\n */\nmxSvgCanvas2D.prototype.node = null;\n\n/**\n * Variable: matchHtmlAlignment\n * \n * Specifies if plain text output should match the vertical HTML alignment.\n * Defaul is true.\n */\nmxSvgCanvas2D.prototype.matchHtmlAlignment = true;\n\n/**\n * Variable: textEnabled\n * \n * Specifies if text output should be enabled. Default is true.\n */\nmxSvgCanvas2D.prototype.textEnabled = true;\n\n/**\n * Variable: foEnabled\n * \n * Specifies if use of foreignObject for HTML markup is allowed. Default is true.\n */\nmxSvgCanvas2D.prototype.foEnabled = true;\n\n/**\n * Variable: foAltText\n * \n * Specifies the fallback text for unsupported foreignObjects in exported\n * documents. Default is '[Object]'. If this is set to null then no fallback\n * text is added to the exported document.\n */\nmxSvgCanvas2D.prototype.foAltText = '[Object]';\n\n/**\n * Variable: foOffset\n * \n * Offset to be used for foreignObjects.\n */\nmxSvgCanvas2D.prototype.foOffset = 0;\n\n/**\n * Variable: textOffset\n * \n * Offset to be used for text elements.\n */\nmxSvgCanvas2D.prototype.textOffset = 0;\n\n/**\n * Variable: imageOffset\n * \n * Offset to be used for image elements.\n */\nmxSvgCanvas2D.prototype.imageOffset = 0;\n\n/**\n * Variable: strokeTolerance\n * \n * Adds transparent paths for strokes.\n */\nmxSvgCanvas2D.prototype.strokeTolerance = 0;\n\n/**\n * Variable: minStrokeWidth\n * \n * Minimum stroke width for output.\n */\nmxSvgCanvas2D.prototype.minStrokeWidth = 1;\n\n/**\n * Variable: refCount\n * \n * Local counter for references in SVG export.\n */\nmxSvgCanvas2D.prototype.refCount = 0;\n\n/**\n * Variable: lineHeightCorrection\n * \n * Correction factor for <mxConstants.LINE_HEIGHT> in HTML output. Default is 1.\n */\nmxSvgCanvas2D.prototype.lineHeightCorrection = 1;\n\n/**\n * Variable: pointerEventsValue\n * \n * Default value for active pointer events. Default is all.\n */\nmxSvgCanvas2D.prototype.pointerEventsValue = 'all';\n\n/**\n * Variable: fontMetricsPadding\n * \n * Padding to be added for text that is not wrapped to account for differences\n * in font metrics on different platforms in pixels. Default is 10.\n */\nmxSvgCanvas2D.prototype.fontMetricsPadding = 10;\n\n/**\n * Variable: cacheOffsetSize\n * \n * Specifies if offsetWidth and offsetHeight should be cached. Default is true.\n * This is used to speed up repaint of text in <updateText>.\n */\nmxSvgCanvas2D.prototype.cacheOffsetSize = true;\n\n/**\n * Function: format\n * \n * Rounds all numbers to 2 decimal points.\n */\nmxSvgCanvas2D.prototype.format = function(value)\n{\n\treturn parseFloat(parseFloat(value).toFixed(2));\n};\n\n/**\n * Function: getBaseUrl\n * \n * Returns the URL of the page without the hash part. This needs to use href to\n * include any search part with no params (ie question mark alone). This is a\n * workaround for the fact that window.location.search is empty if there is\n * no search string behind the question mark.\n */\nmxSvgCanvas2D.prototype.getBaseUrl = function()\n{\n\tvar href = window.location.href;\n\tvar hash = href.lastIndexOf('#');\n\t\n\tif (hash > 0)\n\t{\n\t\thref = href.substring(0, hash);\n\t}\n\t\n\treturn href;\n};\n\n/**\n * Function: reset\n * \n * Returns any offsets for rendering pixels.\n */\nmxSvgCanvas2D.prototype.reset = function()\n{\n\tmxAbstractCanvas2D.prototype.reset.apply(this, arguments);\n\tthis.gradients = [];\n};\n\n/**\n * Function: createStyle\n * \n * Creates the optional style section.\n */\nmxSvgCanvas2D.prototype.createStyle = function(x)\n{\n\tvar style = this.createElement('style');\n\tstyle.setAttribute('type', 'text/css');\n\tmxUtils.write(style, 'svg{font-family:' + mxConstants.DEFAULT_FONTFAMILY +\n\t\t\t';font-size:' + mxConstants.DEFAULT_FONTSIZE +\n\t\t\t';fill:none;stroke-miterlimit:10}');\n\t\n\treturn style;\n};\n\n/**\n * Function: createElement\n * \n * Private helper function to create SVG elements\n */\nmxSvgCanvas2D.prototype.createElement = function(tagName, namespace)\n{\n\tif (this.root.ownerDocument.createElementNS != null)\n\t{\n\t\treturn this.root.ownerDocument.createElementNS(namespace || mxConstants.NS_SVG, tagName);\n\t}\n\telse\n\t{\n\t\tvar elt = this.root.ownerDocument.createElement(tagName);\n\t\t\n\t\tif (namespace != null)\n\t\t{\n\t\t\telt.setAttribute('xmlns', namespace);\n\t\t}\n\t\t\n\t\treturn elt;\n\t}\n};\n\n/**\n * Function: getAlternateText\n * \n * Returns the alternate text string for the given foreignObject.\n */\nmxSvgCanvas2D.prototype.getAlternateText = function(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation)\n{\n\treturn (str != null) ? this.foAltText : null;\n};\n\n/**\n * Function: getAlternateContent\n * \n * Returns the alternate content for the given foreignObject.\n */\nmxSvgCanvas2D.prototype.createAlternateContent = function(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation)\n{\n\tvar text = this.getAlternateText(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation);\n\tvar s = this.state;\n\n\tif (text != null && s.fontSize > 0)\n\t{\n\t\tvar dy = (valign == mxConstants.ALIGN_TOP) ? 1 :\n\t\t\t(valign == mxConstants.ALIGN_BOTTOM) ? 0 : 0.3;\n\t\tvar anchor = (align == mxConstants.ALIGN_RIGHT) ? 'end' :\n\t\t\t(align == mxConstants.ALIGN_LEFT) ? 'start' :\n\t\t\t'middle';\n\t\n\t\tvar alt = this.createElement('text');\n\t\talt.setAttribute('x', Math.round(x + s.dx));\n\t\talt.setAttribute('y', Math.round(y + s.dy + dy * s.fontSize));\n\t\talt.setAttribute('fill', s.fontColor || 'black');\n\t\talt.setAttribute('font-family', s.fontFamily);\n\t\talt.setAttribute('font-size', Math.round(s.fontSize) + 'px');\n\n\t\t// Text-anchor start is default in SVG\n\t\tif (anchor != 'start')\n\t\t{\n\t\t\talt.setAttribute('text-anchor', anchor);\n\t\t}\n\t\t\n\t\tif ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD)\n\t\t{\n\t\t\talt.setAttribute('font-weight', 'bold');\n\t\t}\n\t\t\n\t\tif ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC)\n\t\t{\n\t\t\talt.setAttribute('font-style', 'italic');\n\t\t}\n\t\t\n\t\tvar txtDecor = [];\n\t\t\n\t\tif ((s.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE)\n\t\t{\n\t\t\ttxtDecor.push('underline');\n\t\t}\n\t\t\n\t\tif ((s.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH)\n\t\t{\n\t\t\ttxtDecor.push('line-through');\n\t\t}\n\t\t\n\t\tif (txtDecor.length > 0)\n\t\t{\n\t\t\talt.setAttribute('text-decoration', txtDecor.join(' '));\n\t\t}\n\t\t\n\t\tmxUtils.write(alt, text);\n\t\t\n\t\treturn alt;\n\t}\n\telse\n\t{\n\t\treturn null;\n\t}\n};\n\n/**\n * Function: createGradientId\n * \n * Private helper function to create SVG elements\n */\nmxSvgCanvas2D.prototype.createGradientId = function(start, end, alpha1, alpha2, direction)\n{\n\t// Removes illegal characters from gradient ID\n\tif (start.charAt(0) == '#')\n\t{\n\t\tstart = start.substring(1);\n\t}\n\t\n\tif (end.charAt(0) == '#')\n\t{\n\t\tend = end.substring(1);\n\t}\n\t\n\t// Workaround for gradient IDs not working in Safari 5 / Chrome 6\n\t// if they contain uppercase characters\n\tstart = start.toLowerCase() + '-' + alpha1;\n\tend = end.toLowerCase() + '-' + alpha2;\n\n\t// Wrong gradient directions possible?\n\tvar dir = null;\n\t\n\tif (direction == null || direction == mxConstants.DIRECTION_SOUTH)\n\t{\n\t\tdir = 's';\n\t}\n\telse if (direction == mxConstants.DIRECTION_EAST)\n\t{\n\t\tdir = 'e';\n\t}\n\telse\n\t{\n\t\tvar tmp = start;\n\t\tstart = end;\n\t\tend = tmp;\n\t\t\n\t\tif (direction == mxConstants.DIRECTION_NORTH)\n\t\t{\n\t\t\tdir = 's';\n\t\t}\n\t\telse if (direction == mxConstants.DIRECTION_WEST)\n\t\t{\n\t\t\tdir = 'e';\n\t\t}\n\t}\n\t\n\treturn 'mx-gradient-' + start + '-' + end + '-' + dir;\n};\n\n/**\n * Function: getSvgGradient\n * \n * Private helper function to create SVG elements\n */\nmxSvgCanvas2D.prototype.getSvgGradient = function(start, end, alpha1, alpha2, direction)\n{\n\tvar id = this.createGradientId(start, end, alpha1, alpha2, direction);\n\tvar gradient = this.gradients[id];\n\t\n\tif (gradient == null)\n\t{\n\t\tvar svg = this.root.ownerSVGElement;\n\n\t\tvar counter = 0;\n\t\tvar tmpId = id + '-' + counter;\n\n\t\tif (svg != null)\n\t\t{\n\t\t\tgradient = svg.ownerDocument.getElementById(tmpId);\n\t\t\t\n\t\t\twhile (gradient != null && gradient.ownerSVGElement != svg)\n\t\t\t{\n\t\t\t\ttmpId = id + '-' + counter++;\n\t\t\t\tgradient = svg.ownerDocument.getElementById(tmpId);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Uses shorter IDs for export\n\t\t\ttmpId = 'id' + (++this.refCount);\n\t\t}\n\t\t\n\t\tif (gradient == null)\n\t\t{\n\t\t\tgradient = this.createSvgGradient(start, end, alpha1, alpha2, direction);\n\t\t\tgradient.setAttribute('id', tmpId);\n\t\t\t\n\t\t\tif (this.defs != null)\n\t\t\t{\n\t\t\t\tthis.defs.appendChild(gradient);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsvg.appendChild(gradient);\n\t\t\t}\n\t\t}\n\n\t\tthis.gradients[id] = gradient;\n\t}\n\n\treturn gradient.getAttribute('id');\n};\n\n/**\n * Function: createSvgGradient\n * \n * Creates the given SVG gradient.\n */\nmxSvgCanvas2D.prototype.createSvgGradient = function(start, end, alpha1, alpha2, direction)\n{\n\tvar gradient = this.createElement('linearGradient');\n\tgradient.setAttribute('x1', '0%');\n\tgradient.setAttribute('y1', '0%');\n\tgradient.setAttribute('x2', '0%');\n\tgradient.setAttribute('y2', '0%');\n\t\n\tif (direction == null || direction == mxConstants.DIRECTION_SOUTH)\n\t{\n\t\tgradient.setAttribute('y2', '100%');\n\t}\n\telse if (direction == mxConstants.DIRECTION_EAST)\n\t{\n\t\tgradient.setAttribute('x2', '100%');\n\t}\n\telse if (direction == mxConstants.DIRECTION_NORTH)\n\t{\n\t\tgradient.setAttribute('y1', '100%');\n\t}\n\telse if (direction == mxConstants.DIRECTION_WEST)\n\t{\n\t\tgradient.setAttribute('x1', '100%');\n\t}\n\t\n\tvar op = (alpha1 < 1) ? ';stop-opacity:' + alpha1 : '';\n\t\n\tvar stop = this.createElement('stop');\n\tstop.setAttribute('offset', '0%');\n\tstop.setAttribute('style', 'stop-color:' + start + op);\n\tgradient.appendChild(stop);\n\t\n\top = (alpha2 < 1) ? ';stop-opacity:' + alpha2 : '';\n\t\n\tstop = this.createElement('stop');\n\tstop.setAttribute('offset', '100%');\n\tstop.setAttribute('style', 'stop-color:' + end + op);\n\tgradient.appendChild(stop);\n\t\n\treturn gradient;\n};\n\n/**\n * Function: addNode\n * \n * Private helper function to create SVG elements\n */\nmxSvgCanvas2D.prototype.addNode = function(filled, stroked)\n{\n\tvar node = this.node;\n\tvar s = this.state;\n\n\tif (node != null)\n\t{\n\t\tif (node.nodeName == 'path')\n\t\t{\n\t\t\t// Checks if the path is not empty\n\t\t\tif (this.path != null && this.path.length > 0)\n\t\t\t{\n\t\t\t\tnode.setAttribute('d', this.path.join(' '));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (filled && s.fillColor != null)\n\t\t{\n\t\t\tthis.updateFill();\n\t\t}\n\t\telse if (!this.styleEnabled)\n\t\t{\n\t\t\t// Workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=814952\n\t\t\tif (node.nodeName == 'ellipse' && mxClient.IS_FF)\n\t\t\t{\n\t\t\t\tnode.setAttribute('fill', 'transparent');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.setAttribute('fill', 'none');\n\t\t\t}\n\t\t\t\n\t\t\t// Sets the actual filled state for stroke tolerance\n\t\t\tfilled = false;\n\t\t}\n\t\t\n\t\tif (stroked && s.strokeColor != null)\n\t\t{\n\t\t\tthis.updateStroke();\n\t\t}\n\t\telse if (!this.styleEnabled)\n\t\t{\n\t\t\tnode.setAttribute('stroke', 'none');\n\t\t}\n\t\t\n\t\tif (s.transform != null && s.transform.length > 0)\n\t\t{\n\t\t\tnode.setAttribute('transform', s.transform);\n\t\t}\n\t\t\n\t\tif (s.shadow)\n\t\t{\n\t\t\tthis.root.appendChild(this.createShadow(node));\n\t\t}\n\t\n\t\t// Adds stroke tolerance\n\t\tif (this.strokeTolerance > 0 && !filled)\n\t\t{\n\t\t\tthis.root.appendChild(this.createTolerance(node));\n\t\t}\n\n\t\t// Adds pointer events\n\t\tif (this.pointerEvents)\n\t\t{\n\t\t\tnode.setAttribute('pointer-events', this.pointerEventsValue);\n\t\t}\n\t\t// Enables clicks for nodes inside a link element\n\t\telse if (!this.pointerEvents && this.originalRoot == null)\n\t\t{\n\t\t\tnode.setAttribute('pointer-events', 'none');\n\t\t}\n\t\t\n\t\t// Removes invisible nodes from output if they don't handle events\n\t\tif ((node.nodeName != 'rect' && node.nodeName != 'path' && node.nodeName != 'ellipse') ||\n\t\t\t(node.getAttribute('fill') != 'none' && node.getAttribute('fill') != 'transparent') ||\n\t\t\tnode.getAttribute('stroke') != 'none' || node.getAttribute('pointer-events') != 'none')\n\t\t{\n\t\t\t// LATER: Update existing DOM for performance\t\t\n\t\t\tthis.root.appendChild(node);\n\t\t}\n\t\t\n\t\tthis.node = null;\n\t}\n};\n\n/**\n * Function: updateFill\n * \n * Transfers the stroke attributes from <state> to <node>.\n */\nmxSvgCanvas2D.prototype.updateFill = function()\n{\n\tvar s = this.state;\n\t\n\tif (s.alpha < 1 || s.fillAlpha < 1)\n\t{\n\t\tthis.node.setAttribute('fill-opacity', s.alpha * s.fillAlpha);\n\t}\n\t\n\tif (s.fillColor != null)\n\t{\n\t\tif (s.gradientColor != null)\n\t\t{\n\t\t\tvar id = this.getSvgGradient(String(s.fillColor), String(s.gradientColor),\n\t\t\t\ts.gradientFillAlpha, s.gradientAlpha, s.gradientDirection);\n\t\t\t\n\t\t\tif (this.root.ownerDocument == document && this.useAbsoluteIds)\n\t\t\t{\n\t\t\t\t// Workaround for no fill with base tag in page (escape brackets)\n\t\t\t\tvar base = this.getBaseUrl().replace(/([\\(\\)])/g, '\\\\$1');\n\t\t\t\tthis.node.setAttribute('fill', 'url(' + base + '#' + id + ')');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.node.setAttribute('fill', 'url(#' + id + ')');\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.node.setAttribute('fill', String(s.fillColor).toLowerCase());\n\t\t}\n\t}\n};\n\n/**\n * Function: getCurrentStrokeWidth\n * \n * Returns the current stroke width (>= 1), ie. max(1, this.format(this.state.strokeWidth * this.state.scale)).\n */\nmxSvgCanvas2D.prototype.getCurrentStrokeWidth = function()\n{\n\treturn Math.max(this.minStrokeWidth, Math.max(0.01, this.format(this.state.strokeWidth * this.state.scale)));\n};\n\n/**\n * Function: updateStroke\n * \n * Transfers the stroke attributes from <state> to <node>.\n */\nmxSvgCanvas2D.prototype.updateStroke = function()\n{\n\tvar s = this.state;\n\n\tthis.node.setAttribute('stroke', String(s.strokeColor).toLowerCase());\n\t\n\tif (s.alpha < 1 || s.strokeAlpha < 1)\n\t{\n\t\tthis.node.setAttribute('stroke-opacity', s.alpha * s.strokeAlpha);\n\t}\n\t\n\tvar sw = this.getCurrentStrokeWidth();\n\t\n\tif (sw != 1)\n\t{\n\t\tthis.node.setAttribute('stroke-width', sw);\n\t}\n\t\n\tif (this.node.nodeName == 'path')\n\t{\n\t\tthis.updateStrokeAttributes();\n\t}\n\t\n\tif (s.dashed)\n\t{\n\t\tthis.node.setAttribute('stroke-dasharray', this.createDashPattern(\n\t\t\t((s.fixDash) ? 1 : s.strokeWidth) * s.scale));\n\t}\n};\n\n/**\n * Function: updateStrokeAttributes\n * \n * Transfers the stroke attributes from <state> to <node>.\n */\nmxSvgCanvas2D.prototype.updateStrokeAttributes = function()\n{\n\tvar s = this.state;\n\t\n\t// Linejoin miter is default in SVG\n\tif (s.lineJoin != null && s.lineJoin != 'miter')\n\t{\n\t\tthis.node.setAttribute('stroke-linejoin', s.lineJoin);\n\t}\n\t\n\tif (s.lineCap != null)\n\t{\n\t\t// flat is called butt in SVG\n\t\tvar value = s.lineCap;\n\t\t\n\t\tif (value == 'flat')\n\t\t{\n\t\t\tvalue = 'butt';\n\t\t}\n\t\t\n\t\t// Linecap butt is default in SVG\n\t\tif (value != 'butt')\n\t\t{\n\t\t\tthis.node.setAttribute('stroke-linecap', value);\n\t\t}\n\t}\n\t\n\t// Miterlimit 10 is default in our document\n\tif (s.miterLimit != null && (!this.styleEnabled || s.miterLimit != 10))\n\t{\n\t\tthis.node.setAttribute('stroke-miterlimit', s.miterLimit);\n\t}\n};\n\n/**\n * Function: createDashPattern\n * \n * Creates the SVG dash pattern for the given state.\n */\nmxSvgCanvas2D.prototype.createDashPattern = function(scale)\n{\n\tvar pat = [];\n\t\n\tif (typeof(this.state.dashPattern) === 'string')\n\t{\n\t\tvar dash = this.state.dashPattern.split(' ');\n\t\t\n\t\tif (dash.length > 0)\n\t\t{\n\t\t\tfor (var i = 0; i < dash.length; i++)\n\t\t\t{\n\t\t\t\tpat[i] = Number(dash[i]) * scale;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn pat.join(' ');\n};\n\n/**\n * Function: createTolerance\n * \n * Creates a hit detection tolerance shape for the given node.\n */\nmxSvgCanvas2D.prototype.createTolerance = function(node)\n{\n\tvar tol = node.cloneNode(true);\n\tvar sw = parseFloat(tol.getAttribute('stroke-width') || 1) + this.strokeTolerance;\n\ttol.setAttribute('pointer-events', 'stroke');\n\ttol.setAttribute('visibility', 'hidden');\n\ttol.removeAttribute('stroke-dasharray');\n\ttol.setAttribute('stroke-width', sw);\n\ttol.setAttribute('fill', 'none');\n\t\n\t// Workaround for Opera ignoring the visiblity attribute above while\n\t// other browsers need a stroke color to perform the hit-detection but\n\t// do not ignore the visibility attribute. Side-effect is that Opera's\n\t// hit detection for horizontal/vertical edges seems to ignore the tol.\n\ttol.setAttribute('stroke', (mxClient.IS_OT) ? 'none' : 'white');\n\t\n\treturn tol;\n};\n\n/**\n * Function: createShadow\n * \n * Creates a shadow for the given node.\n */\nmxSvgCanvas2D.prototype.createShadow = function(node)\n{\n\tvar shadow = node.cloneNode(true);\n\tvar s = this.state;\n\n\t// Firefox uses transparent for no fill in ellipses\n\tif (shadow.getAttribute('fill') != 'none' && (!mxClient.IS_FF || shadow.getAttribute('fill') != 'transparent'))\n\t{\n\t\tshadow.setAttribute('fill', s.shadowColor);\n\t}\n\t\n\tif (shadow.getAttribute('stroke') != 'none')\n\t{\n\t\tshadow.setAttribute('stroke', s.shadowColor);\n\t}\n\n\tshadow.setAttribute('transform', 'translate(' + this.format(s.shadowDx * s.scale) +\n\t\t',' + this.format(s.shadowDy * s.scale) + ')' + (s.transform || ''));\n\tshadow.setAttribute('opacity', s.shadowAlpha);\n\t\n\treturn shadow;\n};\n\n/**\n * Function: setLink\n * \n * Experimental implementation for hyperlinks.\n */\nmxSvgCanvas2D.prototype.setLink = function(link)\n{\n\tif (link == null)\n\t{\n\t\tthis.root = this.originalRoot;\n\t}\n\telse\n\t{\n\t\tthis.originalRoot = this.root;\n\t\t\n\t\tvar node = this.createElement('a');\n\t\t\n\t\t// Workaround for implicit namespace handling in HTML5 export, IE adds NS1 namespace so use code below\n\t\t// in all IE versions except quirks mode. KNOWN: Adds xlink namespace to each image tag in output.\n\t\tif (node.setAttributeNS == null || (this.root.ownerDocument != document && document.documentMode == null))\n\t\t{\n\t\t\tnode.setAttribute('xlink:href', link);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnode.setAttributeNS(mxConstants.NS_XLINK, 'xlink:href', link);\n\t\t}\n\t\t\n\t\tthis.root.appendChild(node);\n\t\tthis.root = node;\n\t}\n};\n\n/**\n * Function: rotate\n * \n * Sets the rotation of the canvas. Note that rotation cannot be concatenated.\n */\nmxSvgCanvas2D.prototype.rotate = function(theta, flipH, flipV, cx, cy)\n{\n\tif (theta != 0 || flipH || flipV)\n\t{\n\t\tvar s = this.state;\n\t\tcx += s.dx;\n\t\tcy += s.dy;\n\t\n\t\tcx *= s.scale;\n\t\tcy *= s.scale;\n\n\t\ts.transform = s.transform || '';\n\t\t\n\t\t// This implementation uses custom scale/translate and built-in rotation\n\t\t// Rotation state is part of the AffineTransform in state.transform\n\t\tif (flipH && flipV)\n\t\t{\n\t\t\ttheta += 180;\n\t\t}\n\t\telse if (flipH != flipV)\n\t\t{\n\t\t\tvar tx = (flipH) ? cx : 0;\n\t\t\tvar sx = (flipH) ? -1 : 1;\n\t\n\t\t\tvar ty = (flipV) ? cy : 0;\n\t\t\tvar sy = (flipV) ? -1 : 1;\n\n\t\t\ts.transform += 'translate(' + this.format(tx) + ',' + this.format(ty) + ')' +\n\t\t\t\t'scale(' + this.format(sx) + ',' + this.format(sy) + ')' +\n\t\t\t\t'translate(' + this.format(-tx) + ',' + this.format(-ty) + ')';\n\t\t}\n\t\t\n\t\tif (flipH ? !flipV : flipV)\n\t\t{\n\t\t\ttheta *= -1;\n\t\t}\n\t\t\n\t\tif (theta != 0)\n\t\t{\n\t\t\ts.transform += 'rotate(' + this.format(theta) + ',' + this.format(cx) + ',' + this.format(cy) + ')';\n\t\t}\n\t\t\n\t\ts.rotation = s.rotation + theta;\n\t\ts.rotationCx = cx;\n\t\ts.rotationCy = cy;\n\t}\n};\n\n/**\n * Function: begin\n * \n * Extends superclass to create path.\n */\nmxSvgCanvas2D.prototype.begin = function()\n{\n\tmxAbstractCanvas2D.prototype.begin.apply(this, arguments);\n\tthis.node = this.createElement('path');\n};\n\n/**\n * Function: rect\n * \n * Private helper function to create SVG elements\n */\nmxSvgCanvas2D.prototype.rect = function(x, y, w, h)\n{\n\tvar s = this.state;\n\tvar n = this.createElement('rect');\n\tn.setAttribute('x', this.format((x + s.dx) * s.scale));\n\tn.setAttribute('y', this.format((y + s.dy) * s.scale));\n\tn.setAttribute('width', this.format(w * s.scale));\n\tn.setAttribute('height', this.format(h * s.scale));\n\t\n\tthis.node = n;\n};\n\n/**\n * Function: roundrect\n * \n * Private helper function to create SVG elements\n */\nmxSvgCanvas2D.prototype.roundrect = function(x, y, w, h, dx, dy)\n{\n\tthis.rect(x, y, w, h);\n\t\n\tif (dx > 0)\n\t{\n\t\tthis.node.setAttribute('rx', this.format(dx * this.state.scale));\n\t}\n\t\n\tif (dy > 0)\n\t{\n\t\tthis.node.setAttribute('ry', this.format(dy * this.state.scale));\n\t}\n};\n\n/**\n * Function: ellipse\n * \n * Private helper function to create SVG elements\n */\nmxSvgCanvas2D.prototype.ellipse = function(x, y, w, h)\n{\n\tvar s = this.state;\n\tvar n = this.createElement('ellipse');\n\t// No rounding for consistent output with 1.x\n\tn.setAttribute('cx', this.format((x + w / 2 + s.dx) * s.scale));\n\tn.setAttribute('cy', this.format((y + h / 2 + s.dy) * s.scale));\n\tn.setAttribute('rx', w / 2 * s.scale);\n\tn.setAttribute('ry', h / 2 * s.scale);\n\tthis.node = n;\n};\n\n/**\n * Function: image\n * \n * Private helper function to create SVG elements\n */\nmxSvgCanvas2D.prototype.image = function(x, y, w, h, src, aspect, flipH, flipV)\n{\n\tsrc = this.converter.convert(src);\n\t\n\t// LATER: Add option for embedding images as base64.\n\taspect = (aspect != null) ? aspect : true;\n\tflipH = (flipH != null) ? flipH : false;\n\tflipV = (flipV != null) ? flipV : false;\n\t\n\tvar s = this.state;\n\tx += s.dx;\n\ty += s.dy;\n\t\n\tvar node = this.createElement('image');\n\tnode.setAttribute('x', this.format(x * s.scale) + this.imageOffset);\n\tnode.setAttribute('y', this.format(y * s.scale) + this.imageOffset);\n\tnode.setAttribute('width', this.format(w * s.scale));\n\tnode.setAttribute('height', this.format(h * s.scale));\n\t\n\t// Workaround for missing namespace support\n\tif (node.setAttributeNS == null)\n\t{\n\t\tnode.setAttribute('xlink:href', src);\n\t}\n\telse\n\t{\n\t\tnode.setAttributeNS(mxConstants.NS_XLINK, 'xlink:href', src);\n\t}\n\t\n\tif (!aspect)\n\t{\n\t\tnode.setAttribute('preserveAspectRatio', 'none');\n\t}\n\n\tif (s.alpha < 1 || s.fillAlpha < 1)\n\t{\n\t\tnode.setAttribute('opacity', s.alpha * s.fillAlpha);\n\t}\n\t\n\tvar tr = this.state.transform || '';\n\t\n\tif (flipH || flipV)\n\t{\n\t\tvar sx = 1;\n\t\tvar sy = 1;\n\t\tvar dx = 0;\n\t\tvar dy = 0;\n\t\t\n\t\tif (flipH)\n\t\t{\n\t\t\tsx = -1;\n\t\t\tdx = -w - 2 * x;\n\t\t}\n\t\t\n\t\tif (flipV)\n\t\t{\n\t\t\tsy = -1;\n\t\t\tdy = -h - 2 * y;\n\t\t}\n\t\t\n\t\t// Adds image tansformation to existing transform\n\t\ttr += 'scale(' + sx + ',' + sy + ')translate(' + (dx * s.scale) + ',' + (dy * s.scale) + ')';\n\t}\n\n\tif (tr.length > 0)\n\t{\n\t\tnode.setAttribute('transform', tr);\n\t}\n\t\n\tif (!this.pointerEvents)\n\t{\n\t\tnode.setAttribute('pointer-events', 'none');\n\t}\n\t\n\tthis.root.appendChild(node);\n};\n\n/**\n * Function: convertHtml\n * \n * Converts the given HTML string to XHTML.\n */\nmxSvgCanvas2D.prototype.convertHtml = function(val)\n{\n\tif (this.useDomParser)\n\t{\n\t\tvar doc = new DOMParser().parseFromString(val, 'text/html');\n\n\t\tif (doc != null)\n\t\t{\n\t\t\tval = new XMLSerializer().serializeToString(doc.body);\n\t\t\t\n\t\t\t// Extracts body content from DOM\n\t\t\tif (val.substring(0, 5) == '<body')\n\t\t\t{\n\t\t\t\tval = val.substring(val.indexOf('>', 5) + 1);\n\t\t\t}\n\t\t\t\n\t\t\tif (val.substring(val.length - 7, val.length) == '</body>')\n\t\t\t{\n\t\t\t\tval = val.substring(0, val.length - 7);\n\t\t\t}\n\t\t}\n\t}\n\telse if (document.implementation != null && document.implementation.createDocument != null)\n\t{\n\t\tvar xd = document.implementation.createDocument('http://www.w3.org/1999/xhtml', 'html', null);\n\t\tvar xb = xd.createElement('body');\n\t\txd.documentElement.appendChild(xb);\n\t\t\n\t\tvar div = document.createElement('div');\n\t\tdiv.innerHTML = val;\n\t\tvar child = div.firstChild;\n\t\t\n\t\twhile (child != null)\n\t\t{\n\t\t\tvar next = child.nextSibling;\n\t\t\txb.appendChild(xd.adoptNode(child));\n\t\t\tchild = next;\n\t\t}\n\t\t\n\t\treturn xb.innerHTML;\n\t}\n\telse\n\t{\n\t\tvar ta = document.createElement('textarea');\n\t\t\n\t\t// Handles special HTML entities < and > and double escaping\n\t\t// and converts unclosed br, hr and img tags to XHTML\n\t\t// LATER: Convert all unclosed tags\n\t\tta.innerHTML = val.replace(/&amp;/g, '&amp;amp;').\n\t\t\treplace(/&#60;/g, '&amp;lt;').replace(/&#62;/g, '&amp;gt;').\n\t\t\treplace(/&lt;/g, '&amp;lt;').replace(/&gt;/g, '&amp;gt;').\n\t\t\treplace(/</g, '&lt;').replace(/>/g, '&gt;');\n\t\tval = ta.value.replace(/&/g, '&amp;').replace(/&amp;lt;/g, '&lt;').\n\t\t\treplace(/&amp;gt;/g, '&gt;').replace(/&amp;amp;/g, '&amp;').\n\t\t\treplace(/<br>/g, '<br />').replace(/<hr>/g, '<hr />').\n\t\t\treplace(/(<img[^>]+)>/gm, \"$1 />\");\n\t}\n\t\n\treturn val;\n};\n\n/**\n * Function: createDiv\n * \n * Private helper function to create SVG elements\n */\nmxSvgCanvas2D.prototype.createDiv = function(str)\n{\n\tvar val = str;\n\t\n\tif (!mxUtils.isNode(val))\n\t{\n\t\tval = '<div><div>' + this.convertHtml(val) + '</div></div>';\n\t}\n\n\t// IE uses this code for export as it cannot render foreignObjects\n\tif (!mxClient.IS_IE && !mxClient.IS_IE11 && document.createElementNS)\n\t{\n\t\tvar div = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');\n\t\t\n\t\tif (mxUtils.isNode(val))\n\t\t{\n\t\t\tvar div2 = document.createElement('div');\n\t\t\tvar div3 = div2.cloneNode(false);\n\t\t\t\n\t\t\t// Creates a copy for export\n\t\t\tif (this.root.ownerDocument != document)\n\t\t\t{\n\t\t\t\tdiv2.appendChild(val.cloneNode(true));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdiv2.appendChild(val);\n\t\t\t}\n\t\t\t\n\t\t\tdiv3.appendChild(div2);\n\t\t\tdiv.appendChild(div3);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdiv.innerHTML = val;\n\t\t}\n\t\t\n\t\treturn div;\n\t}\n\telse\n\t{\n\t\tif (mxUtils.isNode(val))\n\t\t{\n\t\t\tval = '<div><div>' + mxUtils.getXml(val) + '</div></div>';\n\t\t}\n\t\t\n\t\tval = '<div xmlns=\"http://www.w3.org/1999/xhtml\">' + val + '</div>';\n\n\t\t// NOTE: FF 3.6 crashes if content CSS contains \"height:100%\"\n\t\treturn  mxUtils.parseXml(val).documentElement;\n\t}\n};\n\n/**\n * Updates existing DOM nodes for text rendering. LATER: Merge common parts with text function below.\n */\nmxSvgCanvas2D.prototype.updateText = function(x, y, w, h, align, valign, wrap, overflow, clip, rotation, node)\n{\n\tif (node != null && node.firstChild != null && node.firstChild.firstChild != null)\n\t{\n\t\tthis.updateTextNodes(x, y, w, h, align, valign, wrap, overflow, clip, rotation, node.firstChild);\n\t}\n};\n\n/**\n * Function: addForeignObject\n * \n * Creates a foreignObject for the given string and adds it to the given root.\n */\nmxSvgCanvas2D.prototype.addForeignObject = function(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir, div, root)\n{\n\tvar group = this.createElement('g');\n\tvar fo = this.createElement('foreignObject');\n\t\n\t// Workarounds for print clipping and static position in Safari\n\tfo.setAttribute('style', 'overflow: visible; text-align: left;');\n\tfo.setAttribute('pointer-events', 'none');\n\t\n\t// Import needed for older versions of IE\n\tif (div.ownerDocument != document)\n\t{\n\t\tdiv = mxUtils.importNodeImplementation(fo.ownerDocument, div, true);\n\t}\n\n\tfo.appendChild(div);\n\tgroup.appendChild(fo);\n\n\tthis.updateTextNodes(x, y, w, h, align, valign, wrap, overflow, clip, rotation, group);\n\t\n\t// Alternate content if foreignObject not supported\n\tif (this.root.ownerDocument != document)\n\t{\n\t\tvar alt = this.createAlternateContent(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation);\n\t\t\n\t\tif (alt != null)\n\t\t{\n\t\t\tfo.setAttribute('requiredFeatures', 'http://www.w3.org/TR/SVG11/feature#Extensibility');\n\t\t\tvar sw = this.createElement('switch');\n\t\t\tsw.appendChild(fo);\n\t\t\tsw.appendChild(alt);\n\t\t\tgroup.appendChild(sw);\n\t\t}\n\t}\n\t\n\troot.appendChild(group);\n};\n\n/**\n * Updates existing DOM nodes for text rendering.\n */\nmxSvgCanvas2D.prototype.updateTextNodes = function(x, y, w, h, align, valign, wrap, overflow, clip, rotation, g)\n{\n\tvar s = this.state.scale;\n\n\tmxSvgCanvas2D.createCss(w + 2, h, align, valign, wrap, overflow, clip,\n\t\t(this.state.fontBackgroundColor != null) ? this.state.fontBackgroundColor : null,\n\t\t(this.state.fontBorderColor != null) ? this.state.fontBorderColor : null,\n\t\t'display: flex; align-items: unsafe ' +\n\t\t((valign == mxConstants.ALIGN_TOP) ? 'flex-start' :\n\t\t((valign == mxConstants.ALIGN_BOTTOM) ? 'flex-end' : 'center'))  + '; ' +\n\t\t'justify-content: unsafe ' + ((align == mxConstants.ALIGN_LEFT) ? 'flex-start' :\n\t\t((align == mxConstants.ALIGN_RIGHT) ? 'flex-end' : 'center'))  + '; ',\n\t\tthis.getTextCss(), s, mxUtils.bind(this, function(dx, dy, flex, item, block)\n\t{\n\t\tx += this.state.dx;\n\t\ty += this.state.dy;\n\n\t\tvar fo = g.firstChild;\n\t\tvar div = fo.firstChild;\n\t\tvar box = div.firstChild;\n\t\tvar text = box.firstChild;\n\t\tvar r = ((this.rotateHtml) ? this.state.rotation : 0) + ((rotation != null) ? rotation : 0);\n\t\tvar t = ((this.foOffset != 0) ? 'translate(' + this.foOffset + ' ' + this.foOffset + ')' : '') +\n\t\t\t((s != 1) ? 'scale(' + s + ')' : '');\n\t\t\n\t\ttext.setAttribute('style', block);\n\t\tbox.setAttribute('style', item);\n\t\t\n\t\t// Workaround for clipping in Webkit with scrolling and zoom\n\t\tfo.setAttribute('width', Math.ceil(1 / Math.min(1, s) * 100) + '%');\n\t\tfo.setAttribute('height', Math.ceil(1 / Math.min(1, s) * 100) + '%');\n\t\tvar yp = Math.round(y + dy);\n\t\t\n\t\t// Allows for negative values which are causing problems with\n\t\t// transformed content where the top edge of the foreignObject\n\t\t// limits the text box being moved further up in the diagram.\n\t\t// KNOWN: Possible clipping problems with zoom and scrolling\n\t\t// but this is normally not used with scrollbars as the\n\t\t// coordinates are always positive with scrollbars.\n\t\t// Margin-top is ignored in Safari and no negative values allowed\n\t\t// for padding.\n\t\tif (yp < 0)\n\t\t{\n\t\t\tfo.setAttribute('y', yp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfo.removeAttribute('y');\n\t\t\tflex += 'padding-top: ' + yp + 'px; ';\n\t\t}\n\t\t\n\t\tdiv.setAttribute('style', flex + 'margin-left: ' + Math.round(x + dx) + 'px;');\n\t\tt += ((r != 0) ? ('rotate(' + r + ' ' + x + ' ' + y + ')') : '');\n\n\t\t// Output allows for reflow but Safari cannot use absolute position,\n\t\t// transforms or opacity. https://bugs.webkit.org/show_bug.cgi?id=23113\n\t\tif (t != '')\n\t\t{\t\n\t\t\tg.setAttribute('transform', t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tg.removeAttribute('transform');\n\t\t}\n\t\t\n\t\tif (this.state.alpha != 1)\n\t\t{\n\t\t\tg.setAttribute('opacity', this.state.alpha);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tg.removeAttribute('opacity');\n\t\t}\n\t}));\n};\n\n/**\n * Updates existing DOM nodes for text rendering.\n */\nmxSvgCanvas2D.createCss = function(w, h, align, valign, wrap, overflow, clip, bg, border, flex, block, s, callback)\n{\n\tvar item = 'box-sizing: border-box; font-size: 0; text-align: ' + ((align == mxConstants.ALIGN_LEFT) ? 'left' :\n\t\t((align == mxConstants.ALIGN_RIGHT) ? 'right' : 'center')) + '; ';\n\tvar pt = mxUtils.getAlignmentAsPoint(align, valign);\n\tvar ofl = 'overflow: hidden; ';\n\tvar fw = 'width: 1px; ';\n\tvar fh = 'height: 1px; ';\n\tvar dx = pt.x * w;\n\tvar dy = pt.y * h;\n\t\n\tif (clip)\n\t{\n\t\tfw = 'width: ' + Math.round(w) + 'px; ';\n\t\titem += 'max-height: ' + Math.round(h) + 'px; ';\n\t\tdy = 0;\n\t}\n\telse if (overflow == 'fill')\n\t{\n\t\tfw = 'width: ' + Math.round(w) + 'px; ';\n\t\tfh = 'height: ' + Math.round(h) + 'px; ';\n\t\tblock += 'width: 100%; height: 100%; ';\n\t\titem += fw + fh;\n\t}\n\telse if (overflow == 'width')\n\t{\n\t\tfw = 'width: ' + Math.round(w) + 'px; ';\n\t\tblock += 'width: 100%; ';\n\t\titem += fw;\n\t\tdy = 0;\n\t\t\n\t\tif (h > 0)\n\t\t{\n\t\t\titem += 'max-height: ' + Math.round(h) + 'px; ';\n\t\t}\n\t}\n\telse\n\t{\n\t\tofl = '';\n\t\tdy = 0;\n\t}\n\t\n\tvar bgc = '';\n\t\n\tif (bg != null)\n\t{\n\t\tbgc += 'background-color: ' + bg + '; ';\n\t}\n\t\n\tif (border != null)\n\t{\n\t\tbgc += 'border: 1px solid ' + border + '; ';\n\t}\n\t\n\tif (ofl == '' || clip)\n\t{\n\t\tblock += bgc;\n\t}\n\telse\n\t{\n\t\titem += bgc;\n\t}\n\n\tif (wrap && w > 0)\n\t{\n\t\tblock += 'white-space: normal; word-wrap: ' + mxConstants.WORD_WRAP + '; ';\n\t\tfw = 'width: ' + Math.round(w) + 'px; ';\n\t\t\n\t\tif (ofl != '' && overflow != 'fill')\n\t\t{\n\t\t\tdy = 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\tblock += 'white-space: nowrap; ';\n\t\t\n\t\tif (ofl == '')\n\t\t{\n\t\t\tdx = 0;\n\t\t}\n\t}\n\t\n\tcallback(dx, dy, flex + fw + fh, item + ofl, block, ofl);\n};\n\n/**\n * Function: getTextCss\n * \n * Private helper function to create SVG elements\n */\nmxSvgCanvas2D.prototype.getTextCss = function()\n{\n\tvar s = this.state;\n\tvar lh = (mxConstants.ABSOLUTE_LINE_HEIGHT) ? (s.fontSize * mxConstants.LINE_HEIGHT) + 'px' :\n\t\t(mxConstants.LINE_HEIGHT * this.lineHeightCorrection);\n\tvar css = 'display: inline-block; font-size: ' + s.fontSize + 'px; ' +\n\t\t'font-family: ' + s.fontFamily + '; color: ' + s.fontColor + '; line-height: ' + lh +\n\t\t'; pointer-events: ' + ((this.pointerEvents) ? this.pointerEventsValue : 'none') + '; ';\n\t\n\tif ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD)\n\t{\n\t\tcss += 'font-weight: bold; ';\n\t}\n\n\tif ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC)\n\t{\n\t\tcss += 'font-style: italic; ';\n\t}\n\n\tvar deco = [];\n\t\n\tif ((s.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE)\n\t{\n\t\tdeco.push('underline');\n\t}\n\t\n\tif ((s.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH)\n\t{\n\t\tdeco.push('line-through');\n\t}\n\t\n\tif (deco.length > 0)\n\t{\n\t\tcss += 'text-decoration: ' + deco.join(' ') + '; ';\n\t}\n\n\treturn css;\n};\n\n/**\n * Function: text\n * \n * Paints the given text. Possible values for format are empty string for plain\n * text and html for HTML markup. Note that HTML markup is only supported if\n * foreignObject is supported and <foEnabled> is true. (This means IE9 and later\n * does currently not support HTML text as part of shapes.)\n */\nmxSvgCanvas2D.prototype.text = function(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir)\n{\n\tif (this.textEnabled && str != null)\n\t{\n\t\trotation = (rotation != null) ? rotation : 0;\n\n\t\tif (this.foEnabled && format == 'html')\n\t\t{\n\t\t\tvar div = this.createDiv(str);\n\t\t\t\n\t\t\t// Ignores invalid XHTML labels\n\t\t\tif (div != null)\n\t\t\t{\n\t\t\t\tif (dir != null)\n\t\t\t\t{\n\t\t\t\t\tdiv.setAttribute('dir', dir);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.addForeignObject(x, y, w, h, str, align, valign, wrap,\n\t\t\t\t\tformat, overflow, clip, rotation, dir, div, this.root);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.plainText(x + this.state.dx, y + this.state.dy, w, h, str,\n\t\t\t\talign, valign, wrap, overflow, clip, rotation, dir);\n\t\t}\n\t}\n};\n\n/**\n * Function: createClip\n * \n * Creates a clip for the given coordinates.\n */\nmxSvgCanvas2D.prototype.createClip = function(x, y, w, h)\n{\n\tx = Math.round(x);\n\ty = Math.round(y);\n\tw = Math.round(w);\n\th = Math.round(h);\n\t\n\tvar id = 'mx-clip-' + x + '-' + y + '-' + w + '-' + h;\n\n\tvar counter = 0;\n\tvar tmp = id + '-' + counter;\n\t\n\t// Resolves ID conflicts\n\twhile (document.getElementById(tmp) != null)\n\t{\n\t\ttmp = id + '-' + (++counter);\n\t}\n\t\n\tclip = this.createElement('clipPath');\n\tclip.setAttribute('id', tmp);\n\t\n\tvar rect = this.createElement('rect');\n\trect.setAttribute('x', x);\n\trect.setAttribute('y', y);\n\trect.setAttribute('width', w);\n\trect.setAttribute('height', h);\n\t\t\n\tclip.appendChild(rect);\n\t\n\treturn clip;\n};\n\n/**\n * Function: plainText\n * \n * Paints the given text. Possible values for format are empty string for\n * plain text and html for HTML markup.\n */\nmxSvgCanvas2D.prototype.plainText = function(x, y, w, h, str, align, valign, wrap, overflow, clip, rotation, dir)\n{\n\trotation = (rotation != null) ? rotation : 0;\n\tvar s = this.state;\n\tvar size = s.fontSize;\n\tvar node = this.createElement('g');\n\tvar tr = s.transform || '';\n\tthis.updateFont(node);\n\t\t\t\t\n\t// Ignores pointer events\n\tif (!this.pointerEvents && this.originalRoot == null)\n\t{\n\t\tnode.setAttribute('pointer-events', 'none');\n\t}\n\t\t\n\t// Non-rotated text\n\tif (rotation != 0)\n\t{\n\t\ttr += 'rotate(' + rotation  + ',' + this.format(x * s.scale) + ',' + this.format(y * s.scale) + ')';\n\t}\n\t\n\tif (dir != null)\n\t{\n\t\tnode.setAttribute('direction', dir);\n\t}\n\n\tif (clip && w > 0 && h > 0)\n\t{\n\t\tvar cx = x;\n\t\tvar cy = y;\n\t\t\n\t\tif (align == mxConstants.ALIGN_CENTER)\n\t\t{\n\t\t\tcx -= w / 2;\n\t\t}\n\t\telse if (align == mxConstants.ALIGN_RIGHT)\n\t\t{\n\t\t\tcx -= w;\n\t\t}\n\t\t\n\t\tif (overflow != 'fill')\n\t\t{\n\t\t\tif (valign == mxConstants.ALIGN_MIDDLE)\n\t\t\t{\n\t\t\t\tcy -= h / 2;\n\t\t\t}\n\t\t\telse if (valign == mxConstants.ALIGN_BOTTOM)\n\t\t\t{\n\t\t\t\tcy -= h;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// LATER: Remove spacing from clip rectangle\n\t\tvar c = this.createClip(cx * s.scale - 2, cy * s.scale - 2, w * s.scale + 4, h * s.scale + 4);\n\t\t\n\t\tif (this.defs != null)\n\t\t{\n\t\t\tthis.defs.appendChild(c);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Makes sure clip is removed with referencing node\n\t\t\tthis.root.appendChild(c);\n\t\t}\n\t\t\n\t\tif (!mxClient.IS_CHROMEAPP && !mxClient.IS_IE && !mxClient.IS_IE11 &&\n\t\t\t!mxClient.IS_EDGE && this.root.ownerDocument == document)\n\t\t{\n\t\t\t// Workaround for potential base tag\n\t\t\tvar base = this.getBaseUrl().replace(/([\\(\\)])/g, '\\\\$1');\n\t\t\tnode.setAttribute('clip-path', 'url(' + base + '#' + c.getAttribute('id') + ')');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnode.setAttribute('clip-path', 'url(#' + c.getAttribute('id') + ')');\n\t\t}\n\t}\n\n\t// Default is left\n\tvar anchor = (align == mxConstants.ALIGN_RIGHT) ? 'end' :\n\t\t\t\t\t(align == mxConstants.ALIGN_CENTER) ? 'middle' :\n\t\t\t\t\t'start';\n\n\t// Text-anchor start is default in SVG\n\tif (anchor != 'start')\n\t{\n\t\tnode.setAttribute('text-anchor', anchor);\n\t}\n\t\n\tif (!this.styleEnabled || size != mxConstants.DEFAULT_FONTSIZE)\n\t{\n\t\tnode.setAttribute('font-size', (size * s.scale) + 'px');\n\t}\n\t\n\tif (tr.length > 0)\n\t{\n\t\tnode.setAttribute('transform', tr);\n\t}\n\t\n\tif (s.alpha < 1)\n\t{\n\t\tnode.setAttribute('opacity', s.alpha);\n\t}\n\t\n\tvar lines = str.split('\\n');\n\tvar lh = Math.round(size * mxConstants.LINE_HEIGHT);\n\tvar textHeight = size + (lines.length - 1) * lh;\n\n\tvar cy = y + size - 1;\n\n\tif (valign == mxConstants.ALIGN_MIDDLE)\n\t{\n\t\tif (overflow == 'fill')\n\t\t{\n\t\t\tcy -= h / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar dy = ((this.matchHtmlAlignment && clip && h > 0) ? Math.min(textHeight, h) : textHeight) / 2;\n\t\t\tcy -= dy;\n\t\t}\n\t}\n\telse if (valign == mxConstants.ALIGN_BOTTOM)\n\t{\n\t\tif (overflow == 'fill')\n\t\t{\n\t\t\tcy -= h;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar dy = (this.matchHtmlAlignment && clip && h > 0) ? Math.min(textHeight, h) : textHeight;\n\t\t\tcy -= dy + 1;\n\t\t}\n\t}\n\n\tfor (var i = 0; i < lines.length; i++)\n\t{\n\t\t// Workaround for bounding box of empty lines and spaces\n\t\tif (lines[i].length > 0 && mxUtils.trim(lines[i]).length > 0)\n\t\t{\n\t\t\tvar text = this.createElement('text');\n\t\t\t// LATER: Match horizontal HTML alignment\n\t\t\ttext.setAttribute('x', this.format(x * s.scale) + this.textOffset);\n\t\t\ttext.setAttribute('y', this.format(cy * s.scale) + this.textOffset);\n\t\n\t\t\tmxUtils.write(text, lines[i]);\n\t\t\tnode.appendChild(text);\n\t\t}\n\n\t\tcy += lh;\n\t}\n\n\tthis.root.appendChild(node);\n\tthis.addTextBackground(node, str, x, y, w, (overflow == 'fill') ? h : textHeight, align, valign, overflow);\n};\n\n/**\n * Function: updateFont\n * \n * Updates the text properties for the given node. (NOTE: For this to work in\n * IE, the given node must be a text or tspan element.)\n */\nmxSvgCanvas2D.prototype.updateFont = function(node)\n{\n\tvar s = this.state;\n\n\tnode.setAttribute('fill', s.fontColor);\n\t\n\tif (!this.styleEnabled || s.fontFamily != mxConstants.DEFAULT_FONTFAMILY)\n\t{\n\t\tnode.setAttribute('font-family', s.fontFamily);\n\t}\n\n\tif ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD)\n\t{\n\t\tnode.setAttribute('font-weight', 'bold');\n\t}\n\n\tif ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC)\n\t{\n\t\tnode.setAttribute('font-style', 'italic');\n\t}\n\t\n\tvar txtDecor = [];\n\t\n\tif ((s.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE)\n\t{\n\t\ttxtDecor.push('underline');\n\t}\n\t\n\tif ((s.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH)\n\t{\n\t\ttxtDecor.push('line-through');\n\t}\n\t\n\tif (txtDecor.length > 0)\n\t{\n\t\tnode.setAttribute('text-decoration', txtDecor.join(' '));\n\t}\n};\n\n/**\n * Function: addTextBackground\n * \n * Background color and border\n */\nmxSvgCanvas2D.prototype.addTextBackground = function(node, str, x, y, w, h, align, valign, overflow)\n{\n\tvar s = this.state;\n\n\tif (s.fontBackgroundColor != null || s.fontBorderColor != null)\n\t{\n\t\tvar bbox = null;\n\t\t\n\t\tif (overflow == 'fill' || overflow == 'width')\n\t\t{\n\t\t\tif (align == mxConstants.ALIGN_CENTER)\n\t\t\t{\n\t\t\t\tx -= w / 2;\n\t\t\t}\n\t\t\telse if (align == mxConstants.ALIGN_RIGHT)\n\t\t\t{\n\t\t\t\tx -= w;\n\t\t\t}\n\t\t\t\n\t\t\tif (valign == mxConstants.ALIGN_MIDDLE)\n\t\t\t{\n\t\t\t\ty -= h / 2;\n\t\t\t}\n\t\t\telse if (valign == mxConstants.ALIGN_BOTTOM)\n\t\t\t{\n\t\t\t\ty -= h;\n\t\t\t}\n\t\t\t\n\t\t\tbbox = new mxRectangle((x + 1) * s.scale, y * s.scale, (w - 2) * s.scale, (h + 2) * s.scale);\n\t\t}\n\t\telse if (node.getBBox != null && this.root.ownerDocument == document)\n\t\t{\n\t\t\t// Uses getBBox only if inside document for correct size\n\t\t\ttry\n\t\t\t{\n\t\t\t\tbbox = node.getBBox();\n\t\t\t\tvar ie = mxClient.IS_IE && mxClient.IS_SVG;\n\t\t\t\tbbox = new mxRectangle(bbox.x, bbox.y + ((ie) ? 0 : 1), bbox.width, bbox.height + ((ie) ? 1 : 0));\n\t\t\t}\n\t\t\tcatch (e)\n\t\t\t{\n\t\t\t\t// Ignores NS_ERROR_FAILURE in FF if container display is none.\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (bbox == null || bbox.width == 0 || bbox.height == 0)\n\t\t{\n\t\t\t// Computes size if not in document or no getBBox available\n\t\t\tvar div = document.createElement('div');\n\n\t\t\t// Wrapping and clipping can be ignored here\n\t\t\tdiv.style.lineHeight = (mxConstants.ABSOLUTE_LINE_HEIGHT) ? (s.fontSize * mxConstants.LINE_HEIGHT) + 'px' : mxConstants.LINE_HEIGHT;\n\t\t\tdiv.style.fontSize = s.fontSize + 'px';\n\t\t\tdiv.style.fontFamily = s.fontFamily;\n\t\t\tdiv.style.whiteSpace = 'nowrap';\n\t\t\tdiv.style.position = 'absolute';\n\t\t\tdiv.style.visibility = 'hidden';\n\t\t\tdiv.style.display = (mxClient.IS_QUIRKS) ? 'inline' : 'inline-block';\n\t\t\tdiv.style.zoom = '1';\n\t\t\t\n\t\t\tif ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD)\n\t\t\t{\n\t\t\t\tdiv.style.fontWeight = 'bold';\n\t\t\t}\n\n\t\t\tif ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC)\n\t\t\t{\n\t\t\t\tdiv.style.fontStyle = 'italic';\n\t\t\t}\n\t\t\t\n\t\t\tstr = mxUtils.htmlEntities(str, false);\n\t\t\tdiv.innerHTML = str.replace(/\\n/g, '<br/>');\n\t\t\t\n\t\t\tdocument.body.appendChild(div);\n\t\t\tvar w = div.offsetWidth;\n\t\t\tvar h = div.offsetHeight;\n\t\t\tdiv.parentNode.removeChild(div);\n\t\t\t\n\t\t\tif (align == mxConstants.ALIGN_CENTER)\n\t\t\t{\n\t\t\t\tx -= w / 2;\n\t\t\t}\n\t\t\telse if (align == mxConstants.ALIGN_RIGHT)\n\t\t\t{\n\t\t\t\tx -= w;\n\t\t\t}\n\t\t\t\n\t\t\tif (valign == mxConstants.ALIGN_MIDDLE)\n\t\t\t{\n\t\t\t\ty -= h / 2;\n\t\t\t}\n\t\t\telse if (valign == mxConstants.ALIGN_BOTTOM)\n\t\t\t{\n\t\t\t\ty -= h;\n\t\t\t}\n\t\t\t\n\t\t\tbbox = new mxRectangle((x + 1) * s.scale, (y + 2) * s.scale, w * s.scale, (h + 1) * s.scale);\n\t\t}\n\t\t\n\t\tif (bbox != null)\n\t\t{\n\t\t\tvar n = this.createElement('rect');\n\t\t\tn.setAttribute('fill', s.fontBackgroundColor || 'none');\n\t\t\tn.setAttribute('stroke', s.fontBorderColor || 'none');\n\t\t\tn.setAttribute('x', Math.floor(bbox.x - 1));\n\t\t\tn.setAttribute('y', Math.floor(bbox.y - 1));\n\t\t\tn.setAttribute('width', Math.ceil(bbox.width + 2));\n\t\t\tn.setAttribute('height', Math.ceil(bbox.height));\n\n\t\t\tvar sw = (s.fontBorderColor != null) ? Math.max(1, this.format(s.scale)) : 0;\n\t\t\tn.setAttribute('stroke-width', sw);\n\t\t\t\n\t\t\t// Workaround for crisp rendering - only required if not exporting\n\t\t\tif (this.root.ownerDocument == document && mxUtils.mod(sw, 2) == 1)\n\t\t\t{\n\t\t\t\tn.setAttribute('transform', 'translate(0.5, 0.5)');\n\t\t\t}\n\t\t\t\n\t\t\tnode.insertBefore(n, node.firstChild);\n\t\t}\n\t}\n};\n\n/**\n * Function: stroke\n * \n * Paints the outline of the current path.\n */\nmxSvgCanvas2D.prototype.stroke = function()\n{\n\tthis.addNode(false, true);\n};\n\n/**\n * Function: fill\n * \n * Fills the current path.\n */\nmxSvgCanvas2D.prototype.fill = function()\n{\n\tthis.addNode(true, false);\n};\n\n/**\n * Function: fillAndStroke\n * \n * Fills and paints the outline of the current path.\n */\nmxSvgCanvas2D.prototype.fillAndStroke = function()\n{\n\tthis.addNode(true, true);\n};\n\n__mxOutput.mxSvgCanvas2D = typeof mxSvgCanvas2D !== 'undefined' ? mxSvgCanvas2D : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n *\n * Class: mxVmlCanvas2D\n * \n * Implements a canvas to be used for rendering VML. Here is an example of implementing a\n * fallback for SVG images which are not supported in VML-based browsers.\n * \n * (code)\n * var mxVmlCanvas2DImage = mxVmlCanvas2D.prototype.image;\n * mxVmlCanvas2D.prototype.image = function(x, y, w, h, src, aspect, flipH, flipV)\n * {\n *   if (src.substring(src.length - 4, src.length) == '.svg')\n *   {\n *     src = 'http://www.jgraph.com/images/mxgraph.gif';\n *   }\n *   \n *   mxVmlCanvas2DImage.apply(this, arguments);\n * };\n * (end)\n * \n * To disable anti-aliasing in the output, use the following code.\n * \n * (code)\n * document.createStyleSheet().cssText = mxClient.VML_PREFIX + '\\\\:*{antialias:false;)}';\n * (end)\n * \n * A description of the public API is available in <mxXmlCanvas2D>. Note that\n * there is a known issue in VML where gradients are painted using the outer\n * bounding box of rotated shapes, not the actual bounds of the shape. See\n * also <text> for plain text label restrictions in shapes for VML.\n */\nvar mxVmlCanvas2D = function(root)\n{\n\tmxAbstractCanvas2D.call(this);\n\n\t/**\n\t * Variable: root\n\t * \n\t * Reference to the container for the SVG content.\n\t */\n\tthis.root = root;\n};\n\n/**\n * Extends mxAbstractCanvas2D\n */\nmxUtils.extend(mxVmlCanvas2D, mxAbstractCanvas2D);\n\n/**\n * Variable: path\n * \n * Holds the current DOM node.\n */\nmxVmlCanvas2D.prototype.node = null;\n\n/**\n * Variable: textEnabled\n * \n * Specifies if text output should be enabledetB. Default is true.\n */\nmxVmlCanvas2D.prototype.textEnabled = true;\n\n/**\n * Variable: moveOp\n * \n * Contains the string used for moving in paths. Default is 'm'.\n */\nmxVmlCanvas2D.prototype.moveOp = 'm';\n\n/**\n * Variable: lineOp\n * \n * Contains the string used for moving in paths. Default is 'l'.\n */\nmxVmlCanvas2D.prototype.lineOp = 'l';\n\n/**\n * Variable: curveOp\n * \n * Contains the string used for bezier curves. Default is 'c'.\n */\nmxVmlCanvas2D.prototype.curveOp = 'c';\n\n/**\n * Variable: closeOp\n * \n * Holds the operator for closing curves. Default is 'x e'.\n */\nmxVmlCanvas2D.prototype.closeOp = 'x';\n\n/**\n * Variable: rotatedHtmlBackground\n * \n * Background color for rotated HTML. Default is ''. This can be set to eg.\n * white to improve rendering of rotated text in VML for IE9.\n */\nmxVmlCanvas2D.prototype.rotatedHtmlBackground = '';\n\n/**\n * Variable: vmlScale\n * \n * Specifies the scale used to draw VML shapes.\n */\nmxVmlCanvas2D.prototype.vmlScale = 1;\n\n/**\n * Function: createElement\n * \n * Creates the given element using the document.\n */\nmxVmlCanvas2D.prototype.createElement = function(name)\n{\n\treturn document.createElement(name);\n};\n\n/**\n * Function: createVmlElement\n * \n * Creates a new element using <createElement> and prefixes the given name with\n * <mxClient.VML_PREFIX>.\n */\nmxVmlCanvas2D.prototype.createVmlElement = function(name)\n{\n\treturn this.createElement(mxClient.VML_PREFIX + ':' + name);\n};\n\n/**\n * Function: addNode\n * \n * Adds the current node to the <root>.\n */\nmxVmlCanvas2D.prototype.addNode = function(filled, stroked)\n{\n\tvar node = this.node;\n\tvar s = this.state;\n\t\n\tif (node != null)\n\t{\n\t\tif (node.nodeName == 'shape')\n\t\t{\n\t\t\t// Checks if the path is not empty\n\t\t\tif (this.path != null && this.path.length > 0)\n\t\t\t{\n\t\t\t\tnode.path = this.path.join(' ') + ' e';\n\t\t\t\tnode.style.width = this.root.style.width;\n\t\t\t\tnode.style.height = this.root.style.height;\n\t\t\t\tnode.coordsize = parseInt(node.style.width) + ' ' + parseInt(node.style.height);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tnode.strokeweight = this.format(Math.max(1, s.strokeWidth * s.scale / this.vmlScale)) + 'px';\n\t\t\n\t\tif (s.shadow)\n\t\t{\n\t\t\tthis.root.appendChild(this.createShadow(node,\n\t\t\t\tfilled && s.fillColor != null,\n\t\t\t\tstroked && s.strokeColor != null));\n\t\t}\n\t\t\n\t\tif (stroked && s.strokeColor != null)\n\t\t{\n\t\t\tnode.stroked = 'true';\n\t\t\tnode.strokecolor = s.strokeColor;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnode.stroked = 'false';\n\t\t}\n\n\t\tnode.appendChild(this.createStroke());\n\n\t\tif (filled && s.fillColor != null)\n\t\t{\n\t\t\tnode.appendChild(this.createFill());\n\t\t}\n\t\telse if (this.pointerEvents && (node.nodeName != 'shape' ||\n\t\t\tthis.path[this.path.length - 1] == this.closeOp))\n\t\t{\n\t\t\tnode.appendChild(this.createTransparentFill());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnode.filled = 'false';\n\t\t}\n\n\t\t// LATER: Update existing DOM for performance\n\t\tthis.root.appendChild(node);\n\t}\n};\n\n/**\n * Function: createTransparentFill\n * \n * Creates a transparent fill.\n */\nmxVmlCanvas2D.prototype.createTransparentFill = function()\n{\n\tvar fill = this.createVmlElement('fill');\n\tfill.src = mxClient.imageBasePath + '/transparent.gif';\n\tfill.type = 'tile';\n\t\n\treturn fill;\n};\n\n/**\n * Function: createFill\n * \n * Creates a fill for the current state.\n */\nmxVmlCanvas2D.prototype.createFill = function()\n{\n\tvar s = this.state;\n\t\n\t// Gradients in foregrounds not supported because special gradients\n\t// with bounds must be created for each element in graphics-canvases\n\tvar fill = this.createVmlElement('fill');\n\tfill.color = s.fillColor;\n\n\tif (s.gradientColor != null)\n\t{\n\t\tfill.type = 'gradient';\n\t\tfill.method = 'none';\n\t\tfill.color2 = s.gradientColor;\n\t\tvar angle = 180 - s.rotation;\n\t\t\n\t\tif (s.gradientDirection == mxConstants.DIRECTION_WEST)\n\t\t{\n\t\t\tangle -= 90 + ((this.root.style.flip == 'x') ? 180 : 0);\n\t\t}\n\t\telse if (s.gradientDirection == mxConstants.DIRECTION_EAST)\n\t\t{\n\t\t\tangle += 90 + ((this.root.style.flip == 'x') ? 180 : 0);\n\t\t}\n\t\telse if (s.gradientDirection == mxConstants.DIRECTION_NORTH)\n\t\t{\n\t\t\tangle -= 180 + ((this.root.style.flip == 'y') ? -180 : 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t angle += ((this.root.style.flip == 'y') ? -180 : 0);\n\t\t}\n\t\t\n\t\tif (this.root.style.flip == 'x' || this.root.style.flip == 'y')\n\t\t{\n\t\t\tangle *= -1;\n\t\t}\n\n\t\t// LATER: Fix outer bounding box for rotated shapes used in VML.\n\t\tfill.angle = mxUtils.mod(angle, 360);\n\t\tfill.opacity = (s.alpha * s.gradientFillAlpha * 100) + '%';\n\t\tfill.setAttribute(mxClient.OFFICE_PREFIX + ':opacity2', (s.alpha * s.gradientAlpha * 100) + '%');\n\t}\n\telse if (s.alpha < 1 || s.fillAlpha < 1)\n\t{\n\t\tfill.opacity = (s.alpha * s.fillAlpha * 100) + '%';\t\t\t\n\t}\n\t\n\treturn fill;\n};\n/**\n * Function: createStroke\n * \n * Creates a fill for the current state.\n */\nmxVmlCanvas2D.prototype.createStroke = function()\n{\n\tvar s = this.state;\n\tvar stroke = this.createVmlElement('stroke');\n\tstroke.endcap = s.lineCap || 'flat';\n\tstroke.joinstyle = s.lineJoin || 'miter';\n\tstroke.miterlimit = s.miterLimit || '10';\n\t\n\tif (s.alpha < 1 || s.strokeAlpha < 1)\n\t{\n\t\tstroke.opacity = (s.alpha * s.strokeAlpha * 100) + '%';\n\t}\n\t\n\tif (s.dashed)\n\t{\n\t\tstroke.dashstyle = this.getVmlDashStyle();\n\t}\n\t\n\treturn stroke;\n};\n\n/**\n * Function: getVmlDashPattern\n * \n * Returns a VML dash pattern for the current dashPattern.\n * See http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx\n */\nmxVmlCanvas2D.prototype.getVmlDashStyle = function()\n{\n\tvar result = 'dash';\n\t\n\tif (typeof(this.state.dashPattern) === 'string')\n\t{\n\t\tvar tok = this.state.dashPattern.split(' ');\n\t\t\n\t\tif (tok.length > 0 && tok[0] == 1)\n\t\t{\n\t\t\tresult = '0 2';\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: createShadow\n * \n * Creates a shadow for the given node.\n */\nmxVmlCanvas2D.prototype.createShadow = function(node, filled, stroked)\n{\n\tvar s = this.state;\n\tvar rad = -s.rotation * (Math.PI / 180);\n\tvar cos = Math.cos(rad);\n\tvar sin = Math.sin(rad);\n\n\tvar dx = s.shadowDx * s.scale;\n\tvar dy = s.shadowDy * s.scale;\n\n\tif (this.root.style.flip == 'x')\n\t{\n\t\tdx *= -1;\n\t}\n\telse if (this.root.style.flip == 'y')\n\t{\n\t\tdy *= -1;\n\t}\n\t\n\tvar shadow = node.cloneNode(true);\n\tshadow.style.marginLeft = Math.round(dx * cos - dy * sin) + 'px';\n\tshadow.style.marginTop = Math.round(dx * sin + dy * cos) + 'px';\n\n\t// Workaround for wrong cloning in IE8 standards mode\n\tif (document.documentMode == 8)\n\t{\n\t\tshadow.strokeweight = node.strokeweight;\n\t\t\n\t\tif (node.nodeName == 'shape')\n\t\t{\n\t\t\tshadow.path = this.path.join(' ') + ' e';\n\t\t\tshadow.style.width = this.root.style.width;\n\t\t\tshadow.style.height = this.root.style.height;\n\t\t\tshadow.coordsize = parseInt(node.style.width) + ' ' + parseInt(node.style.height);\n\t\t}\n\t}\n\t\n\tif (stroked)\n\t{\n\t\tshadow.strokecolor = s.shadowColor;\n\t\tshadow.appendChild(this.createShadowStroke());\n\t}\n\telse\n\t{\n\t\tshadow.stroked = 'false';\n\t}\n\t\n\tif (filled)\n\t{\n\t\tshadow.appendChild(this.createShadowFill());\n\t}\n\telse\n\t{\n\t\tshadow.filled = 'false';\n\t}\n\t\n\treturn shadow;\n};\n\n/**\n * Function: createShadowFill\n * \n * Creates the fill for the shadow.\n */\nmxVmlCanvas2D.prototype.createShadowFill = function()\n{\n\tvar fill = this.createVmlElement('fill');\n\tfill.color = this.state.shadowColor;\n\tfill.opacity = (this.state.alpha * this.state.shadowAlpha * 100) + '%';\n\t\n\treturn fill;\n};\n\n/**\n * Function: createShadowStroke\n * \n * Creates the stroke for the shadow.\n */\nmxVmlCanvas2D.prototype.createShadowStroke = function()\n{\n\tvar stroke = this.createStroke();\n\tstroke.opacity = (this.state.alpha * this.state.shadowAlpha * 100) + '%';\n\t\n\treturn stroke;\n};\n\n/**\n * Function: rotate\n * \n * Sets the rotation of the canvas. Note that rotation cannot be concatenated.\n */\nmxVmlCanvas2D.prototype.rotate = function(theta, flipH, flipV, cx, cy)\n{\n\tif (flipH && flipV)\n\t{\n\t\ttheta += 180;\n\t}\n\telse if (flipH)\n\t{\n\t\tthis.root.style.flip = 'x';\n\t}\n\telse if (flipV)\n\t{\n\t\tthis.root.style.flip = 'y';\n\t}\n\n\tif (flipH ? !flipV : flipV)\n\t{\n\t\ttheta *= -1;\n\t}\n\n\tthis.root.style.rotation = theta;\n\tthis.state.rotation = this.state.rotation + theta;\n\tthis.state.rotationCx = cx;\n\tthis.state.rotationCy = cy;\n};\n\n/**\n * Function: begin\n * \n * Extends superclass to create path.\n */\nmxVmlCanvas2D.prototype.begin = function()\n{\n\tmxAbstractCanvas2D.prototype.begin.apply(this, arguments);\n\tthis.node = this.createVmlElement('shape');\n\tthis.node.style.position = 'absolute';\n};\n\n/**\n * Function: quadTo\n * \n * Replaces quadratic curve with bezier curve in VML.\n */\nmxVmlCanvas2D.prototype.quadTo = function(x1, y1, x2, y2)\n{\n\tvar s = this.state;\n\n\tvar cpx0 = (this.lastX + s.dx) * s.scale;\n\tvar cpy0 = (this.lastY + s.dy) * s.scale;\n\tvar qpx1 = (x1 + s.dx) * s.scale;\n\tvar qpy1 = (y1 + s.dy) * s.scale;\n\tvar cpx3 = (x2 + s.dx) * s.scale;\n\tvar cpy3 = (y2 + s.dy) * s.scale;\n\t\n\tvar cpx1 = cpx0 + 2/3 * (qpx1 - cpx0);\n\tvar cpy1 = cpy0 + 2/3 * (qpy1 - cpy0);\n\t\n\tvar cpx2 = cpx3 + 2/3 * (qpx1 - cpx3);\n\tvar cpy2 = cpy3 + 2/3 * (qpy1 - cpy3);\n\t\n\tthis.path.push('c ' + this.format(cpx1) + ' ' + this.format(cpy1) +\n\t\t\t' ' + this.format(cpx2) + ' ' + this.format(cpy2) +\n\t\t\t' ' + this.format(cpx3) + ' ' + this.format(cpy3));\n\tthis.lastX = (cpx3 / s.scale) - s.dx;\n\tthis.lastY = (cpy3 / s.scale) - s.dy;\n\t\n};\n\n/**\n * Function: createRect\n * \n * Sets the glass gradient.\n */\nmxVmlCanvas2D.prototype.createRect = function(nodeName, x, y, w, h)\n{\n\tvar s = this.state;\n\tvar n = this.createVmlElement(nodeName);\n\tn.style.position = 'absolute';\n\tn.style.left = this.format((x + s.dx) * s.scale) + 'px';\n\tn.style.top = this.format((y + s.dy) * s.scale) + 'px';\n\tn.style.width = this.format(w * s.scale) + 'px';\n\tn.style.height = this.format(h * s.scale) + 'px';\n\t\n\treturn n;\n};\n\n/**\n * Function: rect\n * \n * Sets the current path to a rectangle.\n */\nmxVmlCanvas2D.prototype.rect = function(x, y, w, h)\n{\n\tthis.node = this.createRect('rect', x, y, w, h);\n};\n\n/**\n * Function: roundrect\n * \n * Sets the current path to a rounded rectangle.\n */\nmxVmlCanvas2D.prototype.roundrect = function(x, y, w, h, dx, dy)\n{\n\tthis.node = this.createRect('roundrect', x, y, w, h);\n\t// SetAttribute needed here for IE8\n\tthis.node.setAttribute('arcsize', Math.max(dx * 100 / w, dy * 100 / h) + '%');\n};\n\n/**\n * Function: ellipse\n * \n * Sets the current path to an ellipse.\n */\nmxVmlCanvas2D.prototype.ellipse = function(x, y, w, h)\n{\n\tthis.node = this.createRect('oval', x, y, w, h);\n};\n\n/**\n * Function: image\n * \n * Paints an image.\n */\nmxVmlCanvas2D.prototype.image = function(x, y, w, h, src, aspect, flipH, flipV)\n{\n\tvar node = null;\n\t\n\tif (!aspect)\n\t{\n\t\tnode = this.createRect('image', x, y, w, h);\n\t\tnode.src = src;\n\t}\n\telse\n\t{\n\t\t// Uses fill with aspect to avoid asynchronous update of size\n\t\tnode = this.createRect('rect', x, y, w, h);\n\t\tnode.stroked = 'false';\n\t\t\n\t\t// Handles image aspect via fill\n\t\tvar fill = this.createVmlElement('fill');\n\t\tfill.aspect = (aspect) ? 'atmost' : 'ignore';\n\t\tfill.rotate = 'true';\n\t\tfill.type = 'frame';\n\t\tfill.src = src;\n\n\t\tnode.appendChild(fill);\n\t}\n\t\n\tif (flipH && flipV)\n\t{\n\t\tnode.style.rotation = '180';\n\t}\n\telse if (flipH)\n\t{\n\t\tnode.style.flip = 'x';\n\t}\n\telse if (flipV)\n\t{\n\t\tnode.style.flip = 'y';\n\t}\n\t\n\tif (this.state.alpha < 1 || this.state.fillAlpha < 1)\n\t{\n\t\t// KNOWN: Borders around transparent images in IE<9. Using fill.opacity\n\t\t// fixes this problem by adding a white background in all IE versions.\n\t\tnode.style.filter += 'alpha(opacity=' + (this.state.alpha * this.state.fillAlpha * 100) + ')';\n\t}\n\n\tthis.root.appendChild(node);\n};\n\n/**\n * Function: createText\n * \n * Creates the innermost element that contains the HTML text.\n */\nmxVmlCanvas2D.prototype.createDiv = function(str, align, valign, overflow)\n{\n\tvar div = this.createElement('div');\n\tvar state = this.state;\n\n\tvar css = '';\n\t\n\tif (state.fontBackgroundColor != null)\n\t{\n\t\tcss += 'background-color:' + mxUtils.htmlEntities(state.fontBackgroundColor) + ';';\n\t}\n\t\n\tif (state.fontBorderColor != null)\n\t{\n\t\tcss += 'border:1px solid ' + mxUtils.htmlEntities(state.fontBorderColor) + ';';\n\t}\n\t\n\tif (mxUtils.isNode(str))\n\t{\n\t\tdiv.appendChild(str);\n\t}\n\telse\n\t{\n\t\tif (overflow != 'fill' && overflow != 'width')\n\t\t{\n\t\t\tvar div2 = this.createElement('div');\n\t\t\tdiv2.style.cssText = css;\n\t\t\tdiv2.style.display = (mxClient.IS_QUIRKS) ? 'inline' : 'inline-block';\n\t\t\tdiv2.style.zoom = '1';\n\t\t\tdiv2.style.textDecoration = 'inherit';\n\t\t\tdiv2.innerHTML = str;\n\t\t\tdiv.appendChild(div2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdiv.style.cssText = css;\n\t\t\tdiv.innerHTML = str;\n\t\t}\n\t}\n\t\n\tvar style = div.style;\n\n\tstyle.fontSize = (state.fontSize / this.vmlScale) + 'px';\n\tstyle.fontFamily = state.fontFamily;\n\tstyle.color = state.fontColor;\n\tstyle.verticalAlign = 'top';\n\tstyle.textAlign = align || 'left';\n\tstyle.lineHeight = (mxConstants.ABSOLUTE_LINE_HEIGHT) ? (state.fontSize * mxConstants.LINE_HEIGHT / this.vmlScale) + 'px' : mxConstants.LINE_HEIGHT;\n\n\tif ((state.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD)\n\t{\n\t\tstyle.fontWeight = 'bold';\n\t}\n\n\tif ((state.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC)\n\t{\n\t\tstyle.fontStyle = 'italic';\n\t}\n\t\n\tif ((state.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE)\n\t{\n\t\tstyle.textDecoration = 'underline';\n\t}\n\t\n\treturn div;\n};\n\n/**\n * Function: text\n * \n * Paints the given text. Possible values for format are empty string for plain\n * text and html for HTML markup. Clipping, text background and border are not\n * supported for plain text in VML.\n */\nmxVmlCanvas2D.prototype.text = function(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir)\n{\n\tif (this.textEnabled && str != null)\n\t{\n\t\tvar s = this.state;\n\t\t\n\t\tif (format == 'html')\n\t\t{\n\t\t\tif (s.rotation != null)\n\t\t\t{\n\t\t\t\tvar pt = this.rotatePoint(x, y, s.rotation, s.rotationCx, s.rotationCy);\n\t\t\t\t\n\t\t\t\tx = pt.x;\n\t\t\t\ty = pt.y;\n\t\t\t}\n\n\t\t\tif (document.documentMode == 8 && !mxClient.IS_EM)\n\t\t\t{\n\t\t\t\tx += s.dx;\n\t\t\t\ty += s.dy;\n\t\t\t\t\n\t\t\t\t// Workaround for rendering offsets\n\t\t\t\tif (overflow != 'fill' && valign == mxConstants.ALIGN_TOP)\n\t\t\t\t{\n\t\t\t\t\ty -= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx *= s.scale;\n\t\t\t\ty *= s.scale;\n\t\t\t}\n\n\t\t\t// Adds event transparency in IE8 standards without the transparent background\n\t\t\t// filter which cannot be used due to bugs in the zoomed bounding box (too slow)\n\t\t\t// FIXME: No event transparency if inside v:rect (ie part of shape)\n\t\t\t// KNOWN: Offset wrong for rotated text with word that are longer than the wrapping\n\t\t\t// width in IE8 because real width of text cannot be determined here.\n\t\t\t// This should be fixed in mxText.updateBoundingBox by calling before this and\n\t\t\t// passing the real width to this method if not clipped and wrapped.\n\t\t\tvar abs = (document.documentMode == 8 && !mxClient.IS_EM) ? this.createVmlElement('group') : this.createElement('div');\n\t\t\tabs.style.position = 'absolute';\n\t\t\tabs.style.display = 'inline';\n\t\t\tabs.style.left = this.format(x) + 'px';\n\t\t\tabs.style.top = this.format(y) + 'px';\n\t\t\tabs.style.zoom = s.scale;\n\n\t\t\tvar box = this.createElement('div');\n\t\t\tbox.style.position = 'relative';\n\t\t\tbox.style.display = 'inline';\n\t\t\t\n\t\t\tvar margin = mxUtils.getAlignmentAsPoint(align, valign);\n\t\t\tvar dx = margin.x;\n\t\t\tvar dy = margin.y;\n\n\t\t\tvar div = this.createDiv(str, align, valign, overflow);\n\t\t\tvar inner = this.createElement('div');\n\t\t\t\n\t\t\tif (dir != null)\n\t\t\t{\n\t\t\t\tdiv.setAttribute('dir', dir);\n\t\t\t}\n\n\t\t\tif (wrap && w > 0)\n\t\t\t{\n\t\t\t\tif (!clip)\n\t\t\t\t{\n\t\t\t\t\tdiv.style.width = Math.round(w) + 'px';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdiv.style.wordWrap = mxConstants.WORD_WRAP;\n\t\t\t\tdiv.style.whiteSpace = 'normal';\n\t\t\t\t\n\t\t\t\t// LATER: Check if other cases need to be handled\n\t\t\t\tif (div.style.wordWrap == 'break-word')\n\t\t\t\t{\n\t\t\t\t\tvar tmp = div;\n\t\t\t\t\t\n\t\t\t\t\tif (tmp.firstChild != null && tmp.firstChild.nodeName == 'DIV')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp.firstChild.style.width = '100%';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdiv.style.whiteSpace = 'nowrap';\n\t\t\t}\n\t\t\t\n\t\t\tvar rot = s.rotation + (rotation || 0);\n\t\t\t\n\t\t\tif (this.rotateHtml && rot != 0)\n\t\t\t{\n\t\t\t\tinner.style.display = 'inline';\n\t\t\t\tinner.style.zoom = '1';\n\t\t\t\tinner.appendChild(div);\n\n\t\t\t\t// Box not needed for rendering in IE8 standards\n\t\t\t\tif (document.documentMode == 8 && !mxClient.IS_EM && this.root.nodeName != 'DIV')\n\t\t\t\t{\n\t\t\t\t\tbox.appendChild(inner);\n\t\t\t\t\tabs.appendChild(box);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tabs.appendChild(inner);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (document.documentMode == 8 && !mxClient.IS_EM)\n\t\t\t{\n\t\t\t\tbox.appendChild(div);\n\t\t\t\tabs.appendChild(box);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdiv.style.display = 'inline';\n\t\t\t\tabs.appendChild(div);\n\t\t\t}\n\t\t\t\n\t\t\t// Inserts the node into the DOM\n\t\t\tif (this.root.nodeName != 'DIV')\n\t\t\t{\n\t\t\t\t// Rectangle to fix position in group\n\t\t\t\tvar rect = this.createVmlElement('rect');\n\t\t\t\trect.stroked = 'false';\n\t\t\t\trect.filled = 'false';\n\n\t\t\t\trect.appendChild(abs);\n\t\t\t\tthis.root.appendChild(rect);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.root.appendChild(abs);\n\t\t\t}\n\t\t\t\n\t\t\tif (clip)\n\t\t\t{\n\t\t\t\tdiv.style.overflow = 'hidden';\n\t\t\t\tdiv.style.width = Math.round(w) + 'px';\n\t\t\t\t\n\t\t\t\tif (!mxClient.IS_QUIRKS)\n\t\t\t\t{\n\t\t\t\t\tdiv.style.maxHeight = Math.round(h) + 'px';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (overflow == 'fill')\n\t\t\t{\n\t\t\t\t// KNOWN: Affects horizontal alignment in quirks\n\t\t\t\t// but fill should only be used with align=left\n\t\t\t\tdiv.style.overflow = 'hidden';\n\t\t\t\tdiv.style.width = (Math.max(0, w) + 1) + 'px';\n\t\t\t\tdiv.style.height = (Math.max(0, h) + 1) + 'px';\n\t\t\t}\n\t\t\telse if (overflow == 'width')\n\t\t\t{\n\t\t\t\t// KNOWN: Affects horizontal alignment in quirks\n\t\t\t\t// but fill should only be used with align=left\n\t\t\t\tdiv.style.overflow = 'hidden';\n\t\t\t\tdiv.style.width = (Math.max(0, w) + 1) + 'px';\n\t\t\t\tdiv.style.maxHeight = (Math.max(0, h) + 1) + 'px';\n\t\t\t}\n\t\t\t\n\t\t\tif (this.rotateHtml && rot != 0)\n\t\t\t{\n\t\t\t\tvar rad = rot * (Math.PI / 180);\n\t\t\t\t\n\t\t\t\t// Precalculate cos and sin for the rotation\n\t\t\t\tvar real_cos = parseFloat(parseFloat(Math.cos(rad)).toFixed(8));\n\t\t\t\tvar real_sin = parseFloat(parseFloat(Math.sin(-rad)).toFixed(8));\n\n\t\t\t\trad %= 2 * Math.PI;\n\t\t\t\tif (rad < 0) rad += 2 * Math.PI;\n\t\t\t\trad %= Math.PI;\n\t\t\t\tif (rad > Math.PI / 2) rad = Math.PI - rad;\n\t\t\t\t\n\t\t\t\tvar cos = Math.cos(rad);\n\t\t\t\tvar sin = Math.sin(rad);\n\n\t\t\t\t// Adds div to document to measure size\n\t\t\t\tif (document.documentMode == 8 && !mxClient.IS_EM)\n\t\t\t\t{\n\t\t\t\t\tdiv.style.display = 'inline-block';\n\t\t\t\t\tinner.style.display = 'inline-block';\n\t\t\t\t\tbox.style.display = 'inline-block';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdiv.style.visibility = 'hidden';\n\t\t\t\tdiv.style.position = 'absolute';\n\t\t\t\tdocument.body.appendChild(div);\n\t\t\t\t\n\t\t\t\tvar sizeDiv = div;\n\t\t\t\t\n\t\t\t\tif (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == 'DIV')\n\t\t\t\t{\n\t\t\t\t\tsizeDiv = sizeDiv.firstChild;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar tmp = sizeDiv.offsetWidth + 3;\n\t\t\t\tvar oh = sizeDiv.offsetHeight;\n\t\t\t\t\n\t\t\t\tif (clip)\n\t\t\t\t{\n\t\t\t\t\tw = Math.min(w, tmp);\n\t\t\t\t\toh = Math.min(oh, h);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tw = tmp;\n\t\t\t\t}\n\n\t\t\t\t// Handles words that are longer than the given wrapping width\n\t\t\t\tif (wrap)\n\t\t\t\t{\n\t\t\t\t\tdiv.style.width = w + 'px';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Simulates max-height in quirks\n\t\t\t\tif (mxClient.IS_QUIRKS && (clip || overflow == 'width') && oh > h)\n\t\t\t\t{\n\t\t\t\t\toh = h;\n\t\t\t\t\t\n\t\t\t\t\t// Quirks does not support maxHeight\n\t\t\t\t\tdiv.style.height = oh + 'px';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\th = oh;\n\n\t\t\t\tvar top_fix = (h - h * cos + w * -sin) / 2 - real_sin * w * (dx + 0.5) + real_cos * h * (dy + 0.5);\n\t\t\t\tvar left_fix = (w - w * cos + h * -sin) / 2 + real_cos * w * (dx + 0.5) + real_sin * h * (dy + 0.5);\n\n\t\t\t\tif (abs.nodeName == 'group' && this.root.nodeName == 'DIV')\n\t\t\t\t{\n\t\t\t\t\t// Workaround for bug where group gets moved away if left and top are non-zero in IE8 standards\n\t\t\t\t\tvar pos = this.createElement('div');\n\t\t\t\t\tpos.style.display = 'inline-block';\n\t\t\t\t\tpos.style.position = 'absolute';\n\t\t\t\t\tpos.style.left = this.format(x + (left_fix - w / 2) * s.scale) + 'px';\n\t\t\t\t\tpos.style.top = this.format(y + (top_fix - h / 2) * s.scale) + 'px';\n\t\t\t\t\t\n\t\t\t\t\tabs.parentNode.appendChild(pos);\n\t\t\t\t\tpos.appendChild(abs);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar sc = (document.documentMode == 8 && !mxClient.IS_EM) ? 1 : s.scale;\n\t\t\t\t\t\n\t\t\t\t\tabs.style.left = this.format(x + (left_fix - w / 2) * sc) + 'px';\n\t\t\t\t\tabs.style.top = this.format(y + (top_fix - h / 2) * sc) + 'px';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// KNOWN: Rotated text rendering quality is bad for IE9 quirks\n\t\t\t\tinner.style.filter = \"progid:DXImageTransform.Microsoft.Matrix(M11=\"+real_cos+\", M12=\"+\n\t\t\t\t\treal_sin+\", M21=\"+(-real_sin)+\", M22=\"+real_cos+\", sizingMethod='auto expand')\";\n\t\t\t\tinner.style.backgroundColor = this.rotatedHtmlBackground;\n\t\t\t\t\n\t\t\t\tif (this.state.alpha < 1)\n\t\t\t\t{\n\t\t\t\t\tinner.style.filter += 'alpha(opacity=' + (this.state.alpha * 100) + ')';\n\t\t\t\t}\n\n\t\t\t\t// Restore parent node for DIV\n\t\t\t\tinner.appendChild(div);\n\t\t\t\tdiv.style.position = '';\n\t\t\t\tdiv.style.visibility = '';\n\t\t\t}\n\t\t\telse if (document.documentMode != 8 || mxClient.IS_EM)\n\t\t\t{\n\t\t\t\tdiv.style.verticalAlign = 'top';\n\t\t\t\t\n\t\t\t\tif (this.state.alpha < 1)\n\t\t\t\t{\n\t\t\t\t\tabs.style.filter = 'alpha(opacity=' + (this.state.alpha * 100) + ')';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Adds div to document to measure size\n\t\t\t\tvar divParent = div.parentNode;\n\t\t\t\tdiv.style.visibility = 'hidden';\n\t\t\t\tdocument.body.appendChild(div);\n\t\t\t\t\n\t\t\t\tw = div.offsetWidth;\n\t\t\t\tvar oh = div.offsetHeight;\n\t\t\t\t\n\t\t\t\t// Simulates max-height in quirks\n\t\t\t\tif (mxClient.IS_QUIRKS && clip && oh > h)\n\t\t\t\t{\n\t\t\t\t\toh = h;\n\t\t\t\t\t\n\t\t\t\t\t// Quirks does not support maxHeight\n\t\t\t\t\tdiv.style.height = oh + 'px';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\th = oh;\n\t\t\t\t\n\t\t\t\tdiv.style.visibility = '';\n\t\t\t\tdivParent.appendChild(div);\n\t\t\t\t\n\t\t\t\tabs.style.left = this.format(x + w * dx * this.state.scale) + 'px';\n\t\t\t\tabs.style.top = this.format(y + h * dy * this.state.scale) + 'px';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (this.state.alpha < 1)\n\t\t\t\t{\n\t\t\t\t\tdiv.style.filter = 'alpha(opacity=' + (this.state.alpha * 100) + ')';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Faster rendering in IE8 without offsetWidth/Height\n\t\t\t\tbox.style.left = (dx * 100) + '%';\n\t\t\t\tbox.style.top = (dy * 100) + '%';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.plainText(x, y, w, h, mxUtils.htmlEntities(str, false), align, valign, wrap, format, overflow, clip, rotation, dir);\n\t\t}\n\t}\n};\n\n/**\n * Function: plainText\n * \n * Paints the outline of the current path.\n */\nmxVmlCanvas2D.prototype.plainText = function(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir)\n{\n\t// TextDirection is ignored since this code is not used (format is always HTML in the text function)\n\tvar s = this.state;\n\tx = (x + s.dx) * s.scale;\n\ty = (y + s.dy) * s.scale;\n\t\n\tvar node = this.createVmlElement('shape');\n\tnode.style.width = '1px';\n\tnode.style.height = '1px';\n\tnode.stroked = 'false';\n\n\tvar fill = this.createVmlElement('fill');\n\tfill.color = s.fontColor;\n\tfill.opacity = (s.alpha * 100) + '%';\n\tnode.appendChild(fill);\n\t\n\tvar path = this.createVmlElement('path');\n\tpath.textpathok = 'true';\n\tpath.v = 'm ' + this.format(0) + ' ' + this.format(0) + ' l ' + this.format(1) + ' ' + this.format(0);\n\t\n\tnode.appendChild(path);\n\t\n\t// KNOWN: Font family and text decoration ignored\n\tvar tp = this.createVmlElement('textpath');\n\ttp.style.cssText = 'v-text-align:' + align;\n\ttp.style.align = align;\n\ttp.style.fontFamily = s.fontFamily;\n\ttp.string = str;\n\ttp.on = 'true';\n\t\n\t// Scale via fontsize instead of node.style.zoom for correct offsets in IE8\n\tvar size = s.fontSize * s.scale / this.vmlScale;\n\ttp.style.fontSize = size + 'px';\n\t\n\t// Bold\n\tif ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD)\n\t{\n\t\ttp.style.fontWeight = 'bold';\n\t}\n\t\n\t// Italic\n\tif ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC)\n\t{\n\t\ttp.style.fontStyle = 'italic';\n\t}\n\n\t// Underline\n\tif ((s.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE)\n\t{\n\t\ttp.style.textDecoration = 'underline';\n\t}\n\n\tvar lines = str.split('\\n');\n\tvar textHeight = size + (lines.length - 1) * size * mxConstants.LINE_HEIGHT;\n\tvar dx = 0;\n\tvar dy = 0;\n\n\tif (valign == mxConstants.ALIGN_BOTTOM)\n\t{\n\t\tdy = - textHeight / 2;\n\t}\n\telse if (valign != mxConstants.ALIGN_MIDDLE) // top\n\t{\n\t\tdy = textHeight / 2;\n\t}\n\n\tif (rotation != null)\n\t{\n\t\tnode.style.rotation = rotation;\n\t\tvar rad = rotation * (Math.PI / 180);\n\t\tdx = Math.sin(rad) * dy;\n\t\tdy = Math.cos(rad) * dy;\n\t}\n\n\t// FIXME: Clipping is relative to bounding box\n\t/*if (clip)\n\t{\n\t\tnode.style.clip = 'rect(0px ' + this.format(w) + 'px ' + this.format(h) + 'px 0px)';\n\t}*/\n\t\n\tnode.appendChild(tp);\n\tnode.style.left = this.format(x - dx) + 'px';\n\tnode.style.top = this.format(y + dy) + 'px';\n\t\n\tthis.root.appendChild(node);\n};\n\n/**\n * Function: stroke\n * \n * Paints the outline of the current path.\n */\nmxVmlCanvas2D.prototype.stroke = function()\n{\n\tthis.addNode(false, true);\n};\n\n/**\n * Function: fill\n * \n * Fills the current path.\n */\nmxVmlCanvas2D.prototype.fill = function()\n{\n\tthis.addNode(true, false);\n};\n\n/**\n * Function: fillAndStroke\n * \n * Fills and paints the outline of the current path.\n */\nmxVmlCanvas2D.prototype.fillAndStroke = function()\n{\n\tthis.addNode(true, true);\n};\n\n__mxOutput.mxVmlCanvas2D = typeof mxVmlCanvas2D !== 'undefined' ? mxVmlCanvas2D : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGuide\n *\n * Implements the alignment of selection cells to other cells in the graph.\n * \n * Constructor: mxGuide\n * \n * Constructs a new guide object.\n */\nfunction mxGuide(graph, states)\n{\n\tthis.graph = graph;\n\tthis.setStates(states);\n};\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph> instance.\n */\nmxGuide.prototype.graph = null;\n\n/**\n * Variable: states\n * \n * Contains the <mxCellStates> that are used for alignment.\n */\nmxGuide.prototype.states = null;\n\n/**\n * Variable: horizontal\n *\n * Specifies if horizontal guides are enabled. Default is true.\n */\nmxGuide.prototype.horizontal = true;\n\n/**\n * Variable: vertical\n *\n * Specifies if vertical guides are enabled. Default is true.\n */\nmxGuide.prototype.vertical = true;\n\n/**\n * Variable: guideX\n *\n * Holds the <mxShape> for the horizontal guide.\n */\nmxGuide.prototype.guideX = null;\n\n/**\n * Variable: guideY\n *\n * Holds the <mxShape> for the vertical guide.\n */\nmxGuide.prototype.guideY = null;\n\n/**\n * Variable: rounded\n *\n * Specifies if rounded coordinates should be used. Default is false.\n */\nmxGuide.prototype.rounded = false;\n\n/**\n * Variable: tolerance\n * \n * Default tolerance in px if grid is disabled. Default is 2.\n */\nmxGuide.prototype.tolerance = 2;\n\n/**\n * Function: setStates\n * \n * Sets the <mxCellStates> that should be used for alignment.\n */\nmxGuide.prototype.setStates = function(states)\n{\n\tthis.states = states;\n};\n\n/**\n * Function: isEnabledForEvent\n * \n * Returns true if the guide should be enabled for the given native event. This\n * implementation always returns true.\n */\nmxGuide.prototype.isEnabledForEvent = function(evt)\n{\n\treturn true;\n};\n\n/**\n * Function: getGuideTolerance\n * \n * Returns the tolerance for the guides. Default value is gridSize / 2.\n */\nmxGuide.prototype.getGuideTolerance = function(gridEnabled)\n{\n\treturn (gridEnabled && this.graph.gridEnabled) ? this.graph.gridSize / 2 : this.tolerance;\n};\n\n/**\n * Function: createGuideShape\n * \n * Returns the mxShape to be used for painting the respective guide. This\n * implementation returns a new, dashed and crisp <mxPolyline> using\n * <mxConstants.GUIDE_COLOR> and <mxConstants.GUIDE_STROKEWIDTH> as the format.\n * \n * Parameters:\n * \n * horizontal - Boolean that specifies which guide should be created.\n */\nmxGuide.prototype.createGuideShape = function(horizontal)\n{\n\tvar guide = new mxPolyline([], mxConstants.GUIDE_COLOR, mxConstants.GUIDE_STROKEWIDTH);\n\tguide.isDashed = true;\n\t\n\treturn guide;\n};\n\n/**\n * Function: isStateIgnored\n * \n * Returns true if the given state should be ignored.\n */\nmxGuide.prototype.isStateIgnored = function(state)\n{\n\treturn false;\n};\n\n/**\n * Function: move\n * \n * Moves the <bounds> by the given <mxPoint> and returnt the snapped point.\n */\nmxGuide.prototype.move = function(bounds, delta, gridEnabled, clone)\n{\n\tif (this.states != null && (this.horizontal || this.vertical) && bounds != null && delta != null)\n\t{\n\t\tvar scale = this.graph.getView().scale;\n\t\tvar tt = this.getGuideTolerance(gridEnabled) * scale;\n\t\tvar b = bounds.clone();\n\t\tb.x += delta.x;\n\t\tb.y += delta.y;\n\t\tvar overrideX = false;\n\t\tvar stateX = null;\n\t\tvar valueX = null;\n\t\tvar overrideY = false;\n\t\tvar stateY = null;\n\t\tvar valueY = null;\n\t\tvar ttX = tt;\n\t\tvar ttY = tt;\n\t\tvar left = b.x;\n\t\tvar right = b.x + b.width;\n\t\tvar center = b.getCenterX();\n\t\tvar top = b.y;\n\t\tvar bottom = b.y + b.height;\n\t\tvar middle = b.getCenterY();\n\t\n\t\t// Snaps the left, center and right to the given x-coordinate\n\t\tfunction snapX(x, state, centerAlign)\n\t\t{\n\t\t\tvar override = false;\n\t\t\t\n\t\t\tif (centerAlign && Math.abs(x - center) < ttX)\n\t\t\t{\n\t\t\t\tdelta.x = x - bounds.getCenterX();\n\t\t\t\tttX = Math.abs(x - center);\n\t\t\t\toverride = true;\n\t\t\t}\n\t\t\telse if (!centerAlign)\n\t\t\t{\n\t\t\t\tif (Math.abs(x - left) < ttX)\n\t\t\t\t{\n\t\t\t\t\tdelta.x = x - bounds.x;\n\t\t\t\t\tttX = Math.abs(x - left);\n\t\t\t\t\toverride = true;\n\t\t\t\t}\n\t\t\t\telse if (Math.abs(x - right) < ttX)\n\t\t\t\t{\n\t\t\t\t\tdelta.x = x - bounds.x - bounds.width;\n\t\t\t\t\tttX = Math.abs(x - right);\n\t\t\t\t\toverride = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (override)\n\t\t\t{\n\t\t\t\tstateX = state;\n\t\t\t\tvalueX = x;\n\t\t\t\t\n\t\t\t\tif (this.guideX == null)\n\t\t\t\t{\n\t\t\t\t\tthis.guideX = this.createGuideShape(true);\n\t\t\t\t\t\n\t\t\t\t\t// Makes sure to use either VML or SVG shapes in order to implement\n\t\t\t\t\t// event-transparency on the background area of the rectangle since\n\t\t\t\t\t// HTML shapes do not let mouseevents through even when transparent\n\t\t\t\t\tthis.guideX.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\t\t\t\t\tmxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;\n\t\t\t\t\tthis.guideX.pointerEvents = false;\n\t\t\t\t\tthis.guideX.init(this.graph.getView().getOverlayPane());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\toverrideX = overrideX || override;\n\t\t};\n\t\t\n\t\t// Snaps the top, middle or bottom to the given y-coordinate\n\t\tfunction snapY(y, state, centerAlign)\n\t\t{\n\t\t\tvar override = false;\n\t\t\t\n\t\t\tif (centerAlign && Math.abs(y - middle) < ttY)\n\t\t\t{\n\t\t\t\tdelta.y = y - bounds.getCenterY();\n\t\t\t\tttY = Math.abs(y -  middle);\n\t\t\t\toverride = true;\n\t\t\t}\n\t\t\telse if (!centerAlign)\n\t\t\t{\n\t\t\t\tif (Math.abs(y - top) < ttY)\n\t\t\t\t{\n\t\t\t\t\tdelta.y = y - bounds.y;\n\t\t\t\t\tttY = Math.abs(y - top);\n\t\t\t\t\toverride = true;\n\t\t\t\t}\n\t\t\t\telse if (Math.abs(y - bottom) < ttY)\n\t\t\t\t{\n\t\t\t\t\tdelta.y = y - bounds.y - bounds.height;\n\t\t\t\t\tttY = Math.abs(y - bottom);\n\t\t\t\t\toverride = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (override)\n\t\t\t{\n\t\t\t\tstateY = state;\n\t\t\t\tvalueY = y;\n\t\t\t\t\n\t\t\t\tif (this.guideY == null)\n\t\t\t\t{\n\t\t\t\t\tthis.guideY = this.createGuideShape(false);\n\t\t\t\t\t\n\t\t\t\t\t// Makes sure to use either VML or SVG shapes in order to implement\n\t\t\t\t\t// event-transparency on the background area of the rectangle since\n\t\t\t\t\t// HTML shapes do not let mouseevents through even when transparent\n\t\t\t\t\tthis.guideY.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\t\t\t\t\tmxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;\n\t\t\t\t\tthis.guideY.pointerEvents = false;\n\t\t\t\t\tthis.guideY.init(this.graph.getView().getOverlayPane());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\toverrideY = overrideY || override;\n\t\t};\n\t\t\n\t\tfor (var i = 0; i < this.states.length; i++)\n\t\t{\n\t\t\tvar state =  this.states[i];\n\t\t\t\n\t\t\tif (state != null && !this.isStateIgnored(state))\n\t\t\t{\n\t\t\t\t// Align x\n\t\t\t\tif (this.horizontal)\n\t\t\t\t{\n\t\t\t\t\tsnapX.call(this, state.getCenterX(), state, true);\n\t\t\t\t\tsnapX.call(this, state.x, state, false);\n\t\t\t\t\tsnapX.call(this, state.x + state.width, state, false);\n\t\t\t\t\t\n\t\t\t\t\t// Aligns left and right of shape to center of page\n\t\t\t\t\tif (state.cell == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tsnapX.call(this, state.getCenterX(), state, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Align y\n\t\t\t\tif (this.vertical)\n\t\t\t\t{\n\t\t\t\t\tsnapY.call(this, state.getCenterY(), state, true);\n\t\t\t\t\tsnapY.call(this, state.y, state, false);\n\t\t\t\t\tsnapY.call(this, state.y + state.height, state, false);\n\t\t\t\t\t\n\t\t\t\t\t// Aligns left and right of shape to center of page\n\t\t\t\t\tif (state.cell == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tsnapY.call(this, state.getCenterY(), state, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Moves cells to the raster if not aligned\n\t\tthis.graph.snapDelta(delta, bounds, !gridEnabled, overrideX, overrideY);\n\t\tdelta = this.getDelta(bounds, stateX, delta.x, stateY, delta.y)\n\t\t\n\t\t// Redraws the guides\n\t\tvar c = this.graph.container;\n\t\t\n\t\tif (!overrideX && this.guideX != null)\n\t\t{\n\t\t\tthis.guideX.node.style.visibility = 'hidden';\n\t\t}\n\t\telse if (this.guideX != null)\n\t\t{\n\t\t\tvar minY = null;\n        \tvar maxY = null;\n        \t\n\t\t\tif (stateX != null && bounds != null)\n\t\t\t{\n\t\t\t\tminY = Math.min(bounds.y + delta.y - this.graph.panDy, stateX.y);\n\t\t\t\tmaxY = Math.max(bounds.y + bounds.height + delta.y - this.graph.panDy, stateX.y + stateX.height);\n\t\t\t}\n\t\t\t\n\t\t\tif (minY != null && maxY != null)\n\t\t\t{\n\t\t\t\tthis.guideX.points = [new mxPoint(valueX, minY), new mxPoint(valueX, maxY)];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.guideX.points = [new mxPoint(valueX, -this.graph.panDy),\n\t\t\t\t\tnew mxPoint(valueX, c.scrollHeight - 3 - this.graph.panDy)];\n\t\t\t}\n\t\t\t\n\t\t\tthis.guideX.stroke = this.getGuideColor(stateX, true);\n\t\t\tthis.guideX.node.style.visibility = 'visible';\n\t\t\tthis.guideX.redraw();\n\t\t}\n\t\t\n\t\tif (!overrideY && this.guideY != null)\n\t\t{\n\t\t\tthis.guideY.node.style.visibility = 'hidden';\n\t\t}\n\t\telse if (this.guideY != null)\n\t\t{\n\t\t\tvar minX = null;\n        \tvar maxX = null;\n        \t\n\t\t\tif (stateY != null && bounds != null)\n\t\t\t{\n\t\t\t\tminX = Math.min(bounds.x + delta.x - this.graph.panDx, stateY.x);\n\t\t\t\tmaxX = Math.max(bounds.x + bounds.width + delta.x - this.graph.panDx, stateY.x + stateY.width);\n\t\t\t}\n\t\t\t\n\t\t\tif (minX != null && maxX != null)\n\t\t\t{\n\t\t\t\tthis.guideY.points = [new mxPoint(minX, valueY), new mxPoint(maxX, valueY)];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.guideY.points = [new mxPoint(-this.graph.panDx, valueY),\n\t\t\t\t\tnew mxPoint(c.scrollWidth - 3 - this.graph.panDx, valueY)];\n\t\t\t}\n\t\t\t\n\t\t\tthis.guideY.stroke = this.getGuideColor(stateY, false);\n\t\t\tthis.guideY.node.style.visibility = 'visible';\n\t\t\tthis.guideY.redraw();\n\t\t}\n\t}\n\t\n\treturn delta;\n};\n\n/**\n * Function: getDelta\n * \n * Rounds to pixels for virtual states (eg. page guides)\n */\nmxGuide.prototype.getDelta = function(bounds, stateX, dx, stateY, dy)\n{\n\tvar s = this.graph.view.scale;\n\t\n\tif (this.rounded || (stateX != null && stateX.cell == null))\n\t{\n\t\tdx = Math.round((bounds.x + dx) / s) * s - bounds.x;\n\t}\n\n\tif (this.rounded || (stateY != null && stateY.cell == null))\n\t{\n\t\tdy = Math.round((bounds.y + dy) / s) * s - bounds.y;\n\t}\n\t\n\treturn new mxPoint(dx, dy);\n};\n\n/**\n * Function: getGuideColor\n * \n * Returns the color for the given state.\n */\nmxGuide.prototype.getGuideColor = function(state, horizontal)\n{\n\treturn mxConstants.GUIDE_COLOR;\n};\n\n/**\n * Function: hide\n * \n * Hides all current guides.\n */\nmxGuide.prototype.hide = function()\n{\n\tthis.setVisible(false);\n};\n\n/**\n * Function: setVisible\n * \n * Shows or hides the current guides.\n */\nmxGuide.prototype.setVisible = function(visible)\n{\n\tif (this.guideX != null)\n\t{\n\t\tthis.guideX.node.style.visibility = (visible) ? 'visible' : 'hidden';\n\t}\n\t\n\tif (this.guideY != null)\n\t{\n\t\tthis.guideY.node.style.visibility = (visible) ? 'visible' : 'hidden';\n\t}\n};\n\n/**\n * Function: destroy\n * \n * Destroys all resources that this object uses.\n */\nmxGuide.prototype.destroy = function()\n{\n\tif (this.guideX != null)\n\t{\n\t\tthis.guideX.destroy();\n\t\tthis.guideX = null;\n\t}\n\t\n\tif (this.guideY != null)\n\t{\n\t\tthis.guideY.destroy();\n\t\tthis.guideY = null;\n\t}\n};\n\n__mxOutput.mxGuide = typeof mxGuide !== 'undefined' ? mxGuide : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxShape\n *\n * Base class for all shapes. A shape in mxGraph is a\n * separate implementation for SVG, VML and HTML. Which\n * implementation to use is controlled by the <dialect>\n * property which is assigned from within the <mxCellRenderer>\n * when the shape is created. The dialect must be assigned\n * for a shape, and it does normally depend on the browser and\n * the confiuration of the graph (see <mxGraph> rendering hint).\n *\n * For each supported shape in SVG and VML, a corresponding\n * shape exists in mxGraph, namely for text, image, rectangle,\n * rhombus, ellipse and polyline. The other shapes are a\n * combination of these shapes (eg. label and swimlane)\n * or they consist of one or more (filled) path objects\n * (eg. actor and cylinder). The HTML implementation is\n * optional but may be required for a HTML-only view of\n * the graph.\n *\n * Custom Shapes:\n *\n * To extend from this class, the basic code looks as follows.\n * In the special case where the custom shape consists only of\n * one filled region or one filled region and an additional stroke\n * the <mxActor> and <mxCylinder> should be subclassed,\n * respectively.\n *\n * (code)\n * function CustomShape() { }\n * \n * CustomShape.prototype = new mxShape();\n * CustomShape.prototype.constructor = CustomShape; \n * (end)\n *\n * To register a custom shape in an existing graph instance,\n * one must register the shape under a new name in the graph's\n * cell renderer as follows:\n *\n * (code)\n * mxCellRenderer.registerShape('customShape', CustomShape);\n * (end)\n *\n * The second argument is the name of the constructor.\n *\n * In order to use the shape you can refer to the given name above\n * in a stylesheet. For example, to change the shape for the default\n * vertex style, the following code is used:\n *\n * (code)\n * var style = graph.getStylesheet().getDefaultVertexStyle();\n * style[mxConstants.STYLE_SHAPE] = 'customShape';\n * (end)\n * \n * Constructor: mxShape\n *\n * Constructs a new shape.\n */\nfunction mxShape(stencil)\n{\n\tthis.stencil = stencil;\n\tthis.initStyles();\n};\n\n/**\n * Variable: dialect\n *\n * Holds the dialect in which the shape is to be painted.\n * This can be one of the DIALECT constants in <mxConstants>.\n */\nmxShape.prototype.dialect = null;\n\n/**\n * Variable: scale\n *\n * Holds the scale in which the shape is being painted.\n */\nmxShape.prototype.scale = 1;\n\n/**\n * Variable: antiAlias\n * \n * Rendering hint for configuring the canvas.\n */\nmxShape.prototype.antiAlias = true;\n\n/**\n * Variable: minSvgStrokeWidth\n * \n * Minimum stroke width for SVG output.\n */\nmxShape.prototype.minSvgStrokeWidth = 1;\n\n/**\n * Variable: bounds\n *\n * Holds the <mxRectangle> that specifies the bounds of this shape.\n */\nmxShape.prototype.bounds = null;\n\n/**\n * Variable: points\n *\n * Holds the array of <mxPoints> that specify the points of this shape.\n */\nmxShape.prototype.points = null;\n\n/**\n * Variable: node\n *\n * Holds the outermost DOM node that represents this shape.\n */\nmxShape.prototype.node = null;\n \n/**\n * Variable: state\n * \n * Optional reference to the corresponding <mxCellState>.\n */\nmxShape.prototype.state = null;\n\n/**\n * Variable: style\n *\n * Optional reference to the style of the corresponding <mxCellState>.\n */\nmxShape.prototype.style = null;\n\n/**\n * Variable: boundingBox\n *\n * Contains the bounding box of the shape, that is, the smallest rectangle\n * that includes all pixels of the shape.\n */\nmxShape.prototype.boundingBox = null;\n\n/**\n * Variable: stencil\n *\n * Holds the <mxStencil> that defines the shape.\n */\nmxShape.prototype.stencil = null;\n\n/**\n * Variable: svgStrokeTolerance\n *\n * Event-tolerance for SVG strokes (in px). Default is 8. This is only passed\n * to the canvas in <createSvgCanvas> if <pointerEvents> is true.\n */\nmxShape.prototype.svgStrokeTolerance = 8;\n\n/**\n * Variable: pointerEvents\n * \n * Specifies if pointer events should be handled. Default is true.\n */\nmxShape.prototype.pointerEvents = true;\n\n/**\n * Variable: svgPointerEvents\n * \n * Specifies if pointer events should be handled. Default is true.\n */\nmxShape.prototype.svgPointerEvents = 'all';\n\n/**\n * Variable: shapePointerEvents\n * \n * Specifies if pointer events outside of shape should be handled. Default\n * is false.\n */\nmxShape.prototype.shapePointerEvents = false;\n\n/**\n * Variable: stencilPointerEvents\n * \n * Specifies if pointer events outside of stencils should be handled. Default\n * is false. Set this to true for backwards compatibility with the 1.x branch.\n */\nmxShape.prototype.stencilPointerEvents = false;\n\n/**\n * Variable: vmlScale\n * \n * Scale for improving the precision of VML rendering. Default is 1.\n */\nmxShape.prototype.vmlScale = 1;\n\n/**\n * Variable: outline\n * \n * Specifies if the shape should be drawn as an outline. This disables all\n * fill colors and can be used to disable other drawing states that should\n * not be painted for outlines. Default is false. This should be set before\n * calling <apply>.\n */\nmxShape.prototype.outline = false;\n\n/**\n * Variable: visible\n * \n * Specifies if the shape is visible. Default is true.\n */\nmxShape.prototype.visible = true;\n\n/**\n * Variable: useSvgBoundingBox\n * \n * Allows to use the SVG bounding box in SVG. Default is false for performance\n * reasons.\n */\nmxShape.prototype.useSvgBoundingBox = false;\n\n/**\n * Function: init\n *\n * Initializes the shape by creaing the DOM node using <create>\n * and adding it into the given container.\n *\n * Parameters:\n *\n * container - DOM node that will contain the shape.\n */\nmxShape.prototype.init = function(container)\n{\n\tif (this.node == null)\n\t{\n\t\tthis.node = this.create(container);\n\t\t\n\t\tif (container != null)\n\t\t{\n\t\t\tcontainer.appendChild(this.node);\n\t\t}\n\t}\n};\n\n/**\n * Function: initStyles\n *\n * Sets the styles to their default values.\n */\nmxShape.prototype.initStyles = function(container)\n{\n\tthis.strokewidth = 1;\n\tthis.rotation = 0;\n\tthis.opacity = 100;\n\tthis.fillOpacity = 100;\n\tthis.strokeOpacity = 100;\n\tthis.flipH = false;\n\tthis.flipV = false;\n};\n\n/**\n * Function: isParseVml\n * \n * Specifies if any VML should be added via insertAdjacentHtml to the DOM. This\n * is only needed in IE8 and only if the shape contains VML markup. This method\n * returns true.\n */\nmxShape.prototype.isParseVml = function()\n{\n\treturn true;\n};\n\n/**\n * Function: isHtmlAllowed\n * \n * Returns true if HTML is allowed for this shape. This implementation always\n * returns false.\n */\nmxShape.prototype.isHtmlAllowed = function()\n{\n\treturn false;\n};\n\n/**\n * Function: getSvgScreenOffset\n * \n * Returns 0, or 0.5 if <strokewidth> % 2 == 1.\n */\nmxShape.prototype.getSvgScreenOffset = function()\n{\n\tvar sw = this.stencil && this.stencil.strokewidth != 'inherit' ? Number(this.stencil.strokewidth) : this.strokewidth;\n\t\n\treturn (mxUtils.mod(Math.max(1, Math.round(sw * this.scale)), 2) == 1) ? 0.5 : 0;\n};\n\n/**\n * Function: create\n *\n * Creates and returns the DOM node(s) for the shape in\n * the given container. This implementation invokes\n * <createSvg>, <createHtml> or <createVml> depending\n * on the <dialect> and style settings.\n *\n * Parameters:\n *\n * container - DOM node that will contain the shape.\n */\nmxShape.prototype.create = function(container)\n{\n\tvar node = null;\n\t\n\tif (container != null && container.ownerSVGElement != null)\n\t{\n\t\tnode = this.createSvg(container);\n\t}\n\telse if (document.documentMode == 8 || !mxClient.IS_VML ||\n\t\t(this.dialect != mxConstants.DIALECT_VML && this.isHtmlAllowed()))\n\t{\n\t\tnode = this.createHtml(container);\n\t}\n\telse\n\t{\n\t\tnode = this.createVml(container);\n\t}\n\t\n\treturn node;\n};\n\n/**\n * Function: createSvg\n *\n * Creates and returns the SVG node(s) to represent this shape.\n */\nmxShape.prototype.createSvg = function()\n{\n\treturn document.createElementNS(mxConstants.NS_SVG, 'g');\n};\n\n/**\n * Function: createVml\n *\n * Creates and returns the VML node to represent this shape.\n */\nmxShape.prototype.createVml = function()\n{\n\tvar node = document.createElement(mxClient.VML_PREFIX + ':group');\n\tnode.style.position = 'absolute';\n\t\n\treturn node;\n};\n\n/**\n * Function: createHtml\n *\n * Creates and returns the HTML DOM node(s) to represent\n * this shape. This implementation falls back to <createVml>\n * so that the HTML creation is optional.\n */\nmxShape.prototype.createHtml = function()\n{\n\tvar node = document.createElement('div');\n\tnode.style.position = 'absolute';\n\t\n\treturn node;\n};\n\n/**\n * Function: reconfigure\n *\n * Reconfigures this shape. This will update the colors etc in\n * addition to the bounds or points.\n */\nmxShape.prototype.reconfigure = function()\n{\n\tthis.redraw();\n};\n\n/**\n * Function: redraw\n *\n * Creates and returns the SVG node(s) to represent this shape.\n */\nmxShape.prototype.redraw = function()\n{\n\tthis.updateBoundsFromPoints();\n\t\n\tif (this.visible && this.checkBounds())\n\t{\n\t\tthis.node.style.visibility = 'visible';\n\t\tthis.clear();\n\t\t\n\t\tif (this.node.nodeName == 'DIV' && (this.isHtmlAllowed() || !mxClient.IS_VML))\n\t\t{\n\t\t\tthis.redrawHtmlShape();\n\t\t}\n\t\telse\n\t\t{\t\n\t\t\tthis.redrawShape();\n\t\t}\n\n\t\tthis.updateBoundingBox();\n\t}\n\telse\n\t{\n\t\tthis.node.style.visibility = 'hidden';\n\t\tthis.boundingBox = null;\n\t}\n};\n\n/**\n * Function: clear\n * \n * Removes all child nodes and resets all CSS.\n */\nmxShape.prototype.clear = function()\n{\n\tif (this.node.ownerSVGElement != null)\n\t{\n\t\twhile (this.node.lastChild != null)\n\t\t{\n\t\t\tthis.node.removeChild(this.node.lastChild);\n\t\t}\n\t}\n\telse\n\t{\n\t\tthis.node.style.cssText = 'position:absolute;' + ((this.cursor != null) ?\n\t\t\t('cursor:' + this.cursor + ';') : '');\n\t\tthis.node.innerHTML = '';\n\t}\n};\n\n/**\n * Function: updateBoundsFromPoints\n * \n * Updates the bounds based on the points.\n */\nmxShape.prototype.updateBoundsFromPoints = function()\n{\n\tvar pts = this.points;\n\t\n\tif (pts != null && pts.length > 0 && pts[0] != null)\n\t{\n\t\tthis.bounds = new mxRectangle(Number(pts[0].x), Number(pts[0].y), 1, 1);\n\t\t\n\t\tfor (var i = 1; i < this.points.length; i++)\n\t\t{\n\t\t\tif (pts[i] != null)\n\t\t\t{\n\t\t\t\tthis.bounds.add(new mxRectangle(Number(pts[i].x), Number(pts[i].y), 1, 1));\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: getLabelBounds\n * \n * Returns the <mxRectangle> for the label bounds of this shape, based on the\n * given scaled and translated bounds of the shape. This method should not\n * change the rectangle in-place. This implementation returns the given rect.\n */\nmxShape.prototype.getLabelBounds = function(rect)\n{\n\tvar d = mxUtils.getValue(this.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);\n\tvar bounds = rect;\n\t\n\t// Normalizes argument for getLabelMargins hook\n\tif (d != mxConstants.DIRECTION_SOUTH && d != mxConstants.DIRECTION_NORTH &&\n\t\tthis.state != null && this.state.text != null &&\n\t\tthis.state.text.isPaintBoundsInverted())\n\t{\n\t\tbounds = bounds.clone();\n\t\tvar tmp = bounds.width;\n\t\tbounds.width = bounds.height;\n\t\tbounds.height = tmp;\n\t}\n\t\t\n\tvar m = this.getLabelMargins(bounds);\n\t\n\tif (m != null)\n\t{\n\t\tvar flipH = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, false) == '1';\n\t\tvar flipV = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, false) == '1';\n\t\t\n\t\t// Handles special case for vertical labels\n\t\tif (this.state != null && this.state.text != null &&\n\t\t\tthis.state.text.isPaintBoundsInverted())\n\t\t{\n\t\t\tvar tmp = m.x;\n\t\t\tm.x = m.height;\n\t\t\tm.height = m.width;\n\t\t\tm.width = m.y;\n\t\t\tm.y = tmp;\n\n\t\t\ttmp = flipH;\n\t\t\tflipH = flipV;\n\t\t\tflipV = tmp;\n\t\t}\n\t\t\n\t\treturn mxUtils.getDirectedBounds(rect, m, this.style, flipH, flipV);\n\t}\n\t\n\treturn rect;\n};\n\n/**\n * Function: getLabelMargins\n * \n * Returns the scaled top, left, bottom and right margin to be used for\n * computing the label bounds as an <mxRectangle>, where the bottom and right\n * margin are defined in the width and height of the rectangle, respectively.\n */\nmxShape.prototype.getLabelMargins= function(rect)\n{\n\treturn null;\n};\n\n/**\n * Function: checkBounds\n * \n * Returns true if the bounds are not null and all of its variables are numeric.\n */\nmxShape.prototype.checkBounds = function()\n{\n\treturn (!isNaN(this.scale) && isFinite(this.scale) && this.scale > 0 &&\n\t\t\tthis.bounds != null && !isNaN(this.bounds.x) && !isNaN(this.bounds.y) &&\n\t\t\t!isNaN(this.bounds.width) && !isNaN(this.bounds.height) &&\n\t\t\tthis.bounds.width > 0 && this.bounds.height > 0);\n};\n\n/**\n * Function: createVmlGroup\n *\n * Returns the temporary element used for rendering in IE8 standards mode.\n */\nmxShape.prototype.createVmlGroup = function()\n{\n\tvar node = document.createElement(mxClient.VML_PREFIX + ':group');\n\tnode.style.position = 'absolute';\n\tnode.style.width = this.node.style.width;\n\tnode.style.height = this.node.style.height;\n\t\n\treturn node;\n};\n\n/**\n * Function: redrawShape\n *\n * Updates the SVG or VML shape.\n */\nmxShape.prototype.redrawShape = function()\n{\n\tvar canvas = this.createCanvas();\n\t\n\tif (canvas != null)\n\t{\n\t\t// Specifies if events should be handled\n\t\tcanvas.pointerEvents = this.pointerEvents;\n\t\n\t\tthis.beforePaint(canvas);\n\t\tthis.paint(canvas);\n\t\tthis.afterPaint(canvas);\n\t\n\t\tif (this.node != canvas.root)\n\t\t{\n\t\t\t// Forces parsing in IE8 standards mode - slow! avoid\n\t\t\tthis.node.insertAdjacentHTML('beforeend', canvas.root.outerHTML);\n\t\t}\n\t\n\t\tif (this.node.nodeName == 'DIV' && document.documentMode == 8)\n\t\t{\n\t\t\t// Makes DIV transparent to events for IE8 in IE8 standards\n\t\t\t// mode (Note: Does not work for IE9 in IE8 standards mode\n\t\t\t// and not for IE11 in enterprise mode)\n\t\t\tthis.node.style.filter = '';\n\t\t\t\n\t\t\t// Adds event transparency in IE8 standards\n\t\t\tmxUtils.addTransparentBackgroundFilter(this.node);\n\t\t}\n\t\t\n\t\tthis.destroyCanvas(canvas);\n\t}\n};\n\n/**\n * Function: createCanvas\n * \n * Creates a new canvas for drawing this shape. May return null.\n */\nmxShape.prototype.createCanvas = function()\n{\n\tvar canvas = null;\n\t\n\t// LATER: Check if reusing existing DOM nodes improves performance\n\tif (this.node.ownerSVGElement != null)\n\t{\n\t\tcanvas = this.createSvgCanvas();\n\t}\n\telse if (mxClient.IS_VML)\n\t{\n\t\tthis.updateVmlContainer();\n\t\tcanvas = this.createVmlCanvas();\n\t}\n\t\n\tif (canvas != null && this.outline)\n\t{\n\t\tcanvas.setStrokeWidth(this.strokewidth);\n\t\tcanvas.setStrokeColor(this.stroke);\n\t\t\n\t\tif (this.isDashed != null)\n\t\t{\n\t\t\tcanvas.setDashed(this.isDashed);\n\t\t}\n\t\t\n\t\tcanvas.setStrokeWidth = function() {};\n\t\tcanvas.setStrokeColor = function() {};\n\t\tcanvas.setFillColor = function() {};\n\t\tcanvas.setGradient = function() {};\n\t\tcanvas.setDashed = function() {};\n\t\tcanvas.text = function() {};\n\t}\n\n\treturn canvas;\n};\n\n/**\n * Function: createSvgCanvas\n * \n * Creates and returns an <mxSvgCanvas2D> for rendering this shape.\n */\nmxShape.prototype.createSvgCanvas = function()\n{\n\tvar canvas = new mxSvgCanvas2D(this.node, false);\n\tcanvas.strokeTolerance = (this.pointerEvents) ? this.svgStrokeTolerance : 0;\n\tcanvas.pointerEventsValue = this.svgPointerEvents;\n\tvar off = this.getSvgScreenOffset();\n\n\tif (off != 0)\n\t{\n\t\tthis.node.setAttribute('transform', 'translate(' + off + ',' + off + ')');\n\t}\n\telse\n\t{\n\t\tthis.node.removeAttribute('transform');\n\t}\n\n\tcanvas.minStrokeWidth = this.minSvgStrokeWidth;\n\t\n\tif (!this.antiAlias)\n\t{\n\t\t// Rounds all numbers in the SVG output to integers\n\t\tcanvas.format = function(value)\n\t\t{\n\t\t\treturn Math.round(parseFloat(value));\n\t\t};\n\t}\n\t\n\treturn canvas;\n};\n\n/**\n * Function: createVmlCanvas\n * \n * Creates and returns an <mxVmlCanvas2D> for rendering this shape.\n */\nmxShape.prototype.createVmlCanvas = function()\n{\n\t// Workaround for VML rendering bug in IE8 standards mode\n\tvar node = (document.documentMode == 8 && this.isParseVml()) ? this.createVmlGroup() : this.node;\n\tvar canvas = new mxVmlCanvas2D(node, false);\n\t\n\tif (node.tagUrn != '')\n\t{\n\t\tvar w = Math.max(1, Math.round(this.bounds.width));\n\t\tvar h = Math.max(1, Math.round(this.bounds.height));\n\t\tnode.coordsize = (w * this.vmlScale) + ',' + (h * this.vmlScale);\n\t\tcanvas.scale(this.vmlScale);\n\t\tcanvas.vmlScale = this.vmlScale;\n\t}\n\n\t// Painting relative to top, left shape corner\n\tvar s = this.scale;\n\tcanvas.translate(-Math.round(this.bounds.x / s), -Math.round(this.bounds.y / s));\n\t\n\treturn canvas;\n};\n\n/**\n * Function: updateVmlContainer\n * \n * Updates the bounds of the VML container.\n */\nmxShape.prototype.updateVmlContainer = function()\n{\n\tthis.node.style.left = Math.round(this.bounds.x) + 'px';\n\tthis.node.style.top = Math.round(this.bounds.y) + 'px';\n\tvar w = Math.max(1, Math.round(this.bounds.width));\n\tvar h = Math.max(1, Math.round(this.bounds.height));\n\tthis.node.style.width = w + 'px';\n\tthis.node.style.height = h + 'px';\n\tthis.node.style.overflow = 'visible';\n};\n\n/**\n * Function: redrawHtml\n *\n * Allow optimization by replacing VML with HTML.\n */\nmxShape.prototype.redrawHtmlShape = function()\n{\n\t// LATER: Refactor methods\n\tthis.updateHtmlBounds(this.node);\n\tthis.updateHtmlFilters(this.node);\n\tthis.updateHtmlColors(this.node);\n};\n\n/**\n * Function: updateHtmlFilters\n *\n * Allow optimization by replacing VML with HTML.\n */\nmxShape.prototype.updateHtmlFilters = function(node)\n{\n\tvar f = '';\n\t\n\tif (this.opacity < 100)\n\t{\n\t\tf += 'alpha(opacity=' + (this.opacity) + ')';\n\t}\n\t\n\tif (this.isShadow)\n\t{\n\t\t// FIXME: Cannot implement shadow transparency with filter\n\t\tf += 'progid:DXImageTransform.Microsoft.dropShadow (' +\n\t\t\t'OffX=\\'' + Math.round(mxConstants.SHADOW_OFFSET_X * this.scale) + '\\', ' +\n\t\t\t'OffY=\\'' + Math.round(mxConstants.SHADOW_OFFSET_Y * this.scale) + '\\', ' +\n\t\t\t'Color=\\'' + mxConstants.VML_SHADOWCOLOR + '\\')';\n\t}\n\t\n\tif (this.fill != null && this.fill != mxConstants.NONE && this.gradient && this.gradient != mxConstants.NONE)\n\t{\n\t\tvar start = this.fill;\n\t\tvar end = this.gradient;\n\t\tvar type = '0';\n\t\t\n\t\tvar lookup = {east:0,south:1,west:2,north:3};\n\t\tvar dir = (this.direction != null) ? lookup[this.direction] : 0;\n\t\t\n\t\tif (this.gradientDirection != null)\n\t\t{\n\t\t\tdir = mxUtils.mod(dir + lookup[this.gradientDirection] - 1, 4);\n\t\t}\n\n\t\tif (dir == 1)\n\t\t{\n\t\t\ttype = '1';\n\t\t\tvar tmp = start;\n\t\t\tstart = end;\n\t\t\tend = tmp;\n\t\t}\n\t\telse if (dir == 2)\n\t\t{\n\t\t\tvar tmp = start;\n\t\t\tstart = end;\n\t\t\tend = tmp;\n\t\t}\n\t\telse if (dir == 3)\n\t\t{\n\t\t\ttype = '1';\n\t\t}\n\t\t\n\t\tf += 'progid:DXImageTransform.Microsoft.gradient(' +\n\t\t\t'startColorStr=\\'' + start + '\\', endColorStr=\\'' + end +\n\t\t\t'\\', gradientType=\\'' + type + '\\')';\n\t}\n\n\tnode.style.filter = f;\n};\n\n/**\n * Function: updateHtmlColors\n *\n * Allow optimization by replacing VML with HTML.\n */\nmxShape.prototype.updateHtmlColors = function(node)\n{\n\tvar color = this.stroke;\n\t\n\tif (color != null && color != mxConstants.NONE)\n\t{\n\t\tnode.style.borderColor = color;\n\n\t\tif (this.isDashed)\n\t\t{\n\t\t\tnode.style.borderStyle = 'dashed';\n\t\t}\n\t\telse if (this.strokewidth > 0)\n\t\t{\n\t\t\tnode.style.borderStyle = 'solid';\n\t\t}\n\n\t\tnode.style.borderWidth = Math.max(1, Math.ceil(this.strokewidth * this.scale)) + 'px';\n\t}\n\telse\n\t{\n\t\tnode.style.borderWidth = '0px';\n\t}\n\n\tcolor = (this.outline) ? null : this.fill;\n\t\n\tif (color != null && color != mxConstants.NONE)\n\t{\n\t\tnode.style.backgroundColor = color;\n\t\tnode.style.backgroundImage = 'none';\n\t}\n\telse if (this.pointerEvents)\n\t{\n\t\t node.style.backgroundColor = 'transparent';\n\t}\n\telse if (document.documentMode == 8)\n\t{\n\t\tmxUtils.addTransparentBackgroundFilter(node);\n\t}\n\telse\n\t{\n\t\tthis.setTransparentBackgroundImage(node);\n\t}\n};\n\n/**\n * Function: updateHtmlBounds\n *\n * Allow optimization by replacing VML with HTML.\n */\nmxShape.prototype.updateHtmlBounds = function(node)\n{\n\tvar sw = (document.documentMode >= 9) ? 0 : Math.ceil(this.strokewidth * this.scale);\n\tnode.style.borderWidth = Math.max(1, sw) + 'px';\n\tnode.style.overflow = 'hidden';\n\t\n\tnode.style.left = Math.round(this.bounds.x - sw / 2) + 'px';\n\tnode.style.top = Math.round(this.bounds.y - sw / 2) + 'px';\n\n\tif (document.compatMode == 'CSS1Compat')\n\t{\n\t\tsw = -sw;\n\t}\n\t\n\tnode.style.width = Math.round(Math.max(0, this.bounds.width + sw)) + 'px';\n\tnode.style.height = Math.round(Math.max(0, this.bounds.height + sw)) + 'px';\n};\n\n/**\n * Function: destroyCanvas\n * \n * Destroys the given canvas which was used for drawing. This implementation\n * increments the reference counts on all shared gradients used in the canvas.\n */\nmxShape.prototype.destroyCanvas = function(canvas)\n{\n\t// Manages reference counts\n\tif (canvas instanceof mxSvgCanvas2D)\n\t{\n\t\t// Increments ref counts\n\t\tfor (var key in canvas.gradients)\n\t\t{\n\t\t\tvar gradient = canvas.gradients[key];\n\t\t\t\n\t\t\tif (gradient != null)\n\t\t\t{\n\t\t\t\tgradient.mxRefCount = (gradient.mxRefCount || 0) + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.releaseSvgGradients(this.oldGradients);\n\t\tthis.oldGradients = canvas.gradients;\n\t}\n};\n\n/**\n * Function: beforePaint\n * \n * Invoked before paint is called.\n */\nmxShape.prototype.beforePaint = function(c) { }\n\n/**\n * Function: afterPaint\n * \n * Invokes after paint was called.\n */\nmxShape.prototype.afterPaint = function(c) { }\n\n/**\n * Function: paint\n * \n * Generic rendering code.\n */\nmxShape.prototype.paint = function(c)\n{\n\tvar strokeDrawn = false;\n\t\n\tif (c != null && this.outline)\n\t{\n\t\tvar stroke = c.stroke;\n\t\t\n\t\tc.stroke = function()\n\t\t{\n\t\t\tstrokeDrawn = true;\n\t\t\tstroke.apply(this, arguments);\n\t\t};\n\n\t\tvar fillAndStroke = c.fillAndStroke;\n\t\t\n\t\tc.fillAndStroke = function()\n\t\t{\n\t\t\tstrokeDrawn = true;\n\t\t\tfillAndStroke.apply(this, arguments);\n\t\t};\n\t}\n\n\t// Scale is passed-through to canvas\n\tvar s = this.scale;\n\tvar x = this.bounds.x / s;\n\tvar y = this.bounds.y / s;\n\tvar w = this.bounds.width / s;\n\tvar h = this.bounds.height / s;\n\n\tif (this.isPaintBoundsInverted())\n\t{\n\t\tvar t = (w - h) / 2;\n\t\tx += t;\n\t\ty -= t;\n\t\tvar tmp = w;\n\t\tw = h;\n\t\th = tmp;\n\t}\n\t\n\tthis.updateTransform(c, x, y, w, h);\n\tthis.configureCanvas(c, x, y, w, h);\n\n\t// Adds background rectangle to capture events\n\tvar bg = null;\n\t\n\tif ((this.stencil == null && this.points == null && this.shapePointerEvents) ||\n\t\t(this.stencil != null && this.stencilPointerEvents))\n\t{\n\t\tvar bb = this.createBoundingBox();\n\t\t\n\t\tif (this.dialect == mxConstants.DIALECT_SVG)\n\t\t{\n\t\t\tbg = this.createTransparentSvgRectangle(bb.x, bb.y, bb.width, bb.height);\n\t\t\tthis.node.appendChild(bg);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar rect = c.createRect('rect', bb.x / s, bb.y / s, bb.width / s, bb.height / s);\n\t\t\trect.appendChild(c.createTransparentFill());\n\t\t\trect.stroked = 'false';\n\t\t\tc.root.appendChild(rect);\n\t\t}\n\t}\n\n\tif (this.stencil != null)\n\t{\n\t\tthis.stencil.drawShape(c, this, x, y, w, h);\n\t}\n\telse\n\t{\n\t\t// Stencils have separate strokewidth\n\t\tc.setStrokeWidth(this.strokewidth);\n\t\t\n\t\tif (this.points != null)\n\t\t{\n\t\t\t// Paints edge shape\n\t\t\tvar pts = [];\n\t\t\t\n\t\t\tfor (var i = 0; i < this.points.length; i++)\n\t\t\t{\n\t\t\t\tif (this.points[i] != null)\n\t\t\t\t{\n\t\t\t\t\tpts.push(new mxPoint(this.points[i].x / s, this.points[i].y / s));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.paintEdgeShape(c, pts);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Paints vertex shape\n\t\t\tthis.paintVertexShape(c, x, y, w, h);\n\t\t}\n\t}\n\t\n\tif (bg != null && c.state != null && c.state.transform != null)\n\t{\n\t\tbg.setAttribute('transform', c.state.transform);\n\t}\n\t\n\t// Draws highlight rectangle if no stroke was used\n\tif (c != null && this.outline && !strokeDrawn)\n\t{\n\t\tc.rect(x, y, w, h);\n\t\tc.stroke();\n\t}\n};\n\n/**\n * Function: configureCanvas\n * \n * Sets the state of the canvas for drawing the shape.\n */\nmxShape.prototype.configureCanvas = function(c, x, y, w, h)\n{\n\tvar dash = null;\n\t\n\tif (this.style != null)\n\t{\n\t\tdash = this.style['dashPattern'];\t\t\n\t}\n\n\tc.setAlpha(this.opacity / 100);\n\tc.setFillAlpha(this.fillOpacity / 100);\n\tc.setStrokeAlpha(this.strokeOpacity / 100);\n\n\t// Sets alpha, colors and gradients\n\tif (this.isShadow != null)\n\t{\n\t\tc.setShadow(this.isShadow);\n\t}\n\t\n\t// Dash pattern\n\tif (this.isDashed != null)\n\t{\n\t\tc.setDashed(this.isDashed, (this.style != null) ?\n\t\t\tmxUtils.getValue(this.style, mxConstants.STYLE_FIX_DASH, false) == 1 : false);\n\t}\n\n\tif (dash != null)\n\t{\n\t\tc.setDashPattern(dash);\n\t}\n\n\tif (this.fill != null && this.fill != mxConstants.NONE && this.gradient && this.gradient != mxConstants.NONE)\n\t{\n\t\tvar b = this.getGradientBounds(c, x, y, w, h);\n\t\tc.setGradient(this.fill, this.gradient, b.x, b.y, b.width, b.height, this.gradientDirection);\n\t}\n\telse\n\t{\n\t\tc.setFillColor(this.fill);\n\t}\n\n\tc.setStrokeColor(this.stroke);\n};\n\n/**\n * Function: getGradientBounds\n * \n * Returns the bounding box for the gradient box for this shape.\n */\nmxShape.prototype.getGradientBounds = function(c, x, y, w, h)\n{\n\treturn new mxRectangle(x, y, w, h);\n};\n\n/**\n * Function: updateTransform\n * \n * Sets the scale and rotation on the given canvas.\n */\nmxShape.prototype.updateTransform = function(c, x, y, w, h)\n{\n\t// NOTE: Currently, scale is implemented in state and canvas. This will\n\t// move to canvas in a later version, so that the states are unscaled\n\t// and untranslated and do not need an update after zooming or panning.\n\tc.scale(this.scale);\n\tc.rotate(this.getShapeRotation(), this.flipH, this.flipV, x + w / 2, y + h / 2);\n};\n\n/**\n * Function: paintVertexShape\n * \n * Paints the vertex shape.\n */\nmxShape.prototype.paintVertexShape = function(c, x, y, w, h)\n{\n\tthis.paintBackground(c, x, y, w, h);\n\t\n\tif (!this.outline || this.style == null || mxUtils.getValue(\n\t\tthis.style, mxConstants.STYLE_BACKGROUND_OUTLINE, 0) == 0)\n\t{\n\t\tc.setShadow(false);\n\t\tthis.paintForeground(c, x, y, w, h);\n\t}\n};\n\n/**\n * Function: paintBackground\n * \n * Hook for subclassers. This implementation is empty.\n */\nmxShape.prototype.paintBackground = function(c, x, y, w, h) { };\n\n/**\n * Function: paintForeground\n * \n * Hook for subclassers. This implementation is empty.\n */\nmxShape.prototype.paintForeground = function(c, x, y, w, h) { };\n\n/**\n * Function: paintEdgeShape\n * \n * Hook for subclassers. This implementation is empty.\n */\nmxShape.prototype.paintEdgeShape = function(c, pts) { };\n\n/**\n * Function: getArcSize\n * \n * Returns the arc size for the given dimension.\n */\nmxShape.prototype.getArcSize = function(w, h)\n{\n\tvar r = 0;\n\t\n\tif (mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0) == '1')\n\t{\n\t\tr = Math.min(w / 2, Math.min(h / 2, mxUtils.getValue(this.style,\n\t\t\tmxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2));\n\t}\n\telse\n\t{\n\t\tvar f = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE,\n\t\t\tmxConstants.RECTANGLE_ROUNDING_FACTOR * 100) / 100;\n\t\tr = Math.min(w * f, h * f);\n\t}\n\t\n\treturn r;\n};\n\n/**\n * Function: paintGlassEffect\n * \n * Paints the glass gradient effect.\n */\nmxShape.prototype.paintGlassEffect = function(c, x, y, w, h, arc)\n{\n\tvar sw = Math.ceil(this.strokewidth / 2);\n\tvar size = 0.4;\n\t\n\tc.setGradient('#ffffff', '#ffffff', x, y, w, h * 0.6, 'south', 0.9, 0.1);\n\tc.begin();\n\tarc += 2 * sw;\n\t\t\n\tif (this.isRounded)\n\t{\n\t\tc.moveTo(x - sw + arc, y - sw);\n\t\tc.quadTo(x - sw, y - sw, x - sw, y - sw + arc);\n\t\tc.lineTo(x - sw, y + h * size);\n\t\tc.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);\n\t\tc.lineTo(x + w + sw, y - sw + arc);\n\t\tc.quadTo(x + w + sw, y - sw, x + w + sw - arc, y - sw);\n\t}\n\telse\n\t{\n\t\tc.moveTo(x - sw, y - sw);\n\t\tc.lineTo(x - sw, y + h * size);\n\t\tc.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);\n\t\tc.lineTo(x + w + sw, y - sw);\n\t}\n\t\n\tc.close();\n\tc.fill();\n};\n\n/**\n * Function: addPoints\n * \n * Paints the given points with rounded corners.\n */\nmxShape.prototype.addPoints = function(c, pts, rounded, arcSize, close, exclude, initialMove)\n{\n\tif (pts != null && pts.length > 0)\n\t{\n\t\tinitialMove = (initialMove != null) ? initialMove : true;\n\t\tvar pe = pts[pts.length - 1];\n\t\t\n\t\t// Adds virtual waypoint in the center between start and end point\n\t\tif (close && rounded)\n\t\t{\n\t\t\tpts = pts.slice();\n\t\t\tvar p0 = pts[0];\n\t\t\tvar wp = new mxPoint(pe.x + (p0.x - pe.x) / 2, pe.y + (p0.y - pe.y) / 2);\n\t\t\tpts.splice(0, 0, wp);\n\t\t}\n\t\n\t\tvar pt = pts[0];\n\t\tvar i = 1;\n\t\n\t\t// Draws the line segments\n\t\tif (initialMove)\n\t\t{\n\t\t\tc.moveTo(pt.x, pt.y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc.lineTo(pt.x, pt.y);\n\t\t}\n\t\t\n\t\twhile (i < ((close) ? pts.length : pts.length - 1))\n\t\t{\n\t\t\tvar tmp = pts[mxUtils.mod(i, pts.length)];\n\t\t\tvar dx = pt.x - tmp.x;\n\t\t\tvar dy = pt.y - tmp.y;\n\t\n\t\t\tif (rounded && (dx != 0 || dy != 0) && (exclude == null || mxUtils.indexOf(exclude, i - 1) < 0))\n\t\t\t{\n\t\t\t\t// Draws a line from the last point to the current\n\t\t\t\t// point with a spacing of size off the current point\n\t\t\t\t// into direction of the last point\n\t\t\t\tvar dist = Math.sqrt(dx * dx + dy * dy);\n\t\t\t\tvar nx1 = dx * Math.min(arcSize, dist / 2) / dist;\n\t\t\t\tvar ny1 = dy * Math.min(arcSize, dist / 2) / dist;\n\t\n\t\t\t\tvar x1 = tmp.x + nx1;\n\t\t\t\tvar y1 = tmp.y + ny1;\n\t\t\t\tc.lineTo(x1, y1);\n\t\n\t\t\t\t// Draws a curve from the last point to the current\n\t\t\t\t// point with a spacing of size off the current point\n\t\t\t\t// into direction of the next point\n\t\t\t\tvar next = pts[mxUtils.mod(i + 1, pts.length)];\n\t\t\t\t\n\t\t\t\t// Uses next non-overlapping point\n\t\t\t\twhile (i < pts.length - 2 && Math.round(next.x - tmp.x) == 0 && Math.round(next.y - tmp.y) == 0)\n\t\t\t\t{\n\t\t\t\t\tnext = pts[mxUtils.mod(i + 2, pts.length)];\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdx = next.x - tmp.x;\n\t\t\t\tdy = next.y - tmp.y;\n\t\n\t\t\t\tdist = Math.max(1, Math.sqrt(dx * dx + dy * dy));\n\t\t\t\tvar nx2 = dx * Math.min(arcSize, dist / 2) / dist;\n\t\t\t\tvar ny2 = dy * Math.min(arcSize, dist / 2) / dist;\n\t\n\t\t\t\tvar x2 = tmp.x + nx2;\n\t\t\t\tvar y2 = tmp.y + ny2;\n\t\n\t\t\t\tc.quadTo(tmp.x, tmp.y, x2, y2);\n\t\t\t\ttmp = new mxPoint(x2, y2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc.lineTo(tmp.x, tmp.y);\n\t\t\t}\n\t\n\t\t\tpt = tmp;\n\t\t\ti++;\n\t\t}\n\t\n\t\tif (close)\n\t\t{\n\t\t\tc.close();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc.lineTo(pe.x, pe.y);\n\t\t}\n\t}\n};\n\n/**\n * Function: resetStyles\n * \n * Resets all styles.\n */\nmxShape.prototype.resetStyles = function()\n{\n\tthis.initStyles();\n\n\tthis.spacing = 0;\n\t\n\tdelete this.fill;\n\tdelete this.gradient;\n\tdelete this.gradientDirection;\n\tdelete this.stroke;\n\tdelete this.startSize;\n\tdelete this.endSize;\n\tdelete this.startArrow;\n\tdelete this.endArrow;\n\tdelete this.direction;\n\tdelete this.isShadow;\n\tdelete this.isDashed;\n\tdelete this.isRounded;\n\tdelete this.glass;\n};\n\n/**\n * Function: apply\n * \n * Applies the style of the given <mxCellState> to the shape. This\n * implementation assigns the following styles to local fields:\n * \n * - <mxConstants.STYLE_FILLCOLOR> => fill\n * - <mxConstants.STYLE_GRADIENTCOLOR> => gradient\n * - <mxConstants.STYLE_GRADIENT_DIRECTION> => gradientDirection\n * - <mxConstants.STYLE_OPACITY> => opacity\n * - <mxConstants.STYLE_FILL_OPACITY> => fillOpacity\n * - <mxConstants.STYLE_STROKE_OPACITY> => strokeOpacity\n * - <mxConstants.STYLE_STROKECOLOR> => stroke\n * - <mxConstants.STYLE_STROKEWIDTH> => strokewidth\n * - <mxConstants.STYLE_SHADOW> => isShadow\n * - <mxConstants.STYLE_DASHED> => isDashed\n * - <mxConstants.STYLE_SPACING> => spacing\n * - <mxConstants.STYLE_STARTSIZE> => startSize\n * - <mxConstants.STYLE_ENDSIZE> => endSize\n * - <mxConstants.STYLE_ROUNDED> => isRounded\n * - <mxConstants.STYLE_STARTARROW> => startArrow\n * - <mxConstants.STYLE_ENDARROW> => endArrow\n * - <mxConstants.STYLE_ROTATION> => rotation\n * - <mxConstants.STYLE_DIRECTION> => direction\n * - <mxConstants.STYLE_GLASS> => glass\n *\n * This keeps a reference to the <style>. If you need to keep a reference to\n * the cell, you can override this method and store a local reference to\n * state.cell or the <mxCellState> itself. If <outline> should be true, make\n * sure to set it before calling this method.\n *\n * Parameters:\n *\n * state - <mxCellState> of the corresponding cell.\n */\nmxShape.prototype.apply = function(state)\n{\n\tthis.state = state;\n\tthis.style = state.style;\n\n\tif (this.style != null)\n\t{\n\t\tthis.fill = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, this.fill);\n\t\tthis.gradient = mxUtils.getValue(this.style, mxConstants.STYLE_GRADIENTCOLOR, this.gradient);\n\t\tthis.gradientDirection = mxUtils.getValue(this.style, mxConstants.STYLE_GRADIENT_DIRECTION, this.gradientDirection);\n\t\tthis.opacity = mxUtils.getValue(this.style, mxConstants.STYLE_OPACITY, this.opacity);\n\t\tthis.fillOpacity = mxUtils.getValue(this.style, mxConstants.STYLE_FILL_OPACITY, this.fillOpacity);\n\t\tthis.strokeOpacity = mxUtils.getValue(this.style, mxConstants.STYLE_STROKE_OPACITY, this.strokeOpacity);\n\t\tthis.stroke = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, this.stroke);\n\t\tthis.strokewidth = mxUtils.getNumber(this.style, mxConstants.STYLE_STROKEWIDTH, this.strokewidth);\n\t\tthis.spacing = mxUtils.getValue(this.style, mxConstants.STYLE_SPACING, this.spacing);\n\t\tthis.startSize = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, this.startSize);\n\t\tthis.endSize = mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, this.endSize);\n\t\tthis.startArrow = mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, this.startArrow);\n\t\tthis.endArrow = mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, this.endArrow);\n\t\tthis.rotation = mxUtils.getValue(this.style, mxConstants.STYLE_ROTATION, this.rotation);\n\t\tthis.direction = mxUtils.getValue(this.style, mxConstants.STYLE_DIRECTION, this.direction);\n\t\tthis.flipH = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, 0) == 1;\n\t\tthis.flipV = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, 0) == 1;\t\n\t\t\n\t\t// Legacy support for stencilFlipH/V\n\t\tif (this.stencil != null)\n\t\t{\n\t\t\tthis.flipH = mxUtils.getValue(this.style, 'stencilFlipH', 0) == 1 || this.flipH;\n\t\t\tthis.flipV = mxUtils.getValue(this.style, 'stencilFlipV', 0) == 1 || this.flipV;\n\t\t}\n\t\t\n\t\tif (this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH)\n\t\t{\n\t\t\tvar tmp = this.flipH;\n\t\t\tthis.flipH = this.flipV;\n\t\t\tthis.flipV = tmp;\n\t\t}\n\n\t\tthis.isShadow = mxUtils.getValue(this.style, mxConstants.STYLE_SHADOW, this.isShadow) == 1;\n\t\tthis.isDashed = mxUtils.getValue(this.style, mxConstants.STYLE_DASHED, this.isDashed) == 1;\n\t\tthis.isRounded = mxUtils.getValue(this.style, mxConstants.STYLE_ROUNDED, this.isRounded) == 1;\n\t\tthis.glass = mxUtils.getValue(this.style, mxConstants.STYLE_GLASS, this.glass) == 1;\n\t\t\n\t\tif (this.fill == mxConstants.NONE)\n\t\t{\n\t\t\tthis.fill = null;\n\t\t}\n\n\t\tif (this.gradient == mxConstants.NONE)\n\t\t{\n\t\t\tthis.gradient = null;\n\t\t}\n\n\t\tif (this.stroke == mxConstants.NONE)\n\t\t{\n\t\t\tthis.stroke = null;\n\t\t}\n\t}\n};\n\n/**\n * Function: setCursor\n * \n * Sets the cursor on the given shape.\n *\n * Parameters:\n *\n * cursor - The cursor to be used.\n */\nmxShape.prototype.setCursor = function(cursor)\n{\n\tif (cursor == null)\n\t{\n\t\tcursor = '';\n\t}\n\t\n\tthis.cursor = cursor;\n\n\tif (this.node != null)\n\t{\n\t\tthis.node.style.cursor = cursor;\n\t}\n};\n\n/**\n * Function: getCursor\n * \n * Returns the current cursor.\n */\nmxShape.prototype.getCursor = function()\n{\n\treturn this.cursor;\n};\n\n/**\n * Function: isRoundable\n * \n * Hook for subclassers.\n */\nmxShape.prototype.isRoundable = function()\n{\n\treturn false;\n};\n\n/**\n * Function: updateBoundingBox\n *\n * Updates the <boundingBox> for this shape using <createBoundingBox> and\n * <augmentBoundingBox> and stores the result in <boundingBox>.\n */\nmxShape.prototype.updateBoundingBox = function()\n{\n\t// Tries to get bounding box from SVG subsystem\n\t// LATER: Use getBoundingClientRect for fallback in VML\n\tif (this.useSvgBoundingBox && this.node != null && this.node.ownerSVGElement != null)\n\t{\n\t\ttry\n\t\t{\n\t\t\tvar b = this.node.getBBox();\n\t\n\t\t\tif (b.width > 0 && b.height > 0)\n\t\t\t{\n\t\t\t\tthis.boundingBox = new mxRectangle(b.x, b.y, b.width, b.height);\n\t\t\t\t\n\t\t\t\t// Adds strokeWidth\n\t\t\t\tthis.boundingBox.grow(this.strokewidth * this.scale / 2);\n\t\t\t\t\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch(e)\n\t\t{\n\t\t\t// fallback to code below\n\t\t}\n\t}\n\n\tif (this.bounds != null)\n\t{\n\t\tvar bbox = this.createBoundingBox();\n\t\t\n\t\tif (bbox != null)\n\t\t{\n\t\t\tthis.augmentBoundingBox(bbox);\n\t\t\tvar rot = this.getShapeRotation();\n\t\t\t\n\t\t\tif (rot != 0)\n\t\t\t{\n\t\t\t\tbbox = mxUtils.getBoundingBox(bbox, rot);\n\t\t\t}\n\t\t}\n\n\t\tthis.boundingBox = bbox;\n\t}\n};\n\n/**\n * Function: createBoundingBox\n *\n * Returns a new rectangle that represents the bounding box of the bare shape\n * with no shadows or strokewidths.\n */\nmxShape.prototype.createBoundingBox = function()\n{\n\tvar bb = this.bounds.clone();\n\n\tif ((this.stencil != null && (this.direction == mxConstants.DIRECTION_NORTH ||\n\t\tthis.direction == mxConstants.DIRECTION_SOUTH)) || this.isPaintBoundsInverted())\n\t{\n\t\tbb.rotate90();\n\t}\n\t\n\treturn bb;\n};\n\n/**\n * Function: augmentBoundingBox\n *\n * Augments the bounding box with the strokewidth and shadow offsets.\n */\nmxShape.prototype.augmentBoundingBox = function(bbox)\n{\n\tif (this.isShadow)\n\t{\n\t\tbbox.width += Math.ceil(mxConstants.SHADOW_OFFSET_X * this.scale);\n\t\tbbox.height += Math.ceil(mxConstants.SHADOW_OFFSET_Y * this.scale);\n\t}\n\t\n\t// Adds strokeWidth\n\tbbox.grow(this.strokewidth * this.scale / 2);\n};\n\n/**\n * Function: isPaintBoundsInverted\n * \n * Returns true if the bounds should be inverted.\n */\nmxShape.prototype.isPaintBoundsInverted = function()\n{\n\t// Stencil implements inversion via aspect\n\treturn this.stencil == null && (this.direction == mxConstants.DIRECTION_NORTH ||\n\t\t\tthis.direction == mxConstants.DIRECTION_SOUTH);\n};\n\n/**\n * Function: getRotation\n * \n * Returns the rotation from the style.\n */\nmxShape.prototype.getRotation = function()\n{\n\treturn (this.rotation != null) ? this.rotation : 0;\n};\n\n/**\n * Function: getTextRotation\n * \n * Returns the rotation for the text label.\n */\nmxShape.prototype.getTextRotation = function()\n{\n\tvar rot = this.getRotation();\n\t\n\tif (mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, 1) != 1)\n\t{\n\t\trot += mxText.prototype.verticalTextRotation;\n\t}\n\t\n\treturn rot;\n};\n\n/**\n * Function: getShapeRotation\n * \n * Returns the actual rotation of the shape.\n */\nmxShape.prototype.getShapeRotation = function()\n{\n\tvar rot = this.getRotation();\n\t\n\tif (this.direction != null)\n\t{\n\t\tif (this.direction == mxConstants.DIRECTION_NORTH)\n\t\t{\n\t\t\trot += 270;\n\t\t}\n\t\telse if (this.direction == mxConstants.DIRECTION_WEST)\n\t\t{\n\t\t\trot += 180;\n\t\t}\n\t\telse if (this.direction == mxConstants.DIRECTION_SOUTH)\n\t\t{\n\t\t\trot += 90;\n\t\t}\n\t}\n\t\n\treturn rot;\n};\n\n/**\n * Function: createTransparentSvgRectangle\n * \n * Adds a transparent rectangle that catches all events.\n */\nmxShape.prototype.createTransparentSvgRectangle = function(x, y, w, h)\n{\n\tvar rect = document.createElementNS(mxConstants.NS_SVG, 'rect');\n\trect.setAttribute('x', x);\n\trect.setAttribute('y', y);\n\trect.setAttribute('width', w);\n\trect.setAttribute('height', h);\n\trect.setAttribute('fill', 'none');\n\trect.setAttribute('stroke', 'none');\n\trect.setAttribute('pointer-events', 'all');\n\t\n\treturn rect;\n};\n\n/**\n * Function: setTransparentBackgroundImage\n * \n * Sets a transparent background CSS style to catch all events.\n * \n * Paints the line shape.\n */\nmxShape.prototype.setTransparentBackgroundImage = function(node)\n{\n\tnode.style.backgroundImage = 'url(\\'' + mxClient.imageBasePath + '/transparent.gif\\')';\n};\n\n/**\n * Function: releaseSvgGradients\n * \n * Paints the line shape.\n */\nmxShape.prototype.releaseSvgGradients = function(grads)\n{\n\tif (grads != null)\n\t{\n\t\tfor (var key in grads)\n\t\t{\n\t\t\tvar gradient = grads[key];\n\t\t\t\n\t\t\tif (gradient != null)\n\t\t\t{\n\t\t\t\tgradient.mxRefCount = (gradient.mxRefCount || 0) - 1;\n\t\t\t\t\n\t\t\t\tif (gradient.mxRefCount == 0 && gradient.parentNode != null)\n\t\t\t\t{\n\t\t\t\t\tgradient.parentNode.removeChild(gradient);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: destroy\n *\n * Destroys the shape by removing it from the DOM and releasing the DOM\n * node associated with the shape using <mxEvent.release>.\n */\nmxShape.prototype.destroy = function()\n{\n\tif (this.node != null)\n\t{\n\t\tmxEvent.release(this.node);\n\t\t\n\t\tif (this.node.parentNode != null)\n\t\t{\n\t\t\tthis.node.parentNode.removeChild(this.node);\n\t\t}\n\t\t\n\t\tthis.node = null;\n\t}\n\t\n\t// Decrements refCount and removes unused\n\tthis.releaseSvgGradients(this.oldGradients);\n\tthis.oldGradients = null;\n};\n\n__mxOutput.mxShape = typeof mxShape !== 'undefined' ? mxShape : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxStencil\n *\n * Implements a generic shape which is based on a XML node as a description.\n * \n * shape:\n * \n * The outer element is *shape*, that has attributes:\n * \n * - \"name\", string, required. The stencil name that uniquely identifies the shape.\n * - \"w\" and \"h\" are optional decimal view bounds. This defines your co-ordinate\n * system for the graphics operations in the shape. The default is 100,100.\n * - \"aspect\", optional string. Either \"variable\", the default, or \"fixed\". Fixed\n * means always render the shape with the aspect ratio defined by the ratio w/h.\n * Variable causes the ratio to match that of the geometry of the current vertex.\n * - \"strokewidth\", optional string. Either an integer or the string \"inherit\".\n * \"inherit\" indicates that the strokeWidth of the cell is only changed on scaling,\n * not on resizing. Default is \"1\".\n * If numeric values are used, the strokeWidth of the cell is changed on both\n * scaling and resizing and the value defines the multiple that is applied to\n * the width.\n * \n * connections:\n * \n * If you want to define specific fixed connection points on the shape use the\n * *connections* element. Each *constraint* element within connections defines\n * a fixed connection point on the shape. Constraints have attributes:\n * \n * - \"perimeter\", required. 1 or 0. 0 sets the connection point where specified\n * by x,y. 1 Causes the position of the connection point to be extrapolated from\n * the center of the shape, through x,y to the point of intersection with the\n * perimeter of the shape.\n * - \"x\" and \"y\" are the position of the fixed point relative to the bounds of\n * the shape. They can be automatically adjusted if perimeter=1. So, (0,0) is top\n * left, (0.5,0.5) the center, (1,0.5) the center of the right hand edge of the\n * bounds, etc. Values may be less than 0 or greater than 1 to be positioned\n * outside of the shape.\n * - \"name\", optional string. A unique identifier for the port on the shape.\n * \n * background and foreground:\n * \n * The path of the graphics drawing is split into two elements, *foreground* and\n * *background*. The split is to define which part any shadow applied to the shape\n * is derived from (the background). This, generally, means the background is the\n * line tracing of the outside of the shape, but not always.\n * \n * Any stroke, fill or fillstroke of a background must be the first element of the\n * foreground element, they must not be used within *background*. If the background\n * is empty, this is not required.\n * \n * Because the background cannot have any fill or stroke, it can contain only one\n * *path*, *rect*, *roundrect* or *ellipse* element (or none). It can also not\n * include *image*, *text* or *include-shape*.\n * \n * Note that the state, styling and drawing in mxGraph stencils is very close in\n * design to that of HTML 5 canvas. Tutorials on this subject, if you're not\n * familiar with the topic, will give a good high-level introduction to the\n * concepts used.\n * \n * State:\n * \n * Rendering within the foreground and background elements has the concept of\n * state. There are two types of operations other than state save/load, styling\n * and drawing. The styling operations change the current state, so you can save\n * the current state with <save/> and pull the last saved state from the state\n * stack using <restore/>.\n * \n * Styling:\n * \n * The elements that change colors within the current state all take a hash\n * prefixed hex color code (\"#FFEA80\").\n * \n * - *strokecolor*, this sets the color that drawing paths will be rendered in\n * when a stroke or fillstroke command is issued.\n * - *fillcolor*, this sets the color that the inside of closed paths will be\n * rendered in when a fill or fillstroke command is issued.\n * - *fontcolor*, this sets the color that fonts are rendered in when text is drawn.\n * \n * *alpha* defines the degree of transparency used between 1.0 for fully opaque\n * and 0.0 for fully transparent.\n * \n * *fillalpha* defines the degree of fill transparency used between 1.0 for fully\n * opaque and 0.0 for fully transparent.\n * \n * *strokealpha* defines the degree of stroke transparency used between 1.0 for\n * fully opaque and 0.0 for fully transparent.\n * \n * *strokewidth* defines the integer thickness of drawing elements rendered by\n * stroking. Use fixed=\"1\" to apply the value as-is, without scaling.\n * \n * *dashed* is \"1\" for dashing enabled and \"0\" for disabled.\n * \n * When *dashed* is enabled the current dash pattern, defined by *dashpattern*,\n * is used on strokes. dashpattern is a sequence of space separated \"on, off\"\n * lengths that define what distance to paint the stroke for, then what distance\n * to paint nothing for, repeat... The default is \"3 3\". You could define a more\n * complex pattern with \"5 3 2 6\", for example. Generally, it makes sense to have\n * an even number of elements in the dashpattern, but that's not required.\n * \n * *linejoin*, *linecap* and *miterlimit* are best explained by the Mozilla page\n * on Canvas styling (about halfway down). The values are all the same except we\n * use \"flat\" for linecap, instead of Canvas' \"butt\".\n * \n * For font styling there are.\n * \n * - *fontsize*, an integer,\n * - *fontstyle*, an ORed bit pattern of bold (1), italic (2) and underline (4),\n * i.e bold underline is \"5\".\n * - *fontfamily*, is a string defining the typeface to be used.\n * \n * Drawing:\n * \n * Most drawing is contained within a *path* element. Again, the graphic\n * primitives are very similar to that of HTML 5 canvas.\n * \n * - *move* to attributes required decimals (x,y).\n * - *line* to attributes required decimals (x,y).\n * - *quad* to required decimals (x2,y2) via control point required decimals\n * (x1,y1).\n * - *curve* to required decimals (x3,y3), via control points required decimals\n * (x1,y1) and (x2,y2).\n * - *arc*, this doesn't follow the HTML Canvas signatures, instead it's a copy\n * of the SVG arc command. The SVG specification documentation gives the best\n * description of its behaviors. The attributes are named identically, they are\n * decimals and all required.\n * - *close* ends the current subpath and causes an automatic straight line to\n * be drawn from the current point to the initial point of the current subpath.\n * \n * Complex drawing:\n * \n * In addition to the graphics primitive operations there are non-primitive\n * operations. These provide an easy method to draw some basic shapes.\n * \n * - *rect*, attributes \"x\", \"y\", \"w\", \"h\", all required decimals\n * - *roundrect*, attributes \"x\", \"y\", \"w\", \"h\", all required decimals. Also\n * \"arcsize\" an optional decimal attribute defining how large, the corner curves\n * are.\n * - *ellipse*, attributes \"x\", \"y\", \"w\", \"h\", all required decimals.\n * \n * Note that these 3 shapes and all paths must be followed by either a fill,\n * stroke, or fillstroke.\n * \n * Text:\n * \n * *text* elements have the following attributes.\n * \n * - \"str\", the text string to display, required.\n * - \"x\" and \"y\", the decimal location (x,y) of the text element, required.\n * - \"align\", the horizontal alignment of the text element, either \"left\",\n * \"center\" or \"right\". Optional, default is \"left\".\n * - \"valign\", the vertical alignment of the text element, either \"top\", \"middle\"\n * or \"bottom\". Optional, default is \"top\".\n * - \"localized\", 0 or 1, if 1 then the \"str\" actually contains a key to use to\n * fetch the value out of mxResources. Optional, default is\n * <mxStencil.defaultLocalized>.\n * - \"vertical\", 0 or 1, if 1 the label is rendered vertically (rotated by 90\n * degrees). Optional, default is 0.\n * - \"rotation\", angle in degrees (0 to 360). The angle to rotate the text by.\n * Optional, default is 0.\n * - \"align-shape\", 0 or 1, if 0 ignore the rotation of the shape when setting\n * the text rotation. Optional, default is 1.\n * \n * If <allowEval> is true, then the text content of the this element can define\n * a function which is invoked with the shape as the only argument and returns\n * the value for the text element (ignored if the str attribute is not null).\n * \n * Images:\n * \n * *image* elements can either be external URLs, or data URIs, where supported\n * (not in IE 7-). Attributes are:\n * \n * - \"src\", required string. Either a data URI or URL.\n * - \"x\", \"y\", required decimals. The (x,y) position of the image.\n * - \"w\", \"h\", required decimals. The width and height of the image.\n * - \"flipH\" and \"flipV\", optional 0 or 1. Whether to flip the image along the\n * horizontal/vertical axis. Default is 0 for both.\n * \n * If <allowEval> is true, then the text content of the this element can define\n * a function which is invoked with the shape as the only argument and returns\n * the value for the image source (ignored if the src attribute is not null).\n * \n * Sub-shapes:\n * \n * *include-shape* allow stencils to be rendered within the current stencil by\n * referencing the sub-stencil by name. Attributes are:\n * \n * - \"name\", required string. The unique shape name of the stencil.\n * - \"x\", \"y\", \"w\", \"h\", required decimals. The (x,y) position of the sub-shape\n * and its width and height.\n * \n * Constructor: mxStencil\n * \n * Constructs a new generic shape by setting <desc> to the given XML node and\n * invoking <parseDescription> and <parseConstraints>.\n * \n * Parameters:\n * \n * desc - XML node that contains the stencil description.\n */\nfunction mxStencil(desc)\n{\n\tthis.desc = desc;\n\tthis.parseDescription();\n\tthis.parseConstraints();\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxStencil, mxShape);\n\n/**\n * Variable: defaultLocalized\n * \n * Static global variable that specifies the default value for the localized\n * attribute of the text element. Default is false.\n */\nmxStencil.defaultLocalized = false;\n\n/**\n * Function: allowEval\n * \n * Static global switch that specifies if the use of eval is allowed for\n * evaluating text content and images. Default is false. Set this to true\n * if stencils can not contain user input.\n */\nmxStencil.allowEval = false;\n\n/**\n * Variable: desc\n *\n * Holds the XML node with the stencil description.\n */\nmxStencil.prototype.desc = null;\n\n/**\n * Variable: constraints\n * \n * Holds an array of <mxConnectionConstraints> as defined in the shape.\n */\nmxStencil.prototype.constraints = null;\n\n/**\n * Variable: aspect\n *\n * Holds the aspect of the shape. Default is 'auto'.\n */\nmxStencil.prototype.aspect = null;\n\n/**\n * Variable: w0\n *\n * Holds the width of the shape. Default is 100.\n */\nmxStencil.prototype.w0 = null;\n\n/**\n * Variable: h0\n *\n * Holds the height of the shape. Default is 100.\n */\nmxStencil.prototype.h0 = null;\n\n/**\n * Variable: bgNodes\n *\n * Holds the XML node with the stencil description.\n */\nmxStencil.prototype.bgNode = null;\n\n/**\n * Variable: fgNodes\n *\n * Holds the XML node with the stencil description.\n */\nmxStencil.prototype.fgNode = null;\n\n/**\n * Variable: strokewidth\n *\n * Holds the strokewidth direction from the description.\n */\nmxStencil.prototype.strokewidth = null;\n\n/**\n * Function: parseDescription\n *\n * Reads <w0>, <h0>, <aspect>, <bgNodes> and <fgNodes> from <desc>.\n */\nmxStencil.prototype.parseDescription = function()\n{\n\t// LATER: Preprocess nodes for faster painting\n\tthis.fgNode = this.desc.getElementsByTagName('foreground')[0];\n\tthis.bgNode = this.desc.getElementsByTagName('background')[0];\n\tthis.w0 = Number(this.desc.getAttribute('w') || 100);\n\tthis.h0 = Number(this.desc.getAttribute('h') || 100);\n\t\n\t// Possible values for aspect are: variable and fixed where\n\t// variable means fill the available space and fixed means\n\t// use w0 and h0 to compute the aspect.\n\tvar aspect = this.desc.getAttribute('aspect');\n\tthis.aspect = (aspect != null) ? aspect : 'variable';\n\t\n\t// Possible values for strokewidth are all numbers and \"inherit\"\n\t// where the inherit means take the value from the style (ie. the\n\t// user-defined stroke-width). Note that the strokewidth is scaled\n\t// by the minimum scaling that is used to draw the shape (sx, sy).\n\tvar sw = this.desc.getAttribute('strokewidth');\n\tthis.strokewidth = (sw != null) ? sw : '1';\n};\n\n/**\n * Function: parseConstraints\n *\n * Reads the constraints from <desc> into <constraints> using\n * <parseConstraint>.\n */\nmxStencil.prototype.parseConstraints = function()\n{\n\tvar conns = this.desc.getElementsByTagName('connections')[0];\n\t\n\tif (conns != null)\n\t{\n\t\tvar tmp = mxUtils.getChildNodes(conns);\n\t\t\n\t\tif (tmp != null && tmp.length > 0)\n\t\t{\n\t\t\tthis.constraints = [];\n\t\t\t\n\t\t\tfor (var i = 0; i < tmp.length; i++)\n\t\t\t{\n\t\t\t\tthis.constraints.push(this.parseConstraint(tmp[i]));\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: parseConstraint\n *\n * Parses the given XML node and returns its <mxConnectionConstraint>.\n */\nmxStencil.prototype.parseConstraint = function(node)\n{\n\tvar x = Number(node.getAttribute('x'));\n\tvar y = Number(node.getAttribute('y'));\n\tvar perimeter = node.getAttribute('perimeter') == '1';\n\tvar name = node.getAttribute('name');\n\t\n\treturn new mxConnectionConstraint(new mxPoint(x, y), perimeter, name);\n};\n\n/**\n * Function: evaluateTextAttribute\n * \n * Gets the given attribute as a text. The return value from <evaluateAttribute>\n * is used as a key to <mxResources.get> if the localized attribute in the text\n * node is 1 or if <defaultLocalized> is true.\n */\nmxStencil.prototype.evaluateTextAttribute = function(node, attribute, shape)\n{\n\tvar result = this.evaluateAttribute(node, attribute, shape);\n\tvar loc = node.getAttribute('localized');\n\t\n\tif ((mxStencil.defaultLocalized && loc == null) || loc == '1')\n\t{\n\t\tresult = mxResources.get(result);\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: evaluateAttribute\n *\n * Gets the attribute for the given name from the given node. If the attribute\n * does not exist then the text content of the node is evaluated and if it is\n * a function it is invoked with <shape> as the only argument and the return\n * value is used as the attribute value to be returned.\n */\nmxStencil.prototype.evaluateAttribute = function(node, attribute, shape)\n{\n\tvar result = node.getAttribute(attribute);\n\t\n\tif (result == null)\n\t{\n\t\tvar text = mxUtils.getTextContent(node);\n\t\t\n\t\tif (text != null && mxStencil.allowEval)\n\t\t{\n\t\t\tvar funct = mxUtils.eval(text);\n\t\t\t\n\t\t\tif (typeof(funct) == 'function')\n\t\t\t{\n\t\t\t\tresult = funct(shape);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: drawShape\n *\n * Draws this stencil inside the given bounds.\n */\nmxStencil.prototype.drawShape = function(canvas, shape, x, y, w, h)\n{\n\tvar stack = canvas.states.slice();\n\t\n\t// TODO: Internal structure (array of special structs?), relative and absolute\n\t// coordinates (eg. note shape, process vs star, actor etc.), text rendering\n\t// and non-proportional scaling, how to implement pluggable edge shapes\n\t// (start, segment, end blocks), pluggable markers, how to implement\n\t// swimlanes (title area) with this API, add icon, horizontal/vertical\n\t// label, indicator for all shapes, rotation\n\tvar direction = mxUtils.getValue(shape.style, mxConstants.STYLE_DIRECTION, null);\n\tvar aspect = this.computeAspect(shape.style, x, y, w, h, direction);\n\tvar minScale = Math.min(aspect.width, aspect.height);\n\tvar sw = (this.strokewidth == 'inherit') ?\n\t\t\tNumber(mxUtils.getNumber(shape.style, mxConstants.STYLE_STROKEWIDTH, 1)) :\n\t\t\tNumber(this.strokewidth) * minScale;\n\tcanvas.setStrokeWidth(sw);\n\n\t// Draws a transparent rectangle for catching events\n\tif (shape.style != null && mxUtils.getValue(shape.style, mxConstants.STYLE_POINTER_EVENTS, '0') == '1')\n\t{\n\t\tcanvas.setStrokeColor(mxConstants.NONE);\n\t\tcanvas.rect(x, y, w, h);\n\t\tcanvas.stroke();\n\t\tcanvas.setStrokeColor(shape.stroke);\n\t}\n\n\tthis.drawChildren(canvas, shape, x, y, w, h, this.bgNode, aspect, false, true);\n\tthis.drawChildren(canvas, shape, x, y, w, h, this.fgNode, aspect, true,\n\t\t!shape.outline || shape.style == null || mxUtils.getValue(\n\t\tshape.style, mxConstants.STYLE_BACKGROUND_OUTLINE, 0) == 0);\n\t\n\t// Restores stack for unequal count of save/restore calls\n\tif (canvas.states.length != stack.length)\n\t{\n\t\tcanvas.states = stack;\n\t}\n};\n\n/**\n * Function: drawChildren\n *\n * Draws this stencil inside the given bounds.\n */\nmxStencil.prototype.drawChildren = function(canvas, shape, x, y, w, h, node, aspect, disableShadow, paint)\n{\n\tif (node != null && w > 0 && h > 0)\n\t{\n\t\tvar tmp = node.firstChild;\n\t\t\n\t\twhile (tmp != null)\n\t\t{\n\t\t\tif (tmp.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t\t{\n\t\t\t\tthis.drawNode(canvas, shape, tmp, aspect, disableShadow, paint);\n\t\t\t}\n\t\t\t\n\t\t\ttmp = tmp.nextSibling;\n\t\t}\n\t}\n};\n\n/**\n * Function: computeAspect\n *\n * Returns a rectangle that contains the offset in x and y and the horizontal\n * and vertical scale in width and height used to draw this shape inside the\n * given <mxRectangle>.\n * \n * Parameters:\n * \n * shape - <mxShape> to be drawn.\n * bounds - <mxRectangle> that should contain the stencil.\n * direction - Optional direction of the shape to be darwn.\n */\nmxStencil.prototype.computeAspect = function(shape, x, y, w, h, direction)\n{\n\tvar x0 = x;\n\tvar y0 = y;\n\tvar sx = w / this.w0;\n\tvar sy = h / this.h0;\n\t\n\tvar inverse = (direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH);\n\n\tif (inverse)\n\t{\n\t\tsy = w / this.h0;\n\t\tsx = h / this.w0;\n\t\t\n\t\tvar delta = (w - h) / 2;\n\n\t\tx0 += delta;\n\t\ty0 -= delta;\n\t}\n\n\tif (this.aspect == 'fixed')\n\t{\n\t\tsy = Math.min(sx, sy);\n\t\tsx = sy;\n\t\t\n\t\t// Centers the shape inside the available space\n\t\tif (inverse)\n\t\t{\n\t\t\tx0 += (h - this.w0 * sx) / 2;\n\t\t\ty0 += (w - this.h0 * sy) / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tx0 += (w - this.w0 * sx) / 2;\n\t\t\ty0 += (h - this.h0 * sy) / 2;\n\t\t}\n\t}\n\n\treturn new mxRectangle(x0, y0, sx, sy);\n};\n\n/**\n * Function: drawNode\n *\n * Draws this stencil inside the given bounds.\n */\nmxStencil.prototype.drawNode = function(canvas, shape, node, aspect, disableShadow, paint)\n{\n\tvar name = node.nodeName;\n\tvar x0 = aspect.x;\n\tvar y0 = aspect.y;\n\tvar sx = aspect.width;\n\tvar sy = aspect.height;\n\tvar minScale = Math.min(sx, sy);\n\t\n\tif (name == 'save')\n\t{\n\t\tcanvas.save();\n\t}\n\telse if (name == 'restore')\n\t{\n\t\tcanvas.restore();\n\t}\n\telse if (paint)\n\t{\n\t\tif (name == 'path')\n\t\t{\n\t\t\tcanvas.begin();\n\t\t\t\n\t\t\tvar parseRegularly = true;\n\t\t\t\n\t\t\tif (node.getAttribute('rounded') == '1')\n\t\t\t{\n\t\t\t\tparseRegularly = false;\n\t\t\t\t\n\t\t\t\tvar arcSize = Number(node.getAttribute('arcSize'));\n\t\t\t\tvar pointCount = 0;\n\t\t\t\tvar segs = [];\n\t\t\t\t\n\t\t\t\t// Renders the elements inside the given path\n\t\t\t\tvar childNode = node.firstChild;\n\t\t\t\t\n\t\t\t\twhile (childNode != null)\n\t\t\t\t{\n\t\t\t\t\tif (childNode.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar childName = childNode.nodeName;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (childName == 'move' || childName == 'line')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (childName == 'move' || segs.length == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsegs.push([]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tsegs[segs.length - 1].push(new mxPoint(x0 + Number(childNode.getAttribute('x')) * sx,\n\t\t\t\t\t\t\t\ty0 + Number(childNode.getAttribute('y')) * sy));\n\t\t\t\t\t\t\tpointCount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//We only support move and line for rounded corners\n\t\t\t\t\t\t\tparseRegularly = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tchildNode = childNode.nextSibling;\n\t\t\t\t}\n\n\t\t\t\tif (!parseRegularly && pointCount > 0)\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < segs.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar close = false, ps = segs[i][0], pe = segs[i][segs[i].length - 1];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (ps.x == pe.x && ps.y == pe.y) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsegs[i].pop();\n\t\t\t\t\t\t\tclose = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.addPoints(canvas, segs[i], true, arcSize, close);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparseRegularly = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (parseRegularly)\n\t\t\t{\n\t\t\t\t// Renders the elements inside the given path\n\t\t\t\tvar childNode = node.firstChild;\n\t\t\t\t\n\t\t\t\twhile (childNode != null)\n\t\t\t\t{\n\t\t\t\t\tif (childNode.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.drawNode(canvas, shape, childNode, aspect, disableShadow, paint);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tchildNode = childNode.nextSibling;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (name == 'close')\n\t\t{\n\t\t\tcanvas.close();\n\t\t}\n\t\telse if (name == 'move')\n\t\t{\n\t\t\tcanvas.moveTo(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy);\n\t\t}\n\t\telse if (name == 'line')\n\t\t{\n\t\t\tcanvas.lineTo(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy);\n\t\t}\n\t\telse if (name == 'quad')\n\t\t{\n\t\t\tcanvas.quadTo(x0 + Number(node.getAttribute('x1')) * sx,\n\t\t\t\t\ty0 + Number(node.getAttribute('y1')) * sy,\n\t\t\t\t\tx0 + Number(node.getAttribute('x2')) * sx,\n\t\t\t\t\ty0 + Number(node.getAttribute('y2')) * sy);\n\t\t}\n\t\telse if (name == 'curve')\n\t\t{\n\t\t\tcanvas.curveTo(x0 + Number(node.getAttribute('x1')) * sx,\n\t\t\t\t\ty0 + Number(node.getAttribute('y1')) * sy,\n\t\t\t\t\tx0 + Number(node.getAttribute('x2')) * sx,\n\t\t\t\t\ty0 + Number(node.getAttribute('y2')) * sy,\n\t\t\t\t\tx0 + Number(node.getAttribute('x3')) * sx,\n\t\t\t\t\ty0 + Number(node.getAttribute('y3')) * sy);\n\t\t}\n\t\telse if (name == 'arc')\n\t\t{\n\t\t\tcanvas.arcTo(Number(node.getAttribute('rx')) * sx,\n\t\t\t\t\tNumber(node.getAttribute('ry')) * sy,\n\t\t\t\t\tNumber(node.getAttribute('x-axis-rotation')),\n\t\t\t\t\tNumber(node.getAttribute('large-arc-flag')),\n\t\t\t\t\tNumber(node.getAttribute('sweep-flag')),\n\t\t\t\t\tx0 + Number(node.getAttribute('x')) * sx,\n\t\t\t\t\ty0 + Number(node.getAttribute('y')) * sy);\n\t\t}\n\t\telse if (name == 'rect')\n\t\t{\n\t\t\tcanvas.rect(x0 + Number(node.getAttribute('x')) * sx,\n\t\t\t\t\ty0 + Number(node.getAttribute('y')) * sy,\n\t\t\t\t\tNumber(node.getAttribute('w')) * sx,\n\t\t\t\t\tNumber(node.getAttribute('h')) * sy);\n\t\t}\n\t\telse if (name == 'roundrect')\n\t\t{\n\t\t\tvar arcsize = Number(node.getAttribute('arcsize'));\n\t\n\t\t\tif (arcsize == 0)\n\t\t\t{\n\t\t\t\tarcsize = mxConstants.RECTANGLE_ROUNDING_FACTOR * 100;\n\t\t\t}\n\t\t\t\n\t\t\tvar w = Number(node.getAttribute('w')) * sx;\n\t\t\tvar h = Number(node.getAttribute('h')) * sy;\n\t\t\tvar factor = Number(arcsize) / 100;\n\t\t\tvar r = Math.min(w * factor, h * factor);\n\t\t\t\n\t\t\tcanvas.roundrect(x0 + Number(node.getAttribute('x')) * sx,\n\t\t\t\t\ty0 + Number(node.getAttribute('y')) * sy,\n\t\t\t\t\tw, h, r, r);\n\t\t}\n\t\telse if (name == 'ellipse')\n\t\t{\n\t\t\tcanvas.ellipse(x0 + Number(node.getAttribute('x')) * sx,\n\t\t\t\ty0 + Number(node.getAttribute('y')) * sy,\n\t\t\t\tNumber(node.getAttribute('w')) * sx,\n\t\t\t\tNumber(node.getAttribute('h')) * sy);\n\t\t}\n\t\telse if (name == 'image')\n\t\t{\n\t\t\tif (!shape.outline)\n\t\t\t{\n\t\t\t\tvar src = this.evaluateAttribute(node, 'src', shape);\n\t\t\t\t\n\t\t\t\tcanvas.image(x0 + Number(node.getAttribute('x')) * sx,\n\t\t\t\t\ty0 + Number(node.getAttribute('y')) * sy,\n\t\t\t\t\tNumber(node.getAttribute('w')) * sx,\n\t\t\t\t\tNumber(node.getAttribute('h')) * sy,\n\t\t\t\t\tsrc, false, node.getAttribute('flipH') == '1',\n\t\t\t\t\tnode.getAttribute('flipV') == '1');\n\t\t\t}\n\t\t}\n\t\telse if (name == 'text')\n\t\t{\n\t\t\tif (!shape.outline)\n\t\t\t{\n\t\t\t\tvar str = this.evaluateTextAttribute(node, 'str', shape);\n\t\t\t\tvar rotation = node.getAttribute('vertical') == '1' ? -90 : 0;\n\t\t\t\t\n\t\t\t\tif (node.getAttribute('align-shape') == '0')\n\t\t\t\t{\n\t\t\t\t\tvar dr = shape.rotation;\n\t\t\n\t\t\t\t\t// Depends on flipping\n\t\t\t\t\tvar flipH = mxUtils.getValue(shape.style, mxConstants.STYLE_FLIPH, 0) == 1;\n\t\t\t\t\tvar flipV = mxUtils.getValue(shape.style, mxConstants.STYLE_FLIPV, 0) == 1;\n\t\t\t\t\t\n\t\t\t\t\tif (flipH && flipV)\n\t\t\t\t\t{\n\t\t\t\t\t\trotation -= dr;\n\t\t\t\t\t}\n\t\t\t\t\telse if (flipH || flipV)\n\t\t\t\t\t{\n\t\t\t\t\t\trotation += dr;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\trotation -= dr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n\t\t\t\trotation -= node.getAttribute('rotation');\n\t\t\n\t\t\t\tcanvas.text(x0 + Number(node.getAttribute('x')) * sx,\n\t\t\t\t\t\ty0 + Number(node.getAttribute('y')) * sy,\n\t\t\t\t\t\t0, 0, str, node.getAttribute('align') || 'left',\n\t\t\t\t\t\tnode.getAttribute('valign') || 'top', false, '',\n\t\t\t\t\t\tnull, false, rotation);\n\t\t\t}\n\t\t}\n\t\telse if (name == 'include-shape')\n\t\t{\n\t\t\tvar stencil = mxStencilRegistry.getStencil(node.getAttribute('name'));\n\t\t\t\n\t\t\tif (stencil != null)\n\t\t\t{\n\t\t\t\tvar x = x0 + Number(node.getAttribute('x')) * sx;\n\t\t\t\tvar y = y0 + Number(node.getAttribute('y')) * sy;\n\t\t\t\tvar w = Number(node.getAttribute('w')) * sx;\n\t\t\t\tvar h = Number(node.getAttribute('h')) * sy;\n\t\t\t\t\n\t\t\t\tstencil.drawShape(canvas, shape, x, y, w, h);\n\t\t\t}\n\t\t}\n\t\telse if (name == 'fillstroke')\n\t\t{\n\t\t\tcanvas.fillAndStroke();\n\t\t}\n\t\telse if (name == 'fill')\n\t\t{\n\t\t\tcanvas.fill();\n\t\t}\n\t\telse if (name == 'stroke')\n\t\t{\n\t\t\tcanvas.stroke();\n\t\t}\n\t\telse if (name == 'strokewidth')\n\t\t{\n\t\t\tvar s = (node.getAttribute('fixed') == '1') ? 1 : minScale;\n\t\t\tcanvas.setStrokeWidth(Number(node.getAttribute('width')) * s);\n\t\t}\n\t\telse if (name == 'dashed')\n\t\t{\n\t\t\tcanvas.setDashed(node.getAttribute('dashed') == '1');\n\t\t}\n\t\telse if (name == 'dashpattern')\n\t\t{\n\t\t\tvar value = node.getAttribute('pattern');\n\t\t\t\n\t\t\tif (value != null)\n\t\t\t{\n\t\t\t\tvar tmp = value.split(' ');\n\t\t\t\tvar pat = [];\n\t\t\t\t\n\t\t\t\tfor (var i = 0; i < tmp.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (tmp[i].length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tpat.push(Number(tmp[i]) * minScale);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvalue = pat.join(' ');\n\t\t\t\tcanvas.setDashPattern(value);\n\t\t\t}\n\t\t}\n\t\telse if (name == 'strokecolor')\n\t\t{\n\t\t\tcanvas.setStrokeColor(node.getAttribute('color'));\n\t\t}\n\t\telse if (name == 'linecap')\n\t\t{\n\t\t\tcanvas.setLineCap(node.getAttribute('cap'));\n\t\t}\n\t\telse if (name == 'linejoin')\n\t\t{\n\t\t\tcanvas.setLineJoin(node.getAttribute('join'));\n\t\t}\n\t\telse if (name == 'miterlimit')\n\t\t{\n\t\t\tcanvas.setMiterLimit(Number(node.getAttribute('limit')));\n\t\t}\n\t\telse if (name == 'fillcolor')\n\t\t{\n\t\t\tcanvas.setFillColor(node.getAttribute('color'));\n\t\t}\n\t\telse if (name == 'alpha')\n\t\t{\n\t\t\tcanvas.setAlpha(node.getAttribute('alpha'));\n\t\t}\n\t\telse if (name == 'fillalpha')\n\t\t{\n\t\t\tcanvas.setAlpha(node.getAttribute('alpha'));\n\t\t}\n\t\telse if (name == 'strokealpha')\n\t\t{\n\t\t\tcanvas.setAlpha(node.getAttribute('alpha'));\n\t\t}\n\t\telse if (name == 'fontcolor')\n\t\t{\n\t\t\tcanvas.setFontColor(node.getAttribute('color'));\n\t\t}\n\t\telse if (name == 'fontstyle')\n\t\t{\n\t\t\tcanvas.setFontStyle(node.getAttribute('style'));\n\t\t}\n\t\telse if (name == 'fontfamily')\n\t\t{\n\t\t\tcanvas.setFontFamily(node.getAttribute('family'));\n\t\t}\n\t\telse if (name == 'fontsize')\n\t\t{\n\t\t\tcanvas.setFontSize(Number(node.getAttribute('size')) * minScale);\n\t\t}\n\t\t\n\t\tif (disableShadow && (name == 'fillstroke' || name == 'fill' || name == 'stroke'))\n\t\t{\n\t\t\tdisableShadow = false;\n\t\t\tcanvas.setShadow(false);\n\t\t}\n\t}\n};\n\n__mxOutput.mxStencil = typeof mxStencil !== 'undefined' ? mxStencil : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n * \n * Code to add stencils.\n * \n * (code)\n * var req = mxUtils.load('test/stencils.xml');\n * var root = req.getDocumentElement();\n * var shape = root.firstChild;\n * \n * while (shape != null)\n * {\n * \t if (shape.nodeType == mxConstants.NODETYPE_ELEMENT)\n *   {\n *     mxStencilRegistry.addStencil(shape.getAttribute('name'), new mxStencil(shape));\n *   }\n *   \n *   shape = shape.nextSibling;\n * }\n * (end)\n */\nvar mxStencilRegistry =\n{\n\t/**\n\t * Class: mxStencilRegistry\n\t * \n\t * A singleton class that provides a registry for stencils and the methods\n\t * for painting those stencils onto a canvas or into a DOM.\n\t */\n\tstencils: {},\n\t\n\t/**\n\t * Function: addStencil\n\t * \n\t * Adds the given <mxStencil>.\n\t */\n\taddStencil: function(name, stencil)\n\t{\n\t\tmxStencilRegistry.stencils[name] = stencil;\n\t},\n\t\n\t/**\n\t * Function: getStencil\n\t * \n\t * Returns the <mxStencil> for the given name.\n\t */\n\tgetStencil: function(name)\n\t{\n\t\treturn mxStencilRegistry.stencils[name];\n\t}\n\n};\n\n__mxOutput.mxStencilRegistry = typeof mxStencilRegistry !== 'undefined' ? mxStencilRegistry : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxMarker =\n{\n\t/**\n\t * Class: mxMarker\n\t * \n\t * A static class that implements all markers for VML and SVG using a\n\t * registry. NOTE: The signatures in this class will change.\n\t * \n\t * Variable: markers\n\t * \n\t * Maps from markers names to functions to paint the markers.\n\t */\n\tmarkers: [],\n\t\n\t/**\n\t * Function: addMarker\n\t * \n\t * Adds a factory method that updates a given endpoint and returns a\n\t * function to paint the marker onto the given canvas.\n\t */\n\taddMarker: function(type, funct)\n\t{\n\t\tmxMarker.markers[type] = funct;\n\t},\n\t\n\t/**\n\t * Function: createMarker\n\t * \n\t * Returns a function to paint the given marker.\n\t */\n\tcreateMarker: function(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled)\n\t{\n\t\tvar funct = mxMarker.markers[type];\n\t\t\n\t\treturn (funct != null) ? funct(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) : null;\n\t}\n\n};\n\n/**\n * Adds the classic and block marker factory method.\n */\n(function()\n{\n\tfunction createArrow(widthFactor)\n\t{\n\t\twidthFactor = (widthFactor != null) ? widthFactor : 2;\n\t\t\n\t\treturn function(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled)\n\t\t{\n\t\t\t// The angle of the forward facing arrow sides against the x axis is\n\t\t\t// 26.565 degrees, 1/sin(26.565) = 2.236 / 2 = 1.118 ( / 2 allows for\n\t\t\t// only half the strokewidth is processed ).\n\t\t\tvar endOffsetX = unitX * sw * 1.118;\n\t\t\tvar endOffsetY = unitY * sw * 1.118;\n\t\t\t\n\t\t\tunitX = unitX * (size + sw);\n\t\t\tunitY = unitY * (size + sw);\n\t\n\t\t\tvar pt = pe.clone();\n\t\t\tpt.x -= endOffsetX;\n\t\t\tpt.y -= endOffsetY;\n\t\t\t\n\t\t\tvar f = (type != mxConstants.ARROW_CLASSIC && type != mxConstants.ARROW_CLASSIC_THIN) ? 1 : 3 / 4;\n\t\t\tpe.x += -unitX * f - endOffsetX;\n\t\t\tpe.y += -unitY * f - endOffsetY;\n\t\t\t\n\t\t\treturn function()\n\t\t\t{\n\t\t\t\tcanvas.begin();\n\t\t\t\tcanvas.moveTo(pt.x, pt.y);\n\t\t\t\tcanvas.lineTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);\n\t\t\t\n\t\t\t\tif (type == mxConstants.ARROW_CLASSIC || type == mxConstants.ARROW_CLASSIC_THIN)\n\t\t\t\t{\n\t\t\t\t\tcanvas.lineTo(pt.x - unitX * 3 / 4, pt.y - unitY * 3 / 4);\n\t\t\t\t}\n\t\t\t\n\t\t\t\tcanvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);\n\t\t\t\tcanvas.close();\n\t\n\t\t\t\tif (filled)\n\t\t\t\t{\n\t\t\t\t\tcanvas.fillAndStroke();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcanvas.stroke();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n\t\n\tmxMarker.addMarker('classic', createArrow(2));\n\tmxMarker.addMarker('classicThin', createArrow(3));\n\tmxMarker.addMarker('block', createArrow(2));\n\tmxMarker.addMarker('blockThin', createArrow(3));\n\t\n\tfunction createOpenArrow(widthFactor)\n\t{\n\t\twidthFactor = (widthFactor != null) ? widthFactor : 2;\n\t\t\n\t\treturn function(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled)\n\t\t{\n\t\t\t// The angle of the forward facing arrow sides against the x axis is\n\t\t\t// 26.565 degrees, 1/sin(26.565) = 2.236 / 2 = 1.118 ( / 2 allows for\n\t\t\t// only half the strokewidth is processed ).\n\t\t\tvar endOffsetX = unitX * sw * 1.118;\n\t\t\tvar endOffsetY = unitY * sw * 1.118;\n\t\t\t\n\t\t\tunitX = unitX * (size + sw);\n\t\t\tunitY = unitY * (size + sw);\n\t\t\t\n\t\t\tvar pt = pe.clone();\n\t\t\tpt.x -= endOffsetX;\n\t\t\tpt.y -= endOffsetY;\n\t\t\t\n\t\t\tpe.x += -endOffsetX * 2;\n\t\t\tpe.y += -endOffsetY * 2;\n\n\t\t\treturn function()\n\t\t\t{\n\t\t\t\tcanvas.begin();\n\t\t\t\tcanvas.moveTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);\n\t\t\t\tcanvas.lineTo(pt.x, pt.y);\n\t\t\t\tcanvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);\n\t\t\t\tcanvas.stroke();\n\t\t\t};\n\t\t}\n\t};\n\t\n\tmxMarker.addMarker('open', createOpenArrow(2));\n\tmxMarker.addMarker('openThin', createOpenArrow(3));\n\t\n\tmxMarker.addMarker('oval', function(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled)\n\t{\n\t\tvar a = size / 2;\n\t\t\n\t\tvar pt = pe.clone();\n\t\tpe.x -= unitX * a;\n\t\tpe.y -= unitY * a;\n\n\t\treturn function()\n\t\t{\n\t\t\tcanvas.ellipse(pt.x - a, pt.y - a, size, size);\n\t\t\t\t\t\t\n\t\t\tif (filled)\n\t\t\t{\n\t\t\t\tcanvas.fillAndStroke();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcanvas.stroke();\n\t\t\t}\n\t\t};\n\t});\n\n\tfunction diamond(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled)\n\t{\n\t\t// The angle of the forward facing arrow sides against the x axis is\n\t\t// 45 degrees, 1/sin(45) = 1.4142 / 2 = 0.7071 ( / 2 allows for\n\t\t// only half the strokewidth is processed ). Or 0.9862 for thin diamond.\n\t\t// Note these values and the tk variable below are dependent, update\n\t\t// both together (saves trig hard coding it).\n\t\tvar swFactor = (type == mxConstants.ARROW_DIAMOND) ?  0.7071 : 0.9862;\n\t\tvar endOffsetX = unitX * sw * swFactor;\n\t\tvar endOffsetY = unitY * sw * swFactor;\n\t\t\n\t\tunitX = unitX * (size + sw);\n\t\tunitY = unitY * (size + sw);\n\t\t\n\t\tvar pt = pe.clone();\n\t\tpt.x -= endOffsetX;\n\t\tpt.y -= endOffsetY;\n\t\t\n\t\tpe.x += -unitX - endOffsetX;\n\t\tpe.y += -unitY - endOffsetY;\n\t\t\n\t\t// thickness factor for diamond\n\t\tvar tk = ((type == mxConstants.ARROW_DIAMOND) ?  2 : 3.4);\n\t\t\n\t\treturn function()\n\t\t{\n\t\t\tcanvas.begin();\n\t\t\tcanvas.moveTo(pt.x, pt.y);\n\t\t\tcanvas.lineTo(pt.x - unitX / 2 - unitY / tk, pt.y + unitX / tk - unitY / 2);\n\t\t\tcanvas.lineTo(pt.x - unitX, pt.y - unitY);\n\t\t\tcanvas.lineTo(pt.x - unitX / 2 + unitY / tk, pt.y - unitY / 2 - unitX / tk);\n\t\t\tcanvas.close();\n\t\t\t\n\t\t\tif (filled)\n\t\t\t{\n\t\t\t\tcanvas.fillAndStroke();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcanvas.stroke();\n\t\t\t}\n\t\t};\n\t};\n\n\tmxMarker.addMarker('diamond', diamond);\n\tmxMarker.addMarker('diamondThin', diamond);\n})();\n\n__mxOutput.mxMarker = typeof mxMarker !== 'undefined' ? mxMarker : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxActor\n *\n * Extends <mxShape> to implement an actor shape. If a custom shape with one\n * filled area is needed, then this shape's <redrawPath> should be overridden.\n * \n * Example:\n * \n * (code)\n * function SampleShape() { }\n * \n * SampleShape.prototype = new mxActor();\n * SampleShape.prototype.constructor = vsAseShape;\n * \n * mxCellRenderer.registerShape('sample', SampleShape);\n * SampleShape.prototype.redrawPath = function(path, x, y, w, h)\n * {\n *   path.moveTo(0, 0);\n *   path.lineTo(w, h);\n *   // ...\n *   path.close();\n * }\n * (end)\n * \n * This shape is registered under <mxConstants.SHAPE_ACTOR> in\n * <mxCellRenderer>.\n * \n * Constructor: mxActor\n *\n * Constructs a new actor shape.\n * \n * Parameters:\n * \n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxActor(bounds, fill, stroke, strokewidth)\n{\n\tmxShape.call(this);\n\tthis.bounds = bounds;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxActor, mxShape);\n\n/**\n * Function: paintVertexShape\n * \n * Redirects to redrawPath for subclasses to work.\n */\nmxActor.prototype.paintVertexShape = function(c, x, y, w, h)\n{\n\tc.translate(x, y);\n\tc.begin();\n\tthis.redrawPath(c, x, y, w, h);\n\tc.fillAndStroke();\n};\n\n/**\n * Function: redrawPath\n *\n * Draws the path for this shape.\n */\nmxActor.prototype.redrawPath = function(c, x, y, w, h)\n{\n\tvar width = w/3;\n\tc.moveTo(0, h);\n\tc.curveTo(0, 3 * h / 5, 0, 2 * h / 5, w / 2, 2 * h / 5);\n\tc.curveTo(w / 2 - width, 2 * h / 5, w / 2 - width, 0, w / 2, 0);\n\tc.curveTo(w / 2 + width, 0, w / 2 + width, 2 * h / 5, w / 2, 2 * h / 5);\n\tc.curveTo(w, 2 * h / 5, w, 3 * h / 5, w, h);\n\tc.close();\n};\n\n__mxOutput.mxActor = typeof mxActor !== 'undefined' ? mxActor : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCloud\n *\n * Extends <mxActor> to implement a cloud shape.\n * \n * This shape is registered under <mxConstants.SHAPE_CLOUD> in\n * <mxCellRenderer>.\n * \n * Constructor: mxCloud\n *\n * Constructs a new cloud shape.\n * \n * Parameters:\n * \n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxCloud(bounds, fill, stroke, strokewidth)\n{\n\tmxActor.call(this);\n\tthis.bounds = bounds;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n};\n\n/**\n * Extends mxActor.\n */\nmxUtils.extend(mxCloud, mxActor);\n\n/**\n * Function: redrawPath\n *\n * Draws the path for this shape.\n */\nmxCloud.prototype.redrawPath = function(c, x, y, w, h)\n{\n\tc.moveTo(0.25 * w, 0.25 * h);\n\tc.curveTo(0.05 * w, 0.25 * h, 0, 0.5 * h, 0.16 * w, 0.55 * h);\n\tc.curveTo(0, 0.66 * h, 0.18 * w, 0.9 * h, 0.31 * w, 0.8 * h);\n\tc.curveTo(0.4 * w, h, 0.7 * w, h, 0.8 * w, 0.8 * h);\n\tc.curveTo(w, 0.8 * h, w, 0.6 * h, 0.875 * w, 0.5 * h);\n\tc.curveTo(w, 0.3 * h, 0.8 * w, 0.1 * h, 0.625 * w, 0.2 * h);\n\tc.curveTo(0.5 * w, 0.05 * h, 0.3 * w, 0.05 * h, 0.25 * w, 0.25 * h);\n\tc.close();\n};\n\n__mxOutput.mxCloud = typeof mxCloud !== 'undefined' ? mxCloud : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxRectangleShape\n *\n * Extends <mxShape> to implement a rectangle shape.\n * This shape is registered under <mxConstants.SHAPE_RECTANGLE>\n * in <mxCellRenderer>.\n * \n * Constructor: mxRectangleShape\n *\n * Constructs a new rectangle shape.\n * \n * Parameters:\n * \n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxRectangleShape(bounds, fill, stroke, strokewidth)\n{\n\tmxShape.call(this);\n\tthis.bounds = bounds;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxRectangleShape, mxShape);\n\n/**\n * Function: isHtmlAllowed\n *\n * Returns true for non-rounded, non-rotated shapes with no glass gradient.\n */\nmxRectangleShape.prototype.isHtmlAllowed = function()\n{\n\tvar events = true;\n\t\n\tif (this.style != null)\n\t{\n\t\tevents = mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, '1') == '1';\t\t\n\t}\n\t\n\treturn !this.isRounded && !this.glass && this.rotation == 0 && (events ||\n\t\t(this.fill != null && this.fill != mxConstants.NONE));\n};\n\n/**\n * Function: paintBackground\n * \n * Generic background painting implementation.\n */\nmxRectangleShape.prototype.paintBackground = function(c, x, y, w, h)\n{\n\tvar events = true;\n\t\n\tif (this.style != null)\n\t{\n\t\tevents = mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, '1') == '1';\n\t}\n\t\n\tif (events || (this.fill != null && this.fill != mxConstants.NONE) ||\n\t\t(this.stroke != null && this.stroke != mxConstants.NONE))\n\t{\n\t\tif (!events && (this.fill == null || this.fill == mxConstants.NONE))\n\t\t{\n\t\t\tc.pointerEvents = false;\n\t\t}\n\t\t\n\t\tif (this.isRounded)\n\t\t{\n\t\t\tvar r = 0;\n\t\t\t\n\t\t\tif (mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0) == '1')\n\t\t\t{\n\t\t\t\tr = Math.min(w / 2, Math.min(h / 2, mxUtils.getValue(this.style,\n\t\t\t\t\tmxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar f = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE,\n\t\t\t\t\tmxConstants.RECTANGLE_ROUNDING_FACTOR * 100) / 100;\n\t\t\t\tr = Math.min(w * f, h * f);\n\t\t\t}\n\t\t\t\n\t\t\tc.roundrect(x, y, w, h, r, r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc.rect(x, y, w, h);\n\t\t}\n\t\t\t\n\t\tc.fillAndStroke();\n\t}\n};\n\n/**\n * Function: isRoundable\n * \n * Adds roundable support.\n */\nmxRectangleShape.prototype.isRoundable = function(c, x, y, w, h)\n{\n\treturn true;\n};\n\n/**\n * Function: paintForeground\n * \n * Generic background painting implementation.\n */\nmxRectangleShape.prototype.paintForeground = function(c, x, y, w, h)\n{\n\tif (this.glass && !this.outline && this.fill != null && this.fill != mxConstants.NONE)\n\t{\n\t\tthis.paintGlassEffect(c, x, y, w, h, this.getArcSize(w + this.strokewidth, h + this.strokewidth));\n\t}\n};\n\n__mxOutput.mxRectangleShape = typeof mxRectangleShape !== 'undefined' ? mxRectangleShape : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxEllipse\n *\n * Extends <mxShape> to implement an ellipse shape.\n * This shape is registered under <mxConstants.SHAPE_ELLIPSE>\n * in <mxCellRenderer>.\n * \n * Constructor: mxEllipse\n *\n * Constructs a new ellipse shape.\n * \n * Parameters:\n * \n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxEllipse(bounds, fill, stroke, strokewidth)\n{\n\tmxShape.call(this);\n\tthis.bounds = bounds;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxEllipse, mxShape);\n\n/**\n * Function: paintVertexShape\n * \n * Paints the ellipse shape.\n */\nmxEllipse.prototype.paintVertexShape = function(c, x, y, w, h)\n{\n\tc.ellipse(x, y, w, h);\n\tc.fillAndStroke();\n};\n\n__mxOutput.mxEllipse = typeof mxEllipse !== 'undefined' ? mxEllipse : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxDoubleEllipse\n *\n * Extends <mxShape> to implement a double ellipse shape. This shape is\n * registered under <mxConstants.SHAPE_DOUBLE_ELLIPSE> in <mxCellRenderer>.\n * Use the following override to only fill the inner ellipse in this shape:\n * \n * (code)\n * mxDoubleEllipse.prototype.paintVertexShape = function(c, x, y, w, h)\n * {\n *   c.ellipse(x, y, w, h);\n *   c.stroke();\n *   \n *   var inset = mxUtils.getValue(this.style, mxConstants.STYLE_MARGIN, Math.min(3 + this.strokewidth, Math.min(w / 5, h / 5)));\n *   x += inset;\n *   y += inset;\n *   w -= 2 * inset;\n *   h -= 2 * inset;\n *   \n *   if (w > 0 && h > 0)\n *   {\n *     c.ellipse(x, y, w, h);\n *   }\n *   \n *   c.fillAndStroke();\n * };\n * (end)\n * \n * Constructor: mxDoubleEllipse\n *\n * Constructs a new ellipse shape.\n *\n * Parameters:\n *\n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxDoubleEllipse(bounds, fill, stroke, strokewidth)\n{\n\tmxShape.call(this);\n\tthis.bounds = bounds;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxDoubleEllipse, mxShape);\n\n/**\n * Variable: vmlScale\n * \n * Scale for improving the precision of VML rendering. Default is 10.\n */\nmxDoubleEllipse.prototype.vmlScale = 10;\n\n/**\n * Function: paintBackground\n * \n * Paints the background.\n */\nmxDoubleEllipse.prototype.paintBackground = function(c, x, y, w, h)\n{\n\tc.ellipse(x, y, w, h);\n\tc.fillAndStroke();\n};\n\n/**\n * Function: paintForeground\n * \n * Paints the foreground.\n */\nmxDoubleEllipse.prototype.paintForeground = function(c, x, y, w, h)\n{\n\tif (!this.outline)\n\t{\n\t\tvar margin = mxUtils.getValue(this.style, mxConstants.STYLE_MARGIN, Math.min(3 + this.strokewidth, Math.min(w / 5, h / 5)));\n\t\tx += margin;\n\t\ty += margin;\n\t\tw -= 2 * margin;\n\t\th -= 2 * margin;\n\t\t\n\t\t// FIXME: Rounding issues in IE8 standards mode (not in 1.x)\n\t\tif (w > 0 && h > 0)\n\t\t{\n\t\t\tc.ellipse(x, y, w, h);\n\t\t}\n\t\t\n\t\tc.stroke();\n\t}\n};\n\n/**\n * Function: getLabelBounds\n * \n * Returns the bounds for the label.\n */\nmxDoubleEllipse.prototype.getLabelBounds = function(rect)\n{\n\tvar margin = (mxUtils.getValue(this.style, mxConstants.STYLE_MARGIN, Math.min(3 + this.strokewidth,\n\t\t\tMath.min(rect.width / 5 / this.scale, rect.height / 5 / this.scale)))) * this.scale;\n\n\treturn new mxRectangle(rect.x + margin, rect.y + margin, rect.width - 2 * margin, rect.height - 2 * margin);\n};\n\n__mxOutput.mxDoubleEllipse = typeof mxDoubleEllipse !== 'undefined' ? mxDoubleEllipse : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxRhombus\n *\n * Extends <mxShape> to implement a rhombus (aka diamond) shape.\n * This shape is registered under <mxConstants.SHAPE_RHOMBUS>\n * in <mxCellRenderer>.\n * \n * Constructor: mxRhombus\n *\n * Constructs a new rhombus shape.\n * \n * Parameters:\n * \n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxRhombus(bounds, fill, stroke, strokewidth)\n{\n\tmxShape.call(this);\n\tthis.bounds = bounds;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxRhombus, mxShape);\n\n/**\n * Function: isRoundable\n * \n * Adds roundable support.\n */\nmxRhombus.prototype.isRoundable = function()\n{\n\treturn true;\n};\n\n/**\n * Function: paintVertexShape\n * \n * Generic painting implementation.\n */\nmxRhombus.prototype.paintVertexShape = function(c, x, y, w, h)\n{\n\tvar hw = w / 2;\n\tvar hh = h / 2;\n\t\n\tvar arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;\n\tc.begin();\n\tthis.addPoints(c, [new mxPoint(x + hw, y), new mxPoint(x + w, y + hh), new mxPoint(x + hw, y + h),\n\t     new mxPoint(x, y + hh)], this.isRounded, arcSize, true);\n\tc.fillAndStroke();\n};\n\n__mxOutput.mxRhombus = typeof mxRhombus !== 'undefined' ? mxRhombus : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxPolyline\n *\n * Extends <mxShape> to implement a polyline (a line with multiple points).\n * This shape is registered under <mxConstants.SHAPE_POLYLINE> in\n * <mxCellRenderer>.\n * \n * Constructor: mxPolyline\n *\n * Constructs a new polyline shape.\n * \n * Parameters:\n * \n * points - Array of <mxPoints> that define the points. This is stored in\n * <mxShape.points>.\n * stroke - String that defines the stroke color. Default is 'black'. This is\n * stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxPolyline(points, stroke, strokewidth)\n{\n\tmxShape.call(this);\n\tthis.points = points;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxPolyline, mxShape);\n\n/**\n * Function: getRotation\n * \n * Returns 0.\n */\nmxPolyline.prototype.getRotation = function()\n{\n\treturn 0;\n};\n\n/**\n * Function: getShapeRotation\n * \n * Returns 0.\n */\nmxPolyline.prototype.getShapeRotation = function()\n{\n\treturn 0;\n};\n\n/**\n * Function: isPaintBoundsInverted\n * \n * Returns false.\n */\nmxPolyline.prototype.isPaintBoundsInverted = function()\n{\n\treturn false;\n};\n\n/**\n * Function: paintEdgeShape\n * \n * Paints the line shape.\n */\nmxPolyline.prototype.paintEdgeShape = function(c, pts)\n{\n\tvar prev = c.pointerEventsValue;\n\tc.pointerEventsValue = 'stroke';\n\t\n\tif (this.style == null || this.style[mxConstants.STYLE_CURVED] != 1)\n\t{\n\t\tthis.paintLine(c, pts, this.isRounded);\n\t}\n\telse\n\t{\n\t\tthis.paintCurvedLine(c, pts);\n\t}\n\t\n\tc.pointerEventsValue = prev;\n};\n\n/**\n * Function: paintLine\n * \n * Paints the line shape.\n */\nmxPolyline.prototype.paintLine = function(c, pts, rounded)\n{\n\tvar arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;\n\tc.begin();\n\tthis.addPoints(c, pts, rounded, arcSize, false);\n\tc.stroke();\n};\n\n/**\n * Function: paintCurvedLine\n * \n * Paints a curved line.\n */\nmxPolyline.prototype.paintCurvedLine = function(c, pts)\n{\n\tc.begin();\n\t\n\tvar pt = pts[0];\n\tvar n = pts.length;\n\t\n\tc.moveTo(pt.x, pt.y);\n\t\n\tfor (var i = 1; i < n - 2; i++)\n\t{\n\t\tvar p0 = pts[i];\n\t\tvar p1 = pts[i + 1];\n\t\tvar ix = (p0.x + p1.x) / 2;\n\t\tvar iy = (p0.y + p1.y) / 2;\n\t\t\n\t\tc.quadTo(p0.x, p0.y, ix, iy);\n\t}\n\t\n\tvar p0 = pts[n - 2];\n\tvar p1 = pts[n - 1];\n\t\n\tc.quadTo(p0.x, p0.y, p1.x, p1.y);\n\tc.stroke();\n};\n\n__mxOutput.mxPolyline = typeof mxPolyline !== 'undefined' ? mxPolyline : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxArrow\n *\n * Extends <mxShape> to implement an arrow shape. (The shape\n * is used to represent edges, not vertices.)\n * This shape is registered under <mxConstants.SHAPE_ARROW>\n * in <mxCellRenderer>.\n * \n * Constructor: mxArrow\n *\n * Constructs a new arrow shape.\n * \n * Parameters:\n * \n * points - Array of <mxPoints> that define the points. This is stored in\n * <mxShape.points>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n * arrowWidth - Optional integer that defines the arrow width. Default is\n * <mxConstants.ARROW_WIDTH>. This is stored in <arrowWidth>.\n * spacing - Optional integer that defines the spacing between the arrow shape\n * and its endpoints. Default is <mxConstants.ARROW_SPACING>. This is stored in\n * <spacing>.\n * endSize - Optional integer that defines the size of the arrowhead. Default\n * is <mxConstants.ARROW_SIZE>. This is stored in <endSize>.\n */\nfunction mxArrow(points, fill, stroke, strokewidth, arrowWidth, spacing, endSize)\n{\n\tmxShape.call(this);\n\tthis.points = points;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n\tthis.arrowWidth = (arrowWidth != null) ? arrowWidth : mxConstants.ARROW_WIDTH;\n\tthis.spacing = (spacing != null) ? spacing : mxConstants.ARROW_SPACING;\n\tthis.endSize = (endSize != null) ? endSize : mxConstants.ARROW_SIZE;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxArrow, mxShape);\n\n/**\n * Function: augmentBoundingBox\n *\n * Augments the bounding box with the edge width and markers.\n */\nmxArrow.prototype.augmentBoundingBox = function(bbox)\n{\n\tmxShape.prototype.augmentBoundingBox.apply(this, arguments);\n\t\n\tvar w = Math.max(this.arrowWidth, this.endSize);\n\tbbox.grow((w / 2 + this.strokewidth) * this.scale);\n};\n\n/**\n * Function: paintEdgeShape\n * \n * Paints the line shape.\n */\nmxArrow.prototype.paintEdgeShape = function(c, pts)\n{\n\t// Geometry of arrow\n\tvar spacing =  mxConstants.ARROW_SPACING;\n\tvar width = mxConstants.ARROW_WIDTH;\n\tvar arrow = mxConstants.ARROW_SIZE;\n\n\t// Base vector (between end points)\n\tvar p0 = pts[0];\n\tvar pe = pts[pts.length - 1];\n\tvar dx = pe.x - p0.x;\n\tvar dy = pe.y - p0.y;\n\tvar dist = Math.sqrt(dx * dx + dy * dy);\n\tvar length = dist - 2 * spacing - arrow;\n\t\n\t// Computes the norm and the inverse norm\n\tvar nx = dx / dist;\n\tvar ny = dy / dist;\n\tvar basex = length * nx;\n\tvar basey = length * ny;\n\tvar floorx = width * ny/3;\n\tvar floory = -width * nx/3;\n\t\n\t// Computes points\n\tvar p0x = p0.x - floorx / 2 + spacing * nx;\n\tvar p0y = p0.y - floory / 2 + spacing * ny;\n\tvar p1x = p0x + floorx;\n\tvar p1y = p0y + floory;\n\tvar p2x = p1x + basex;\n\tvar p2y = p1y + basey;\n\tvar p3x = p2x + floorx;\n\tvar p3y = p2y + floory;\n\t// p4 not necessary\n\tvar p5x = p3x - 3 * floorx;\n\tvar p5y = p3y - 3 * floory;\n\t\n\tc.begin();\n\tc.moveTo(p0x, p0y);\n\tc.lineTo(p1x, p1y);\n\tc.lineTo(p2x, p2y);\n\tc.lineTo(p3x, p3y);\n\tc.lineTo(pe.x - spacing * nx, pe.y - spacing * ny);\n\tc.lineTo(p5x, p5y);\n\tc.lineTo(p5x + floorx, p5y + floory);\n\tc.close();\n\n\tc.fillAndStroke();\n};\n\n__mxOutput.mxArrow = typeof mxArrow !== 'undefined' ? mxArrow : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxArrowConnector\n *\n * Extends <mxShape> to implement an new rounded arrow shape with support for\n * waypoints and double arrows. (The shape is used to represent edges, not\n * vertices.) This shape is registered under <mxConstants.SHAPE_ARROW_CONNECTOR>\n * in <mxCellRenderer>.\n * \n * Constructor: mxArrowConnector\n *\n * Constructs a new arrow shape.\n * \n * Parameters:\n * \n * points - Array of <mxPoints> that define the points. This is stored in\n * <mxShape.points>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n * arrowWidth - Optional integer that defines the arrow width. Default is\n * <mxConstants.ARROW_WIDTH>. This is stored in <arrowWidth>.\n * spacing - Optional integer that defines the spacing between the arrow shape\n * and its endpoints. Default is <mxConstants.ARROW_SPACING>. This is stored in\n * <spacing>.\n * endSize - Optional integer that defines the size of the arrowhead. Default\n * is <mxConstants.ARROW_SIZE>. This is stored in <endSize>.\n */\nfunction mxArrowConnector(points, fill, stroke, strokewidth, arrowWidth, spacing, endSize)\n{\n\tmxShape.call(this);\n\tthis.points = points;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n\tthis.arrowWidth = (arrowWidth != null) ? arrowWidth : mxConstants.ARROW_WIDTH;\n\tthis.arrowSpacing = (spacing != null) ? spacing : mxConstants.ARROW_SPACING;\n\tthis.startSize = mxConstants.ARROW_SIZE / 5;\n\tthis.endSize = mxConstants.ARROW_SIZE / 5;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxArrowConnector, mxShape);\n\n/**\n * Variable: useSvgBoundingBox\n * \n * Allows to use the SVG bounding box in SVG. Default is false for performance\n * reasons.\n */\nmxArrowConnector.prototype.useSvgBoundingBox = true;\n\n/**\n * Function: isRoundable\n * \n * Hook for subclassers.\n */\nmxArrowConnector.prototype.isRoundable = function()\n{\n\treturn true;\n};\n\n/**\n * Variable: resetStyles\n * \n * Overrides mxShape to reset spacing.\n */\nmxArrowConnector.prototype.resetStyles = function()\n{\n\tmxShape.prototype.resetStyles.apply(this, arguments);\n\t\n\tthis.arrowSpacing = mxConstants.ARROW_SPACING;\n};\n\n/**\n * Overrides apply to get smooth transition from default start- and endsize.\n */\nmxArrowConnector.prototype.apply = function(state)\n{\n\tmxShape.prototype.apply.apply(this, arguments);\n\n\tif (this.style != null)\n\t{\n\t\tthis.startSize = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.ARROW_SIZE / 5) * 3;\n\t\tthis.endSize = mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, mxConstants.ARROW_SIZE / 5) * 3;\n\t}\n};\n\n/**\n * Function: augmentBoundingBox\n *\n * Augments the bounding box with the edge width and markers.\n */\nmxArrowConnector.prototype.augmentBoundingBox = function(bbox)\n{\n\tmxShape.prototype.augmentBoundingBox.apply(this, arguments);\n\t\n\tvar w = this.getEdgeWidth();\n\t\n\tif (this.isMarkerStart())\n\t{\n\t\tw = Math.max(w, this.getStartArrowWidth());\n\t}\n\t\n\tif (this.isMarkerEnd())\n\t{\n\t\tw = Math.max(w, this.getEndArrowWidth());\n\t}\n\t\n\tbbox.grow((w / 2 + this.strokewidth) * this.scale);\n};\n\n/**\n * Function: paintEdgeShape\n * \n * Paints the line shape.\n */\nmxArrowConnector.prototype.paintEdgeShape = function(c, pts)\n{\n\t// Geometry of arrow\n\tvar strokeWidth = this.strokewidth;\n\t\n\tif (this.outline)\n\t{\n\t\tstrokeWidth = Math.max(1, mxUtils.getNumber(this.style, mxConstants.STYLE_STROKEWIDTH, this.strokewidth));\n\t}\n\t\n\tvar startWidth = this.getStartArrowWidth() + strokeWidth;\n\tvar endWidth = this.getEndArrowWidth() + strokeWidth;\n\tvar edgeWidth = this.outline ? this.getEdgeWidth() + strokeWidth : this.getEdgeWidth();\n\tvar openEnded = this.isOpenEnded();\n\tvar markerStart = this.isMarkerStart();\n\tvar markerEnd = this.isMarkerEnd();\n\tvar spacing = (openEnded) ? 0 : this.arrowSpacing + strokeWidth / 2;\n\tvar startSize = this.startSize + strokeWidth;\n\tvar endSize = this.endSize + strokeWidth;\n\tvar isRounded = this.isArrowRounded();\n\t\n\t// Base vector (between first points)\n\tvar pe = pts[pts.length - 1];\n\n\t// Finds first non-overlapping point\n\tvar i0 = 1;\n\t\n\twhile (i0 < pts.length - 1 && pts[i0].x == pts[0].x && pts[i0].y == pts[0].y)\n\t{\n\t\ti0++;\n\t}\n\t\n\tvar dx = pts[i0].x - pts[0].x;\n\tvar dy = pts[i0].y - pts[0].y;\n\tvar dist = Math.sqrt(dx * dx + dy * dy);\n\t\n\tif (dist == 0)\n\t{\n\t\treturn;\n\t}\n\t\n\t// Computes the norm and the inverse norm\n\tvar nx = dx / dist;\n\tvar nx2, nx1 = nx;\n\tvar ny = dy / dist;\n\tvar ny2, ny1 = ny;\n\tvar orthx = edgeWidth * ny;\n\tvar orthy = -edgeWidth * nx;\n\t\n\t// Stores the inbound function calls in reverse order in fns\n\tvar fns = [];\n\t\n\tif (isRounded)\n\t{\n\t\tc.setLineJoin('round');\n\t}\n\telse if (pts.length > 2)\n\t{\n\t\t// Only mitre if there are waypoints\n\t\tc.setMiterLimit(1.42);\n\t}\n\n\tc.begin();\n\n\tvar startNx = nx;\n\tvar startNy = ny;\n\n\tif (markerStart && !openEnded)\n\t{\n\t\tthis.paintMarker(c, pts[0].x, pts[0].y, nx, ny, startSize, startWidth, edgeWidth, spacing, true);\n\t}\n\telse\n\t{\n\t\tvar outStartX = pts[0].x + orthx / 2 + spacing * nx;\n\t\tvar outStartY = pts[0].y + orthy / 2 + spacing * ny;\n\t\tvar inEndX = pts[0].x - orthx / 2 + spacing * nx;\n\t\tvar inEndY = pts[0].y - orthy / 2 + spacing * ny;\n\t\t\n\t\tif (openEnded)\n\t\t{\n\t\t\tc.moveTo(outStartX, outStartY);\n\t\t\t\n\t\t\tfns.push(function()\n\t\t\t{\n\t\t\t\tc.lineTo(inEndX, inEndY);\n\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc.moveTo(inEndX, inEndY);\n\t\t\tc.lineTo(outStartX, outStartY);\n\t\t}\n\t}\n\t\n\tvar dx1 = 0;\n\tvar dy1 = 0;\n\tvar dist1 = 0;\n\n\tfor (var i = 0; i < pts.length - 2; i++)\n\t{\n\t\t// Work out in which direction the line is bending\n\t\tvar pos = mxUtils.relativeCcw(pts[i].x, pts[i].y, pts[i+1].x, pts[i+1].y, pts[i+2].x, pts[i+2].y);\n\n\t\tdx1 = pts[i+2].x - pts[i+1].x;\n\t\tdy1 = pts[i+2].y - pts[i+1].y;\n\n\t\tdist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n\t\t\n\t\tif (dist1 != 0)\n\t\t{\n\t\t\tnx1 = dx1 / dist1;\n\t\t\tny1 = dy1 / dist1;\n\t\t\t\n\t\t\tvar tmp1 = nx * nx1 + ny * ny1;\n\t\t\tvar tmp = Math.max(Math.sqrt((tmp1 + 1) / 2), 0.04);\n\t\t\t\n\t\t\t// Work out the normal orthogonal to the line through the control point and the edge sides intersection\n\t\t\tnx2 = (nx + nx1);\n\t\t\tny2 = (ny + ny1);\n\t\n\t\t\tvar dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\n\t\t\t\n\t\t\tif (dist2 != 0)\n\t\t\t{\n\t\t\t\tnx2 = nx2 / dist2;\n\t\t\t\tny2 = ny2 / dist2;\n\t\t\t\t\n\t\t\t\t// Higher strokewidths require a larger minimum bend, 0.35 covers all but the most extreme cases\n\t\t\t\tvar strokeWidthFactor = Math.max(tmp, Math.min(this.strokewidth / 200 + 0.04, 0.35));\n\t\t\t\tvar angleFactor = (pos != 0 && isRounded) ? Math.max(0.1, strokeWidthFactor) : Math.max(tmp, 0.06);\n\n\t\t\t\tvar outX = pts[i+1].x + ny2 * edgeWidth / 2 / angleFactor;\n\t\t\t\tvar outY = pts[i+1].y - nx2 * edgeWidth / 2 / angleFactor;\n\t\t\t\tvar inX = pts[i+1].x - ny2 * edgeWidth / 2 / angleFactor;\n\t\t\t\tvar inY = pts[i+1].y + nx2 * edgeWidth / 2 / angleFactor;\n\t\t\t\t\n\t\t\t\tif (pos == 0 || !isRounded)\n\t\t\t\t{\n\t\t\t\t\t// If the two segments are aligned, or if we're not drawing curved sections between segments\n\t\t\t\t\t// just draw straight to the intersection point\n\t\t\t\t\tc.lineTo(outX, outY);\n\t\t\t\t\t\n\t\t\t\t\t(function(x, y)\n\t\t\t\t\t{\n\t\t\t\t\t\tfns.push(function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc.lineTo(x, y);\n\t\t\t\t\t\t});\n\t\t\t\t\t})(inX, inY);\n\t\t\t\t}\n\t\t\t\telse if (pos == -1)\n\t\t\t\t{\n\t\t\t\t\tvar c1x = inX + ny * edgeWidth;\n\t\t\t\t\tvar c1y = inY - nx * edgeWidth;\n\t\t\t\t\tvar c2x = inX + ny1 * edgeWidth;\n\t\t\t\t\tvar c2y = inY - nx1 * edgeWidth;\n\t\t\t\t\tc.lineTo(c1x, c1y);\n\t\t\t\t\tc.quadTo(outX, outY, c2x, c2y);\n\t\t\t\t\t\n\t\t\t\t\t(function(x, y)\n\t\t\t\t\t{\n\t\t\t\t\t\tfns.push(function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc.lineTo(x, y);\n\t\t\t\t\t\t});\n\t\t\t\t\t})(inX, inY);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tc.lineTo(outX, outY);\n\t\t\t\t\t\n\t\t\t\t\t(function(x, y)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar c1x = outX - ny * edgeWidth;\n\t\t\t\t\t\tvar c1y = outY + nx * edgeWidth;\n\t\t\t\t\t\tvar c2x = outX - ny1 * edgeWidth;\n\t\t\t\t\t\tvar c2y = outY + nx1 * edgeWidth;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfns.push(function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc.quadTo(x, y, c1x, c1y);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns.push(function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc.lineTo(c2x, c2y);\n\t\t\t\t\t\t});\n\t\t\t\t\t})(inX, inY);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnx = nx1;\n\t\t\t\tny = ny1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\torthx = edgeWidth * ny1;\n\torthy = - edgeWidth * nx1;\n\n\tif (markerEnd && !openEnded)\n\t{\n\t\tthis.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, false);\n\t}\n\telse\n\t{\n\t\tc.lineTo(pe.x - spacing * nx1 + orthx / 2, pe.y - spacing * ny1 + orthy / 2);\n\t\t\n\t\tvar inStartX = pe.x - spacing * nx1 - orthx / 2;\n\t\tvar inStartY = pe.y - spacing * ny1 - orthy / 2;\n\n\t\tif (!openEnded)\n\t\t{\n\t\t\tc.lineTo(inStartX, inStartY);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc.moveTo(inStartX, inStartY);\n\t\t\t\n\t\t\tfns.splice(0, 0, function()\n\t\t\t{\n\t\t\t\tc.moveTo(inStartX, inStartY);\n\t\t\t});\n\t\t}\n\t}\n\t\n\tfor (var i = fns.length - 1; i >= 0; i--)\n\t{\n\t\tfns[i]();\n\t}\n\n\tif (openEnded)\n\t{\n\t\tc.end();\n\t\tc.stroke();\n\t}\n\telse\n\t{\n\t\tc.close();\n\t\tc.fillAndStroke();\n\t}\n\t\n\t// Workaround for shadow on top of base arrow\n\tc.setShadow(false);\n\t\n\t// Need to redraw the markers without the low miter limit\n\tc.setMiterLimit(4);\n\t\n\tif (isRounded)\n\t{\n\t\tc.setLineJoin('flat');\n\t}\n\n\tif (pts.length > 2)\n\t{\n\t\t// Only to repaint markers if no waypoints\n\t\t// Need to redraw the markers without the low miter limit\n\t\tc.setMiterLimit(4);\n\t\tif (markerStart && !openEnded)\n\t\t{\n\t\t\tc.begin();\n\t\t\tthis.paintMarker(c, pts[0].x, pts[0].y, startNx, startNy, startSize, startWidth, edgeWidth, spacing, true);\n\t\t\tc.stroke();\n\t\t\tc.end();\n\t\t}\n\t\t\n\t\tif (markerEnd && !openEnded)\n\t\t{\n\t\t\tc.begin();\n\t\t\tthis.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, true);\n\t\t\tc.stroke();\n\t\t\tc.end();\n\t\t}\n\t}\n};\n\n/**\n * Function: paintMarker\n * \n * Paints the marker.\n */\nmxArrowConnector.prototype.paintMarker = function(c, ptX, ptY, nx, ny, size, arrowWidth, edgeWidth, spacing, initialMove)\n{\n\tvar widthArrowRatio = edgeWidth / arrowWidth;\n\tvar orthx = edgeWidth * ny / 2;\n\tvar orthy = -edgeWidth * nx / 2;\n\n\tvar spaceX = (spacing + size) * nx;\n\tvar spaceY = (spacing + size) * ny;\n\n\tif (initialMove)\n\t{\n\t\tc.moveTo(ptX - orthx + spaceX, ptY - orthy + spaceY);\n\t}\n\telse\n\t{\n\t\tc.lineTo(ptX - orthx + spaceX, ptY - orthy + spaceY);\n\t}\n\n\tc.lineTo(ptX - orthx / widthArrowRatio + spaceX, ptY - orthy / widthArrowRatio + spaceY);\n\tc.lineTo(ptX + spacing * nx, ptY + spacing * ny);\n\tc.lineTo(ptX + orthx / widthArrowRatio + spaceX, ptY + orthy / widthArrowRatio + spaceY);\n\tc.lineTo(ptX + orthx + spaceX, ptY + orthy + spaceY);\n}\n\n/**\n * Function: isArrowRounded\n * \n * Returns wether the arrow is rounded\n */\nmxArrowConnector.prototype.isArrowRounded = function()\n{\n\treturn this.isRounded;\n};\n\n/**\n * Function: getStartArrowWidth\n * \n * Returns the width of the start arrow\n */\nmxArrowConnector.prototype.getStartArrowWidth = function()\n{\n\treturn mxConstants.ARROW_WIDTH;\n};\n\n/**\n * Function: getEndArrowWidth\n * \n * Returns the width of the end arrow\n */\nmxArrowConnector.prototype.getEndArrowWidth = function()\n{\n\treturn mxConstants.ARROW_WIDTH;\n};\n\n/**\n * Function: getEdgeWidth\n * \n * Returns the width of the body of the edge\n */\nmxArrowConnector.prototype.getEdgeWidth = function()\n{\n\treturn mxConstants.ARROW_WIDTH / 3;\n};\n\n/**\n * Function: isOpenEnded\n * \n * Returns whether the ends of the shape are drawn\n */\nmxArrowConnector.prototype.isOpenEnded = function()\n{\n\treturn false;\n};\n\n/**\n * Function: isMarkerStart\n * \n * Returns whether the start marker is drawn\n */\nmxArrowConnector.prototype.isMarkerStart = function()\n{\n\treturn (mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, mxConstants.NONE) != mxConstants.NONE);\n};\n\n/**\n * Function: isMarkerEnd\n * \n * Returns whether the end marker is drawn\n */\nmxArrowConnector.prototype.isMarkerEnd = function()\n{\n\treturn (mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE);\n};\n__mxOutput.mxArrowConnector = typeof mxArrowConnector !== 'undefined' ? mxArrowConnector : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxText\n *\n * Extends <mxShape> to implement a text shape. To change vertical text from\n * bottom to top to top to bottom, the following code can be used:\n * \n * (code)\n * mxText.prototype.verticalTextRotation = 90;\n * (end)\n * \n * Constructor: mxText\n *\n * Constructs a new text shape.\n * \n * Parameters:\n * \n * value - String that represents the text to be displayed. This is stored in\n * <value>.\n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * align - Specifies the horizontal alignment. Default is ''. This is stored in\n * <align>.\n * valign - Specifies the vertical alignment. Default is ''. This is stored in\n * <valign>.\n * color - String that specifies the text color. Default is 'black'. This is\n * stored in <color>.\n * family - String that specifies the font family. Default is\n * <mxConstants.DEFAULT_FONTFAMILY>. This is stored in <family>.\n * size - Integer that specifies the font size. Default is\n * <mxConstants.DEFAULT_FONTSIZE>. This is stored in <size>.\n * fontStyle - Specifies the font style. Default is 0. This is stored in\n * <fontStyle>.\n * spacing - Integer that specifies the global spacing. Default is 2. This is\n * stored in <spacing>.\n * spacingTop - Integer that specifies the top spacing. Default is 0. The\n * sum of the spacing and this is stored in <spacingTop>.\n * spacingRight - Integer that specifies the right spacing. Default is 0. The\n * sum of the spacing and this is stored in <spacingRight>.\n * spacingBottom - Integer that specifies the bottom spacing. Default is 0.The\n * sum of the spacing and this is stored in <spacingBottom>.\n * spacingLeft - Integer that specifies the left spacing. Default is 0. The\n * sum of the spacing and this is stored in <spacingLeft>.\n * horizontal - Boolean that specifies if the label is horizontal. Default is\n * true. This is stored in <horizontal>.\n * background - String that specifies the background color. Default is null.\n * This is stored in <background>.\n * border - String that specifies the label border color. Default is null.\n * This is stored in <border>.\n * wrap - Specifies if word-wrapping should be enabled. Default is false.\n * This is stored in <wrap>.\n * clipped - Specifies if the label should be clipped. Default is false.\n * This is stored in <clipped>.\n * overflow - Value of the overflow style. Default is 'visible'.\n */\nfunction mxText(value, bounds, align, valign, color,\n\tfamily,\tsize, fontStyle, spacing, spacingTop, spacingRight,\n\tspacingBottom, spacingLeft, horizontal, background, border,\n\twrap, clipped, overflow, labelPadding, textDirection)\n{\n\tmxShape.call(this);\n\tthis.value = value;\n\tthis.bounds = bounds;\n\tthis.color = (color != null) ? color : 'black';\n\tthis.align = (align != null) ? align : mxConstants.ALIGN_CENTER;\n\tthis.valign = (valign != null) ? valign : mxConstants.ALIGN_MIDDLE;\n\tthis.family = (family != null) ? family : mxConstants.DEFAULT_FONTFAMILY;\n\tthis.size = (size != null) ? size : mxConstants.DEFAULT_FONTSIZE;\n\tthis.fontStyle = (fontStyle != null) ? fontStyle : mxConstants.DEFAULT_FONTSTYLE;\n\tthis.spacing = parseInt(spacing || 2);\n\tthis.spacingTop = this.spacing + parseInt(spacingTop || 0);\n\tthis.spacingRight = this.spacing + parseInt(spacingRight || 0);\n\tthis.spacingBottom = this.spacing + parseInt(spacingBottom || 0);\n\tthis.spacingLeft = this.spacing + parseInt(spacingLeft || 0);\n\tthis.horizontal = (horizontal != null) ? horizontal : true;\n\tthis.background = background;\n\tthis.border = border;\n\tthis.wrap = (wrap != null) ? wrap : false;\n\tthis.clipped = (clipped != null) ? clipped : false;\n\tthis.overflow = (overflow != null) ? overflow : 'visible';\n\tthis.labelPadding = (labelPadding != null) ? labelPadding : 0;\n\tthis.textDirection = textDirection;\n\tthis.rotation = 0;\n\tthis.updateMargin();\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxText, mxShape);\n\n/**\n * Variable: baseSpacingTop\n * \n * Specifies the spacing to be added to the top spacing. Default is 0. Use the\n * value 5 here to get the same label positions as in mxGraph 1.x.\n */\nmxText.prototype.baseSpacingTop = 0;\n\n/**\n * Variable: baseSpacingBottom\n * \n * Specifies the spacing to be added to the bottom spacing. Default is 0. Use the\n * value 1 here to get the same label positions as in mxGraph 1.x.\n */\nmxText.prototype.baseSpacingBottom = 0;\n\n/**\n * Variable: baseSpacingLeft\n * \n * Specifies the spacing to be added to the left spacing. Default is 0.\n */\nmxText.prototype.baseSpacingLeft = 0;\n\n/**\n * Variable: baseSpacingRight\n * \n * Specifies the spacing to be added to the right spacing. Default is 0.\n */\nmxText.prototype.baseSpacingRight = 0;\n\n/**\n * Variable: replaceLinefeeds\n * \n * Specifies if linefeeds in HTML labels should be replaced with BR tags.\n * Default is true.\n */\nmxText.prototype.replaceLinefeeds = true;\n\n/**\n * Variable: verticalTextRotation\n * \n * Rotation for vertical text. Default is -90 (bottom to top).\n */\nmxText.prototype.verticalTextRotation = -90;\n\n/**\n * Variable: ignoreClippedStringSize\n * \n * Specifies if the string size should be measured in <updateBoundingBox> if\n * the label is clipped and the label position is center and middle. If this is\n * true, then the bounding box will be set to <bounds>. Default is true.\n * <ignoreStringSize> has precedence over this switch.\n */\nmxText.prototype.ignoreClippedStringSize = true;\n\n/**\n * Variable: ignoreStringSize\n * \n * Specifies if the actual string size should be measured. If disabled the\n * boundingBox will not ignore the actual size of the string, otherwise\n * <bounds> will be used instead. Default is false.\n */\nmxText.prototype.ignoreStringSize = false;\n\n/**\n * Variable: textWidthPadding\n * \n * Specifies the padding to be added to the text width for the bounding box.\n * This is needed to make sure no clipping is applied to borders. Default is 4\n * for IE 8 standards mode and 3 for all others.\n */\nmxText.prototype.textWidthPadding = (document.documentMode == 8 && !mxClient.IS_EM) ? 4 : 3;\n\n/**\n * Variable: lastValue\n * \n * Contains the last rendered text value. Used for caching.\n */\nmxText.prototype.lastValue = null;\n\n/**\n * Variable: cacheEnabled\n * \n * Specifies if caching for HTML labels should be enabled. Default is true.\n */\nmxText.prototype.cacheEnabled = true;\n\n/**\n * Function: isParseVml\n * \n * Text shapes do not contain VML markup and do not need to be parsed. This\n * method returns false to speed up rendering in IE8.\n */\nmxText.prototype.isParseVml = function()\n{\n\treturn false;\n};\n\n/**\n * Function: isHtmlAllowed\n * \n * Returns true if HTML is allowed for this shape. This implementation returns\n * true if the browser is not in IE8 standards mode.\n */\nmxText.prototype.isHtmlAllowed = function()\n{\n\treturn document.documentMode != 8 || mxClient.IS_EM;\n};\n\n/**\n * Function: getSvgScreenOffset\n * \n * Disables offset in IE9 for crisper image output.\n */\nmxText.prototype.getSvgScreenOffset = function()\n{\n\treturn 0;\n};\n\n/**\n * Function: checkBounds\n * \n * Returns true if the bounds are not null and all of its variables are numeric.\n */\nmxText.prototype.checkBounds = function()\n{\n\treturn (!isNaN(this.scale) && isFinite(this.scale) && this.scale > 0 &&\n\t\t\tthis.bounds != null && !isNaN(this.bounds.x) && !isNaN(this.bounds.y) &&\n\t\t\t!isNaN(this.bounds.width) && !isNaN(this.bounds.height));\n};\n\n/**\n * Function: paint\n * \n * Generic rendering code.\n */\nmxText.prototype.paint = function(c, update)\n{\n\t// Scale is passed-through to canvas\n\tvar s = this.scale;\n\tvar x = this.bounds.x / s;\n\tvar y = this.bounds.y / s;\n\tvar w = this.bounds.width / s;\n\tvar h = this.bounds.height / s;\n\t\n\tthis.updateTransform(c, x, y, w, h);\n\tthis.configureCanvas(c, x, y, w, h);\n\t\n\tif (update)\n\t{\n\t\tc.updateText(x, y, w, h, this.align, this.valign, this.wrap, this.overflow,\n\t\t\t\tthis.clipped, this.getTextRotation(), this.node);\n\t}\n\telse\n\t{\n\t\t// Checks if text contains HTML markup\n\t\tvar realHtml = mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML;\n\t\t\n\t\t// Always renders labels as HTML in VML\n\t\tvar fmt = (realHtml || c instanceof mxVmlCanvas2D) ? 'html' : '';\n\t\tvar val = this.value;\n\t\t\n\t\tif (!realHtml && fmt == 'html')\n\t\t{\n\t\t\tval = mxUtils.htmlEntities(val, false);\n\t\t}\n\t\t\n\t\tif (fmt == 'html' && !mxUtils.isNode(this.value))\n\t\t{\n\t\t\tval = mxUtils.replaceTrailingNewlines(val, '<div><br></div>');\t\t\t\n\t\t}\n\t\t\n\t\t// Handles trailing newlines to make sure they are visible in rendering output\n\t\tval = (!mxUtils.isNode(this.value) && this.replaceLinefeeds && fmt == 'html') ?\n\t\t\tval.replace(/\\n/g, '<br/>') : val;\n\t\t\t\n\t\tvar dir = this.textDirection;\n\t\n\t\tif (dir == mxConstants.TEXT_DIRECTION_AUTO && !realHtml)\n\t\t{\n\t\t\tdir = this.getAutoDirection();\n\t\t}\n\t\t\n\t\tif (dir != mxConstants.TEXT_DIRECTION_LTR && dir != mxConstants.TEXT_DIRECTION_RTL)\n\t\t{\n\t\t\tdir = null;\n\t\t}\n\t\t\n\t\tc.text(x, y, w, h, val, this.align, this.valign, this.wrap, fmt,\n\t\t\tthis.overflow, this.clipped, this.getTextRotation(), dir);\n\t}\n};\n\n/**\n * Function: redraw\n * \n * Renders the text using the given DOM nodes.\n */\nmxText.prototype.redraw = function()\n{\n\tif (this.visible && this.checkBounds() && this.cacheEnabled && this.lastValue == this.value &&\n\t\t(mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML))\n\t{\n\t\tif (this.node.nodeName == 'DIV' && (this.isHtmlAllowed() || !mxClient.IS_VML))\n\t\t{\n\t\t\tif (mxClient.IS_SVG)\n\t\t\t{\n\t\t\t\tthis.redrawHtmlShapeWithCss3();\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.updateSize(this.node, (this.state == null || this.state.view.textDiv == null));\n\t\n\t\t\t\tif (mxClient.IS_IE && (document.documentMode == null || document.documentMode <= 8))\n\t\t\t\t{\n\t\t\t\t\tthis.updateHtmlFilter();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.updateHtmlTransform();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.updateBoundingBox();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar canvas = this.createCanvas();\n\n\t\t\tif (canvas != null && canvas.updateText != null)\n\t\t\t{\n\t\t\t\t// Specifies if events should be handled\n\t\t\t\tcanvas.pointerEvents = this.pointerEvents;\n\t\n\t\t\t\tthis.paint(canvas, true);\n\t\t\t\tthis.destroyCanvas(canvas);\n\t\t\t\tthis.updateBoundingBox();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Fallback if canvas does not support updateText (VML)\n\t\t\t\tmxShape.prototype.redraw.apply(this, arguments);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tmxShape.prototype.redraw.apply(this, arguments);\n\t\t\n\t\tif (mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML)\n\t\t{\n\t\t\tthis.lastValue = this.value;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.lastValue = null;\n\t\t}\n\t}\n};\n\n/**\n * Function: resetStyles\n * \n * Resets all styles.\n */\nmxText.prototype.resetStyles = function()\n{\n\tmxShape.prototype.resetStyles.apply(this, arguments);\n\t\n\tthis.color = 'black';\n\tthis.align = mxConstants.ALIGN_CENTER;\n\tthis.valign = mxConstants.ALIGN_MIDDLE;\n\tthis.family = mxConstants.DEFAULT_FONTFAMILY;\n\tthis.size = mxConstants.DEFAULT_FONTSIZE;\n\tthis.fontStyle = mxConstants.DEFAULT_FONTSTYLE;\n\tthis.spacing = 2;\n\tthis.spacingTop = 2;\n\tthis.spacingRight = 2;\n\tthis.spacingBottom = 2;\n\tthis.spacingLeft = 2;\n\tthis.horizontal = true;\n\tdelete this.background;\n\tdelete this.border;\n\tthis.textDirection = mxConstants.DEFAULT_TEXT_DIRECTION;\n\tdelete this.margin;\n};\n\n/**\n * Function: apply\n * \n * Extends mxShape to update the text styles.\n *\n * Parameters:\n *\n * state - <mxCellState> of the corresponding cell.\n */\nmxText.prototype.apply = function(state)\n{\n\tvar old = this.spacing;\n\tmxShape.prototype.apply.apply(this, arguments);\n\t\n\tif (this.style != null)\n\t{\n\t\tthis.fontStyle = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSTYLE, this.fontStyle);\n\t\tthis.family = mxUtils.getValue(this.style, mxConstants.STYLE_FONTFAMILY, this.family);\n\t\tthis.size = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, this.size);\n\t\tthis.color = mxUtils.getValue(this.style, mxConstants.STYLE_FONTCOLOR, this.color);\n\t\tthis.align = mxUtils.getValue(this.style, mxConstants.STYLE_ALIGN, this.align);\n\t\tthis.valign = mxUtils.getValue(this.style, mxConstants.STYLE_VERTICAL_ALIGN, this.valign);\n\t\tthis.spacing = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING, this.spacing));\n\t\tthis.spacingTop = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_TOP, this.spacingTop - old)) + this.spacing;\n\t\tthis.spacingRight = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_RIGHT, this.spacingRight - old)) + this.spacing;\n\t\tthis.spacingBottom = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_BOTTOM, this.spacingBottom - old)) + this.spacing;\n\t\tthis.spacingLeft = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_LEFT, this.spacingLeft - old)) + this.spacing;\n\t\tthis.horizontal = mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, this.horizontal);\n\t\tthis.background = mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_BACKGROUNDCOLOR, this.background);\n\t\tthis.border = mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_BORDERCOLOR, this.border);\n\t\tthis.textDirection = mxUtils.getValue(this.style, mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION);\n\t\tthis.opacity = mxUtils.getValue(this.style, mxConstants.STYLE_TEXT_OPACITY, 100);\n\t\tthis.updateMargin();\n\t}\n\t\n\tthis.flipV = null;\n\tthis.flipH = null;\n};\n\n/**\n * Function: getAutoDirection\n * \n * Used to determine the automatic text direction. Returns\n * <mxConstants.TEXT_DIRECTION_LTR> or <mxConstants.TEXT_DIRECTION_RTL>\n * depending on the contents of <value>. This is not invoked for HTML, wrapped\n * content or if <value> is a DOM node.\n */\nmxText.prototype.getAutoDirection = function()\n{\n\t// Looks for strong (directional) characters\n\tvar tmp = /[A-Za-z\\u05d0-\\u065f\\u066a-\\u06ef\\u06fa-\\u07ff\\ufb1d-\\ufdff\\ufe70-\\ufefc]/.exec(this.value);\n\t\n\t// Returns the direction defined by the character\n\treturn (tmp != null && tmp.length > 0 && tmp[0] > 'z') ?\n\t\tmxConstants.TEXT_DIRECTION_RTL : mxConstants.TEXT_DIRECTION_LTR;\n};\n\n/**\n * Function: getContentNode\n * \n * Returns the node that contains the rendered input.\n */\nmxText.prototype.getContentNode = function()\n{\n\tvar result = this.node;\n\t\n\tif (result != null)\n\t{\n\t\t// Rendered with no foreignObject\n\t\tif (result.ownerSVGElement == null)\n\t\t{\n\t\t\tresult = this.node.firstChild.firstChild;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Innermost DIV that contains the actual content\n\t\t\tresult = result.firstChild.firstChild.firstChild.firstChild.firstChild;\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: updateBoundingBox\n *\n * Updates the <boundingBox> for this shape using the given node and position.\n */\nmxText.prototype.updateBoundingBox = function()\n{\n\tvar node = this.node;\n\tthis.boundingBox = this.bounds.clone();\n\tvar rot = this.getTextRotation();\n\t\n\tvar h = (this.style != null) ? mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER) : null;\n\tvar v = (this.style != null) ? mxUtils.getValue(this.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE) : null;\n\n\tif (!this.ignoreStringSize && node != null && this.overflow != 'fill' && (!this.clipped ||\n\t\t!this.ignoreClippedStringSize || h != mxConstants.ALIGN_CENTER || v != mxConstants.ALIGN_MIDDLE))\n\t{\n\t\tvar ow = null;\n\t\tvar oh = null;\n\t\t\n\t\tif (node.ownerSVGElement != null)\n\t\t{\n\t\t\tif (node.firstChild != null && node.firstChild.firstChild != null &&\n\t\t\t\tnode.firstChild.firstChild.nodeName == 'foreignObject')\n\t\t\t{\n\t\t\t\t// Uses second inner DIV for font metrics\n\t\t\t\tnode = node.firstChild.firstChild.firstChild.firstChild;\n\t\t\t\toh = node.offsetHeight * this.scale;\n\t\t\t\t\n\t\t\t\tif (this.overflow == 'width')\n\t\t\t\t{\n\t\t\t\t\tow = this.boundingBox.width;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tow = node.offsetWidth * this.scale;\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tvar b = node.getBBox();\n\t\t\t\t\t\n\t\t\t\t\t// Workaround for bounding box of empty string\n\t\t\t\t\tif (typeof(this.value) == 'string' && mxUtils.trim(this.value) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.boundingBox = null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (b.width == 0 && b.height == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.boundingBox = null;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.boundingBox = new mxRectangle(b.x, b.y, b.width, b.height);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (e)\n\t\t\t\t{\n\t\t\t\t\t// Ignores NS_ERROR_FAILURE in FF if container display is none.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar td = (this.state != null) ? this.state.view.textDiv : null;\n\n\t\t\t// Use cached offset size\n\t\t\tif (this.offsetWidth != null && this.offsetHeight != null)\n\t\t\t{\n\t\t\t\tow = this.offsetWidth * this.scale;\n\t\t\t\toh = this.offsetHeight * this.scale;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Cannot get node size while container hidden so a\n\t\t\t\t// shared temporary DIV is used for text measuring\n\t\t\t\tif (td != null)\n\t\t\t\t{\n\t\t\t\t\tthis.updateFont(td);\n\t\t\t\t\tthis.updateSize(td, false);\n\t\t\t\t\tthis.updateInnerHtml(td);\n\n\t\t\t\t\tnode = td;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar sizeDiv = node;\n\n\t\t\t\tif (document.documentMode == 8 && !mxClient.IS_EM)\n\t\t\t\t{\n\t\t\t\t\tvar w = Math.round(this.bounds.width / this.scale);\n\t\n\t\t\t\t\tif (this.wrap && w > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.style.wordWrap = mxConstants.WORD_WRAP;\n\t\t\t\t\t\tnode.style.whiteSpace = 'normal';\n\n\t\t\t\t\t\tif (node.style.wordWrap != 'break-word')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Innermost DIV is used for measuring text\n\t\t\t\t\t\t\tvar divs = sizeDiv.getElementsByTagName('div');\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (divs.length > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsizeDiv = divs[divs.length - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tow = sizeDiv.offsetWidth + 2;\n\t\t\t\t\t\t\tdivs = this.node.getElementsByTagName('div');\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (this.clipped)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tow = Math.min(w, ow);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Second last DIV width must be updated in DOM tree\n\t\t\t\t\t\t\tif (divs.length > 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdivs[divs.length - 2].style.width = ow + 'px';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.style.whiteSpace = 'nowrap';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == 'DIV')\n\t\t\t\t{\n\t\t\t\t\tsizeDiv = sizeDiv.firstChild;\n\t\t\t\t}\n\n\t\t\t\tthis.offsetWidth = sizeDiv.offsetWidth + this.textWidthPadding;\n\t\t\t\tthis.offsetHeight = sizeDiv.offsetHeight;\n\t\t\t\t\n\t\t\t\tow = this.offsetWidth * this.scale;\n\t\t\t\toh = this.offsetHeight * this.scale;\n\t\t\t}\n\t\t}\n\n\t\tif (ow != null && oh != null)\n\t\t{\t\n\t\t\tthis.boundingBox = new mxRectangle(this.bounds.x,\n\t\t\t\tthis.bounds.y, ow, oh);\n\t\t}\n\t}\n\n\tif (this.boundingBox != null)\n\t{\n\t\tif (rot != 0)\n\t\t{\n\t\t\t// Accounts for pre-rotated x and y\n\t\t\tvar bbox = mxUtils.getBoundingBox(new mxRectangle(\n\t\t\t\tthis.margin.x * this.boundingBox.width,\n\t\t\t\tthis.margin.y * this.boundingBox.height,\n\t\t\t\tthis.boundingBox.width, this.boundingBox.height),\n\t\t\t\trot, new mxPoint(0, 0));\n\t\t\t\n\t\t\tthis.unrotatedBoundingBox = mxRectangle.fromRectangle(this.boundingBox);\n\t\t\tthis.unrotatedBoundingBox.x += this.margin.x * this.unrotatedBoundingBox.width;\n\t\t\tthis.unrotatedBoundingBox.y += this.margin.y * this.unrotatedBoundingBox.height;\n\t\t\t\n\t\t\tthis.boundingBox.x += bbox.x;\n\t\t\tthis.boundingBox.y += bbox.y;\n\t\t\tthis.boundingBox.width = bbox.width;\n\t\t\tthis.boundingBox.height = bbox.height;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.boundingBox.x += this.margin.x * this.boundingBox.width;\n\t\t\tthis.boundingBox.y += this.margin.y * this.boundingBox.height;\n\t\t\tthis.unrotatedBoundingBox = null;\n\t\t}\n\t}\n};\n\n/**\n * Function: getShapeRotation\n * \n * Returns 0 to avoid using rotation in the canvas via updateTransform.\n */\nmxText.prototype.getShapeRotation = function()\n{\n\treturn 0;\n};\n\n/**\n * Function: getTextRotation\n * \n * Returns the rotation for the text label of the corresponding shape.\n */\nmxText.prototype.getTextRotation = function()\n{\n\treturn (this.state != null && this.state.shape != null) ? this.state.shape.getTextRotation() : 0;\n};\n\n/**\n * Function: isPaintBoundsInverted\n * \n * Inverts the bounds if <mxShape.isBoundsInverted> returns true or if the\n * horizontal style is false.\n */\nmxText.prototype.isPaintBoundsInverted = function()\n{\n\treturn !this.horizontal && this.state != null && this.state.view.graph.model.isVertex(this.state.cell);\n};\n\n/**\n * Function: configureCanvas\n * \n * Sets the state of the canvas for drawing the shape.\n */\nmxText.prototype.configureCanvas = function(c, x, y, w, h)\n{\n\tmxShape.prototype.configureCanvas.apply(this, arguments);\n\t\n\tc.setFontColor(this.color);\n\tc.setFontBackgroundColor(this.background);\n\tc.setFontBorderColor(this.border);\n\tc.setFontFamily(this.family);\n\tc.setFontSize(this.size);\n\tc.setFontStyle(this.fontStyle);\n};\n\n/**\n * Function: updateVmlContainer\n * \n * Sets the width and height of the container to 1px.\n */\nmxText.prototype.updateVmlContainer = function()\n{\n\tthis.node.style.left = Math.round(this.bounds.x) + 'px';\n\tthis.node.style.top = Math.round(this.bounds.y) + 'px';\n\tthis.node.style.width = '1px';\n\tthis.node.style.height = '1px';\n\tthis.node.style.overflow = 'visible';\n};\n\n/**\n * Function: getHtmlValue\n * \n * Private helper function to create SVG elements\n */\nmxText.prototype.getHtmlValue = function()\n{\n\tvar val = this.value;\n\t\n\tif (this.dialect != mxConstants.DIALECT_STRICTHTML)\n\t{\n\t\tval = mxUtils.htmlEntities(val, false);\n\t}\n\t\n\t// Handles trailing newlines to make sure they are visible in rendering output\n\tval = mxUtils.replaceTrailingNewlines(val, '<div><br></div>');\n\tval = (this.replaceLinefeeds) ? val.replace(/\\n/g, '<br/>') : val;\n\t\n\treturn val;\n};\n\n/**\n * Function: getTextCss\n * \n * Private helper function to create SVG elements\n */\nmxText.prototype.getTextCss = function()\n{\n\tvar lh = (mxConstants.ABSOLUTE_LINE_HEIGHT) ? (this.size * mxConstants.LINE_HEIGHT) + 'px' :\n\t\tmxConstants.LINE_HEIGHT;\n\n\tvar css = 'display: inline-block; font-size: ' + this.size + 'px; ' +\n\t\t'font-family: ' + this.family + '; color: ' + this.color + '; line-height: ' + lh +\n\t\t'; pointer-events: ' + ((this.pointerEvents) ? 'all' : 'none') + '; ';\n\n\tif ((this.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD)\n\t{\n\t\tcss += 'font-weight: bold; ';\n\t}\n\n\tif ((this.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC)\n\t{\n\t\tcss += 'font-style: italic; ';\n\t}\n\t\n\tvar deco = [];\n\t\n\tif ((this.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE)\n\t{\n\t\tdeco.push('underline');\n\t}\n\t\n\tif ((this.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH)\n\t{\n\t\tdeco.push('line-through');\n\t}\n\t\n\tif (deco.length > 0)\n\t{\n\t\tcss += 'text-decoration: ' + deco.join(' ') + '; ';\n\t}\n\n\treturn css;\n};\n\n/**\n * Function: redrawHtmlShape\n *\n * Updates the HTML node(s) to reflect the latest bounds and scale.\n */\nmxText.prototype.redrawHtmlShape = function()\n{\n\tif (mxClient.IS_SVG)\n\t{\n\t\tthis.redrawHtmlShapeWithCss3();\t\n\t}\n\telse\n\t{\n\t\tvar style = this.node.style;\n\t\n\t\t// Resets CSS styles\n\t\tstyle.whiteSpace = 'normal';\n\t\tstyle.overflow = '';\n\t\tstyle.width = '';\n\t\tstyle.height = '';\n\t\t\n\t\tthis.updateValue();\n\t\tthis.updateFont(this.node);\n\t\tthis.updateSize(this.node, (this.state == null || this.state.view.textDiv == null));\n\t\t\n\t\tthis.offsetWidth = null;\n\t\tthis.offsetHeight = null;\n\t\n\t\tif (mxClient.IS_IE && (document.documentMode == null || document.documentMode <= 8))\n\t\t{\n\t\t\tthis.updateHtmlFilter();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.updateHtmlTransform();\n\t\t}\n\t}\n};\n\n/**\n * Function: redrawHtmlShapeWithCss3\n *\n * Updates the HTML node(s) to reflect the latest bounds and scale.\n */\nmxText.prototype.redrawHtmlShapeWithCss3 = function()\n{\n\tvar w = Math.max(0, Math.round(this.bounds.width / this.scale));\n\tvar h = Math.max(0, Math.round(this.bounds.height / this.scale));\n\tvar flex = 'position: absolute; left: ' + Math.round(this.bounds.x) + 'px; ' +\n\t\t'top: ' + Math.round(this.bounds.y) + 'px; pointer-events: none; ';\n\tvar block = this.getTextCss();\n\t\n\tmxSvgCanvas2D.createCss(w + 2, h, this.align, this.valign, this.wrap, this.overflow, this.clipped,\n\t\t(this.background != null) ? mxUtils.htmlEntities(this.background) : null,\n\t\t(this.border != null) ? mxUtils.htmlEntities(this.border) : null,\n\t\tflex, block, this.scale, mxUtils.bind(this, function(dx, dy, flex, item, block, ofl)\n\t{\n\t\tvar r = this.getTextRotation();\n\t\tvar tr = ((this.scale != 1) ? 'scale(' + this.scale + ') ' : '') +\n\t\t\t((r != 0) ? 'rotate(' + r + 'deg) ' : '') +\n\t\t\t((this.margin.x != 0 || this.margin.y != 0) ?\n\t\t\t\t'translate(' + (this.margin.x * 100) + '%,' +\n\t\t\t\t\t(this.margin.y * 100) + '%)' : '');\n\t\t\n\t\tif (tr != '')\n\t\t{\n\t\t\ttr = 'transform-origin: 0 0; transform: ' + tr + '; ';\n\t\t}\n\n\t\tif (ofl == '')\n\t\t{\n\t\t\tflex += item;\n\t\t\titem = 'display:inline-block; min-width: 100%; ' + tr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\titem += tr;\n\t\t\t\n\t\t\tif (mxClient.IS_SF)\n\t\t\t{\n\t\t\t\titem += '-webkit-clip-path: content-box;';\n\t\t\t}\n\t\t}\n\n\t\tif (this.opacity < 100)\n\t\t{\n\t\t\tblock += 'opacity: ' + (this.opacity / 100) + '; ';\n\t\t}\n\t\t\n\t\tthis.node.setAttribute('style', flex);\n\t\t\n\t\tvar html = (mxUtils.isNode(this.value)) ? this.value.outerHTML : this.getHtmlValue();\n\t\t\n\t\tif (this.node.firstChild == null)\n\t\t{\n\t\t\tthis.node.innerHTML = '<div><div>' + html +'</div></div>';\n\t\t}\n\n\t\tthis.node.firstChild.firstChild.setAttribute('style', block);\n\t\tthis.node.firstChild.setAttribute('style', item);\n\t}));\n};\n\n/**\n * Function: updateHtmlTransform\n *\n * Returns the spacing as an <mxPoint>.\n */\nmxText.prototype.updateHtmlTransform = function()\n{\n\tvar theta = this.getTextRotation();\n\tvar style = this.node.style;\n\tvar dx = this.margin.x;\n\tvar dy = this.margin.y;\n\t\n\tif (theta != 0)\n\t{\n\t\tmxUtils.setPrefixedStyle(style, 'transformOrigin', (-dx * 100) + '%' + ' ' + (-dy * 100) + '%');\n\t\tmxUtils.setPrefixedStyle(style, 'transform', 'translate(' + (dx * 100) + '%' + ',' + (dy * 100) + '%) ' +\n\t\t\t'scale(' + this.scale + ') rotate(' + theta + 'deg)');\n\t}\n\telse\n\t{\n\t\tmxUtils.setPrefixedStyle(style, 'transformOrigin', '0% 0%');\n\t\tmxUtils.setPrefixedStyle(style, 'transform', 'scale(' + this.scale + ') ' +\n\t\t\t'translate(' + (dx * 100) + '%' + ',' + (dy * 100) + '%)');\n\t}\n\n\tstyle.left = Math.round(this.bounds.x - Math.ceil(dx * ((this.overflow != 'fill' &&\n\t\tthis.overflow != 'width') ? 3 : 1))) + 'px';\n\tstyle.top = Math.round(this.bounds.y - dy * ((this.overflow != 'fill') ? 3 : 1)) + 'px';\n\t\n\tif (this.opacity < 100)\n\t{\n\t\tstyle.opacity = this.opacity / 100;\n\t}\n\telse\n\t{\n\t\tstyle.opacity = '';\n\t}\n};\n\n/**\n * Function: updateInnerHtml\n * \n * Sets the inner HTML of the given element to the <value>.\n */\nmxText.prototype.updateInnerHtml = function(elt)\n{\n\tif (mxUtils.isNode(this.value))\n\t{\n\t\telt.innerHTML = this.value.outerHTML;\n\t}\n\telse\n\t{\n\t\tvar val = this.value;\n\t\t\n\t\tif (this.dialect != mxConstants.DIALECT_STRICTHTML)\n\t\t{\n\t\t\t// LATER: Can be cached in updateValue\n\t\t\tval = mxUtils.htmlEntities(val, false);\n\t\t}\n\t\t\n\t\t// Handles trailing newlines to make sure they are visible in rendering output\n\t\tval = mxUtils.replaceTrailingNewlines(val, '<div>&nbsp;</div>');\n\t\tval = (this.replaceLinefeeds) ? val.replace(/\\n/g, '<br/>') : val;\n\t\tval = '<div style=\"display:inline-block;_display:inline;\">' + val + '</div>';\n\t\t\n\t\telt.innerHTML = val;\n\t}\n};\n\n/**\n * Function: updateHtmlFilter\n *\n * Rotated text rendering quality is bad for IE9 quirks/IE8 standards\n */\nmxText.prototype.updateHtmlFilter = function()\n{\n\tvar style = this.node.style;\n\tvar dx = this.margin.x;\n\tvar dy = this.margin.y;\n\tvar s = this.scale;\n\t\n\t// Resets filter before getting offsetWidth\n\tmxUtils.setOpacity(this.node, this.opacity);\n\t\n\t// Adds 1 to match table height in 1.x\n\tvar ow = 0;\n\tvar oh = 0;\n\tvar td = (this.state != null) ? this.state.view.textDiv : null;\n\tvar sizeDiv = this.node;\n\t\n\t// Fallback for hidden text rendering in IE quirks mode\n\tif (td != null)\n\t{\n\t\ttd.style.overflow = '';\n\t\ttd.style.height = '';\n\t\ttd.style.width = '';\n\t\t\n\t\tthis.updateFont(td);\n\t\tthis.updateSize(td, false);\n\t\tthis.updateInnerHtml(td);\n\t\t\n\t\tvar w = Math.round(this.bounds.width / this.scale);\n\n\t\tif (this.wrap && w > 0)\n\t\t{\n\t\t\ttd.style.whiteSpace = 'normal';\n\t\t\ttd.style.wordWrap = mxConstants.WORD_WRAP;\n\t\t\tow = w;\n\t\t\t\n\t\t\tif (this.clipped)\n\t\t\t{\n\t\t\t\tow = Math.min(ow, this.bounds.width);\n\t\t\t}\n\n\t\t\ttd.style.width = ow + 'px';\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttd.style.whiteSpace = 'nowrap';\n\t\t}\n\t\t\n\t\tsizeDiv = td;\n\t\t\n\t\tif (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == 'DIV')\n\t\t{\n\t\t\tsizeDiv = sizeDiv.firstChild;\n\t\t\t\n\t\t\tif (this.wrap && td.style.wordWrap == 'break-word')\n\t\t\t{\n\t\t\t\tsizeDiv.style.width = '100%';\n\t\t\t}\n\t\t}\n\n\t\t// Required to update the height of the text box after wrapping width is known \n\t\tif (!this.clipped && this.wrap && w > 0)\n\t\t{\n\t\t\tow = sizeDiv.offsetWidth + this.textWidthPadding;\n\t\t\ttd.style.width = ow + 'px';\n\t\t}\n\t\t\n\t\toh = sizeDiv.offsetHeight + 2;\n\t\t\n\t\tif (mxClient.IS_QUIRKS && this.border != null && this.border != mxConstants.NONE)\n\t\t{\n\t\t\toh += 3;\n\t\t}\n\t}\n\telse if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == 'DIV')\n\t{\n\t\tsizeDiv = sizeDiv.firstChild;\n\t\toh = sizeDiv.offsetHeight;\n\t}\n\n\tow = sizeDiv.offsetWidth + this.textWidthPadding;\n\t\n\tif (this.clipped)\n\t{\n\t\toh = Math.min(oh, this.bounds.height);\n\t}\n\n\tvar w = this.bounds.width / s;\n\tvar h = this.bounds.height / s;\n\n\t// Handles special case for live preview with no wrapper DIV and no textDiv\n\tif (this.overflow == 'fill')\n\t{\n\t\toh = h;\n\t\tow = w;\n\t}\n\telse if (this.overflow == 'width')\n\t{\n\t\toh = sizeDiv.scrollHeight;\n\t\tow = w;\n\t}\n\t\n\t// Stores for later use\n\tthis.offsetWidth = ow;\n\tthis.offsetHeight = oh;\n\t\n\t// Simulates max-height CSS in quirks mode\n\tif (mxClient.IS_QUIRKS && (this.clipped || (this.overflow == 'width' && h > 0)))\n\t{\n\t\th = Math.min(h, oh);\n\t\tstyle.height = Math.round(h) + 'px';\n\t}\n\telse\n\t{\n\t\th = oh;\n\t}\n\n\tif (this.overflow != 'fill' && this.overflow != 'width')\n\t{\n\t\tif (this.clipped)\n\t\t{\n\t\t\tow = Math.min(w, ow);\n\t\t}\n\t\t\n\t\tw = ow;\n\n\t\t// Simulates max-width CSS in quirks mode\n\t\tif ((mxClient.IS_QUIRKS && this.clipped) || this.wrap)\n\t\t{\n\t\t\tstyle.width = Math.round(w) + 'px';\n\t\t}\n\t}\n\n\th *= s;\n\tw *= s;\n\t\n\t// Rotation case is handled via VML canvas\n\tvar rad = this.getTextRotation() * (Math.PI / 180);\n\t\n\t// Precalculate cos and sin for the rotation\n\tvar real_cos = parseFloat(parseFloat(Math.cos(rad)).toFixed(8));\n\tvar real_sin = parseFloat(parseFloat(Math.sin(-rad)).toFixed(8));\n\n\trad %= 2 * Math.PI;\n\t\n\tif (rad < 0)\n\t{\n\t\trad += 2 * Math.PI;\n\t}\n\t\n\trad %= Math.PI;\n\t\n\tif (rad > Math.PI / 2)\n\t{\n\t\trad = Math.PI - rad;\n\t}\n\t\n\tvar cos = Math.cos(rad);\n\tvar sin = Math.sin(-rad);\n\n\tvar tx = w * -(dx + 0.5);\n\tvar ty = h * -(dy + 0.5);\n\n\tvar top_fix = (h - h * cos + w * sin) / 2 + real_sin * tx - real_cos * ty;\n\tvar left_fix = (w - w * cos + h * sin) / 2 - real_cos * tx - real_sin * ty;\n\t\n\tif (rad != 0)\n\t{\n\t\tvar f = 'progid:DXImageTransform.Microsoft.Matrix(M11=' + real_cos + ', M12='+\n\t\t\treal_sin + ', M21=' + (-real_sin) + ', M22=' + real_cos + ', sizingMethod=\\'auto expand\\')';\n\t\t\n\t\tif (style.filter != null && style.filter.length > 0)\n\t\t{\n\t\t\tstyle.filter += ' ' + f;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstyle.filter = f;\n\t\t}\n\t}\n\t\n\t// Workaround for rendering offsets\n\tvar dy = 0;\n\t\n\tif (this.overflow != 'fill' && mxClient.IS_QUIRKS)\n\t{\n\t\tif (this.valign == mxConstants.ALIGN_TOP)\n\t\t{\n\t\t\tdy -= 1;\n\t\t}\n\t\telse if (this.valign == mxConstants.ALIGN_BOTTOM)\n\t\t{\n\t\t\tdy += 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdy += 1;\n\t\t}\n\t}\n\n\tstyle.zoom = s;\n\tstyle.left = Math.round(this.bounds.x + left_fix - w / 2) + 'px';\n\tstyle.top = Math.round(this.bounds.y + top_fix - h / 2 + dy) + 'px';\n};\n\n/**\n * Function: updateValue\n *\n * Updates the HTML node(s) to reflect the latest bounds and scale.\n */\nmxText.prototype.updateValue = function()\n{\n\tif (mxUtils.isNode(this.value))\n\t{\n\t\tthis.node.innerHTML = '';\n\t\tthis.node.appendChild(this.value);\n\t}\n\telse\n\t{\n\t\tvar val = this.value;\n\t\t\n\t\tif (this.dialect != mxConstants.DIALECT_STRICTHTML)\n\t\t{\n\t\t\tval = mxUtils.htmlEntities(val, false);\n\t\t}\n\t\t\n\t\t// Handles trailing newlines to make sure they are visible in rendering output\n\t\tval = mxUtils.replaceTrailingNewlines(val, '<div><br></div>');\n\t\tval = (this.replaceLinefeeds) ? val.replace(/\\n/g, '<br/>') : val;\n\t\tvar bg = (this.background != null && this.background != mxConstants.NONE) ? this.background : null;\n\t\tvar bd = (this.border != null && this.border != mxConstants.NONE) ? this.border : null;\n\n\t\tif (this.overflow == 'fill' || this.overflow == 'width')\n\t\t{\n\t\t\tif (bg != null)\n\t\t\t{\n\t\t\t\tthis.node.style.backgroundColor = bg;\n\t\t\t}\n\t\t\t\n\t\t\tif (bd != null)\n\t\t\t{\n\t\t\t\tthis.node.style.border = '1px solid ' + bd;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar css = '';\n\t\t\t\n\t\t\tif (bg != null)\n\t\t\t{\n\t\t\t\tcss += 'background-color:' + mxUtils.htmlEntities(bg) + ';';\n\t\t\t}\n\t\t\t\n\t\t\tif (bd != null)\n\t\t\t{\n\t\t\t\tcss += 'border:1px solid ' + mxUtils.htmlEntities(bd) + ';';\n\t\t\t}\n\t\t\t\n\t\t\t// Wrapper DIV for background, zoom needed for inline in quirks\n\t\t\t// and to measure wrapped font sizes in all browsers\n\t\t\t// FIXME: Background size in quirks mode for wrapped text\n\t\t\tvar lh = (mxConstants.ABSOLUTE_LINE_HEIGHT) ? (this.size * mxConstants.LINE_HEIGHT) + 'px' :\n\t\t\t\tmxConstants.LINE_HEIGHT;\n\t\t\tval = '<div style=\"zoom:1;' + css + 'display:inline-block;_display:inline;text-decoration:inherit;' +\n\t\t\t\t'padding-bottom:1px;padding-right:1px;line-height:' + lh + '\">' + val + '</div>';\n\t\t}\n\n\t\tthis.node.innerHTML = val;\n\t\t\n\t\t// Sets text direction\n\t\tvar divs = this.node.getElementsByTagName('div');\n\t\t\n\t\tif (divs.length > 0)\n\t\t{\n\t\t\tvar dir = this.textDirection;\n\n\t\t\tif (dir == mxConstants.TEXT_DIRECTION_AUTO && this.dialect != mxConstants.DIALECT_STRICTHTML)\n\t\t\t{\n\t\t\t\tdir = this.getAutoDirection();\n\t\t\t}\n\t\t\t\n\t\t\tif (dir == mxConstants.TEXT_DIRECTION_LTR || dir == mxConstants.TEXT_DIRECTION_RTL)\n\t\t\t{\n\t\t\t\tdivs[divs.length - 1].setAttribute('dir', dir);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdivs[divs.length - 1].removeAttribute('dir');\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: updateFont\n *\n * Updates the HTML node(s) to reflect the latest bounds and scale.\n */\nmxText.prototype.updateFont = function(node)\n{\n\tvar style = node.style;\n\t\n\tstyle.lineHeight = (mxConstants.ABSOLUTE_LINE_HEIGHT) ? (this.size * mxConstants.LINE_HEIGHT) + 'px' : mxConstants.LINE_HEIGHT;\n\tstyle.fontSize = this.size + 'px';\n\tstyle.fontFamily = this.family;\n\tstyle.verticalAlign = 'top';\n\tstyle.color = this.color;\n\t\n\tif ((this.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD)\n\t{\n\t\tstyle.fontWeight = 'bold';\n\t}\n\telse\n\t{\n\t\tstyle.fontWeight = '';\n\t}\n\n\tif ((this.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC)\n\t{\n\t\tstyle.fontStyle = 'italic';\n\t}\n\telse\n\t{\n\t\tstyle.fontStyle = '';\n\t}\n\t\n\tvar txtDecor = [];\n\t\n\tif ((this.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE)\n\t{\n\t\ttxtDecor.push('underline');\n\t}\n\t\n\tif ((this.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH)\n\t{\n\t\ttxtDecor.push('line-through');\n\t}\n\t\n\tstyle.textDecoration = txtDecor.join(' ');\n\t\n\tif (this.align == mxConstants.ALIGN_CENTER)\n\t{\n\t\tstyle.textAlign = 'center';\n\t}\n\telse if (this.align == mxConstants.ALIGN_RIGHT)\n\t{\n\t\tstyle.textAlign = 'right';\n\t}\n\telse\n\t{\n\t\tstyle.textAlign = 'left';\n\t}\n};\n\n/**\n * Function: updateSize\n *\n * Updates the HTML node(s) to reflect the latest bounds and scale.\n */\nmxText.prototype.updateSize = function(node, enableWrap)\n{\n\tvar w = Math.max(0, Math.round(this.bounds.width / this.scale));\n\tvar h = Math.max(0, Math.round(this.bounds.height / this.scale));\n\tvar style = node.style;\n\t\n\t// NOTE: Do not use maxWidth here because wrapping will\n\t// go wrong if the cell is outside of the viewable area\n\tif (this.clipped)\n\t{\n\t\tstyle.overflow = 'hidden';\n\t\t\n\t\tif (!mxClient.IS_QUIRKS)\n\t\t{\n\t\t\tstyle.maxHeight = h + 'px';\n\t\t\tstyle.maxWidth = w + 'px';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstyle.width = w + 'px';\n\t\t}\n\t}\n\telse if (this.overflow == 'fill')\n\t{\n\t\tstyle.width = (w + 1) + 'px';\n\t\tstyle.height = (h + 1) + 'px';\n\t\tstyle.overflow = 'hidden';\n\t}\n\telse if (this.overflow == 'width')\n\t{\n\t\tstyle.width = (w + 1) + 'px';\n\t\tstyle.maxHeight = (h + 1) + 'px';\n\t\tstyle.overflow = 'hidden';\n\t}\n\t\n\tif (this.wrap && w > 0)\n\t{\n\t\tstyle.wordWrap = mxConstants.WORD_WRAP;\n\t\tstyle.whiteSpace = 'normal';\n\t\tstyle.width = w + 'px';\n\n\t\tif (enableWrap && this.overflow != 'fill' && this.overflow != 'width')\n\t\t{\n\t\t\tvar sizeDiv = node;\n\t\t\t\n\t\t\tif (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == 'DIV')\n\t\t\t{\n\t\t\t\tsizeDiv = sizeDiv.firstChild;\n\t\t\t\t\n\t\t\t\tif (node.style.wordWrap == 'break-word')\n\t\t\t\t{\n\t\t\t\t\tsizeDiv.style.width = '100%';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar tmp = sizeDiv.offsetWidth;\n\t\t\t\n\t\t\t// Workaround for text measuring in hidden containers\n\t\t\tif (tmp == 0)\n\t\t\t{\n\t\t\t\tvar prev = node.parentNode;\n\t\t\t\tnode.style.visibility = 'hidden';\n\t\t\t\tdocument.body.appendChild(node);\n\t\t\t\ttmp = sizeDiv.offsetWidth;\n\t\t\t\tnode.style.visibility = '';\n\t\t\t\tprev.appendChild(node);\n\t\t\t}\n\n\t\t\ttmp += 3;\n\t\t\t\n\t\t\tif (this.clipped)\n\t\t\t{\n\t\t\t\ttmp = Math.min(tmp, w);\n\t\t\t}\n\t\t\t\n\t\t\tstyle.width = tmp + 'px';\n\t\t}\n\t}\n\telse\n\t{\n\t\tstyle.whiteSpace = 'nowrap';\n\t}\n};\n\n/**\n * Function: getMargin\n *\n * Returns the spacing as an <mxPoint>.\n */\nmxText.prototype.updateMargin = function()\n{\n\tthis.margin = mxUtils.getAlignmentAsPoint(this.align, this.valign);\n};\n\n/**\n * Function: getSpacing\n *\n * Returns the spacing as an <mxPoint>.\n */\nmxText.prototype.getSpacing = function()\n{\n\tvar dx = 0;\n\tvar dy = 0;\n\n\tif (this.align == mxConstants.ALIGN_CENTER)\n\t{\n\t\tdx = (this.spacingLeft - this.spacingRight) / 2;\n\t}\n\telse if (this.align == mxConstants.ALIGN_RIGHT)\n\t{\n\t\tdx = -this.spacingRight - this.baseSpacingRight;\n\t}\n\telse\n\t{\n\t\tdx = this.spacingLeft + this.baseSpacingLeft;\n\t}\n\n\tif (this.valign == mxConstants.ALIGN_MIDDLE)\n\t{\n\t\tdy = (this.spacingTop - this.spacingBottom) / 2;\n\t}\n\telse if (this.valign == mxConstants.ALIGN_BOTTOM)\n\t{\n\t\tdy = -this.spacingBottom - this.baseSpacingBottom;;\n\t}\n\telse\n\t{\n\t\tdy = this.spacingTop + this.baseSpacingTop;\n\t}\n\t\n\treturn new mxPoint(dx, dy);\n};\n\n__mxOutput.mxText = typeof mxText !== 'undefined' ? mxText : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxTriangle\n * \n * Implementation of the triangle shape.\n * \n * Constructor: mxTriangle\n *\n * Constructs a new triangle shape.\n */\nfunction mxTriangle()\n{\n\tmxActor.call(this);\n};\n\n/**\n * Extends mxActor.\n */\nmxUtils.extend(mxTriangle, mxActor);\n\n/**\n * Function: isRoundable\n * \n * Adds roundable support.\n */\nmxTriangle.prototype.isRoundable = function()\n{\n\treturn true;\n};\n\n/**\n * Function: redrawPath\n *\n * Draws the path for this shape.\n */\nmxTriangle.prototype.redrawPath = function(c, x, y, w, h)\n{\n\tvar arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;\n\tthis.addPoints(c, [new mxPoint(0, 0), new mxPoint(w, 0.5 * h), new mxPoint(0, h)], this.isRounded, arcSize, true);\n};\n\n__mxOutput.mxTriangle = typeof mxTriangle !== 'undefined' ? mxTriangle : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxHexagon\n * \n * Implementation of the hexagon shape.\n * \n * Constructor: mxHexagon\n *\n * Constructs a new hexagon shape.\n */\nfunction mxHexagon()\n{\n\tmxActor.call(this);\n};\n\n/**\n * Extends mxActor.\n */\nmxUtils.extend(mxHexagon, mxActor);\n\n/**\n * Function: redrawPath\n *\n * Draws the path for this shape.\n */\nmxHexagon.prototype.redrawPath = function(c, x, y, w, h)\n{\n\tvar arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;\n\tthis.addPoints(c, [new mxPoint(0.25 * w, 0), new mxPoint(0.75 * w, 0), new mxPoint(w, 0.5 * h), new mxPoint(0.75 * w, h),\n\t                   new mxPoint(0.25 * w, h), new mxPoint(0, 0.5 * h)], this.isRounded, arcSize, true);\n};\n\n__mxOutput.mxHexagon = typeof mxHexagon !== 'undefined' ? mxHexagon : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxLine\n *\n * Extends <mxShape> to implement a horizontal line shape.\n * This shape is registered under <mxConstants.SHAPE_LINE> in\n * <mxCellRenderer>.\n * \n * Constructor: mxLine\n *\n * Constructs a new line shape.\n * \n * Parameters:\n * \n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * stroke - String that defines the stroke color. Default is 'black'. This is\n * stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxLine(bounds, stroke, strokewidth, vertical)\n{\n\tmxShape.call(this);\n\tthis.bounds = bounds;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n\tthis.vertical = (vertical != null) ? vertical : this.vertical;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxLine, mxShape);\n\n/**\n * Function: vertical\n * \n * Whether to paint a vertical line.\n */\nmxLine.prototype.vertical = false;\n\n/**\n * Function: paintVertexShape\n * \n * Redirects to redrawPath for subclasses to work.\n */\nmxLine.prototype.paintVertexShape = function(c, x, y, w, h)\n{\n\tc.begin();\n\n\tif (this.vertical)\n\t{\n\t\tvar mid = x + w / 2;\n\t\tc.moveTo(mid, y);\n\t\tc.lineTo(mid, y + h);\n\t}\n\telse\n\t{\n\t\tvar mid = y + h / 2;\n\t\tc.moveTo(x, mid);\n\t\tc.lineTo(x + w, mid);\n\t}\n\n\tc.stroke();\n};\n\n__mxOutput.mxLine = typeof mxLine !== 'undefined' ? mxLine : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxImageShape\n *\n * Extends <mxShape> to implement an image shape. This shape is registered\n * under <mxConstants.SHAPE_IMAGE> in <mxCellRenderer>.\n * \n * Constructor: mxImageShape\n * \n * Constructs a new image shape.\n * \n * Parameters:\n * \n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * image - String that specifies the URL of the image. This is stored in\n * <image>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 0. This is stored in <strokewidth>.\n */\nfunction mxImageShape(bounds, image, fill, stroke, strokewidth)\n{\n\tmxShape.call(this);\n\tthis.bounds = bounds;\n\tthis.image = image;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n\tthis.shadow = false;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxImageShape, mxRectangleShape);\n\n/**\n * Variable: preserveImageAspect\n *\n * Switch to preserve image aspect. Default is true.\n */\nmxImageShape.prototype.preserveImageAspect = true;\n\n/**\n * Function: getSvgScreenOffset\n * \n * Disables offset in IE9 for crisper image output.\n */\nmxImageShape.prototype.getSvgScreenOffset = function()\n{\n\treturn 0;\n};\n\n/**\n * Function: apply\n * \n * Overrides <mxShape.apply> to replace the fill and stroke colors with the\n * respective values from <mxConstants.STYLE_IMAGE_BACKGROUND> and\n * <mxConstants.STYLE_IMAGE_BORDER>.\n * \n * Applies the style of the given <mxCellState> to the shape. This\n * implementation assigns the following styles to local fields:\n * \n * - <mxConstants.STYLE_IMAGE_BACKGROUND> => fill\n * - <mxConstants.STYLE_IMAGE_BORDER> => stroke\n *\n * Parameters:\n *\n * state - <mxCellState> of the corresponding cell.\n */\nmxImageShape.prototype.apply = function(state)\n{\n\tmxShape.prototype.apply.apply(this, arguments);\n\t\n\tthis.fill = null;\n\tthis.stroke = null;\n\tthis.gradient = null;\n\t\n\tif (this.style != null)\n\t{\n\t\tthis.preserveImageAspect = mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_ASPECT, 1) == 1;\n\t\t\n\t\t// Legacy support for imageFlipH/V\n\t\tthis.flipH = this.flipH || mxUtils.getValue(this.style, 'imageFlipH', 0) == 1;\n\t\tthis.flipV = this.flipV || mxUtils.getValue(this.style, 'imageFlipV', 0) == 1;\n\t}\n};\n\n/**\n * Function: isHtmlAllowed\n * \n * Returns true if HTML is allowed for this shape. This implementation always\n * returns false.\n */\nmxImageShape.prototype.isHtmlAllowed = function()\n{\n\treturn !this.preserveImageAspect;\n};\n\n/**\n * Function: createHtml\n *\n * Creates and returns the HTML DOM node(s) to represent\n * this shape. This implementation falls back to <createVml>\n * so that the HTML creation is optional.\n */\nmxImageShape.prototype.createHtml = function()\n{\n\tvar node = document.createElement('div');\n\tnode.style.position = 'absolute';\n\n\treturn node;\n};\n\n/**\n * Function: isRoundable\n * \n * Disables inherited roundable support.\n */\nmxImageShape.prototype.isRoundable = function(c, x, y, w, h)\n{\n\treturn false;\n};\n\n/**\n * Function: paintVertexShape\n * \n * Generic background painting implementation.\n */\nmxImageShape.prototype.paintVertexShape = function(c, x, y, w, h)\n{\n\tif (this.image != null)\n\t{\n\t\tvar fill = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BACKGROUND, null);\n\t\tvar stroke = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, null);\n\t\t\n\t\tif (fill != null)\n\t\t{\n\t\t\t// Stroke rendering required for shadow\n\t\t\tc.setFillColor(fill);\n\t\t\tc.setStrokeColor(stroke);\n\t\t\tc.rect(x, y, w, h);\n\t\t\tc.fillAndStroke();\n\t\t}\n\n\t\t// FlipH/V are implicit via mxShape.updateTransform\n\t\tc.image(x, y, w, h, this.image, this.preserveImageAspect, false, false);\n\t\t\n\t\tvar stroke = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, null);\n\t\t\n\t\tif (stroke != null)\n\t\t{\n\t\t\tc.setShadow(false);\n\t\t\tc.setStrokeColor(stroke);\n\t\t\tc.rect(x, y, w, h);\n\t\t\tc.stroke();\n\t\t}\n\t}\n\telse\n\t{\n\t\tmxRectangleShape.prototype.paintBackground.apply(this, arguments);\n\t}\n};\n\n/**\n * Function: redraw\n * \n * Overrides <mxShape.redraw> to preserve the aspect ratio of images.\n */\nmxImageShape.prototype.redrawHtmlShape = function()\n{\n\tthis.node.style.left = Math.round(this.bounds.x) + 'px';\n\tthis.node.style.top = Math.round(this.bounds.y) + 'px';\n\tthis.node.style.width = Math.max(0, Math.round(this.bounds.width)) + 'px';\n\tthis.node.style.height = Math.max(0, Math.round(this.bounds.height)) + 'px';\n\tthis.node.innerHTML = '';\n\n\tif (this.image != null)\n\t{\n\t\tvar fill = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BACKGROUND, '');\n\t\tvar stroke = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, '');\n\t\tthis.node.style.backgroundColor = fill;\n\t\tthis.node.style.borderColor = stroke;\n\t\t\n\t\t// VML image supports PNG in IE6\n\t\tvar useVml = mxClient.IS_IE6 || ((document.documentMode == null || document.documentMode <= 8) && this.rotation != 0);\n\t\tvar img = document.createElement((useVml) ? mxClient.VML_PREFIX + ':image' : 'img');\n\t\timg.setAttribute('border', '0');\n\t\timg.style.position = 'absolute';\n\t\timg.src = this.image;\n\n\t\tvar filter = (this.opacity < 100) ? 'alpha(opacity=' + this.opacity + ')' : '';\n\t\tthis.node.style.filter = filter;\n\t\t\n\t\tif (this.flipH && this.flipV)\n\t\t{\n\t\t\tfilter += 'progid:DXImageTransform.Microsoft.BasicImage(rotation=2)';\n\t\t}\n\t\telse if (this.flipH)\n\t\t{\n\t\t\tfilter += 'progid:DXImageTransform.Microsoft.BasicImage(mirror=1)';\n\t\t}\n\t\telse if (this.flipV)\n\t\t{\n\t\t\tfilter += 'progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)';\n\t\t}\n\n\t\tif (img.style.filter != filter)\n\t\t{\n\t\t\timg.style.filter = filter;\n\t\t}\n\n\t\tif (img.nodeName == 'image')\n\t\t{\n\t\t\timg.style.rotation = this.rotation;\n\t\t}\n\t\telse if (this.rotation != 0)\n\t\t{\n\t\t\t// LATER: Add flipV/H support\n\t\t\tmxUtils.setPrefixedStyle(img.style, 'transform', 'rotate(' + this.rotation + 'deg)');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmxUtils.setPrefixedStyle(img.style, 'transform', '');\n\t\t}\n\n\t\t// Known problem: IE clips top line of image for certain angles\n\t\timg.style.width = this.node.style.width;\n\t\timg.style.height = this.node.style.height;\n\t\t\n\t\tthis.node.style.backgroundImage = '';\n\t\tthis.node.appendChild(img);\n\t}\n\telse\n\t{\n\t\tthis.setTransparentBackgroundImage(this.node);\n\t}\n};\n\n__mxOutput.mxImageShape = typeof mxImageShape !== 'undefined' ? mxImageShape : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxLabel\n *\n * Extends <mxShape> to implement an image shape with a label.\n * This shape is registered under <mxConstants.SHAPE_LABEL> in\n * <mxCellRenderer>.\n * \n * Constructor: mxLabel\n *\n * Constructs a new label shape.\n * \n * Parameters:\n * \n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxLabel(bounds, fill, stroke, strokewidth)\n{\n\tmxRectangleShape.call(this, bounds, fill, stroke, strokewidth);\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxLabel, mxRectangleShape);\n\n/**\n * Variable: imageSize\n *\n * Default width and height for the image. Default is\n * <mxConstants.DEFAULT_IMAGESIZE>.\n */\nmxLabel.prototype.imageSize = mxConstants.DEFAULT_IMAGESIZE;\n\n/**\n * Variable: spacing\n *\n * Default value for image spacing. Default is 2.\n */\nmxLabel.prototype.spacing = 2;\n\n/**\n * Variable: indicatorSize\n *\n * Default width and height for the indicicator. Default is 10.\n */\nmxLabel.prototype.indicatorSize = 10;\n\n/**\n * Variable: indicatorSpacing\n *\n * Default spacing between image and indicator. Default is 2.\n */\nmxLabel.prototype.indicatorSpacing = 2;\n\n/**\n * Function: init\n *\n * Initializes the shape and the <indicator>.\n */\nmxLabel.prototype.init = function(container)\n{\n\tmxShape.prototype.init.apply(this, arguments);\n\n\tif (this.indicatorShape != null)\n\t{\n\t\tthis.indicator = new this.indicatorShape();\n\t\tthis.indicator.dialect = this.dialect;\n\t\tthis.indicator.init(this.node);\n\t}\n};\n\n/**\n * Function: redraw\n *\n * Reconfigures this shape. This will update the colors of the indicator\n * and reconfigure it if required.\n */\nmxLabel.prototype.redraw = function()\n{\n\tif (this.indicator != null)\n\t{\n\t\tthis.indicator.fill = this.indicatorColor;\n\t\tthis.indicator.stroke = this.indicatorStrokeColor;\n\t\tthis.indicator.gradient = this.indicatorGradientColor;\n\t\tthis.indicator.direction = this.indicatorDirection;\n\t\tthis.indicator.redraw();\n\t}\n\t\n\tmxShape.prototype.redraw.apply(this, arguments);\n};\n\n/**\n * Function: isHtmlAllowed\n *\n * Returns true for non-rounded, non-rotated shapes with no glass gradient and\n * no indicator shape.\n */\nmxLabel.prototype.isHtmlAllowed = function()\n{\n\treturn mxRectangleShape.prototype.isHtmlAllowed.apply(this, arguments) &&\n\t\tthis.indicatorColor == null && this.indicatorShape == null;\n};\n\n/**\n * Function: paintForeground\n * \n * Generic background painting implementation.\n */\nmxLabel.prototype.paintForeground = function(c, x, y, w, h)\n{\n\tthis.paintImage(c, x, y, w, h);\n\tthis.paintIndicator(c, x, y, w, h);\n\t\n\tmxRectangleShape.prototype.paintForeground.apply(this, arguments);\n};\n\n/**\n * Function: paintImage\n * \n * Generic background painting implementation.\n */\nmxLabel.prototype.paintImage = function(c, x, y, w, h)\n{\n\tif (this.image != null)\n\t{\n\t\tvar bounds = this.getImageBounds(x, y, w, h);\n\t\tc.image(bounds.x, bounds.y, bounds.width, bounds.height, this.image, false, false, false);\n\t}\n};\n\n/**\n * Function: getImageBounds\n * \n * Generic background painting implementation.\n */\nmxLabel.prototype.getImageBounds = function(x, y, w, h)\n{\n\tvar align = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_ALIGN, mxConstants.ALIGN_LEFT);\n\tvar valign = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);\n\tvar width = mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_WIDTH, mxConstants.DEFAULT_IMAGESIZE);\n\tvar height = mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_HEIGHT, mxConstants.DEFAULT_IMAGESIZE);\n\tvar spacing = mxUtils.getNumber(this.style, mxConstants.STYLE_SPACING, this.spacing) + 5;\n\n\tif (align == mxConstants.ALIGN_CENTER)\n\t{\n\t\tx += (w - width) / 2;\n\t}\n\telse if (align == mxConstants.ALIGN_RIGHT)\n\t{\n\t\tx += w - width - spacing;\n\t}\n\telse // default is left\n\t{\n\t\tx += spacing;\n\t}\n\n\tif (valign == mxConstants.ALIGN_TOP)\n\t{\n\t\ty += spacing;\n\t}\n\telse if (valign == mxConstants.ALIGN_BOTTOM)\n\t{\n\t\ty += h - height - spacing;\n\t}\n\telse // default is middle\n\t{\n\t\ty += (h - height) / 2;\n\t}\n\t\n\treturn new mxRectangle(x, y, width, height);\n};\n\n/**\n * Function: paintIndicator\n * \n * Generic background painting implementation.\n */\nmxLabel.prototype.paintIndicator = function(c, x, y, w, h)\n{\n\tif (this.indicator != null)\n\t{\n\t\tthis.indicator.bounds = this.getIndicatorBounds(x, y, w, h);\n\t\tthis.indicator.paint(c);\n\t}\n\telse if (this.indicatorImage != null)\n\t{\n\t\tvar bounds = this.getIndicatorBounds(x, y, w, h);\n\t\tc.image(bounds.x, bounds.y, bounds.width, bounds.height, this.indicatorImage, false, false, false);\n\t}\n};\n\n/**\n * Function: getIndicatorBounds\n * \n * Generic background painting implementation.\n */\nmxLabel.prototype.getIndicatorBounds = function(x, y, w, h)\n{\n\tvar align = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_ALIGN, mxConstants.ALIGN_LEFT);\n\tvar valign = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);\n\tvar width = mxUtils.getNumber(this.style, mxConstants.STYLE_INDICATOR_WIDTH, this.indicatorSize);\n\tvar height = mxUtils.getNumber(this.style, mxConstants.STYLE_INDICATOR_HEIGHT, this.indicatorSize);\n\tvar spacing = this.spacing + 5;\t\t\n\t\n\tif (align == mxConstants.ALIGN_RIGHT)\n\t{\n\t\tx += w - width - spacing;\n\t}\n\telse if (align == mxConstants.ALIGN_CENTER)\n\t{\n\t\tx += (w - width) / 2;\n\t}\n\telse // default is left\n\t{\n\t\tx += spacing;\n\t}\n\t\n\tif (valign == mxConstants.ALIGN_BOTTOM)\n\t{\n\t\ty += h - height - spacing;\n\t}\n\telse if (valign == mxConstants.ALIGN_TOP)\n\t{\n\t\ty += spacing;\n\t}\n\telse // default is middle\n\t{\n\t\ty += (h - height) / 2;\n\t}\n\t\n\treturn new mxRectangle(x, y, width, height);\n};\n/**\n * Function: redrawHtmlShape\n * \n * Generic background painting implementation.\n */\nmxLabel.prototype.redrawHtmlShape = function()\n{\n\tmxRectangleShape.prototype.redrawHtmlShape.apply(this, arguments);\n\t\n\t// Removes all children\n\twhile(this.node.hasChildNodes())\n\t{\n\t\tthis.node.removeChild(this.node.lastChild);\n\t}\n\t\n\tif (this.image != null)\n\t{\n\t\tvar node = document.createElement('img');\n\t\tnode.style.position = 'relative';\n\t\tnode.setAttribute('border', '0');\n\t\t\n\t\tvar bounds = this.getImageBounds(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);\n\t\tbounds.x -= this.bounds.x;\n\t\tbounds.y -= this.bounds.y;\n\n\t\tnode.style.left = Math.round(bounds.x) + 'px';\n\t\tnode.style.top = Math.round(bounds.y) + 'px';\n\t\tnode.style.width = Math.round(bounds.width) + 'px';\n\t\tnode.style.height = Math.round(bounds.height) + 'px';\n\t\t\n\t\tnode.src = this.image;\n\t\t\n\t\tthis.node.appendChild(node);\n\t}\n};\n\n__mxOutput.mxLabel = typeof mxLabel !== 'undefined' ? mxLabel : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCylinder\n *\n * Extends <mxShape> to implement an cylinder shape. If a\n * custom shape with one filled area and an overlay path is\n * needed, then this shape's <redrawPath> should be overridden.\n * This shape is registered under <mxConstants.SHAPE_CYLINDER>\n * in <mxCellRenderer>.\n * \n * Constructor: mxCylinder\n *\n * Constructs a new cylinder shape.\n * \n * Parameters:\n * \n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxCylinder(bounds, fill, stroke, strokewidth)\n{\n\tmxShape.call(this);\n\tthis.bounds = bounds;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxCylinder, mxShape);\n\n/**\n * Variable: maxHeight\n *\n * Defines the maximum height of the top and bottom part\n * of the cylinder shape.\n */\nmxCylinder.prototype.maxHeight = 40;\n\n/**\n * Variable: svgStrokeTolerance\n *\n * Sets stroke tolerance to 0 for SVG.\n */\nmxCylinder.prototype.svgStrokeTolerance = 0;\n\n/**\n * Function: paintVertexShape\n * \n * Redirects to redrawPath for subclasses to work.\n */\nmxCylinder.prototype.paintVertexShape = function(c, x, y, w, h)\n{\n\tc.translate(x, y);\n\tc.begin();\n\tthis.redrawPath(c, x, y, w, h, false);\n\tc.fillAndStroke();\n\t\n\tif (!this.outline || this.style == null || mxUtils.getValue(\n\t\tthis.style, mxConstants.STYLE_BACKGROUND_OUTLINE, 0) == 0)\n\t{\n\t\tc.setShadow(false);\n\t\tc.begin();\n\t\tthis.redrawPath(c, x, y, w, h, true);\n\t\tc.stroke();\n\t}\n};\n\n/**\n * Function: getCylinderSize\n *\n * Returns the cylinder size.\n */\nmxCylinder.prototype.getCylinderSize = function(x, y, w, h)\n{\n\treturn Math.min(this.maxHeight, Math.round(h / 5));\n};\n\n/**\n * Function: redrawPath\n *\n * Draws the path for this shape.\n */\nmxCylinder.prototype.redrawPath = function(c, x, y, w, h, isForeground)\n{\n\tvar dy = this.getCylinderSize(x, y, w, h);\n\t\n\tif ((isForeground && this.fill != null) || (!isForeground && this.fill == null))\n\t{\n\t\tc.moveTo(0, dy);\n\t\tc.curveTo(0, 2 * dy, w, 2 * dy, w, dy);\n\t\t\n\t\t// Needs separate shapes for correct hit-detection\n\t\tif (!isForeground)\n\t\t{\n\t\t\tc.stroke();\n\t\t\tc.begin();\n\t\t}\n\t}\n\t\n\tif (!isForeground)\n\t{\n\t\tc.moveTo(0, dy);\n\t\tc.curveTo(0, -dy / 3, w, -dy / 3, w, dy);\n\t\tc.lineTo(w, h - dy);\n\t\tc.curveTo(w, h + dy / 3, 0, h + dy / 3, 0, h - dy);\n\t\tc.close();\n\t}\n};\n\n__mxOutput.mxCylinder = typeof mxCylinder !== 'undefined' ? mxCylinder : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxConnector\n * \n * Extends <mxShape> to implement a connector shape. The connector\n * shape allows for arrow heads on either side.\n * \n * This shape is registered under <mxConstants.SHAPE_CONNECTOR> in\n * <mxCellRenderer>.\n * \n * Constructor: mxConnector\n * \n * Constructs a new connector shape.\n * \n * Parameters:\n * \n * points - Array of <mxPoints> that define the points. This is stored in\n * <mxShape.points>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * Default is 'black'.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxConnector(points, stroke, strokewidth)\n{\n\tmxPolyline.call(this, points, stroke, strokewidth);\n};\n\n/**\n * Extends mxPolyline.\n */\nmxUtils.extend(mxConnector, mxPolyline);\n\n/**\n * Function: updateBoundingBox\n *\n * Updates the <boundingBox> for this shape using <createBoundingBox> and\n * <augmentBoundingBox> and stores the result in <boundingBox>.\n */\nmxConnector.prototype.updateBoundingBox = function()\n{\n\tthis.useSvgBoundingBox = this.style != null && this.style[mxConstants.STYLE_CURVED] == 1;\n\tmxShape.prototype.updateBoundingBox.apply(this, arguments);\n};\n\n/**\n * Function: paintEdgeShape\n * \n * Paints the line shape.\n */\nmxConnector.prototype.paintEdgeShape = function(c, pts)\n{\n\t// The indirection via functions for markers is needed in\n\t// order to apply the offsets before painting the line and\n\t// paint the markers after painting the line.\n\tvar sourceMarker = this.createMarker(c, pts, true);\n\tvar targetMarker = this.createMarker(c, pts, false);\n\n\tmxPolyline.prototype.paintEdgeShape.apply(this, arguments);\n\t\n\t// Disables shadows, dashed styles and fixes fill color for markers\n\tc.setFillColor(this.stroke);\n\tc.setShadow(false);\n\tc.setDashed(false);\n\t\n\tif (sourceMarker != null)\n\t{\n\t\tsourceMarker();\n\t}\n\t\n\tif (targetMarker != null)\n\t{\n\t\ttargetMarker();\n\t}\n};\n\n/**\n * Function: createMarker\n * \n * Prepares the marker by adding offsets in pts and returning a function to\n * paint the marker.\n */\nmxConnector.prototype.createMarker = function(c, pts, source)\n{\n\tvar result = null;\n\tvar n = pts.length;\n\tvar type = mxUtils.getValue(this.style, (source) ? mxConstants.STYLE_STARTARROW : mxConstants.STYLE_ENDARROW);\n\tvar p0 = (source) ? pts[1] : pts[n - 2];\n\tvar pe = (source) ? pts[0] : pts[n - 1];\n\t\n\tif (type != null && p0 != null && pe != null)\n\t{\n\t\tvar count = 1;\n\t\t\n\t\t// Uses next non-overlapping point\n\t\twhile (count < n - 1 && Math.round(p0.x - pe.x) == 0 && Math.round(p0.y - pe.y) == 0)\n\t\t{\n\t\t\tp0 = (source) ? pts[1 + count] : pts[n - 2 - count];\n\t\t\tcount++;\n\t\t}\n\t\n\t\t// Computes the norm and the inverse norm\n\t\tvar dx = pe.x - p0.x;\n\t\tvar dy = pe.y - p0.y;\n\t\n\t\tvar dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));\n\t\t\n\t\tvar unitX = dx / dist;\n\t\tvar unitY = dy / dist;\n\t\n\t\tvar size = mxUtils.getNumber(this.style, (source) ? mxConstants.STYLE_STARTSIZE : mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE);\n\t\t\n\t\t// Allow for stroke width in the end point used and the \n\t\t// orthogonal vectors describing the direction of the marker\n\t\tvar filled = this.style[(source) ? mxConstants.STYLE_STARTFILL : mxConstants.STYLE_ENDFILL] != 0;\n\t\t\n\t\tresult = mxMarker.createMarker(c, this, type, pe, unitX, unitY, size, source, this.strokewidth, filled);\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: augmentBoundingBox\n *\n * Augments the bounding box with the strokewidth and shadow offsets.\n */\nmxConnector.prototype.augmentBoundingBox = function(bbox)\n{\n\tmxShape.prototype.augmentBoundingBox.apply(this, arguments);\n\t\n\t// Adds marker sizes\n\tvar size = 0;\n\t\n\tif (mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, mxConstants.NONE) != mxConstants.NONE)\n\t{\n\t\tsize = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_MARKERSIZE) + 1;\n\t}\n\t\n\tif (mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE)\n\t{\n\t\tsize = Math.max(size, mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE)) + 1;\n\t}\n\t\n\tbbox.grow(size * this.scale);\n};\n\n__mxOutput.mxConnector = typeof mxConnector !== 'undefined' ? mxConnector : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxSwimlane\n *\n * Extends <mxShape> to implement a swimlane shape. This shape is registered\n * under <mxConstants.SHAPE_SWIMLANE> in <mxCellRenderer>. Use the\n * <mxConstants.STYLE_STYLE_STARTSIZE> to define the size of the title\n * region, <mxConstants.STYLE_SWIMLANE_FILLCOLOR> for the content area fill,\n * <mxConstants.STYLE_SEPARATORCOLOR> to draw an additional vertical separator\n * and <mxConstants.STYLE_SWIMLANE_LINE> to hide the line between the title\n * region and the content area. The <mxConstants.STYLE_HORIZONTAL> affects\n * the orientation of this shape, not only its label.\n * \n * Constructor: mxSwimlane\n *\n * Constructs a new swimlane shape.\n * \n * Parameters:\n * \n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxSwimlane(bounds, fill, stroke, strokewidth)\n{\n\tmxShape.call(this);\n\tthis.bounds = bounds;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxSwimlane, mxShape);\n\n/**\n * Variable: imageSize\n *\n * Default imagewidth and imageheight if an image but no imagewidth\n * and imageheight are defined in the style. Value is 16.\n */\nmxSwimlane.prototype.imageSize = 16;\n\n/**\n * Function: isRoundable\n * \n * Adds roundable support.\n */\nmxSwimlane.prototype.isRoundable = function(c, x, y, w, h)\n{\n\treturn true;\n};\n\n/**\n * Function: getTitleSize\n * \n * Returns the title size.\n */\nmxSwimlane.prototype.getTitleSize = function()\n{\n\treturn Math.max(0, mxUtils.getValue(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));\n};\n\n/**\n * Function: getLabelBounds\n * \n * Returns the bounding box for the label.\n */\nmxSwimlane.prototype.getLabelBounds = function(rect)\n{\n\tvar start = this.getTitleSize();\n\tvar bounds = new mxRectangle(rect.x, rect.y, rect.width, rect.height);\n\tvar horizontal = this.isHorizontal();\n\t\n\tvar flipH = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, 0) == 1;\n\tvar flipV = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, 0) == 1;\t\n\t\n\t// East is default\n\tvar shapeVertical = (this.direction == mxConstants.DIRECTION_NORTH ||\n\t\t\tthis.direction == mxConstants.DIRECTION_SOUTH);\n\tvar realHorizontal = horizontal == !shapeVertical;\n\t\n\tvar realFlipH = !realHorizontal && flipH != (this.direction == mxConstants.DIRECTION_SOUTH ||\n\t\t\tthis.direction == mxConstants.DIRECTION_WEST);\n\tvar realFlipV = realHorizontal && flipV != (this.direction == mxConstants.DIRECTION_SOUTH ||\n\t\t\tthis.direction == mxConstants.DIRECTION_WEST);\n\n\t// Shape is horizontal\n\tif (!shapeVertical)\n\t{\n\t\tvar tmp = Math.min(bounds.height, start * this.scale);\n\n\t\tif (realFlipH || realFlipV)\n\t\t{\n\t\t\tbounds.y += bounds.height - tmp;\n\t\t}\n\n\t\tbounds.height = tmp;\n\t}\n\telse\n\t{\n\t\tvar tmp = Math.min(bounds.width, start * this.scale);\n\t\t\n\t\tif (realFlipH || realFlipV)\n\t\t{\n\t\t\tbounds.x += bounds.width - tmp;\t\n\t\t}\n\n\t\tbounds.width = tmp;\n\t}\n\t\n\treturn bounds;\n};\n\n/**\n * Function: getGradientBounds\n * \n * Returns the bounding box for the gradient box for this shape.\n */\nmxSwimlane.prototype.getGradientBounds = function(c, x, y, w, h)\n{\n\tvar start = this.getTitleSize();\n\t\n\tif (this.isHorizontal())\n\t{\n\t\tstart = Math.min(start, h);\n\t\treturn new mxRectangle(x, y, w, start);\n\t}\n\telse\n\t{\n\t\tstart = Math.min(start, w);\n\t\treturn new mxRectangle(x, y, start, h);\n\t}\n};\n\n/**\n * Function: getSwimlaneArcSize\n * \n * Returns the arcsize for the swimlane.\n */\nmxSwimlane.prototype.getSwimlaneArcSize = function(w, h, start)\n{\n\tif (mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0) == '1')\n\t{\n\t\treturn Math.min(w / 2, Math.min(h / 2, mxUtils.getValue(this.style,\n\t\t\tmxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2));\n\t}\n\telse\n\t{\n\t\tvar f = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.RECTANGLE_ROUNDING_FACTOR * 100) / 100;\n\n\t\treturn start * f * 3; \n\t}\n};\n\n/**\n * Function: isHorizontal\n *\n * Paints the swimlane vertex shape.\n */\nmxSwimlane.prototype.isHorizontal = function()\n{\n\treturn mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, 1) == 1;\n};\n\n/**\n * Function: paintVertexShape\n *\n * Paints the swimlane vertex shape.\n */\nmxSwimlane.prototype.paintVertexShape = function(c, x, y, w, h)\n{\n\tvar start = this.getTitleSize();\n\tvar fill = mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_FILLCOLOR, mxConstants.NONE);\n\tvar swimlaneLine = mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_LINE, 1) == 1;\n\tvar r = 0;\n\t\n\tif (this.isHorizontal())\n\t{\n\t\tstart = Math.min(start, h);\n\t}\n\telse\n\t{\n\t\tstart = Math.min(start, w);\n\t}\n\t\n\tc.translate(x, y);\n\t\n\tif (!this.isRounded)\n\t{\n\t\tthis.paintSwimlane(c, x, y, w, h, start, fill, swimlaneLine);\n\t}\n\telse\n\t{\n\t\tr = this.getSwimlaneArcSize(w, h, start);\n\t\tr = Math.min(((this.isHorizontal()) ? h : w) - start, Math.min(start, r));\n\t\tthis.paintRoundedSwimlane(c, x, y, w, h, start, r, fill, swimlaneLine);\n\t}\n\t\n\tvar sep = mxUtils.getValue(this.style, mxConstants.STYLE_SEPARATORCOLOR, mxConstants.NONE);\n\tthis.paintSeparator(c, x, y, w, h, start, sep);\n\n\tif (this.image != null)\n\t{\n\t\tvar bounds = this.getImageBounds(x, y, w, h);\n\t\tc.image(bounds.x - x, bounds.y - y, bounds.width, bounds.height,\n\t\t\t\tthis.image, false, false, false);\n\t}\n\t\n\tif (this.glass)\n\t{\n\t\tc.setShadow(false);\n\t\tthis.paintGlassEffect(c, 0, 0, w, start, r);\n\t}\n};\n\n/**\n * Function: paintSwimlane\n *\n * Paints the swimlane vertex shape.\n */\nmxSwimlane.prototype.paintSwimlane = function(c, x, y, w, h, start, fill, swimlaneLine)\n{\n\tc.begin();\n\t\n\tvar events = true;\n\t\n\tif (this.style != null)\n\t{\n\t\tevents = mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, '1') == '1';\n\t}\n\t\n\tif (!events && (this.fill == null || this.fill == mxConstants.NONE))\n\t{\n\t\tc.pointerEvents = false;\n\t}\n\t\n\tif (this.isHorizontal())\n\t{\n\t\tc.moveTo(0, start);\n\t\tc.lineTo(0, 0);\n\t\tc.lineTo(w, 0);\n\t\tc.lineTo(w, start);\n\t\tc.fillAndStroke();\n\n\t\tif (start < h)\n\t\t{\n\t\t\tif (fill == mxConstants.NONE || !events)\n\t\t\t{\n\t\t\t\tc.pointerEvents = false;\n\t\t\t}\n\t\t\t\n\t\t\tif (fill != mxConstants.NONE)\n\t\t\t{\n\t\t\t\tc.setFillColor(fill);\n\t\t\t}\n\t\t\t\n\t\t\tc.begin();\n\t\t\tc.moveTo(0, start);\n\t\t\tc.lineTo(0, h);\n\t\t\tc.lineTo(w, h);\n\t\t\tc.lineTo(w, start);\n\t\t\t\n\t\t\tif (fill == mxConstants.NONE)\n\t\t\t{\n\t\t\t\tc.stroke();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc.fillAndStroke();\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tc.moveTo(start, 0);\n\t\tc.lineTo(0, 0);\n\t\tc.lineTo(0, h);\n\t\tc.lineTo(start, h);\n\t\tc.fillAndStroke();\n\t\t\n\t\tif (start < w)\n\t\t{\n\t\t\tif (fill == mxConstants.NONE || !events)\n\t\t\t{\n\t\t\t\tc.pointerEvents = false;\n\t\t\t}\n\t\t\t\n\t\t\tif (fill != mxConstants.NONE)\n\t\t\t{\n\t\t\t\tc.setFillColor(fill);\n\t\t\t}\n\t\t\t\n\t\t\tc.begin();\n\t\t\tc.moveTo(start, 0);\n\t\t\tc.lineTo(w, 0);\n\t\t\tc.lineTo(w, h);\n\t\t\tc.lineTo(start, h);\n\t\t\t\n\t\t\tif (fill == mxConstants.NONE)\n\t\t\t{\n\t\t\t\tc.stroke();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc.fillAndStroke();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (swimlaneLine)\n\t{\n\t\tthis.paintDivider(c, x, y, w, h, start, fill == mxConstants.NONE);\n\t}\n};\n\n/**\n * Function: paintRoundedSwimlane\n *\n * Paints the swimlane vertex shape.\n */\nmxSwimlane.prototype.paintRoundedSwimlane = function(c, x, y, w, h, start, r, fill, swimlaneLine)\n{\n\tc.begin();\n\t\n\tvar events = true;\n\t\n\tif (this.style != null)\n\t{\n\t\tevents = mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, '1') == '1';\n\t}\n\t\n\tif (!events && (this.fill == null || this.fill == mxConstants.NONE))\n\t{\n\t\tc.pointerEvents = false;\n\t}\n\t\n\tif (this.isHorizontal())\n\t{\n\t\tc.moveTo(w, start);\n\t\tc.lineTo(w, r);\n\t\tc.quadTo(w, 0, w - Math.min(w / 2, r), 0);\n\t\tc.lineTo(Math.min(w / 2, r), 0);\n\t\tc.quadTo(0, 0, 0, r);\n\t\tc.lineTo(0, start);\n\t\tc.fillAndStroke();\n\t\t\n\t\tif (start < h)\n\t\t{\n\t\t\tif (fill == mxConstants.NONE || !events)\n\t\t\t{\n\t\t\t\tc.pointerEvents = false;\n\t\t\t}\n\t\t\t\n\t\t\tif (fill != mxConstants.NONE)\n\t\t\t{\n\t\t\t\tc.setFillColor(fill);\n\t\t\t}\n\t\t\t\n\t\t\tc.begin();\n\t\t\tc.moveTo(0, start);\n\t\t\tc.lineTo(0, h - r);\n\t\t\tc.quadTo(0, h, Math.min(w / 2, r), h);\n\t\t\tc.lineTo(w - Math.min(w / 2, r), h);\n\t\t\tc.quadTo(w, h, w, h - r);\n\t\t\tc.lineTo(w, start);\n\t\t\t\n\t\t\tif (fill == mxConstants.NONE)\n\t\t\t{\n\t\t\t\tc.stroke();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc.fillAndStroke();\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tc.moveTo(start, 0);\n\t\tc.lineTo(r, 0);\n\t\tc.quadTo(0, 0, 0, Math.min(h / 2, r));\n\t\tc.lineTo(0, h - Math.min(h / 2, r));\n\t\tc.quadTo(0, h, r, h);\n\t\tc.lineTo(start, h);\n\t\tc.fillAndStroke();\n\n\t\tif (start < w)\n\t\t{\n\t\t\tif (fill == mxConstants.NONE || !events)\n\t\t\t{\n\t\t\t\tc.pointerEvents = false;\n\t\t\t}\n\t\t\t\n\t\t\tif (fill != mxConstants.NONE)\n\t\t\t{\n\t\t\t\tc.setFillColor(fill);\n\t\t\t}\n\t\t\t\n\t\t\tc.begin();\n\t\t\tc.moveTo(start, h);\n\t\t\tc.lineTo(w - r, h);\n\t\t\tc.quadTo(w, h, w, h - Math.min(h / 2, r));\n\t\t\tc.lineTo(w, Math.min(h / 2, r));\n\t\t\tc.quadTo(w, 0, w - r, 0);\n\t\t\tc.lineTo(start, 0);\n\t\t\t\n\t\t\tif (fill == mxConstants.NONE)\n\t\t\t{\n\t\t\t\tc.stroke();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc.fillAndStroke();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (swimlaneLine)\n\t{\n\t\tthis.paintDivider(c, x, y, w, h, start, fill == mxConstants.NONE);\n\t}\n};\n\n/**\n * Function: paintDivider\n *\n * Paints the divider between swimlane title and content area.\n */\nmxSwimlane.prototype.paintDivider = function(c, x, y, w, h, start, shadow)\n{\n\tif (!shadow)\n\t{\n\t\tc.setShadow(false);\n\t}\n\n\tc.begin();\n\t\n\tif (this.isHorizontal())\n\t{\n\t\tc.moveTo(0, start);\n\t\tc.lineTo(w, start);\n\t}\n\telse\n\t{\n\t\tc.moveTo(start, 0);\n\t\tc.lineTo(start, h);\n\t}\n\n\tc.stroke();\n};\n\n/**\n * Function: paintSeparator\n *\n * Paints the vertical or horizontal separator line between swimlanes.\n */\nmxSwimlane.prototype.paintSeparator = function(c, x, y, w, h, start, color)\n{\n\tif (color != mxConstants.NONE)\n\t{\n\t\tc.setStrokeColor(color);\n\t\tc.setDashed(true);\n\t\tc.begin();\n\t\t\n\t\tif (this.isHorizontal())\n\t\t{\n\t\t\tc.moveTo(w, start);\n\t\t\tc.lineTo(w, h);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc.moveTo(start, 0);\n\t\t\tc.lineTo(w, 0);\n\t\t}\n\t\t\n\t\tc.stroke();\n\t\tc.setDashed(false);\n\t}\n};\n\n/**\n * Function: getImageBounds\n *\n * Paints the swimlane vertex shape.\n */\nmxSwimlane.prototype.getImageBounds = function(x, y, w, h)\n{\n\tif (this.isHorizontal())\n\t{\n\t\treturn new mxRectangle(x + w - this.imageSize, y, this.imageSize, this.imageSize);\n\t}\n\telse\n\t{\n\t\treturn new mxRectangle(x, y, this.imageSize, this.imageSize);\n\t}\n};\n\n__mxOutput.mxSwimlane = typeof mxSwimlane !== 'undefined' ? mxSwimlane : undefined;\n\n/**\n * Copyright (c) 2006-2018, JGraph Ltd\n * Copyright (c) 2006-2018, Gaudenz Alder\n */\n/**\n * Class: mxGraphLayout\n * \n * Base class for all layout algorithms in mxGraph. Main public functions are\n * <moveCell> for handling a moved cell within a layouted parent, and <execute> for\n * running the layout on a given parent cell.\n *\n * Known Subclasses:\n *\n * <mxCircleLayout>, <mxCompactTreeLayout>, <mxCompositeLayout>,\n * <mxFastOrganicLayout>, <mxParallelEdgeLayout>, <mxPartitionLayout>,\n * <mxStackLayout>\n * \n * Constructor: mxGraphLayout\n *\n * Constructs a new layout using the given layouts.\n *\n * Arguments:\n * \n * graph - Enclosing \n */\nfunction mxGraphLayout(graph)\n{\n\tthis.graph = graph;\n};\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxGraphLayout.prototype.graph = null;\n\n/**\n * Variable: useBoundingBox\n *\n * Boolean indicating if the bounding box of the label should be used if\n * its available. Default is true.\n */\nmxGraphLayout.prototype.useBoundingBox = true;\n\n/**\n * Variable: parent\n *\n * The parent cell of the layout, if any\n */\nmxGraphLayout.prototype.parent = null;\n\n/**\n * Function: moveCell\n * \n * Notified when a cell is being moved in a parent that has automatic\n * layout to update the cell state (eg. index) so that the outcome of the\n * layout will position the vertex as close to the point (x, y) as\n * possible.\n * \n * Empty implementation.\n * \n * Parameters:\n * \n * cell - <mxCell> which has been moved.\n * x - X-coordinate of the new cell location.\n * y - Y-coordinate of the new cell location.\n */\nmxGraphLayout.prototype.moveCell = function(cell, x, y) { };\n\n/**\n * Function: resizeCell\n * \n * Notified when a cell is being resized in a parent that has automatic\n * layout to update the other cells in the layout.\n * \n * Empty implementation.\n * \n * Parameters:\n * \n * cell - <mxCell> which has been moved.\n * bounds - <mxRectangle> that represents the new cell bounds.\n */\nmxGraphLayout.prototype.resizeCell = function(cell, bounds) { };\n\n/**\n * Function: execute\n * \n * Executes the layout algorithm for the children of the given parent.\n * \n * Parameters:\n * \n * parent - <mxCell> whose children should be layed out.\n */\nmxGraphLayout.prototype.execute = function(parent) { };\n\n/**\n * Function: getGraph\n * \n * Returns the graph that this layout operates on.\n */\nmxGraphLayout.prototype.getGraph = function()\n{\n\treturn this.graph;\n};\n\n/**\n * Function: getConstraint\n * \n * Returns the constraint for the given key and cell. The optional edge and\n * source arguments are used to return inbound and outgoing routing-\n * constraints for the given edge and vertex. This implementation always\n * returns the value for the given key in the style of the given cell.\n * \n * Parameters:\n * \n * key - Key of the constraint to be returned.\n * cell - <mxCell> whose constraint should be returned.\n * edge - Optional <mxCell> that represents the connection whose constraint\n * should be returned. Default is null.\n * source - Optional boolean that specifies if the connection is incoming\n * or outgoing. Default is null.\n */\nmxGraphLayout.prototype.getConstraint = function(key, cell, edge, source)\n{\n\treturn this.graph.getCurrentCellStyle(cell)[key]\n};\n\n/**\n * Function: traverse\n * \n * Traverses the (directed) graph invoking the given function for each\n * visited vertex and edge. The function is invoked with the current vertex\n * and the incoming edge as a parameter. This implementation makes sure\n * each vertex is only visited once. The function may return false if the\n * traversal should stop at the given vertex.\n * \n * Example:\n * \n * (code)\n * mxLog.show();\n * var cell = graph.getSelectionCell();\n * graph.traverse(cell, false, function(vertex, edge)\n * {\n *   mxLog.debug(graph.getLabel(vertex));\n * });\n * (end)\n * \n * Parameters:\n * \n * vertex - <mxCell> that represents the vertex where the traversal starts.\n * directed - Optional boolean indicating if edges should only be traversed\n * from source to target. Default is true.\n * func - Visitor function that takes the current vertex and the incoming\n * edge as arguments. The traversal stops if the function returns false.\n * edge - Optional <mxCell> that represents the incoming edge. This is\n * null for the first step of the traversal.\n * visited - Optional <mxDictionary> of cell paths for the visited cells.\n */\nmxGraphLayout.traverse = function(vertex, directed, func, edge, visited)\n{\n\tif (func != null && vertex != null)\n\t{\n\t\tdirected = (directed != null) ? directed : true;\n\t\tvisited = visited || new mxDictionary();\n\t\t\n\t\tif (!visited.get(vertex))\n\t\t{\n\t\t\tvisited.put(vertex, true);\n\t\t\tvar result = func(vertex, edge);\n\t\t\t\n\t\t\tif (result == null || result)\n\t\t\t{\n\t\t\t\tvar edgeCount = this.graph.model.getEdgeCount(vertex);\n\t\t\t\t\n\t\t\t\tif (edgeCount > 0)\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < edgeCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar e = this.graph.model.getEdgeAt(vertex, i);\n\t\t\t\t\t\tvar isSource = this.graph.model.getTerminal(e, true) == vertex;\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tif (!directed || isSource)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar next = this.graph.view.getVisibleTerminal(e, !isSource);\n\t\t\t\t\t\t\tthis.traverse(next, directed, func, e, visited);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: isAncestor\n * \n * Returns true if the given parent is an ancestor of the given child.\n *\n * Parameters:\n * \n * parent - <mxCell> that specifies the parent.\n * child - <mxCell> that specifies the child.\n * traverseAncestors - boolean whether to \n */\nmxGraphLayout.prototype.isAncestor = function(parent, child, traverseAncestors)\n{\n\tif (!traverseAncestors)\n\t{\n\t\treturn (this.graph.model.getParent(child) == parent);\n\t}\t\n\t\n\tif (child == parent)\n\t{\n\t\treturn false;\n\t}\n\n\twhile (child != null && child != parent)\n\t{\n\t\tchild = this.graph.model.getParent(child);\n\t}\n\t\n\treturn child == parent;\n};\n\n/**\n * Function: isVertexMovable\n * \n * Returns a boolean indicating if the given <mxCell> is movable or\n * bendable by the algorithm. This implementation returns true if the given\n * cell is movable in the graph.\n * \n * Parameters:\n * \n * cell - <mxCell> whose movable state should be returned.\n */\nmxGraphLayout.prototype.isVertexMovable = function(cell)\n{\n\treturn this.graph.isCellMovable(cell);\n};\n\n/**\n * Function: isVertexIgnored\n * \n * Returns a boolean indicating if the given <mxCell> should be ignored by\n * the algorithm. This implementation returns false for all vertices.\n * \n * Parameters:\n * \n * vertex - <mxCell> whose ignored state should be returned.\n */\nmxGraphLayout.prototype.isVertexIgnored = function(vertex)\n{\n\treturn !this.graph.getModel().isVertex(vertex) ||\n\t\t!this.graph.isCellVisible(vertex);\n};\n\n/**\n * Function: isEdgeIgnored\n * \n * Returns a boolean indicating if the given <mxCell> should be ignored by\n * the algorithm. This implementation returns false for all vertices.\n * \n * Parameters:\n * \n * cell - <mxCell> whose ignored state should be returned.\n */\nmxGraphLayout.prototype.isEdgeIgnored = function(edge)\n{\n\tvar model = this.graph.getModel();\n\t\n\treturn !model.isEdge(edge) ||\n\t\t!this.graph.isCellVisible(edge) ||\n\t\tmodel.getTerminal(edge, true) == null ||\n\t\tmodel.getTerminal(edge, false) == null;\n};\n\n/**\n * Function: setEdgeStyleEnabled\n * \n * Disables or enables the edge style of the given edge.\n */\nmxGraphLayout.prototype.setEdgeStyleEnabled = function(edge, value)\n{\n\tthis.graph.setCellStyles(mxConstants.STYLE_NOEDGESTYLE,\n\t\t\t(value) ? '0' : '1', [edge]);\n};\n\n/**\n * Function: setOrthogonalEdge\n * \n * Disables or enables orthogonal end segments of the given edge.\n */\nmxGraphLayout.prototype.setOrthogonalEdge = function(edge, value)\n{\n\tthis.graph.setCellStyles(mxConstants.STYLE_ORTHOGONAL,\n\t\t\t(value) ? '1' : '0', [edge]);\n};\n\n/**\n * Function: getParentOffset\n * \n * Determines the offset of the given parent to the parent\n * of the layout\n */\nmxGraphLayout.prototype.getParentOffset = function(parent)\n{\n\tvar result = new mxPoint();\n\n\tif (parent != null && parent != this.parent)\n\t{\n\t\tvar model = this.graph.getModel();\n\n\t\tif (model.isAncestor(this.parent, parent))\n\t\t{\n\t\t\tvar parentGeo = model.getGeometry(parent);\n\n\t\t\twhile (parent != this.parent)\n\t\t\t{\n\t\t\t\tresult.x = result.x + parentGeo.x;\n\t\t\t\tresult.y = result.y + parentGeo.y;\n\n\t\t\t\tparent = model.getParent(parent);;\n\t\t\t\tparentGeo = model.getGeometry(parent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: setEdgePoints\n * \n * Replaces the array of mxPoints in the geometry of the given edge\n * with the given array of mxPoints.\n */\nmxGraphLayout.prototype.setEdgePoints = function(edge, points)\n{\n\tif (edge != null)\n\t{\n\t\tvar model = this.graph.model;\n\t\tvar geometry = model.getGeometry(edge);\n\n\t\tif (geometry == null)\n\t\t{\n\t\t\tgeometry = new mxGeometry();\n\t\t\tgeometry.setRelative(true);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgeometry = geometry.clone();\n\t\t}\n\n\t\tif (this.parent != null && points != null)\n\t\t{\n\t\t\tvar parent = model.getParent(edge);\n\n\t\t\tvar parentOffset = this.getParentOffset(parent);\n\n\t\t\tfor (var i = 0; i < points.length; i++)\n\t\t\t{\n\t\t\t\tpoints[i].x = points[i].x - parentOffset.x;\n\t\t\t\tpoints[i].y = points[i].y - parentOffset.y;\n\t\t\t}\n\t\t}\n\n\t\tgeometry.points = points;\n\t\tmodel.setGeometry(edge, geometry);\n\t}\n};\n\n/**\n * Function: setVertexLocation\n * \n * Sets the new position of the given cell taking into account the size of\n * the bounding box if <useBoundingBox> is true. The change is only carried\n * out if the new location is not equal to the existing location, otherwise\n * the geometry is not replaced with an updated instance. The new or old\n * bounds are returned (including overlapping labels).\n * \n * Parameters:\n * \n * cell - <mxCell> whose geometry is to be set.\n * x - Integer that defines the x-coordinate of the new location.\n * y - Integer that defines the y-coordinate of the new location.\n */\nmxGraphLayout.prototype.setVertexLocation = function(cell, x, y)\n{\n\tvar model = this.graph.getModel();\n\tvar geometry = model.getGeometry(cell);\n\tvar result = null;\n\t\n\tif (geometry != null)\n\t{\n\t\tresult = new mxRectangle(x, y, geometry.width, geometry.height);\n\t\t\n\t\t// Checks for oversize labels and shifts the result\n\t\t// TODO: Use mxUtils.getStringSize for label bounds\n\t\tif (this.useBoundingBox)\n\t\t{\n\t\t\tvar state = this.graph.getView().getState(cell);\n\t\t\t\n\t\t\tif (state != null && state.text != null && state.text.boundingBox != null)\n\t\t\t{\n\t\t\t\tvar scale = this.graph.getView().scale;\n\t\t\t\tvar box = state.text.boundingBox;\n\t\t\t\t\n\t\t\t\tif (state.text.boundingBox.x < state.x)\n\t\t\t\t{\n\t\t\t\t\tx += (state.x - box.x) / scale;\n\t\t\t\t\tresult.width = box.width;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (state.text.boundingBox.y < state.y)\n\t\t\t\t{\n\t\t\t\t\ty += (state.y - box.y) / scale;\n\t\t\t\t\tresult.height = box.height;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.parent != null)\n\t\t{\n\t\t\tvar parent = model.getParent(cell);\n\n\t\t\tif (parent != null && parent != this.parent)\n\t\t\t{\n\t\t\t\tvar parentOffset = this.getParentOffset(parent);\n\n\t\t\t\tx = x - parentOffset.x;\n\t\t\t\ty = y - parentOffset.y;\n\t\t\t}\n\t\t}\n\n\t\tif (geometry.x != x || geometry.y != y)\n\t\t{\n\t\t\tgeometry = geometry.clone();\n\t\t\tgeometry.x = x;\n\t\t\tgeometry.y = y;\n\t\t\t\n\t\t\tmodel.setGeometry(cell, geometry);\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getVertexBounds\n * \n * Returns an <mxRectangle> that defines the bounds of the given cell or\n * the bounding box if <useBoundingBox> is true.\n */\nmxGraphLayout.prototype.getVertexBounds = function(cell)\n{\n\tvar geo = this.graph.getModel().getGeometry(cell);\n\n\t// Checks for oversize label bounding box and corrects\n\t// the return value accordingly\n\t// TODO: Use mxUtils.getStringSize for label bounds\n\tif (this.useBoundingBox)\n\t{\n\t\tvar state = this.graph.getView().getState(cell);\n\n\t\tif (state != null && state.text != null && state.text.boundingBox != null)\n\t\t{\n\t\t\tvar scale = this.graph.getView().scale;\n\t\t\tvar tmp = state.text.boundingBox;\n\n\t\t\tvar dx0 = Math.max(state.x - tmp.x, 0) / scale;\n\t\t\tvar dy0 = Math.max(state.y - tmp.y, 0) / scale;\n\t\t\tvar dx1 = Math.max((tmp.x + tmp.width) - (state.x + state.width), 0) / scale;\n  \t\t\tvar dy1 = Math.max((tmp.y + tmp.height) - (state.y + state.height), 0) / scale;\n\n\t\t\tgeo = new mxRectangle(geo.x - dx0, geo.y - dy0, geo.width + dx0 + dx1, geo.height + dy0 + dy1);\n\t\t}\n\t}\n\n\tif (this.parent != null)\n\t{\n\t\tvar parent = this.graph.getModel().getParent(cell);\n\t\tgeo = geo.clone();\n\n\t\tif (parent != null && parent != this.parent)\n\t\t{\n\t\t\tvar parentOffset = this.getParentOffset(parent);\n\t\t\tgeo.x = geo.x + parentOffset.x;\n\t\t\tgeo.y = geo.y + parentOffset.y;\n\t\t}\n\t}\n\n\treturn new mxRectangle(geo.x, geo.y, geo.width, geo.height);\n};\n\n/**\n * Function: arrangeGroups\n * \n * Shortcut to <mxGraph.updateGroupBounds> with moveGroup set to true.\n */\nmxGraphLayout.prototype.arrangeGroups = function(cells, border, topBorder, rightBorder, bottomBorder, leftBorder)\n{\n\treturn this.graph.updateGroupBounds(cells, border, true, topBorder, rightBorder, bottomBorder, leftBorder);\n};\n\n/**\n * Class: WeightedCellSorter\n * \n * A utility class used to track cells whilst sorting occurs on the weighted\n * sum of their connected edges. Does not violate (x.compareTo(y)==0) ==\n * (x.equals(y))\n *\n * Constructor: WeightedCellSorter\n * \n * Constructs a new weighted cell sorted for the given cell and weight.\n */\nfunction WeightedCellSorter(cell, weightedValue)\n{\n\tthis.cell = cell;\n\tthis.weightedValue = weightedValue;\n};\n\n/**\n * Variable: weightedValue\n * \n * The weighted value of the cell stored.\n */\nWeightedCellSorter.prototype.weightedValue = 0;\n\n/**\n * Variable: nudge\n * \n * Whether or not to flip equal weight values.\n */\nWeightedCellSorter.prototype.nudge = false;\n\n/**\n * Variable: visited\n * \n * Whether or not this cell has been visited in the current assignment.\n */\nWeightedCellSorter.prototype.visited = false;\n\n/**\n * Variable: rankIndex\n * \n * The index this cell is in the model rank.\n */\nWeightedCellSorter.prototype.rankIndex = null;\n\n/**\n * Variable: cell\n * \n * The cell whose median value is being calculated.\n */\nWeightedCellSorter.prototype.cell = null;\n\n/**\n * Function: compare\n * \n * Compares two WeightedCellSorters.\n */\nWeightedCellSorter.prototype.compare = function(a, b)\n{\n\tif (a != null && b != null)\n\t{\n\t\tif (b.weightedValue > a.weightedValue)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\telse if (b.weightedValue < a.weightedValue)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (b.nudge)\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n};\n\n__mxOutput.mxGraphLayout = typeof mxGraphLayout !== 'undefined' ? mxGraphLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxStackLayout\n * \n * Extends <mxGraphLayout> to create a horizontal or vertical stack of the\n * child vertices. The children do not need to be connected for this layout\n * to work.\n * \n * Example:\n * \n * (code)\n * var layout = new mxStackLayout(graph, true);\n * layout.execute(graph.getDefaultParent());\n * (end)\n * \n * Constructor: mxStackLayout\n * \n * Constructs a new stack layout layout for the specified graph,\n * spacing, orientation and offset.\n */\nfunction mxStackLayout(graph, horizontal, spacing, x0, y0, border)\n{\n\tmxGraphLayout.call(this, graph);\n\tthis.horizontal = (horizontal != null) ? horizontal : true;\n\tthis.spacing = (spacing != null) ? spacing : 0;\n\tthis.x0 = (x0 != null) ? x0 : 0;\n\tthis.y0 = (y0 != null) ? y0 : 0;\n\tthis.border = (border != null) ? border : 0;\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxStackLayout.prototype = new mxGraphLayout();\nmxStackLayout.prototype.constructor = mxStackLayout;\n\n/**\n * Variable: horizontal\n *\n * Specifies the orientation of the layout. Default is true.\n */\nmxStackLayout.prototype.horizontal = null;\n\n/**\n * Variable: spacing\n *\n * Specifies the spacing between the cells. Default is 0.\n */\nmxStackLayout.prototype.spacing = null;\n\n/**\n * Variable: x0\n *\n * Specifies the horizontal origin of the layout. Default is 0.\n */\nmxStackLayout.prototype.x0 = null;\n\n/**\n * Variable: y0\n *\n * Specifies the vertical origin of the layout. Default is 0.\n */\nmxStackLayout.prototype.y0 = null;\n\n/**\n * Variable: border\n *\n * Border to be added if fill is true. Default is 0.\n */\nmxStackLayout.prototype.border = 0;\n\n/**\n * Variable: marginTop\n * \n * Top margin for the child area. Default is 0.\n */\nmxStackLayout.prototype.marginTop = 0;\n\n/**\n * Variable: marginLeft\n * \n * Top margin for the child area. Default is 0.\n */\nmxStackLayout.prototype.marginLeft = 0;\n\n/**\n * Variable: marginRight\n * \n * Top margin for the child area. Default is 0.\n */\nmxStackLayout.prototype.marginRight = 0;\n\n/**\n * Variable: marginBottom\n * \n * Top margin for the child area. Default is 0.\n */\nmxStackLayout.prototype.marginBottom = 0;\n\n/**\n * Variable: keepFirstLocation\n * \n * Boolean indicating if the location of the first cell should be\n * kept, that is, it will not be moved to x0 or y0. Default is false.\n */\nmxStackLayout.prototype.keepFirstLocation = false;\n\n/**\n * Variable: fill\n * \n * Boolean indicating if dimension should be changed to fill out the parent\n * cell. Default is false.\n */\nmxStackLayout.prototype.fill = false;\n\t\n/**\n * Variable: resizeParent\n * \n * If the parent should be resized to match the width/height of the\n * stack. Default is false.\n */\nmxStackLayout.prototype.resizeParent = false;\n\n/**\n * Variable: resizeParentMax\n * \n * Use maximum of existing value and new value for resize of parent.\n * Default is false.\n */\nmxStackLayout.prototype.resizeParentMax = false;\n\n/**\n * Variable: resizeLast\n * \n * If the last element should be resized to fill out the parent. Default is\n * false. If <resizeParent> is true then this is ignored.\n */\nmxStackLayout.prototype.resizeLast = false;\n\n/**\n * Variable: wrap\n * \n * Value at which a new column or row should be created. Default is null.\n */\nmxStackLayout.prototype.wrap = null;\n\n/**\n * Variable: borderCollapse\n * \n * If the strokeWidth should be ignored. Default is true.\n */\nmxStackLayout.prototype.borderCollapse = true;\n\n/**\n * Variable: allowGaps\n * \n * If gaps should be allowed in the stack. Default is false.\n */\nmxStackLayout.prototype.allowGaps = false;\n\n/**\n * Variable: gridSize\n * \n * Grid size for alignment of position and size. Default is 0.\n */\nmxStackLayout.prototype.gridSize = 0;\n\n/**\n * Function: isHorizontal\n * \n * Returns <horizontal>.\n */\nmxStackLayout.prototype.isHorizontal = function()\n{\n\treturn this.horizontal;\n};\n\n/**\n * Function: moveCell\n * \n * Implements <mxGraphLayout.moveCell>.\n */\nmxStackLayout.prototype.moveCell = function(cell, x, y)\n{\n\tvar model = this.graph.getModel();\n\tvar parent = model.getParent(cell);\n\tvar horizontal = this.isHorizontal();\n\t\n\tif (cell != null && parent != null)\n\t{\n\t\tvar i = 0;\n\t\tvar last = 0;\n\t\tvar childCount = model.getChildCount(parent);\n\t\tvar value = (horizontal) ? x : y;\n\t\tvar pstate = this.graph.getView().getState(parent);\n\n\t\tif (pstate != null)\n\t\t{\n\t\t\tvalue -= (horizontal) ? pstate.x : pstate.y;\n\t\t}\n\t\t\n\t\tvalue /= this.graph.view.scale;\n\t\t\n\t\tfor (i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar child = model.getChildAt(parent, i);\n\t\t\t\n\t\t\tif (child != cell)\n\t\t\t{\n\t\t\t\tvar bounds = model.getGeometry(child);\n\t\t\t\t\n\t\t\t\tif (bounds != null)\n\t\t\t\t{\n\t\t\t\t\tvar tmp = (horizontal) ?\n\t\t\t\t\t\tbounds.x + bounds.width / 2 :\n\t\t\t\t\t\tbounds.y + bounds.height / 2;\n\t\t\t\t\t\n\t\t\t\t\tif (last <= value && tmp > value)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Changes child order in parent\n\t\tvar idx = parent.getIndex(cell);\n\t\tidx = Math.max(0, i - ((i > idx) ? 1 : 0));\n\n\t\tmodel.add(parent, cell, idx);\n\t}\n};\n\n/**\n * Function: getParentSize\n * \n * Returns the size for the parent container or the size of the graph\n * container if the parent is a layer or the root of the model.\n */\nmxStackLayout.prototype.getParentSize = function(parent)\n{\n\tvar model = this.graph.getModel();\t\t\t\n\tvar pgeo = model.getGeometry(parent);\n\t\n\t// Handles special case where the parent is either a layer with no\n\t// geometry or the current root of the view in which case the size\n\t// of the graph's container will be used.\n\tif (this.graph.container != null && ((pgeo == null &&\n\t\tmodel.isLayer(parent)) || parent == this.graph.getView().currentRoot))\n\t{\n\t\tvar width = this.graph.container.offsetWidth - 1;\n\t\tvar height = this.graph.container.offsetHeight - 1;\n\t\tpgeo = new mxRectangle(0, 0, width, height);\n\t}\n\t\n\treturn pgeo;\n};\n\n/**\n * Function: getLayoutCells\n * \n * Returns the cells to be layouted.\n */\nmxStackLayout.prototype.getLayoutCells = function(parent)\n{\n\tvar model = this.graph.getModel();\n\tvar childCount = model.getChildCount(parent);\n\tvar cells = [];\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = model.getChildAt(parent, i);\n\t\t\n\t\tif (!this.isVertexIgnored(child) && this.isVertexMovable(child))\n\t\t{\n\t\t\tcells.push(child);\n\t\t}\n\t}\n\t\n\tif (this.allowGaps)\n\t{\n\t\tcells.sort(mxUtils.bind(this, function(c1, c2)\n\t\t{\n\t\t\tvar geo1 = this.graph.getCellGeometry(c1);\n\t\t\tvar geo2 = this.graph.getCellGeometry(c2);\n\t\t\t\n\t\t\treturn (this.horizontal) ?\n\t\t\t\t((geo1.x == geo2.x) ? 0 : ((geo1.x > geo2.x > 0) ? 1 : -1)) :\n\t\t\t\t((geo1.y == geo2.y) ? 0 : ((geo1.y > geo2.y > 0) ? 1 : -1));\n\t\t}));\n\t}\n\t\n\treturn cells;\n};\n\n/**\n * Function: snap\n * \n * Snaps the given value to the grid size.\n */\nmxStackLayout.prototype.snap = function(value)\n{\n\tif (this.gridSize != null && this.gridSize > 0)\n\t{\n\t\tvalue = Math.max(value, this.gridSize);\n\t\t\n\t\tif (value / this.gridSize > 1)\n\t\t{\n\t\t\tvar mod = value % this.gridSize;\n\t\t\tvalue += mod > this.gridSize / 2 ? (this.gridSize - mod) : -mod;\n\t\t}\n\t}\n\t\n\treturn value;\n};\n\n/**\n * Function: execute\n * \n * Implements <mxGraphLayout.execute>.\n * \n * Only children where <isVertexIgnored> returns false are taken into\n * account.\n */\nmxStackLayout.prototype.execute = function(parent)\n{\n\tif (parent != null)\n\t{\n\t\tvar pgeo = this.getParentSize(parent);\n\t\tvar horizontal = this.isHorizontal();\n\t\tvar model = this.graph.getModel();\t\n\t\tvar fillValue = null;\n\t\t\n\t\tif (pgeo != null)\n\t\t{\n\t\t\tfillValue = (horizontal) ? pgeo.height - this.marginTop - this.marginBottom :\n\t\t\t\tpgeo.width - this.marginLeft - this.marginRight;\n\t\t}\n\t\t\n\t\tfillValue -= 2 * this.border;\n\t\tvar x0 = this.x0 + this.border + this.marginLeft;\n\t\tvar y0 = this.y0 + this.border + this.marginTop;\n\t\t\n\t\t// Handles swimlane start size\n\t\tif (this.graph.isSwimlane(parent))\n\t\t{\n\t\t\t// Uses computed style to get latest \n\t\t\tvar style = this.graph.getCellStyle(parent);\n\t\t\tvar start = mxUtils.getNumber(style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE);\n\t\t\tvar horz = mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true) == 1;\n\n\t\t\tif (pgeo != null)\n\t\t\t{\n\t\t\t\tif (horz)\n\t\t\t\t{\n\t\t\t\t\tstart = Math.min(start, pgeo.height);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstart = Math.min(start, pgeo.width);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (horizontal == horz)\n\t\t\t{\n\t\t\t\tfillValue -= start;\n\t\t\t}\n\n\t\t\tif (horz)\n\t\t\t{\n\t\t\t\ty0 += start;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx0 += start;\n\t\t\t}\n\t\t}\n\n\t\tmodel.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tvar tmp = 0;\n\t\t\tvar last = null;\n\t\t\tvar lastValue = 0;\n\t\t\tvar lastChild = null;\n\t\t\tvar cells = this.getLayoutCells(parent);\n\t\t\t\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tvar child = cells[i];\n\t\t\t\tvar geo = model.getGeometry(child);\n\t\t\t\t\n\t\t\t\tif (geo != null)\n\t\t\t\t{\n\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\n\t\t\t\t\tif (this.wrap != null && last != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((horizontal && last.x + last.width +\n\t\t\t\t\t\t\tgeo.width + 2 * this.spacing > this.wrap) ||\n\t\t\t\t\t\t\t(!horizontal && last.y + last.height +\n\t\t\t\t\t\t\tgeo.height + 2 * this.spacing > this.wrap))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlast = null;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (horizontal)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ty0 += tmp + this.spacing;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tx0 += tmp + this.spacing;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttmp = 0;\n\t\t\t\t\t\t}\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttmp = Math.max(tmp, (horizontal) ? geo.height : geo.width);\n\t\t\t\t\tvar sw = 0;\n\t\t\t\t\t\n\t\t\t\t\tif (!this.borderCollapse)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar childStyle = this.graph.getCellStyle(child);\n\t\t\t\t\t\tsw = mxUtils.getNumber(childStyle, mxConstants.STYLE_STROKEWIDTH, 1);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (last != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar temp = lastValue + this.spacing + Math.floor(sw / 2);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (horizontal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.x = this.snap(((this.allowGaps) ? Math.max(temp, geo.x) :\n\t\t\t\t\t\t\t\ttemp) - this.marginLeft) + this.marginLeft;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.y = this.snap(((this.allowGaps) ? Math.max(temp, geo.y) :\n\t\t\t\t\t\t\t\ttemp) - this.marginTop) + this.marginTop;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (!this.keepFirstLocation)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (horizontal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.x = (this.allowGaps && geo.x > x0) ? Math.max(this.snap(geo.x -\n\t\t\t\t\t\t\t\tthis.marginLeft) + this.marginLeft, x0) : x0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.y = (this.allowGaps && geo.y > y0) ? Math.max(this.snap(geo.y -\n\t\t\t\t\t\t\t\tthis.marginTop) + this.marginTop, y0) : y0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (horizontal)\n\t\t\t\t\t{\n\t\t\t\t\t\tgeo.y = y0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tgeo.x = x0;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (this.fill && fillValue != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (horizontal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.height = fillValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.width = fillValue;\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (horizontal)\n\t\t\t\t\t{\n\t\t\t\t\t\tgeo.width = this.snap(geo.width);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tgeo.height = this.snap(geo.height);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.setChildGeometry(child, geo);\n\t\t\t\t\tlastChild = child;\n\t\t\t\t\tlast = geo;\n\t\t\t\t\t\n\t\t\t\t\tif (horizontal)\n\t\t\t\t\t{\n\t\t\t\t\t\tlastValue = last.x + last.width + Math.floor(sw / 2);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlastValue = last.y + last.height + Math.floor(sw / 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.resizeParent && pgeo != null && last != null && !this.graph.isCellCollapsed(parent))\n\t\t\t{\n\t\t\t\tthis.updateParentGeometry(parent, pgeo, last);\n\t\t\t}\n\t\t\telse if (this.resizeLast && pgeo != null && last != null && lastChild != null)\n\t\t\t{\n\t\t\t\tif (horizontal)\n\t\t\t\t{\n\t\t\t\t\tlast.width = pgeo.width - last.x - this.spacing - this.marginRight - this.marginLeft;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlast.height = pgeo.height - last.y - this.spacing - this.marginBottom;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.setChildGeometry(lastChild, last);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tmodel.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: setChildGeometry\n * \n * Sets the specific geometry to the given child cell.\n * \n * Parameters:\n * \n * child - The given child of <mxCell>.\n * geo - The specific geometry of <mxGeometry>.\n */\nmxStackLayout.prototype.setChildGeometry = function(child, geo)\n{\n\tvar geo2 = this.graph.getCellGeometry(child);\n\t\n\tif (geo2 == null || geo.x != geo2.x || geo.y != geo2.y ||\n\t\tgeo.width != geo2.width || geo.height != geo2.height)\n\t{\n\t\tthis.graph.getModel().setGeometry(child, geo);\n\t}\n};\n\n/**\n * Function: updateParentGeometry\n * \n * Updates the geometry of the given parent cell.\n * \n * Parameters:\n * \n * parent - The given parent of <mxCell>.\n * pgeo - The new <mxGeometry> for parent.\n * last - The last <mxGeometry>.\n */\nmxStackLayout.prototype.updateParentGeometry = function(parent, pgeo, last)\n{\n\tvar horizontal = this.isHorizontal();\n\tvar model = this.graph.getModel();\t\n\n\tvar pgeo2 = pgeo.clone();\n\t\n\tif (horizontal)\n\t{\n\t\tvar tmp = last.x + last.width + this.marginRight + this.border;\n\t\t\n\t\tif (this.resizeParentMax)\n\t\t{\n\t\t\tpgeo2.width = Math.max(pgeo2.width, tmp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpgeo2.width = tmp;\n\t\t}\n\t}\n\telse\n\t{\n\t\tvar tmp = last.y + last.height + this.marginBottom + this.border;\n\t\t\n\t\tif (this.resizeParentMax)\n\t\t{\n\t\t\tpgeo2.height = Math.max(pgeo2.height, tmp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpgeo2.height = tmp;\n\t\t}\n\t}\n\t\n\tif (pgeo.x != pgeo2.x || pgeo.y != pgeo2.y ||\n\t\tpgeo.width != pgeo2.width || pgeo.height != pgeo2.height)\n\t{\n\t\tmodel.setGeometry(parent, pgeo2);\n\t}\n};\n\n__mxOutput.mxStackLayout = typeof mxStackLayout !== 'undefined' ? mxStackLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxPartitionLayout\n * \n * Extends <mxGraphLayout> for partitioning the parent cell vertically or\n * horizontally by filling the complete area with the child cells. A horizontal\n * layout partitions the height of the given parent whereas a a non-horizontal\n * layout partitions the width. If the parent is a layer (that is, a child of\n * the root node), then the current graph size is partitioned. The children do\n * not need to be connected for this layout to work.\n * \n * Example:\n * \n * (code)\n * var layout = new mxPartitionLayout(graph, true, 10, 20);\n * layout.execute(graph.getDefaultParent());\n * (end)\n * \n * Constructor: mxPartitionLayout\n * \n * Constructs a new stack layout layout for the specified graph,\n * spacing, orientation and offset.\n */\nfunction mxPartitionLayout(graph, horizontal, spacing, border)\n{\n\tmxGraphLayout.call(this, graph);\n\tthis.horizontal = (horizontal != null) ? horizontal : true;\n\tthis.spacing = spacing || 0;\n\tthis.border = border || 0;\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxPartitionLayout.prototype = new mxGraphLayout();\nmxPartitionLayout.prototype.constructor = mxPartitionLayout;\n\n/**\n * Variable: horizontal\n * \n * Boolean indicating the direction in which the space is partitioned.\n * Default is true.\n */\nmxPartitionLayout.prototype.horizontal = null;\n\n/**\n * Variable: spacing\n * \n * Integer that specifies the absolute spacing in pixels between the\n * children. Default is 0.\n */\nmxPartitionLayout.prototype.spacing = null;\n\n/**\n * Variable: border\n * \n * Integer that specifies the absolute inset in pixels for the parent that\n * contains the children. Default is 0.\n */\nmxPartitionLayout.prototype.border = null;\n\n/**\n * Variable: resizeVertices\n * \n * Boolean that specifies if vertices should be resized. Default is true.\n */\nmxPartitionLayout.prototype.resizeVertices = true;\n\n/**\n * Function: isHorizontal\n * \n * Returns <horizontal>.\n */\nmxPartitionLayout.prototype.isHorizontal = function()\n{\n\treturn this.horizontal;\n};\n\n/**\n * Function: moveCell\n * \n * Implements <mxGraphLayout.moveCell>.\n */\nmxPartitionLayout.prototype.moveCell = function(cell, x, y)\n{\n\tvar model = this.graph.getModel();\n\tvar parent = model.getParent(cell);\n\t\n\tif (cell != null &&\n\t\tparent != null)\n\t{\n\t\tvar i = 0;\n\t\tvar last = 0;\n\t\tvar childCount = model.getChildCount(parent);\n\t\t\n\t\t// Finds index of the closest swimlane\n\t\t// TODO: Take into account the orientation\n\t\tfor (i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar child = model.getChildAt(parent, i);\n\t\t\tvar bounds = this.getVertexBounds(child);\n\t\t\t\n\t\t\tif (bounds != null)\n\t\t\t{\n\t\t\t\tvar tmp = bounds.x + bounds.width / 2;\n\t\t\t\t\n\t\t\t\tif (last < x && tmp > x)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlast = tmp;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Changes child order in parent\n\t\tvar idx = parent.getIndex(cell);\n\t\tidx = Math.max(0, i - ((i > idx) ? 1 : 0));\n\t\t\n\t\tmodel.add(parent, cell, idx);\n\t}\n};\n\n/**\n * Function: execute\n * \n * Implements <mxGraphLayout.execute>. All children where <isVertexIgnored>\n * returns false and <isVertexMovable> returns true are modified.\n */\nmxPartitionLayout.prototype.execute = function(parent)\n{\n\tvar horizontal = this.isHorizontal();\n\tvar model = this.graph.getModel();\n\tvar pgeo = model.getGeometry(parent);\n\t\n\t// Handles special case where the parent is either a layer with no\n\t// geometry or the current root of the view in which case the size\n\t// of the graph's container will be used.\n\tif (this.graph.container != null &&\n\t\t((pgeo == null &&\n\t\tmodel.isLayer(parent)) ||\n\t\tparent == this.graph.getView().currentRoot))\n\t{\n\t\tvar width = this.graph.container.offsetWidth - 1;\n\t\tvar height = this.graph.container.offsetHeight - 1;\n\t\tpgeo = new mxRectangle(0, 0, width, height);\n\t}\n\n\tif (pgeo != null)\n\t{\n\t\tvar children = [];\n\t\tvar childCount = model.getChildCount(parent);\n\t\t\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar child = model.getChildAt(parent, i);\n\t\t\t\n\t\t\tif (!this.isVertexIgnored(child) &&\n\t\t\t\tthis.isVertexMovable(child))\n\t\t\t{\n\t\t\t\tchildren.push(child);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar n = children.length;\n\n\t\tif (n > 0)\n\t\t{\n\t\t\tvar x0 = this.border;\n\t\t\tvar y0 = this.border;\n\t\t\tvar other = (horizontal) ? pgeo.height : pgeo.width;\n\t\t\tother -= 2 * this.border;\n\n\t\t\tvar size = (this.graph.isSwimlane(parent)) ?\n\t\t\t\tthis.graph.getStartSize(parent) :\n\t\t\t\tnew mxRectangle();\n\n\t\t\tother -= (horizontal) ? size.height : size.width;\n\t\t\tx0 = x0 + size.width;\n\t\t\ty0 = y0 + size.height;\n\n\t\t\tvar tmp = this.border + (n - 1) * this.spacing;\n\t\t\tvar value = (horizontal) ?\n\t\t\t\t((pgeo.width - x0 - tmp) / n) :\n\t\t\t\t((pgeo.height - y0 - tmp) / n);\n\t\t\t\n\t\t\t// Avoids negative values, that is values where the sum of the\n\t\t\t// spacing plus the border is larger then the available space\n\t\t\tif (value > 0)\n\t\t\t{\n\t\t\t\tmodel.beginUpdate();\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < n; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar child = children[i];\n\t\t\t\t\t\tvar geo = model.getGeometry(child);\n\t\t\t\t\t\n\t\t\t\t\t\tif (geo != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\t\tgeo.x = x0;\n\t\t\t\t\t\t\tgeo.y = y0;\n\n\t\t\t\t\t\t\tif (horizontal)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (this.resizeVertices)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tgeo.width = value;\n\t\t\t\t\t\t\t\t\tgeo.height = other;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tx0 += value + this.spacing;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (this.resizeVertices)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tgeo.height = value;\n\t\t\t\t\t\t\t\t\tgeo.width = other;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\ty0 += value + this.spacing;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmodel.setGeometry(child, geo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tmodel.endUpdate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n__mxOutput.mxPartitionLayout = typeof mxPartitionLayout !== 'undefined' ? mxPartitionLayout : undefined;\n\n/**\n * Copyright (c) 2006-2018, JGraph Ltd\n * Copyright (c) 2006-2018, Gaudenz Alder\n */\n/**\n * Class: mxCompactTreeLayout\n * \n * Extends <mxGraphLayout> to implement a compact tree (Moen) algorithm. This\n * layout is suitable for graphs that have no cycles (trees). Vertices that are\n * not connected to the tree will be ignored by this layout.\n * \n * Example:\n * \n * (code)\n * var layout = new mxCompactTreeLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * (end)\n * \n * Constructor: mxCompactTreeLayout\n * \n * Constructs a new compact tree layout for the specified graph\n * and orientation.\n */\nfunction mxCompactTreeLayout(graph, horizontal, invert)\n{\n\tmxGraphLayout.call(this, graph);\n\tthis.horizontal = (horizontal != null) ? horizontal : true;\n\tthis.invert = (invert != null) ? invert : false;\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxCompactTreeLayout.prototype = new mxGraphLayout();\nmxCompactTreeLayout.prototype.constructor = mxCompactTreeLayout;\n\n/**\n * Variable: horizontal\n *\n * Specifies the orientation of the layout. Default is true.\n */\nmxCompactTreeLayout.prototype.horizontal = null;\t \n\n/**\n * Variable: invert\n *\n * Specifies if edge directions should be inverted. Default is false.\n */\nmxCompactTreeLayout.prototype.invert = null;\t \n\n/**\n * Variable: resizeParent\n * \n * If the parents should be resized to match the width/height of the\n * children. Default is true.\n */\nmxCompactTreeLayout.prototype.resizeParent = true;\n\n/**\n * Variable: maintainParentLocation\n * \n * Specifies if the parent location should be maintained, so that the\n * top, left corner stays the same before and after execution of\n * the layout. Default is false for backwards compatibility.\n */\nmxCompactTreeLayout.prototype.maintainParentLocation = false;\n\n/**\n * Variable: groupPadding\n * \n * Padding added to resized parents. Default is 10.\n */\nmxCompactTreeLayout.prototype.groupPadding = 10;\n\n/**\n * Variable: groupPaddingTop\n * \n * Top padding added to resized parents. Default is 0.\n */\nmxCompactTreeLayout.prototype.groupPaddingTop = 0;\n\n/**\n * Variable: groupPaddingRight\n * \n * Right padding added to resized parents. Default is 0.\n */\nmxCompactTreeLayout.prototype.groupPaddingRight = 0;\n\n/**\n * Variable: groupPaddingBottom\n * \n * Bottom padding added to resized parents. Default is 0.\n */\nmxCompactTreeLayout.prototype.groupPaddingBottom = 0;\n\n/**\n * Variable: groupPaddingLeft\n * \n * Left padding added to resized parents. Default is 0.\n */\nmxCompactTreeLayout.prototype.groupPaddingLeft = 0;\n\n/**\n * Variable: parentsChanged\n *\n * A set of the parents that need updating based on children\n * process as part of the layout.\n */\nmxCompactTreeLayout.prototype.parentsChanged = null;\n\n/**\n * Variable: moveTree\n * \n * Specifies if the tree should be moved to the top, left corner\n * if it is inside a top-level layer. Default is false.\n */\nmxCompactTreeLayout.prototype.moveTree = false;\n\n/**\n * Variable: visited\n * \n * Specifies if the tree should be moved to the top, left corner\n * if it is inside a top-level layer. Default is false.\n */\nmxCompactTreeLayout.prototype.visited = null;\n\n/**\n * Variable: levelDistance\n *\n * Holds the levelDistance. Default is 10.\n */\nmxCompactTreeLayout.prototype.levelDistance = 10;\n\n/**\n * Variable: nodeDistance\n *\n * Holds the nodeDistance. Default is 20.\n */\nmxCompactTreeLayout.prototype.nodeDistance = 20;\n\n/**\n * Variable: resetEdges\n * \n * Specifies if all edge points of traversed edges should be removed.\n * Default is true.\n */\nmxCompactTreeLayout.prototype.resetEdges = true;\n\n/**\n * Variable: prefHozEdgeSep\n * \n * The preferred horizontal distance between edges exiting a vertex.\n */\nmxCompactTreeLayout.prototype.prefHozEdgeSep = 5;\n\n/**\n * Variable: prefVertEdgeOff\n * \n * The preferred vertical offset between edges exiting a vertex.\n */\nmxCompactTreeLayout.prototype.prefVertEdgeOff = 4;\n\n/**\n * Variable: minEdgeJetty\n * \n * The minimum distance for an edge jetty from a vertex.\n */\nmxCompactTreeLayout.prototype.minEdgeJetty = 8;\n\n/**\n * Variable: channelBuffer\n * \n * The size of the vertical buffer in the center of inter-rank channels\n * where edge control points should not be placed.\n */\nmxCompactTreeLayout.prototype.channelBuffer = 4;\n\n/**\n * Variable: edgeRouting\n * \n * Whether or not to apply the internal tree edge routing.\n */\nmxCompactTreeLayout.prototype.edgeRouting = true;\n\n/**\n * Variable: sortEdges\n * \n * Specifies if edges should be sorted according to the order of their\n * opposite terminal cell in the model.\n */\nmxCompactTreeLayout.prototype.sortEdges = false;\n\n/**\n * Variable: alignRanks\n * \n * Whether or not the tops of cells in each rank should be aligned\n * across the rank\n */\nmxCompactTreeLayout.prototype.alignRanks = false;\n\n/**\n * Variable: maxRankHeight\n * \n * An array of the maximum height of cells (relative to the layout direction)\n * per rank\n */\nmxCompactTreeLayout.prototype.maxRankHeight = null;\n\n/**\n * Variable: root\n * \n * The cell to use as the root of the tree\n */\nmxCompactTreeLayout.prototype.root = null;\n\n/**\n * Variable: node\n * \n * The internal node representation of the root cell. Do not set directly\n * , this value is only exposed to assist with post-processing functionality\n */\nmxCompactTreeLayout.prototype.node = null;\n\n/**\n * Function: isVertexIgnored\n * \n * Returns a boolean indicating if the given <mxCell> should be ignored as a\n * vertex. This returns true if the cell has no connections.\n * \n * Parameters:\n * \n * vertex - <mxCell> whose ignored state should be returned.\n */\nmxCompactTreeLayout.prototype.isVertexIgnored = function(vertex)\n{\n\treturn mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) ||\n\t\tthis.graph.getConnections(vertex).length == 0;\n};\n\n/**\n * Function: isHorizontal\n * \n * Returns <horizontal>.\n */\nmxCompactTreeLayout.prototype.isHorizontal = function()\n{\n\treturn this.horizontal;\n};\n\n/**\n * Function: execute\n * \n * Implements <mxGraphLayout.execute>.\n * \n * If the parent has any connected edges, then it is used as the root of\n * the tree. Else, <mxGraph.findTreeRoots> will be used to find a suitable\n * root node within the set of children of the given parent.\n * \n * Parameters:\n * \n * parent - <mxCell> whose children should be laid out.\n * root - Optional <mxCell> that will be used as the root of the tree.\n * Overrides <root> if specified.\n */\nmxCompactTreeLayout.prototype.execute = function(parent, root)\n{\n\tthis.parent = parent;\n\tvar model = this.graph.getModel();\n\n\tif (root == null)\n\t{\n\t\t// Takes the parent as the root if it has outgoing edges\n\t\tif (this.graph.getEdges(parent, model.getParent(parent),\n\t\t\tthis.invert, !this.invert, false).length > 0)\n\t\t{\n\t\t\tthis.root = parent;\n\t\t}\n\t\t\n\t\t// Tries to find a suitable root in the parent's\n\t\t// children\n\t\telse\n\t\t{\n\t\t\tvar roots = this.graph.findTreeRoots(parent, true, this.invert);\n\t\t\t\n\t\t\tif (roots.length > 0)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < roots.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (!this.isVertexIgnored(roots[i]) &&\n\t\t\t\t\t\tthis.graph.getEdges(roots[i], null,\n\t\t\t\t\t\t\tthis.invert, !this.invert, false).length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.root = roots[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tthis.root = root;\n\t}\n\t\n\tif (this.root != null)\n\t{\n\t\tif (this.resizeParent)\n\t\t{\n\t\t\tthis.parentsChanged = new Object();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.parentsChanged = null;\n\t\t}\n\n\t\t//  Maintaining parent location\n\t\tthis.parentX = null;\n\t\tthis.parentY = null;\n\t\t\n\t\tif (parent != this.root && model.isVertex(parent) != null && this.maintainParentLocation)\n\t\t{\n\t\t\tvar geo = this.graph.getCellGeometry(parent);\n\t\t\t\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tthis.parentX = geo.x;\n\t\t\t\tthis.parentY = geo.y;\n\t\t\t}\n\t\t}\n\t\t\n\t\tmodel.beginUpdate();\n\t\t\n\t\ttry\n\t\t{\n\t\t\tthis.visited = new Object();\n\t\t\tthis.node = this.dfs(this.root, parent);\n\t\t\t\n\t\t\tif (this.alignRanks)\n\t\t\t{\n\t\t\t\tthis.maxRankHeight = [];\n\t\t\t\tthis.findRankHeights(this.node, 0);\n\t\t\t\tthis.setCellHeights(this.node, 0);\n\t\t\t}\n\t\t\t\n\t\t\tif (this.node != null)\n\t\t\t{\n\t\t\t\tthis.layout(this.node);\n\t\t\t\tvar x0 = this.graph.gridSize;\n\t\t\t\tvar y0 = x0;\n\t\t\t\t\n\t\t\t\tif (!this.moveTree)\n\t\t\t\t{\n\t\t\t\t\tvar g = this.getVertexBounds(this.root);\n\t\t\t\t\t\n\t\t\t\t\tif (g != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tx0 = g.x;\n\t\t\t\t\t\ty0 = g.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar bounds = null;\n\t\t\t\t\n\t\t\t\tif (this.isHorizontal())\n\t\t\t\t{\n\t\t\t\t\tbounds = this.horizontalLayout(this.node, x0, y0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbounds = this.verticalLayout(this.node, null, x0, y0);\n\t\t\t\t}\n\n\t\t\t\tif (bounds != null)\n\t\t\t\t{\n\t\t\t\t\tvar dx = 0;\n\t\t\t\t\tvar dy = 0;\n\n\t\t\t\t\tif (bounds.x < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdx = Math.abs(x0 - bounds.x);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bounds.y < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdy = Math.abs(y0 - bounds.y);\t\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dx != 0 || dy != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.moveNode(this.node, dx, dy);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (this.resizeParent)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.adjustParents();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.edgeRouting)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Iterate through all edges setting their positions\n\t\t\t\t\t\tthis.localEdgeProcessing(this.node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Maintaining parent location\n\t\t\t\tif (this.parentX != null && this.parentY != null)\n\t\t\t\t{\n\t\t\t\t\tvar geo = this.graph.getCellGeometry(parent);\n\t\t\t\t\t\n\t\t\t\t\tif (geo != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\tgeo.x = this.parentX;\n\t\t\t\t\t\tgeo.y = this.parentY;\n\t\t\t\t\t\tmodel.setGeometry(parent, geo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tmodel.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: moveNode\n * \n * Moves the specified node and all of its children by the given amount.\n */\nmxCompactTreeLayout.prototype.moveNode = function(node, dx, dy)\n{\n\tnode.x += dx;\n\tnode.y += dy;\n\tthis.apply(node);\n\t\n\tvar child = node.child;\n\t\n\twhile (child != null)\n\t{\n\t\tthis.moveNode(child, dx, dy);\n\t\tchild = child.next;\n\t}\n};\n\n\n/**\n * Function: sortOutgoingEdges\n * \n * Called if <sortEdges> is true to sort the array of outgoing edges in place.\n */\nmxCompactTreeLayout.prototype.sortOutgoingEdges = function(source, edges)\n{\n\tvar lookup = new mxDictionary();\n\t\n\tedges.sort(function(e1, e2)\n\t{\n\t\tvar end1 = e1.getTerminal(e1.getTerminal(false) == source);\n\t\tvar p1 = lookup.get(end1);\n\t\t\n\t\tif (p1 == null)\n\t\t{\n\t\t\tp1 = mxCellPath.create(end1).split(mxCellPath.PATH_SEPARATOR);\n\t\t\tlookup.put(end1, p1);\n\t\t}\n\n\t\tvar end2 = e2.getTerminal(e2.getTerminal(false) == source);\n\t\tvar p2 = lookup.get(end2);\n\t\t\n\t\tif (p2 == null)\n\t\t{\n\t\t\tp2 = mxCellPath.create(end2).split(mxCellPath.PATH_SEPARATOR);\n\t\t\tlookup.put(end2, p2);\n\t\t}\n\n\t\treturn mxCellPath.compare(p1, p2);\n\t});\n};\n\n/**\n * Function: findRankHeights\n * \n * Stores the maximum height (relative to the layout\n * direction) of cells in each rank\n */\nmxCompactTreeLayout.prototype.findRankHeights = function(node, rank)\n{\n\tif (this.maxRankHeight[rank] == null || this.maxRankHeight[rank] < node.height)\n\t{\n\t\tthis.maxRankHeight[rank] = node.height;\n\t}\n\n\tvar child = node.child;\n\t\n\twhile (child != null)\n\t{\n\t\tthis.findRankHeights(child, rank + 1);\n\t\tchild = child.next;\n\t}\n};\n\n/**\n * Function: setCellHeights\n * \n * Set the cells heights (relative to the layout\n * direction) when the tops of each rank are to be aligned\n */\nmxCompactTreeLayout.prototype.setCellHeights = function(node, rank)\n{\n\tif (this.maxRankHeight[rank] != null && this.maxRankHeight[rank] > node.height)\n\t{\n\t\tnode.height = this.maxRankHeight[rank];\n\t}\n\n\tvar child = node.child;\n\t\n\twhile (child != null)\n\t{\n\t\tthis.setCellHeights(child, rank + 1);\n\t\tchild = child.next;\n\t}\n};\n\n/**\n * Function: dfs\n * \n * Does a depth first search starting at the specified cell.\n * Makes sure the specified parent is never left by the\n * algorithm.\n */\nmxCompactTreeLayout.prototype.dfs = function(cell, parent)\n{\n\tvar id = mxCellPath.create(cell);\n\tvar node = null;\n\t\n\tif (cell != null && this.visited[id] == null && !this.isVertexIgnored(cell))\n\t{\n\t\tthis.visited[id] = cell;\n\t\tnode = this.createNode(cell);\n\n\t\tvar model = this.graph.getModel();\n\t\tvar prev = null;\n\t\tvar out = this.graph.getEdges(cell, parent, this.invert, !this.invert, false, true);\n\t\tvar view = this.graph.getView();\n\t\t\n\t\tif (this.sortEdges)\n\t\t{\n\t\t\tthis.sortOutgoingEdges(cell, out);\n\t\t}\n\n\t\tfor (var i = 0; i < out.length; i++)\n\t\t{\n\t\t\tvar edge = out[i];\n\t\t\t\n\t\t\tif (!this.isEdgeIgnored(edge))\n\t\t\t{\n\t\t\t\t// Resets the points on the traversed edge\n\t\t\t\tif (this.resetEdges)\n\t\t\t\t{\n\t\t\t\t\tthis.setEdgePoints(edge, null);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (this.edgeRouting)\n\t\t\t\t{\n\t\t\t\t\tthis.setEdgeStyleEnabled(edge, false);\n\t\t\t\t\tthis.setEdgePoints(edge, null);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Checks if terminal in same swimlane\n\t\t\t\tvar state = view.getState(edge);\n\t\t\t\tvar target = (state != null) ? state.getVisibleTerminal(this.invert) : view.getVisibleTerminal(edge, this.invert);\n\t\t\t\tvar tmp = this.dfs(target, parent);\n\t\t\t\t\n\t\t\t\tif (tmp != null && model.getGeometry(target) != null)\n\t\t\t\t{\n\t\t\t\t\tif (prev == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.child = tmp;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprev.next = tmp;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tprev = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn node;\n};\n\n/**\n * Function: layout\n * \n * Starts the actual compact tree layout algorithm\n * at the given node.\n */\nmxCompactTreeLayout.prototype.layout = function(node)\n{\n\tif (node != null)\n\t{\n\t\tvar child = node.child;\n\t\t\n\t\twhile (child != null)\n\t\t{\n\t\t\tthis.layout(child);\n\t\t\tchild = child.next;\n\t\t}\n\t\t\n\t\tif (node.child != null)\n\t\t{\n\t\t\tthis.attachParent(node, this.join(node));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.layoutLeaf(node);\n\t\t}\n\t}\n};\n\n/**\n * Function: horizontalLayout\n */\nmxCompactTreeLayout.prototype.horizontalLayout = function(node, x0, y0, bounds)\n{\n\tnode.x += x0 + node.offsetX;\n\tnode.y += y0 + node.offsetY;\n\tbounds = this.apply(node, bounds);\n\tvar child = node.child;\n\t\n\tif (child != null)\n\t{\n\t\tbounds = this.horizontalLayout(child, node.x, node.y, bounds);\n\t\tvar siblingOffset = node.y + child.offsetY;\n\t\tvar s = child.next;\n\t\t\n\t\twhile (s != null)\n\t\t{\n\t\t\tbounds = this.horizontalLayout(s, node.x + child.offsetX, siblingOffset, bounds);\n\t\t\tsiblingOffset += s.offsetY;\n\t\t\ts = s.next;\n\t\t}\n\t}\n\t\n\treturn bounds;\n};\n\t\n/**\n * Function: verticalLayout\n */\nmxCompactTreeLayout.prototype.verticalLayout = function(node, parent, x0, y0, bounds)\n{\n\tnode.x += x0 + node.offsetY;\n\tnode.y += y0 + node.offsetX;\n\tbounds = this.apply(node, bounds);\n\tvar child = node.child;\n\t\n\tif (child != null)\n\t{\n\t\tbounds = this.verticalLayout(child, node, node.x, node.y, bounds);\n\t\tvar siblingOffset = node.x + child.offsetY;\n\t\tvar s = child.next;\n\t\t\n\t\twhile (s != null)\n\t\t{\n\t\t\tbounds = this.verticalLayout(s, node, siblingOffset, node.y + child.offsetX, bounds);\n\t\t\tsiblingOffset += s.offsetY;\n\t\t\ts = s.next;\n\t\t}\n\t}\n\t\n\treturn bounds;\n};\n\n/**\n * Function: attachParent\n */\nmxCompactTreeLayout.prototype.attachParent = function(node, height)\n{\n\tvar x = this.nodeDistance + this.levelDistance;\n\tvar y2 = (height - node.width) / 2 - this.nodeDistance;\n\tvar y1 = y2 + node.width + 2 * this.nodeDistance - height;\n\t\n\tnode.child.offsetX = x + node.height;\n\tnode.child.offsetY = y1;\n\t\n\tnode.contour.upperHead = this.createLine(node.height, 0,\n\t\tthis.createLine(x, y1, node.contour.upperHead));\n\tnode.contour.lowerHead = this.createLine(node.height, 0,\n\t\tthis.createLine(x, y2, node.contour.lowerHead));\n};\n\n/**\n * Function: layoutLeaf\n */\nmxCompactTreeLayout.prototype.layoutLeaf = function(node)\n{\n\tvar dist = 2 * this.nodeDistance;\n\t\n\tnode.contour.upperTail = this.createLine(\n\t\tnode.height + dist, 0);\n\tnode.contour.upperHead = node.contour.upperTail;\n\tnode.contour.lowerTail = this.createLine(\n\t\t0, -node.width - dist);\n\tnode.contour.lowerHead = this.createLine(\n\t\tnode.height + dist, 0, node.contour.lowerTail);\n};\n\n/**\n * Function: join\n */\nmxCompactTreeLayout.prototype.join = function(node)\n{\n\tvar dist = 2 * this.nodeDistance;\n\t\n\tvar child = node.child;\n\tnode.contour = child.contour;\n\tvar h = child.width + dist;\n\tvar sum = h;\n\tchild = child.next;\n\t\n\twhile (child != null)\n\t{\n\t\tvar d = this.merge(node.contour, child.contour);\n\t\tchild.offsetY = d + h;\n\t\tchild.offsetX = 0;\n\t\th = child.width + dist;\n\t\tsum += d + h;\n\t\tchild = child.next;\n\t}\n\t\n\treturn sum;\n};\n\n/**\n * Function: merge\n */\nmxCompactTreeLayout.prototype.merge = function(p1, p2)\n{\n\tvar x = 0;\n\tvar y = 0;\n\tvar total = 0;\n\t\n\tvar upper = p1.lowerHead;\n\tvar lower = p2.upperHead;\n\t\n\twhile (lower != null && upper != null)\n\t{\n\t\tvar d = this.offset(x, y, lower.dx, lower.dy,\n\t\t\tupper.dx, upper.dy);\n\t\ty += d;\n\t\ttotal += d;\n\t\t\n\t\tif (x + lower.dx <= upper.dx)\n\t\t{\n\t\t\tx += lower.dx;\n\t\t\ty += lower.dy;\n\t\t\tlower = lower.next;\n\t\t}\n\t\telse\n\t\t{\t\t\t\t\n\t\t\tx -= upper.dx;\n\t\t\ty -= upper.dy;\n\t\t\tupper = upper.next;\n\t\t}\n\t}\n\t\n\tif (lower != null)\n\t{\n\t\tvar b = this.bridge(p1.upperTail, 0, 0, lower, x, y);\n\t\tp1.upperTail = (b.next != null) ? p2.upperTail : b;\n\t\tp1.lowerTail = p2.lowerTail;\n\t}\n\telse\n\t{\n\t\tvar b = this.bridge(p2.lowerTail, x, y, upper, 0, 0);\n\t\t\n\t\tif (b.next == null)\n\t\t{\n\t\t\tp1.lowerTail = b;\n\t\t}\n\t}\n\t\n\tp1.lowerHead = p2.lowerHead;\n\t\n\treturn total;\n};\n\n/**\n * Function: offset\n */\nmxCompactTreeLayout.prototype.offset = function(p1, p2, a1, a2, b1, b2)\n{\n\tvar d = 0;\n\t\n\tif (b1 <= p1 || p1 + a1 <= 0)\n\t{\n\t\treturn 0;\n\t}\n\n\tvar t = b1 * a2 - a1 * b2;\n\t\n\tif (t > 0)\n\t{\n\t\tif (p1 < 0)\n\t\t{\n\t\t\tvar s = p1 * a2;\n\t\t\td = s / a1 - p2;\n\t\t}\n\t\telse if (p1 > 0)\n\t\t{\n\t\t\tvar s = p1 * b2;\n\t\t\td = s / b1 - p2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\td = -p2;\n\t\t}\n\t}\n\telse if (b1 < p1 + a1)\n\t{\n\t\tvar s = (b1 - p1) * a2;\n\t\td = b2 - (p2 + s / a1);\n\t}\n\telse if (b1 > p1 + a1)\n\t{\n\t\tvar s = (a1 + p1) * b2;\n\t\td = s / b1 - (p2 + a2);\n\t}\n\telse\n\t{\n\t\td = b2 - (p2 + a2);\n\t}\n\n\tif (d > 0)\n\t{\n\t\treturn d;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n};\n\n/**\n * Function: bridge\n */\nmxCompactTreeLayout.prototype.bridge = function(line1, x1, y1, line2, x2, y2)\n{\n\tvar dx = x2 + line2.dx - x1;\n\tvar dy = 0;\n\tvar s = 0;\n\t\n\tif (line2.dx == 0)\n\t{\n\t\tdy = line2.dy;\n\t}\n\telse\n\t{\n\t\ts = dx * line2.dy;\n\t\tdy = s / line2.dx;\n\t}\n\t\n\tvar r = this.createLine(dx, dy, line2.next);\n\tline1.next = this.createLine(0, y2 + line2.dy - dy - y1, r);\n\t\n\treturn r;\n};\n\n/**\n * Function: createNode\n */\nmxCompactTreeLayout.prototype.createNode = function(cell)\n{\n\tvar node = new Object();\n\tnode.cell = cell;\n\tnode.x = 0;\n\tnode.y = 0;\n\tnode.width = 0;\n\tnode.height = 0;\n\t\n\tvar geo = this.getVertexBounds(cell);\n\t\n\tif (geo != null)\n\t{\n\t\tif (this.isHorizontal())\n\t\t{\n\t\t\tnode.width = geo.height;\n\t\t\tnode.height = geo.width;\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnode.width = geo.width;\n\t\t\tnode.height = geo.height;\n\t\t}\n\t}\n\t\n\tnode.offsetX = 0;\n\tnode.offsetY = 0;\n\tnode.contour = new Object();\n\t\n\treturn node;\n};\n\n/**\n * Function: apply\n */\nmxCompactTreeLayout.prototype.apply = function(node, bounds)\n{\n\tvar model = this.graph.getModel();\n\tvar cell = node.cell;\n\tvar g = model.getGeometry(cell);\n\n\tif (cell != null && g != null)\n\t{\n\t\tif (this.isVertexMovable(cell))\n\t\t{\n\t\t\tg = this.setVertexLocation(cell, node.x, node.y);\n\t\t\t\n\t\t\tif (this.resizeParent)\n\t\t\t{\n\t\t\t\tvar parent = model.getParent(cell);\n\t\t\t\tvar id = mxCellPath.create(parent);\n\t\t\t\t\n\t\t\t\t// Implements set semantic\n\t\t\t\tif (this.parentsChanged[id] == null)\n\t\t\t\t{\n\t\t\t\t\tthis.parentsChanged[id] = parent;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (bounds == null)\n\t\t{\n\t\t\tbounds = new mxRectangle(g.x, g.y, g.width, g.height);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbounds = new mxRectangle(Math.min(bounds.x, g.x),\n\t\t\t\tMath.min(bounds.y, g.y),\n\t\t\t\tMath.max(bounds.x + bounds.width, g.x + g.width),\n\t\t\t\tMath.max(bounds.y + bounds.height, g.y + g.height));\n\t\t}\n\t}\n\t\n\treturn bounds;\n};\n\n/**\n * Function: createLine\n */\nmxCompactTreeLayout.prototype.createLine = function(dx, dy, next)\n{\n\tvar line = new Object();\n\tline.dx = dx;\n\tline.dy = dy;\n\tline.next = next;\n\t\n\treturn line;\n};\n\n/**\n * Function: adjustParents\n * \n * Adjust parent cells whose child geometries have changed. The default \n * implementation adjusts the group to just fit around the children with \n * a padding.\n */\nmxCompactTreeLayout.prototype.adjustParents = function()\n{\n\tvar tmp = [];\n\t\n\tfor (var id in this.parentsChanged)\n\t{\n\t\ttmp.push(this.parentsChanged[id]);\n\t}\n\t\n\tthis.arrangeGroups(mxUtils.sortCells(tmp, true), this.groupPadding, this.groupPaddingTop,\n\t\tthis.groupPaddingRight, this.groupPaddingBottom, this.groupPaddingLeft);\n};\n\n/**\n * Function: localEdgeProcessing\n *\n * Moves the specified node and all of its children by the given amount.\n */\nmxCompactTreeLayout.prototype.localEdgeProcessing = function(node)\n{\n\tthis.processNodeOutgoing(node);\n\tvar child = node.child;\n\n\twhile (child != null)\n\t{\n\t\tthis.localEdgeProcessing(child);\n\t\tchild = child.next;\n\t}\n};\n\n/**\n * Function: processNodeOutgoing\n *\n * Separates the x position of edges as they connect to vertices\n */\nmxCompactTreeLayout.prototype.processNodeOutgoing = function(node)\n{\n\tvar child = node.child;\n\tvar parentCell = node.cell;\n\n\tvar childCount = 0;\n\tvar sortedCells = [];\n\n\twhile (child != null)\n\t{\n\t\tchildCount++;\n\n\t\tvar sortingCriterion = child.x;\n\n\t\tif (this.horizontal)\n\t\t{\n\t\t\tsortingCriterion = child.y;\n\t\t}\n\n\t\tsortedCells.push(new WeightedCellSorter(child, sortingCriterion));\n\t\tchild = child.next;\n\t}\n\n\tsortedCells.sort(WeightedCellSorter.prototype.compare);\n\n\tvar availableWidth = node.width;\n\n\tvar requiredWidth = (childCount + 1) * this.prefHozEdgeSep;\n\n\t// Add a buffer on the edges of the vertex if the edge count allows\n\tif (availableWidth > requiredWidth + (2 * this.prefHozEdgeSep))\n\t{\n\t\tavailableWidth -= 2 * this.prefHozEdgeSep;\n\t}\n\n\tvar edgeSpacing = availableWidth / childCount;\n\n\tvar currentXOffset = edgeSpacing / 2.0;\n\n\tif (availableWidth > requiredWidth + (2 * this.prefHozEdgeSep))\n\t{\n\t\tcurrentXOffset += this.prefHozEdgeSep;\n\t}\n\n\tvar currentYOffset = this.minEdgeJetty - this.prefVertEdgeOff;\n\tvar maxYOffset = 0;\n\n\tvar parentBounds = this.getVertexBounds(parentCell);\n\tchild = node.child;\n\n\tfor (var j = 0; j < sortedCells.length; j++)\n\t{\n\t\tvar childCell = sortedCells[j].cell.cell;\n\t\tvar childBounds = this.getVertexBounds(childCell);\n\n\t\tvar edges = this.graph.getEdgesBetween(parentCell,\n\t\t\t\tchildCell, false);\n\t\t\n\t\tvar newPoints = [];\n\t\tvar x = 0;\n\t\tvar y = 0;\n\n\t\tfor (var i = 0; i < edges.length; i++)\n\t\t{\n\t\t\tif (this.horizontal)\n\t\t\t{\n\t\t\t\t// Use opposite co-ords, calculation was done for \n\t\t\t\t// \n\t\t\t\tx = parentBounds.x + parentBounds.width;\n\t\t\t\ty = parentBounds.y + currentXOffset;\n\t\t\t\tnewPoints.push(new mxPoint(x, y));\n\t\t\t\tx = parentBounds.x + parentBounds.width\n\t\t\t\t\t\t+ currentYOffset;\n\t\t\t\tnewPoints.push(new mxPoint(x, y));\n\t\t\t\ty = childBounds.y + childBounds.height / 2.0;\n\t\t\t\tnewPoints.push(new mxPoint(x, y));\n\t\t\t\tthis.setEdgePoints(edges[i], newPoints);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx = parentBounds.x + currentXOffset;\n\t\t\t\ty = parentBounds.y + parentBounds.height;\n\t\t\t\tnewPoints.push(new mxPoint(x, y));\n\t\t\t\ty = parentBounds.y + parentBounds.height\n\t\t\t\t\t\t+ currentYOffset;\n\t\t\t\tnewPoints.push(new mxPoint(x, y));\n\t\t\t\tx = childBounds.x + childBounds.width / 2.0;\n\t\t\t\tnewPoints.push(new mxPoint(x, y));\n\t\t\t\tthis.setEdgePoints(edges[i], newPoints);\n\t\t\t}\n\t\t}\n\n\t\tif (j < childCount / 2)\n\t\t{\n\t\t\tcurrentYOffset += this.prefVertEdgeOff;\n\t\t}\n\t\telse if (j > childCount / 2)\n\t\t{\n\t\t\tcurrentYOffset -= this.prefVertEdgeOff;\n\t\t}\n\t\t// Ignore the case if equals, this means the second of 2\n\t\t// jettys with the same y (even number of edges)\n\n\t\t//\t\t\t\t\t\t\t\tpos[k * 2] = currentX;\n\t\tcurrentXOffset += edgeSpacing;\n\t\t//\t\t\t\t\t\t\t\tpos[k * 2 + 1] = currentYOffset;\n\n\t\tmaxYOffset = Math.max(maxYOffset, currentYOffset);\n\t}\n};\n__mxOutput.mxCompactTreeLayout = typeof mxCompactTreeLayout !== 'undefined' ? mxCompactTreeLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxRadialTreeLayout\n * \n * Extends <mxGraphLayout> to implement a radial tree algorithm. This\n * layout is suitable for graphs that have no cycles (trees). Vertices that are\n * not connected to the tree will be ignored by this layout.\n * \n * Example:\n * \n * (code)\n * var layout = new mxRadialTreeLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * (end)\n * \n * Constructor: mxRadialTreeLayout\n * \n * Constructs a new radial tree layout for the specified graph\n */\nfunction mxRadialTreeLayout(graph)\n{\n\tmxCompactTreeLayout.call(this, graph , false);\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxUtils.extend(mxRadialTreeLayout, mxCompactTreeLayout);\n\n/**\n * Variable: angleOffset\n *\n * The initial offset to compute the angle position.\n */\nmxRadialTreeLayout.prototype.angleOffset = 0.5;\n\n/**\n * Variable: rootx\n *\n * The X co-ordinate of the root cell\n */\nmxRadialTreeLayout.prototype.rootx = 0;\n\n/**\n * Variable: rooty\n *\n * The Y co-ordinate of the root cell\n */\nmxRadialTreeLayout.prototype.rooty = 0;\n\n/**\n * Variable: levelDistance\n *\n * Holds the levelDistance. Default is 120.\n */\nmxRadialTreeLayout.prototype.levelDistance = 120;\n\n/**\n * Variable: nodeDistance\n *\n * Holds the nodeDistance. Default is 10.\n */\nmxRadialTreeLayout.prototype.nodeDistance = 10;\n\n/**\n * Variable: autoRadius\n * \n * Specifies if the radios should be computed automatically\n */\nmxRadialTreeLayout.prototype.autoRadius = false;\n\n/**\n * Variable: sortEdges\n * \n * Specifies if edges should be sorted according to the order of their\n * opposite terminal cell in the model.\n */\nmxRadialTreeLayout.prototype.sortEdges = false;\n\n/**\n * Variable: rowMinX\n * \n * Array of leftmost x coordinate of each row\n */\nmxRadialTreeLayout.prototype.rowMinX = [];\n\n/**\n * Variable: rowMaxX\n * \n * Array of rightmost x coordinate of each row\n */\nmxRadialTreeLayout.prototype.rowMaxX = [];\n\n/**\n * Variable: rowMinCenX\n * \n * Array of x coordinate of leftmost vertex of each row\n */\nmxRadialTreeLayout.prototype.rowMinCenX = [];\n\n/**\n * Variable: rowMaxCenX\n * \n * Array of x coordinate of rightmost vertex of each row\n */\nmxRadialTreeLayout.prototype.rowMaxCenX = [];\n\n/**\n * Variable: rowRadi\n * \n * Array of y deltas of each row behind root vertex, also the radius in the tree\n */\nmxRadialTreeLayout.prototype.rowRadi = [];\n\n/**\n * Variable: row\n * \n * Array of vertices on each row\n */\nmxRadialTreeLayout.prototype.row = [];\n\n/**\n * Function: isVertexIgnored\n * \n * Returns a boolean indicating if the given <mxCell> should be ignored as a\n * vertex. This returns true if the cell has no connections.\n * \n * Parameters:\n * \n * vertex - <mxCell> whose ignored state should be returned.\n */\nmxRadialTreeLayout.prototype.isVertexIgnored = function(vertex)\n{\n\treturn mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) ||\n\t\tthis.graph.getConnections(vertex).length == 0;\n};\n\n/**\n * Function: execute\n * \n * Implements <mxGraphLayout.execute>.\n * \n * If the parent has any connected edges, then it is used as the root of\n * the tree. Else, <mxGraph.findTreeRoots> will be used to find a suitable\n * root node within the set of children of the given parent.\n * \n * Parameters:\n * \n * parent - <mxCell> whose children should be laid out.\n * root - Optional <mxCell> that will be used as the root of the tree.\n */\nmxRadialTreeLayout.prototype.execute = function(parent, root)\n{\n\tthis.parent = parent;\n\t\n\tthis.useBoundingBox = false;\n\tthis.edgeRouting = false;\n\t//this.horizontal = false;\n\n\tmxCompactTreeLayout.prototype.execute.apply(this, arguments);\n\t\n\tvar bounds = null;\n\tvar rootBounds = this.getVertexBounds(this.root);\n\tthis.centerX = rootBounds.x + rootBounds.width / 2;\n\tthis.centerY = rootBounds.y + rootBounds.height / 2;\n\n\t// Calculate the bounds of the involved vertices directly from the values set in the compact tree\n\tfor (var vertex in this.visited)\n\t{\n\t\tvar vertexBounds = this.getVertexBounds(this.visited[vertex]);\n\t\tbounds = (bounds != null) ? bounds : vertexBounds.clone();\n\t\tbounds.add(vertexBounds);\n\t}\n\t\n\tthis.calcRowDims([this.node], 0);\n\t\n\tvar maxLeftGrad = 0;\n\tvar maxRightGrad = 0;\n\n\t// Find the steepest left and right gradients\n\tfor (var i = 0; i < this.row.length; i++)\n\t{\n\t\tvar leftGrad = (this.centerX - this.rowMinX[i] - this.nodeDistance) / this.rowRadi[i];\n\t\tvar rightGrad = (this.rowMaxX[i] - this.centerX - this.nodeDistance) / this.rowRadi[i];\n\t\t\n\t\tmaxLeftGrad = Math.max (maxLeftGrad, leftGrad);\n\t\tmaxRightGrad = Math.max (maxRightGrad, rightGrad);\n\t}\n\t\n\t// Extend out row so they meet the maximum gradient and convert to polar co-ords\n\tfor (var i = 0; i < this.row.length; i++)\n\t{\n\t\tvar xLeftLimit = this.centerX - this.nodeDistance - maxLeftGrad * this.rowRadi[i];\n\t\tvar xRightLimit = this.centerX + this.nodeDistance + maxRightGrad * this.rowRadi[i];\n\t\tvar fullWidth = xRightLimit - xLeftLimit;\n\t\t\n\t\tfor (var j = 0; j < this.row[i].length; j ++)\n\t\t{\n\t\t\tvar row = this.row[i];\n\t\t\tvar node = row[j];\n\t\t\tvar vertexBounds = this.getVertexBounds(node.cell);\n\t\t\tvar xProportion = (vertexBounds.x + vertexBounds.width / 2 - xLeftLimit) / (fullWidth);\n\t\t\tvar theta =  2 * Math.PI * xProportion;\n\t\t\tnode.theta = theta;\n\t\t}\n\t}\n\n\t// Post-process from outside inwards to try to align parents with children\n\tfor (var i = this.row.length - 2; i >= 0; i--)\n\t{\n\t\tvar row = this.row[i];\n\t\t\n\t\tfor (var j = 0; j < row.length; j++)\n\t\t{\n\t\t\tvar node = row[j];\n\t\t\tvar child = node.child;\n\t\t\tvar counter = 0;\n\t\t\tvar totalTheta = 0;\n\t\t\t\n\t\t\twhile (child != null)\n\t\t\t{\n\t\t\t\ttotalTheta += child.theta;\n\t\t\t\tcounter++;\n\t\t\t\tchild = child.next;\n\t\t\t}\n\t\t\t\n\t\t\tif (counter > 0)\n\t\t\t{\n\t\t\t\tvar averTheta = totalTheta / counter;\n\t\t\t\t\n\t\t\t\tif (averTheta > node.theta && j < row.length - 1)\n\t\t\t\t{\n\t\t\t\t\tvar nextTheta = row[j+1].theta;\n\t\t\t\t\tnode.theta = Math.min (averTheta, nextTheta - Math.PI/10);\n\t\t\t\t}\n\t\t\t\telse if (averTheta < node.theta && j > 0 )\n\t\t\t\t{\n\t\t\t\t\tvar lastTheta = row[j-1].theta;\n\t\t\t\t\tnode.theta = Math.max (averTheta, lastTheta + Math.PI/10);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Set locations\n\tfor (var i = 0; i < this.row.length; i++)\n\t{\n\t\tfor (var j = 0; j < this.row[i].length; j ++)\n\t\t{\n\t\t\tvar row = this.row[i];\n\t\t\tvar node = row[j];\n\t\t\tvar vertexBounds = this.getVertexBounds(node.cell);\n\t\t\tthis.setVertexLocation(node.cell,\n\t\t\t\t\t\t\t\t\tthis.centerX - vertexBounds.width / 2 + this.rowRadi[i] * Math.cos(node.theta),\n\t\t\t\t\t\t\t\t\tthis.centerY - vertexBounds.height / 2 + this.rowRadi[i] * Math.sin(node.theta));\n\t\t}\n\t}\n};\n\n/**\n * Function: calcRowDims\n * \n * Recursive function to calculate the dimensions of each row\n * \n * Parameters:\n * \n * row - Array of internal nodes, the children of which are to be processed.\n * rowNum - Integer indicating which row is being processed.\n */\nmxRadialTreeLayout.prototype.calcRowDims = function(row, rowNum)\n{\n\tif (row == null || row.length == 0)\n\t{\n\t\treturn;\n\t}\n\n\t// Place root's children proportionally around the first level\n\tthis.rowMinX[rowNum] = this.centerX;\n\tthis.rowMaxX[rowNum] = this.centerX;\n\tthis.rowMinCenX[rowNum] = this.centerX;\n\tthis.rowMaxCenX[rowNum] = this.centerX;\n\tthis.row[rowNum] = [];\n\n\tvar rowHasChildren = false;\n\n\tfor (var i = 0; i < row.length; i++)\n\t{\n\t\tvar child = row[i] != null ? row[i].child : null;\n\n\t\twhile (child != null)\n\t\t{\n\t\t\tvar cell = child.cell;\n\t\t\tvar vertexBounds = this.getVertexBounds(cell);\n\t\t\t\n\t\t\tthis.rowMinX[rowNum] = Math.min(vertexBounds.x, this.rowMinX[rowNum]);\n\t\t\tthis.rowMaxX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width, this.rowMaxX[rowNum]);\n\t\t\tthis.rowMinCenX[rowNum] = Math.min(vertexBounds.x + vertexBounds.width / 2, this.rowMinCenX[rowNum]);\n\t\t\tthis.rowMaxCenX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width / 2, this.rowMaxCenX[rowNum]);\n\t\t\tthis.rowRadi[rowNum] = vertexBounds.y - this.getVertexBounds(this.root).y;\n\t\n\t\t\tif (child.child != null)\n\t\t\t{\n\t\t\t\trowHasChildren = true;\n\t\t\t}\n\t\t\t\n\t\t\tthis.row[rowNum].push(child);\n\t\t\tchild = child.next;\n\t\t}\n\t}\n\t\n\tif (rowHasChildren)\n\t{\n\t\tthis.calcRowDims(this.row[rowNum], rowNum + 1);\n\t}\n};\n\n__mxOutput.mxRadialTreeLayout = typeof mxRadialTreeLayout !== 'undefined' ? mxRadialTreeLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxFastOrganicLayout\n * \n * Extends <mxGraphLayout> to implement a fast organic layout algorithm.\n * The vertices need to be connected for this layout to work, vertices\n * with no connections are ignored.\n * \n * Example:\n * \n * (code)\n * var layout = new mxFastOrganicLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * (end)\n * \n * Constructor: mxCompactTreeLayout\n * \n * Constructs a new fast organic layout for the specified graph.\n */\nfunction mxFastOrganicLayout(graph)\n{\n\tmxGraphLayout.call(this, graph);\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxFastOrganicLayout.prototype = new mxGraphLayout();\nmxFastOrganicLayout.prototype.constructor = mxFastOrganicLayout;\n\n/**\n * Variable: useInputOrigin\n * \n * Specifies if the top left corner of the input cells should be the origin\n * of the layout result. Default is true.\n */\nmxFastOrganicLayout.prototype.useInputOrigin = true;\n\n/**\n * Variable: resetEdges\n * \n * Specifies if all edge points of traversed edges should be removed.\n * Default is true.\n */\nmxFastOrganicLayout.prototype.resetEdges = true;\n\n/**\n * Variable: disableEdgeStyle\n * \n * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are\n * modified by the result. Default is true.\n */\nmxFastOrganicLayout.prototype.disableEdgeStyle = true;\n\n/**\n * Variable: forceConstant\n * \n * The force constant by which the attractive forces are divided and the\n * replusive forces are multiple by the square of. The value equates to the\n * average radius there is of free space around each node. Default is 50.\n */\nmxFastOrganicLayout.prototype.forceConstant = 50;\n\n/**\n * Variable: forceConstantSquared\n * \n * Cache of <forceConstant>^2 for performance.\n */\nmxFastOrganicLayout.prototype.forceConstantSquared = 0;\n\n/**\n * Variable: minDistanceLimit\n * \n * Minimal distance limit. Default is 2. Prevents of\n * dividing by zero.\n */\nmxFastOrganicLayout.prototype.minDistanceLimit = 2;\n\n/**\n * Variable: maxDistanceLimit\n * \n * Maximal distance limit. Default is 500. Prevents of\n * dividing by zero.\n */\nmxFastOrganicLayout.prototype.maxDistanceLimit = 500;\n\n/**\n * Variable: minDistanceLimitSquared\n * \n * Cached version of <minDistanceLimit> squared.\n */\nmxFastOrganicLayout.prototype.minDistanceLimitSquared = 4;\n\n/**\n * Variable: initialTemp\n * \n * Start value of temperature. Default is 200.\n */\nmxFastOrganicLayout.prototype.initialTemp = 200;\n\n/**\n * Variable: temperature\n * \n * Temperature to limit displacement at later stages of layout.\n */\nmxFastOrganicLayout.prototype.temperature = 0;\n\n/**\n * Variable: maxIterations\n * \n * Total number of iterations to run the layout though.\n */\nmxFastOrganicLayout.prototype.maxIterations = 0;\n\n/**\n * Variable: iteration\n * \n * Current iteration count.\n */\nmxFastOrganicLayout.prototype.iteration = 0;\n\n/**\n * Variable: vertexArray\n * \n * An array of all vertices to be laid out.\n */\nmxFastOrganicLayout.prototype.vertexArray;\n\n/**\n * Variable: dispX\n * \n * An array of locally stored X co-ordinate displacements for the vertices.\n */\nmxFastOrganicLayout.prototype.dispX;\n\n/**\n * Variable: dispY\n * \n * An array of locally stored Y co-ordinate displacements for the vertices.\n */\nmxFastOrganicLayout.prototype.dispY;\n\n/**\n * Variable: cellLocation\n * \n * An array of locally stored co-ordinate positions for the vertices.\n */\nmxFastOrganicLayout.prototype.cellLocation;\n\n/**\n * Variable: radius\n * \n * The approximate radius of each cell, nodes only.\n */\nmxFastOrganicLayout.prototype.radius;\n\n/**\n * Variable: radiusSquared\n * \n * The approximate radius squared of each cell, nodes only.\n */\nmxFastOrganicLayout.prototype.radiusSquared;\n\n/**\n * Variable: isMoveable\n * \n * Array of booleans representing the movable states of the vertices.\n */\nmxFastOrganicLayout.prototype.isMoveable;\n\n/**\n * Variable: neighbours\n * \n * Local copy of cell neighbours.\n */\nmxFastOrganicLayout.prototype.neighbours;\n\n/**\n * Variable: indices\n * \n * Hashtable from cells to local indices.\n */\nmxFastOrganicLayout.prototype.indices;\n\n/**\n * Variable: allowedToRun\n * \n * Boolean flag that specifies if the layout is allowed to run. If this is\n * set to false, then the layout exits in the following iteration.\n */\nmxFastOrganicLayout.prototype.allowedToRun = true;\n\n/**\n * Function: isVertexIgnored\n * \n * Returns a boolean indicating if the given <mxCell> should be ignored as a\n * vertex. This returns true if the cell has no connections.\n * \n * Parameters:\n * \n * vertex - <mxCell> whose ignored state should be returned.\n */\nmxFastOrganicLayout.prototype.isVertexIgnored = function(vertex)\n{\n\treturn mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) ||\n\t\tthis.graph.getConnections(vertex).length == 0;\n};\n\n/**\n * Function: execute\n * \n * Implements <mxGraphLayout.execute>. This operates on all children of the\n * given parent where <isVertexIgnored> returns false.\n */\nmxFastOrganicLayout.prototype.execute = function(parent)\n{\n\tvar model = this.graph.getModel();\n\tthis.vertexArray = [];\n\tvar cells = this.graph.getChildVertices(parent);\n\t\n\tfor (var i = 0; i < cells.length; i++)\n\t{\n\t\tif (!this.isVertexIgnored(cells[i]))\n\t\t{\n\t\t\tthis.vertexArray.push(cells[i]);\n\t\t}\n\t}\n\t\n\tvar initialBounds = (this.useInputOrigin) ?\n\t\t\tthis.graph.getBoundingBoxFromGeometry(this.vertexArray) :\n\t\t\t\tnull;\n\tvar n = this.vertexArray.length;\n\n\tthis.indices = [];\n\tthis.dispX = [];\n\tthis.dispY = [];\n\tthis.cellLocation = [];\n\tthis.isMoveable = [];\n\tthis.neighbours = [];\n\tthis.radius = [];\n\tthis.radiusSquared = [];\n\n\tif (this.forceConstant < 0.001)\n\t{\n\t\tthis.forceConstant = 0.001;\n\t}\n\n\tthis.forceConstantSquared = this.forceConstant * this.forceConstant;\n\n\t// Create a map of vertices first. This is required for the array of\n\t// arrays called neighbours which holds, for each vertex, a list of\n\t// ints which represents the neighbours cells to that vertex as\n\t// the indices into vertexArray\n\tfor (var i = 0; i < this.vertexArray.length; i++)\n\t{\n\t\tvar vertex = this.vertexArray[i];\n\t\tthis.cellLocation[i] = [];\n\t\t\n\t\t// Set up the mapping from array indices to cells\n\t\tvar id = mxObjectIdentity.get(vertex);\n\t\tthis.indices[id] = i;\n\t\tvar bounds = this.getVertexBounds(vertex);\n\n\t\t// Set the X,Y value of the internal version of the cell to\n\t\t// the center point of the vertex for better positioning\n\t\tvar width = bounds.width;\n\t\tvar height = bounds.height;\n\t\t\n\t\t// Randomize (0, 0) locations\n\t\tvar x = bounds.x;\n\t\tvar y = bounds.y;\n\t\t\n\t\tthis.cellLocation[i][0] = x + width / 2.0;\n\t\tthis.cellLocation[i][1] = y + height / 2.0;\n\t\tthis.radius[i] = Math.min(width, height);\n\t\tthis.radiusSquared[i] = this.radius[i] * this.radius[i];\n\t}\n\n\t// Moves cell location back to top-left from center locations used in\n\t// algorithm, resetting the edge points is part of the transaction\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tfor (var i = 0; i < n; i++)\n\t\t{\n\t\t\tthis.dispX[i] = 0;\n\t\t\tthis.dispY[i] = 0;\n\t\t\tthis.isMoveable[i] = this.isVertexMovable(this.vertexArray[i]);\n\n\t\t\t// Get lists of neighbours to all vertices, translate the cells\n\t\t\t// obtained in indices into vertexArray and store as an array\n\t\t\t// against the orginial cell index\n\t\t\tvar edges = this.graph.getConnections(this.vertexArray[i], parent);\n\t\t\tvar cells = this.graph.getOpposites(edges, this.vertexArray[i]);\n\t\t\tthis.neighbours[i] = [];\n\n\t\t\tfor (var j = 0; j < cells.length; j++)\n\t\t\t{\n\t\t\t\t// Resets the points on the traversed edge\n\t\t\t\tif (this.resetEdges)\n\t\t\t\t{\n\t\t\t\t\tthis.graph.resetEdge(edges[j]);\n\t\t\t\t}\n\n\t\t\t    if (this.disableEdgeStyle)\n\t\t\t    {\n\t\t\t    \tthis.setEdgeStyleEnabled(edges[j], false);\n\t\t\t    }\n\n\t\t\t\t// Looks the cell up in the indices dictionary\n\t\t\t\tvar id = mxObjectIdentity.get(cells[j]);\n\t\t\t\tvar index = this.indices[id];\n\n\t\t\t\t// Check the connected cell in part of the vertex list to be\n\t\t\t\t// acted on by this layout\n\t\t\t\tif (index != null)\n\t\t\t\t{\n\t\t\t\t\tthis.neighbours[i][j] = index;\n\t\t\t\t}\n\n\t\t\t\t// Else if index of the other cell doesn't correspond to\n\t\t\t\t// any cell listed to be acted upon in this layout. Set\n\t\t\t\t// the index to the value of this vertex (a dummy self-loop)\n\t\t\t\t// so the attraction force of the edge is not calculated\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.neighbours[i][j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.temperature = this.initialTemp;\n\n\t\t// If max number of iterations has not been set, guess it\n\t\tif (this.maxIterations == 0)\n\t\t{\n\t\t\tthis.maxIterations = 20 * Math.sqrt(n);\n\t\t}\n\t\t\n\t\t// Main iteration loop\n\t\tfor (this.iteration = 0; this.iteration < this.maxIterations; this.iteration++)\n\t\t{\n\t\t\tif (!this.allowedToRun)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// Calculate repulsive forces on all vertices\n\t\t\tthis.calcRepulsion();\n\n\t\t\t// Calculate attractive forces through edges\n\t\t\tthis.calcAttraction();\n\n\t\t\tthis.calcPositions();\n\t\t\tthis.reduceTemperature();\n\t\t}\n\n\t\tvar minx = null;\n\t\tvar miny = null;\n\t\t\n\t\tfor (var i = 0; i < this.vertexArray.length; i++)\n\t\t{\n\t\t\tvar vertex = this.vertexArray[i];\n\t\t\t\n\t\t\tif (this.isVertexMovable(vertex))\n\t\t\t{\n\t\t\t\tvar bounds = this.getVertexBounds(vertex);\n\t\t\t\t\n\t\t\t\tif (bounds != null)\n\t\t\t\t{\n\t\t\t\t\tthis.cellLocation[i][0] -= bounds.width / 2.0;\n\t\t\t\t\tthis.cellLocation[i][1] -= bounds.height / 2.0;\n\t\t\t\t\t\n\t\t\t\t\tvar x = this.graph.snap(Math.round(this.cellLocation[i][0]));\n\t\t\t\t\tvar y = this.graph.snap(Math.round(this.cellLocation[i][1]));\n\t\t\t\t\t\n\t\t\t\t\tthis.setVertexLocation(vertex, x, y);\n\t\t\t\t\t\n\t\t\t\t\tif (minx == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tminx = x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tminx = Math.min(minx, x);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (miny == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tminy = y;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tminy = Math.min(miny, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Modifies the cloned geometries in-place. Not needed\n\t\t// to clone the geometries again as we're in the same\n\t\t// undoable change.\n\t\tvar dx = -(minx || 0) + 1;\n\t\tvar dy = -(miny || 0) + 1;\n\t\t\n\t\tif (initialBounds != null)\n\t\t{\n\t\t\tdx += initialBounds.x;\n\t\t\tdy += initialBounds.y;\n\t\t}\n\t\t\n\t\tthis.graph.moveCells(this.vertexArray, dx, dy);\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n};\n\n/**\n * Function: calcPositions\n * \n * Takes the displacements calculated for each cell and applies them to the\n * local cache of cell positions. Limits the displacement to the current\n * temperature.\n */\nmxFastOrganicLayout.prototype.calcPositions = function()\n{\n\tfor (var index = 0; index < this.vertexArray.length; index++)\n\t{\n\t\tif (this.isMoveable[index])\n\t\t{\n\t\t\t// Get the distance of displacement for this node for this\n\t\t\t// iteration\n\t\t\tvar deltaLength = Math.sqrt(this.dispX[index] * this.dispX[index] +\n\t\t\t\tthis.dispY[index] * this.dispY[index]);\n\n\t\t\tif (deltaLength < 0.001)\n\t\t\t{\n\t\t\t\tdeltaLength = 0.001;\n\t\t\t}\n\n\t\t\t// Scale down by the current temperature if less than the\n\t\t\t// displacement distance\n\t\t\tvar newXDisp = this.dispX[index] / deltaLength\n\t\t\t\t* Math.min(deltaLength, this.temperature);\n\n\t\t\tvar newYDisp = this.dispY[index] / deltaLength\n\t\t\t\t* Math.min(deltaLength, this.temperature);\n\n\t\t\t// reset displacements\n\t\t\tthis.dispX[index] = 0;\n\t\t\tthis.dispY[index] = 0;\n\n\t\t\t// Update the cached cell locations\n\t\t\tthis.cellLocation[index][0] += newXDisp;\n\t\t\tthis.cellLocation[index][1] += newYDisp;\n\t\t}\n\t}\n};\n\n/**\n * Function: calcAttraction\n * \n * Calculates the attractive forces between all laid out nodes linked by\n * edges\n */\nmxFastOrganicLayout.prototype.calcAttraction = function()\n{\n\t// Check the neighbours of each vertex and calculate the attractive\n\t// force of the edge connecting them\n\tfor (var i = 0; i < this.vertexArray.length; i++)\n\t{\n\t\tfor (var k = 0; k < this.neighbours[i].length; k++)\n\t\t{\n\t\t\t// Get the index of the othe cell in the vertex array\n\t\t\tvar j = this.neighbours[i][k];\n\t\t\t\n\t\t\t// Do not proceed self-loops\n\t\t\tif (i != j &&\n\t\t\t\tthis.isMoveable[i] &&\n\t\t\t\tthis.isMoveable[j])\n\t\t\t{\n\t\t\t\tvar xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];\n\t\t\t\tvar yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];\n\n\t\t\t\t// The distance between the nodes\n\t\t\t\tvar deltaLengthSquared = xDelta * xDelta + yDelta\n\t\t\t\t\t\t* yDelta - this.radiusSquared[i] - this.radiusSquared[j];\n\n\t\t\t\tif (deltaLengthSquared < this.minDistanceLimitSquared)\n\t\t\t\t{\n\t\t\t\t\tdeltaLengthSquared = this.minDistanceLimitSquared;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar deltaLength = Math.sqrt(deltaLengthSquared);\n\t\t\t\tvar force = (deltaLengthSquared) / this.forceConstant;\n\n\t\t\t\tvar displacementX = (xDelta / deltaLength) * force;\n\t\t\t\tvar displacementY = (yDelta / deltaLength) * force;\n\t\t\t\t\n\t\t\t\tthis.dispX[i] -= displacementX;\n\t\t\t\tthis.dispY[i] -= displacementY;\n\t\t\t\t\n\t\t\t\tthis.dispX[j] += displacementX;\n\t\t\t\tthis.dispY[j] += displacementY;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: calcRepulsion\n * \n * Calculates the repulsive forces between all laid out nodes\n */\nmxFastOrganicLayout.prototype.calcRepulsion = function()\n{\n\tvar vertexCount = this.vertexArray.length;\n\n\tfor (var i = 0; i < vertexCount; i++)\n\t{\n\t\tfor (var j = i; j < vertexCount; j++)\n\t\t{\n\t\t\t// Exits if the layout is no longer allowed to run\n\t\t\tif (!this.allowedToRun)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (j != i &&\n\t\t\t\tthis.isMoveable[i] &&\n\t\t\t\tthis.isMoveable[j])\n\t\t\t{\n\t\t\t\tvar xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];\n\t\t\t\tvar yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];\n\n\t\t\t\tif (xDelta == 0)\n\t\t\t\t{\n\t\t\t\t\txDelta = 0.01 + Math.random();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (yDelta == 0)\n\t\t\t\t{\n\t\t\t\t\tyDelta = 0.01 + Math.random();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Distance between nodes\n\t\t\t\tvar deltaLength = Math.sqrt((xDelta * xDelta)\n\t\t\t\t\t\t+ (yDelta * yDelta));\n\t\t\t\tvar deltaLengthWithRadius = deltaLength - this.radius[i]\n\t\t\t\t\t\t- this.radius[j];\n\n\t\t\t\tif (deltaLengthWithRadius > this.maxDistanceLimit)\n\t\t\t\t{\n\t\t\t\t\t// Ignore vertices too far apart\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (deltaLengthWithRadius < this.minDistanceLimit)\n\t\t\t\t{\n\t\t\t\t\tdeltaLengthWithRadius = this.minDistanceLimit;\n\t\t\t\t}\n\n\t\t\t\tvar force = this.forceConstantSquared / deltaLengthWithRadius;\n\n\t\t\t\tvar displacementX = (xDelta / deltaLength) * force;\n\t\t\t\tvar displacementY = (yDelta / deltaLength) * force;\n\t\t\t\t\n\t\t\t\tthis.dispX[i] += displacementX;\n\t\t\t\tthis.dispY[i] += displacementY;\n\n\t\t\t\tthis.dispX[j] -= displacementX;\n\t\t\t\tthis.dispY[j] -= displacementY;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: reduceTemperature\n * \n * Reduces the temperature of the layout from an initial setting in a linear\n * fashion to zero.\n */\nmxFastOrganicLayout.prototype.reduceTemperature = function()\n{\n\tthis.temperature = this.initialTemp * (1.0 - this.iteration / this.maxIterations);\n};\n\n__mxOutput.mxFastOrganicLayout = typeof mxFastOrganicLayout !== 'undefined' ? mxFastOrganicLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCircleLayout\n * \n * Extends <mxGraphLayout> to implement a circluar layout for a given radius.\n * The vertices do not need to be connected for this layout to work and all\n * connections between vertices are not taken into account.\n * \n * Example:\n * \n * (code)\n * var layout = new mxCircleLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * (end)\n * \n * Constructor: mxCircleLayout\n *\n * Constructs a new circular layout for the specified radius.\n *\n * Arguments:\n * \n * graph - <mxGraph> that contains the cells.\n * radius - Optional radius as an int. Default is 100.\n */\nfunction mxCircleLayout(graph, radius)\n{\n\tmxGraphLayout.call(this, graph);\n\tthis.radius = (radius != null) ? radius : 100;\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxCircleLayout.prototype = new mxGraphLayout();\nmxCircleLayout.prototype.constructor = mxCircleLayout;\n\n/**\n * Variable: radius\n * \n * Integer specifying the size of the radius. Default is 100.\n */\nmxCircleLayout.prototype.radius = null;\n\n/**\n * Variable: moveCircle\n * \n * Boolean specifying if the circle should be moved to the top,\n * left corner specified by <x0> and <y0>. Default is false.\n */\nmxCircleLayout.prototype.moveCircle = false;\n\n/**\n * Variable: x0\n * \n * Integer specifying the left coordinate of the circle.\n * Default is 0.\n */\nmxCircleLayout.prototype.x0 = 0;\n\n/**\n * Variable: y0\n * \n * Integer specifying the top coordinate of the circle.\n * Default is 0.\n */\nmxCircleLayout.prototype.y0 = 0;\n\n/**\n * Variable: resetEdges\n * \n * Specifies if all edge points of traversed edges should be removed.\n * Default is true.\n */\nmxCircleLayout.prototype.resetEdges = true;\n\n/**\n * Variable: disableEdgeStyle\n * \n * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are\n * modified by the result. Default is true.\n */\nmxCircleLayout.prototype.disableEdgeStyle = true;\n\n/**\n * Function: execute\n * \n * Implements <mxGraphLayout.execute>.\n */\nmxCircleLayout.prototype.execute = function(parent)\n{\n\tvar model = this.graph.getModel();\n\n\t// Moves the vertices to build a circle. Makes sure the\n\t// radius is large enough for the vertices to not\n\t// overlap\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\t// Gets all vertices inside the parent and finds\n\t\t// the maximum dimension of the largest vertex\n\t\tvar max = 0;\n\t\tvar top = null;\n\t\tvar left = null;\n\t\tvar vertices = [];\n\t\tvar childCount = model.getChildCount(parent);\n\t\t\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar cell = model.getChildAt(parent, i);\n\t\t\t\n\t\t\tif (!this.isVertexIgnored(cell))\n\t\t\t{\n\t\t\t\tvertices.push(cell);\n\t\t\t\tvar bounds = this.getVertexBounds(cell);\n\t\t\t\t\n\t\t\t\tif (top == null)\n\t\t\t\t{\n\t\t\t\t\ttop = bounds.y;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttop = Math.min(top, bounds.y);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (left == null)\n\t\t\t\t{\n\t\t\t\t\tleft = bounds.x;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tleft = Math.min(left, bounds.x);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmax = Math.max(max, Math.max(bounds.width, bounds.height));\n\t\t\t}\n\t\t\telse if (!this.isEdgeIgnored(cell))\n\t\t\t{\n\t\t\t\t// Resets the points on the traversed edge\n\t\t\t\tif (this.resetEdges)\n\t\t\t\t{\n\t\t\t\t\tthis.graph.resetEdge(cell);\n\t\t\t\t}\n\n\t\t\t    if (this.disableEdgeStyle)\n\t\t\t    {\n\t\t\t    \t\tthis.setEdgeStyleEnabled(cell, false);\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar r = this.getRadius(vertices.length, max);\n\n\t\t// Moves the circle to the specified origin\n\t\tif (this.moveCircle)\n\t\t{\n\t\t\tleft = this.x0;\n\t\t\ttop = this.y0;\n\t\t}\n\t\t\n\t\tthis.circle(vertices, r, left, top);\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n};\n\n/**\n * Function: getRadius\n * \n * Returns the radius to be used for the given vertex count. Max is the maximum\n * width or height of all vertices in the layout.\n */\nmxCircleLayout.prototype.getRadius = function(count, max)\n{\n\treturn Math.max(count * max / Math.PI, this.radius);\n};\n\n/**\n * Function: circle\n * \n * Executes the circular layout for the specified array\n * of vertices and the given radius. This is called from\n * <execute>.\n */\nmxCircleLayout.prototype.circle = function(vertices, r, left, top)\n{\n\tvar vertexCount = vertices.length;\n\tvar phi = 2 * Math.PI / vertexCount;\n\t\n\tfor (var i = 0; i < vertexCount; i++)\n\t{\n\t\tif (this.isVertexMovable(vertices[i]))\n\t\t{\n\t\t\tthis.setVertexLocation(vertices[i],\n\t\t\t\tMath.round(left + r + r * Math.sin(i * phi)),\n\t\t\t\tMath.round(top + r + r * Math.cos(i * phi)));\n\t\t}\n\t}\n};\n\n__mxOutput.mxCircleLayout = typeof mxCircleLayout !== 'undefined' ? mxCircleLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxParallelEdgeLayout\n * \n * Extends <mxGraphLayout> for arranging parallel edges. This layout works\n * on edges for all pairs of vertices where there is more than one edge\n * connecting the latter.\n * \n * Example:\n * \n * (code)\n * var layout = new mxParallelEdgeLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * (end)\n * \n * To run the layout for the parallel edges of a changed edge only, the\n * following code can be used.\n * \n * (code)\n * var layout = new mxParallelEdgeLayout(graph);\n * \n * graph.addListener(mxEvent.CELL_CONNECTED, function(sender, evt)\n * {\n *   var model = graph.getModel();\n *   var edge = evt.getProperty('edge');\n *   var src = model.getTerminal(edge, true);\n *   var trg = model.getTerminal(edge, false);\n *   \n *   layout.isEdgeIgnored = function(edge2)\n *   {\n *     var src2 = model.getTerminal(edge2, true);\n *     var trg2 = model.getTerminal(edge2, false);\n *     \n *     return !(model.isEdge(edge2) && ((src == src2 && trg == trg2) || (src == trg2 && trg == src2)));\n *   };\n *   \n *   layout.execute(graph.getDefaultParent());\n * });\n * (end)\n * \n * Constructor: mxParallelEdgeLayout\n * \n * Constructs a new parallel edge layout for the specified graph.\n */\nfunction mxParallelEdgeLayout(graph)\n{\n\tmxGraphLayout.call(this, graph);\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxParallelEdgeLayout.prototype = new mxGraphLayout();\nmxParallelEdgeLayout.prototype.constructor = mxParallelEdgeLayout;\n\n/**\n * Variable: spacing\n * \n * Defines the spacing between the parallels. Default is 20.\n */\nmxParallelEdgeLayout.prototype.spacing = 20;\n\n/**\n * Variable: checkOverlap\n * \n * Specifies if only overlapping edges should be considered\n * parallel. Default is false.\n */\nmxParallelEdgeLayout.prototype.checkOverlap = false;\n\n/**\n * Function: execute\n * \n * Implements <mxGraphLayout.execute>.\n */\nmxParallelEdgeLayout.prototype.execute = function(parent, cells)\n{\n\tvar lookup = this.findParallels(parent, cells);\n\t\n\tthis.graph.model.beginUpdate();\t\n\ttry\n\t{\n\t\tfor (var i in lookup)\n\t\t{\n\t\t\tvar parallels = lookup[i];\n\n\t\t\tif (parallels.length > 1)\n\t\t\t{\n\t\t\t\tthis.layout(parallels);\n\t\t\t}\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tthis.graph.model.endUpdate();\n\t}\n};\n\n/**\n * Function: findParallels\n * \n * Finds the parallel edges in the given parent.\n */\nmxParallelEdgeLayout.prototype.findParallels = function(parent, cells)\n{\n\tvar lookup = [];\n\t\n\tvar addCell = mxUtils.bind(this, function(cell)\n\t{\n\t\tif (!this.isEdgeIgnored(cell))\n\t\t{\n\t\t\tvar id = this.getEdgeId(cell);\n\t\t\t\n\t\t\tif (id != null)\n\t\t\t{\n\t\t\t\tif (lookup[id] == null)\n\t\t\t\t{\n\t\t\t\t\tlookup[id] = [];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlookup[id].push(cell);\n\t\t\t}\n\t\t}\n\t});\n\t\n\tif (cells != null)\n\t{\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\taddCell(cells[i]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tvar model = this.graph.getModel();\n\t\tvar childCount = model.getChildCount(parent);\n\t\t\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\taddCell(model.getChildAt(parent, i));\n\t\t}\n\t}\n\t\n\treturn lookup;\n};\n\n/**\n * Function: getEdgeId\n * \n * Returns a unique ID for the given edge. The id is independent of the\n * edge direction and is built using the visible terminal of the given\n * edge.\n */\nmxParallelEdgeLayout.prototype.getEdgeId = function(edge)\n{\n\tvar view = this.graph.getView();\n\t\n\t// Cannot used cached visible terminal because this could be triggered in BEFORE_UNDO\n\tvar src = view.getVisibleTerminal(edge, true);\n\tvar trg = view.getVisibleTerminal(edge, false);\n\tvar pts = '';\n\n\tif (src != null && trg != null)\n\t{\n\t\tsrc = mxObjectIdentity.get(src);\n\t\ttrg = mxObjectIdentity.get(trg);\n\t\t\n\t\tif (this.checkOverlap)\n\t\t{\n\t\t\tvar state = this.graph.view.getState(edge);\n\t\t\t\n\t\t\tif (state != null && state.absolutePoints != null)\n\t\t\t{\n\t\t\t\tvar tmp = [];\n\t\t\t\t\n\t\t\t\tfor (var i = 0; i < state.absolutePoints.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar pt = state.absolutePoints[i];\n\t\t\t\t\t\n\t\t\t\t\tif (pt != null)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp.push(pt.x, pt.y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpts = tmp.join(',');\n\t\t\t}\n\t\t};\n\t\t\n\t\treturn ((src > trg) ? trg + '-' + src : src + '-' + trg) + pts;\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: layout\n * \n * Lays out the parallel edges in the given array.\n */\nmxParallelEdgeLayout.prototype.layout = function(parallels)\n{\n\tvar edge = parallels[0];\n\tvar view = this.graph.getView();\n\tvar model = this.graph.getModel();\n\tvar src = model.getGeometry(view.getVisibleTerminal(edge, true));\n\tvar trg = model.getGeometry(view.getVisibleTerminal(edge, false));\n\t\n\t// Routes multiple loops\n\tif (src == trg)\n\t{\n\t\tvar x0 = src.x + src.width + this.spacing;\n\t\tvar y0 = src.y + src.height / 2;\n\n\t\tfor (var i = 0; i < parallels.length; i++)\n\t\t{\n\t\t\tthis.route(parallels[i], x0, y0);\n\t\t\tx0 += this.spacing;\n\t\t}\n\t}\n\telse if (src != null && trg != null)\n\t{\n\t\t// Routes parallel edges\n\t\tvar scx = src.x + src.width / 2;\n\t\tvar scy = src.y + src.height / 2;\n\t\t\n\t\tvar tcx = trg.x + trg.width / 2;\n\t\tvar tcy = trg.y + trg.height / 2;\n\t\t\n\t\tvar dx = tcx - scx;\n\t\tvar dy = tcy - scy;\n\n\t\tvar len = Math.sqrt(dx * dx + dy * dy);\n\t\t\n\t\tif (len > 0)\n\t\t{\n\t\t\tvar x0 = scx + dx / 2;\n\t\t\tvar y0 = scy + dy / 2;\n\t\t\t\n\t\t\tvar nx = dy * this.spacing / len;\n\t\t\tvar ny = dx * this.spacing / len;\n\t\t\t\n\t\t\tx0 += nx * (parallels.length - 1) / 2;\n\t\t\ty0 -= ny * (parallels.length - 1) / 2;\n\t\n\t\t\tfor (var i = 0; i < parallels.length; i++)\n\t\t\t{\n\t\t\t\tthis.route(parallels[i], x0, y0);\n\t\t\t\tx0 -= nx;\n\t\t\t\ty0 += ny;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: route\n * \n * Routes the given edge via the given point.\n */\nmxParallelEdgeLayout.prototype.route = function(edge, x, y)\n{\n\tif (this.graph.isCellMovable(edge))\n\t{\n\t\tthis.setEdgePoints(edge, [new mxPoint(x, y)]);\n\t}\n};\n\n__mxOutput.mxParallelEdgeLayout = typeof mxParallelEdgeLayout !== 'undefined' ? mxParallelEdgeLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCompositeLayout\n * \n * Allows to compose multiple layouts into a single layout. The master layout\n * is the layout that handles move operations if another layout than the first\n * element in <layouts> should be used. The <master> layout is not executed as\n * the code assumes that it is part of <layouts>.\n * \n * Example:\n * (code)\n * var first = new mxFastOrganicLayout(graph);\n * var second = new mxParallelEdgeLayout(graph);\n * var layout = new mxCompositeLayout(graph, [first, second], first);\n * layout.execute(graph.getDefaultParent());\n * (end)\n * \n * Constructor: mxCompositeLayout\n *\n * Constructs a new layout using the given layouts. The graph instance is\n * required for creating the transaction that contains all layouts.\n *\n * Arguments:\n * \n * graph - Reference to the enclosing <mxGraph>.\n * layouts - Array of <mxGraphLayouts>.\n * master - Optional layout that handles moves. If no layout is given then\n * the first layout of the above array is used to handle moves.\n */\nfunction mxCompositeLayout(graph, layouts, master)\n{\n\tmxGraphLayout.call(this, graph);\n\tthis.layouts = layouts;\n\tthis.master = master;\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxCompositeLayout.prototype = new mxGraphLayout();\nmxCompositeLayout.prototype.constructor = mxCompositeLayout;\n\t\n/**\n * Variable: layouts\n * \n * Holds the array of <mxGraphLayouts> that this layout contains.\n */\nmxCompositeLayout.prototype.layouts = null;\n\n/**\n * Variable: master\n * \n * Reference to the <mxGraphLayouts> that handles moves. If this is null\n * then the first layout in <layouts> is used.\n */\nmxCompositeLayout.prototype.master = null;\n\n/**\n * Function: moveCell\n * \n * Implements <mxGraphLayout.moveCell> by calling move on <master> or the first\n * layout in <layouts>.\n */\nmxCompositeLayout.prototype.moveCell = function(cell, x, y)\n{\n\tif (this.master != null)\n\t{\n\t\tthis.master.moveCell.apply(this.master, arguments);\n\t}\n\telse\n\t{\n\t\tthis.layouts[0].moveCell.apply(this.layouts[0], arguments);\n\t}\n};\n\n/**\n * Function: execute\n * \n * Implements <mxGraphLayout.execute> by executing all <layouts> in a\n * single transaction.\n */\nmxCompositeLayout.prototype.execute = function(parent)\n{\n\tvar model = this.graph.getModel();\n\t\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tfor (var i = 0; i < this.layouts.length; i++)\n\t\t{\n\t\t\tthis.layouts[i].execute.apply(this.layouts[i], arguments);\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n};\n\n__mxOutput.mxCompositeLayout = typeof mxCompositeLayout !== 'undefined' ? mxCompositeLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxEdgeLabelLayout\n * \n * Extends <mxGraphLayout> to implement an edge label layout. This layout\n * makes use of cell states, which means the graph must be validated in\n * a graph view (so that the label bounds are available) before this layout\n * can be executed.\n * \n * Example:\n * \n * (code)\n * var layout = new mxEdgeLabelLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * (end)\n * \n * Constructor: mxEdgeLabelLayout\n *\n * Constructs a new edge label layout.\n *\n * Arguments:\n * \n * graph - <mxGraph> that contains the cells.\n */\nfunction mxEdgeLabelLayout(graph, radius)\n{\n\tmxGraphLayout.call(this, graph);\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxEdgeLabelLayout.prototype = new mxGraphLayout();\nmxEdgeLabelLayout.prototype.constructor = mxEdgeLabelLayout;\n\n/**\n * Function: execute\n * \n * Implements <mxGraphLayout.execute>.\n */\nmxEdgeLabelLayout.prototype.execute = function(parent)\n{\n\tvar view = this.graph.view;\n\tvar model = this.graph.getModel();\n\t\n\t// Gets all vertices and edges inside the parent\n\tvar edges = [];\n\tvar vertices = [];\n\tvar childCount = model.getChildCount(parent);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar cell = model.getChildAt(parent, i);\n\t\tvar state = view.getState(cell);\n\t\t\n\t\tif (state != null)\n\t\t{\n\t\t\tif (!this.isVertexIgnored(cell))\n\t\t\t{\n\t\t\t\tvertices.push(state);\n\t\t\t}\n\t\t\telse if (!this.isEdgeIgnored(cell))\n\t\t\t{\n\t\t\t\tedges.push(state);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis.placeLabels(vertices, edges);\n};\n\n/**\n * Function: placeLabels\n * \n * Places the labels of the given edges.\n */\nmxEdgeLabelLayout.prototype.placeLabels = function(v, e)\n{\n\tvar model = this.graph.getModel();\n\t\n\t// Moves the vertices to build a circle. Makes sure the\n\t// radius is large enough for the vertices to not\n\t// overlap\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tfor (var i = 0; i < e.length; i++)\n\t\t{\n\t\t\tvar edge = e[i];\n\t\t\t\n\t\t\tif (edge != null && edge.text != null &&\n\t\t\t\tedge.text.boundingBox != null)\n\t\t\t{\n\t\t\t\tfor (var j = 0; j < v.length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar vertex = v[j];\n\t\t\t\t\t\n\t\t\t\t\tif (vertex != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.avoid(edge, vertex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n};\n\n/**\n * Function: avoid\n * \n * Places the labels of the given edges.\n */\nmxEdgeLabelLayout.prototype.avoid = function(edge, vertex)\n{\n\tvar model = this.graph.getModel();\n\tvar labRect = edge.text.boundingBox;\n\t\n\tif (mxUtils.intersects(labRect, vertex))\n\t{\n\t\tvar dy1 = -labRect.y - labRect.height + vertex.y;\n\t\tvar dy2 = -labRect.y + vertex.y + vertex.height;\n\t\t\n\t\tvar dy = (Math.abs(dy1) < Math.abs(dy2)) ? dy1 : dy2;\n\t\t\n\t\tvar dx1 = -labRect.x - labRect.width + vertex.x;\n\t\tvar dx2 = -labRect.x + vertex.x + vertex.width;\n\t\n\t\tvar dx = (Math.abs(dx1) < Math.abs(dx2)) ? dx1 : dx2;\n\t\t\n\t\tif (Math.abs(dx) < Math.abs(dy))\n\t\t{\n\t\t\tdy = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdx = 0;\n\t\t}\n\t\n\t\tvar g = model.getGeometry(edge.cell);\n\t\t\n\t\tif (g != null)\n\t\t{\n\t\t\tg = g.clone();\n\t\t\t\n\t\t\tif (g.offset != null)\n\t\t\t{\n\t\t\t\tg.offset.x += dx;\n\t\t\t\tg.offset.y += dy;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tg.offset = new mxPoint(dx, dy);\n\t\t\t}\n\t\t\t\n\t\t\tmodel.setGeometry(edge.cell, g);\n\t\t}\n\t}\n};\n\n__mxOutput.mxEdgeLabelLayout = typeof mxEdgeLabelLayout !== 'undefined' ? mxEdgeLabelLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraphAbstractHierarchyCell\n * \n * An abstraction of an internal hierarchy node or edge\n * \n * Constructor: mxGraphAbstractHierarchyCell\n *\n * Constructs a new hierarchical layout algorithm.\n */\nfunction mxGraphAbstractHierarchyCell()\n{\n\tthis.x = [];\n\tthis.y = [];\n\tthis.temp = [];\n};\n\n/**\n * Variable: maxRank\n * \n * The maximum rank this cell occupies. Default is -1.\n */\nmxGraphAbstractHierarchyCell.prototype.maxRank = -1;\n\n/**\n * Variable: minRank\n * \n * The minimum rank this cell occupies. Default is -1.\n */\nmxGraphAbstractHierarchyCell.prototype.minRank = -1;\n\n/**\n * Variable: x\n * \n * The x position of this cell for each layer it occupies\n */\nmxGraphAbstractHierarchyCell.prototype.x = null;\n\n/**\n * Variable: y\n * \n * The y position of this cell for each layer it occupies\n */\nmxGraphAbstractHierarchyCell.prototype.y = null;\n\n/**\n * Variable: width\n * \n * The width of this cell. Default is 0.\n */\nmxGraphAbstractHierarchyCell.prototype.width = 0;\n\n/**\n * Variable: height\n * \n * The height of this cell. Default is 0.\n */\nmxGraphAbstractHierarchyCell.prototype.height = 0;\n\n/**\n * Variable: nextLayerConnectedCells\n * \n * A cached version of the cells this cell connects to on the next layer up\n */\nmxGraphAbstractHierarchyCell.prototype.nextLayerConnectedCells = null;\n\n/**\n * Variable: previousLayerConnectedCells\n * \n * A cached version of the cells this cell connects to on the next layer down\n */\nmxGraphAbstractHierarchyCell.prototype.previousLayerConnectedCells = null;\n\n/**\n * Variable: temp\n * \n * Temporary variable for general use. Generally, try to avoid\n * carrying information between stages. Currently, the longest\n * path layering sets temp to the rank position in fixRanks()\n * and the crossing reduction uses this. This meant temp couldn't\n * be used for hashing the nodes in the model dfs and so hashCode\n * was created\n */\nmxGraphAbstractHierarchyCell.prototype.temp = null;\n\n/**\n * Function: getNextLayerConnectedCells\n * \n * Returns the cells this cell connects to on the next layer up\n */\nmxGraphAbstractHierarchyCell.prototype.getNextLayerConnectedCells = function(layer)\n{\n\treturn null;\n};\n\n/**\n * Function: getPreviousLayerConnectedCells\n * \n * Returns the cells this cell connects to on the next layer down\n */\nmxGraphAbstractHierarchyCell.prototype.getPreviousLayerConnectedCells = function(layer)\n{\n\treturn null;\n};\n\n/**\n * Function: isEdge\n * \n * Returns whether or not this cell is an edge\n */\nmxGraphAbstractHierarchyCell.prototype.isEdge = function()\n{\n\treturn false;\n};\n\n/**\n * Function: isVertex\n * \n * Returns whether or not this cell is a node\n */\nmxGraphAbstractHierarchyCell.prototype.isVertex = function()\n{\n\treturn false;\n};\n\n/**\n * Function: getGeneralPurposeVariable\n * \n * Gets the value of temp for the specified layer\n */\nmxGraphAbstractHierarchyCell.prototype.getGeneralPurposeVariable = function(layer)\n{\n\treturn null;\n};\n\n/**\n * Function: setGeneralPurposeVariable\n * \n * Set the value of temp for the specified layer\n */\nmxGraphAbstractHierarchyCell.prototype.setGeneralPurposeVariable = function(layer, value)\n{\n\treturn null;\n};\n\n/**\n * Function: setX\n * \n * Set the value of x for the specified layer\n */\nmxGraphAbstractHierarchyCell.prototype.setX = function(layer, value)\n{\n\tif (this.isVertex())\n\t{\n\t\tthis.x[0] = value;\n\t}\n\telse if (this.isEdge())\n\t{\n\t\tthis.x[layer - this.minRank - 1] = value;\n\t}\n};\n\n/**\n * Function: getX\n * \n * Gets the value of x on the specified layer\n */\nmxGraphAbstractHierarchyCell.prototype.getX = function(layer)\n{\n\tif (this.isVertex())\n\t{\n\t\treturn this.x[0];\n\t}\n\telse if (this.isEdge())\n\t{\n\t\treturn this.x[layer - this.minRank - 1];\n\t}\n\n\treturn 0.0;\n};\n\n/**\n * Function: setY\n * \n * Set the value of y for the specified layer\n */\nmxGraphAbstractHierarchyCell.prototype.setY = function(layer, value)\n{\n\tif (this.isVertex())\n\t{\n\t\tthis.y[0] = value;\n\t}\n\telse if (this.isEdge())\n\t{\n\t\tthis.y[layer -this. minRank - 1] = value;\n\t}\n};\n\n__mxOutput.mxGraphAbstractHierarchyCell = typeof mxGraphAbstractHierarchyCell !== 'undefined' ? mxGraphAbstractHierarchyCell : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraphHierarchyNode\n * \n * An abstraction of a hierarchical edge for the hierarchy layout\n * \n * Constructor: mxGraphHierarchyNode\n *\n * Constructs an internal node to represent the specified real graph cell\n *\n * Arguments:\n * \n * cell - the real graph cell this node represents\n */\nfunction mxGraphHierarchyNode(cell)\n{\n\tmxGraphAbstractHierarchyCell.apply(this, arguments);\n\tthis.cell = cell;\n\tthis.id = mxObjectIdentity.get(cell);\n\tthis.connectsAsTarget = [];\n\tthis.connectsAsSource = [];\n};\n\n/**\n * Extends mxGraphAbstractHierarchyCell.\n */\nmxGraphHierarchyNode.prototype = new mxGraphAbstractHierarchyCell();\nmxGraphHierarchyNode.prototype.constructor = mxGraphHierarchyNode;\n\n/**\n * Variable: cell\n * \n * The graph cell this object represents.\n */\nmxGraphHierarchyNode.prototype.cell = null;\n\n/**\n * Variable: id\n * \n * The object identity of the wrapped cell\n */\nmxGraphHierarchyNode.prototype.id = null;\n\n/**\n * Variable: connectsAsTarget\n * \n * Collection of hierarchy edges that have this node as a target\n */\nmxGraphHierarchyNode.prototype.connectsAsTarget = null;\n\n/**\n * Variable: connectsAsSource\n * \n * Collection of hierarchy edges that have this node as a source\n */\nmxGraphHierarchyNode.prototype.connectsAsSource = null;\n\n/**\n * Variable: hashCode\n * \n * Assigns a unique hashcode for each node. Used by the model dfs instead\n * of copying HashSets\n */\nmxGraphHierarchyNode.prototype.hashCode = false;\n\n/**\n * Function: getRankValue\n * \n * Returns the integer value of the layer that this node resides in\n */\nmxGraphHierarchyNode.prototype.getRankValue = function(layer)\n{\n\treturn this.maxRank;\n};\n\n/**\n * Function: getNextLayerConnectedCells\n * \n * Returns the cells this cell connects to on the next layer up\n */\nmxGraphHierarchyNode.prototype.getNextLayerConnectedCells = function(layer)\n{\n\tif (this.nextLayerConnectedCells == null)\n\t{\n\t\tthis.nextLayerConnectedCells = [];\n\t\tthis.nextLayerConnectedCells[0] = [];\n\t\t\n\t\tfor (var i = 0; i < this.connectsAsTarget.length; i++)\n\t\t{\n\t\t\tvar edge = this.connectsAsTarget[i];\n\n\t\t\tif (edge.maxRank == -1 || edge.maxRank == layer + 1)\n\t\t\t{\n\t\t\t\t// Either edge is not in any rank or\n\t\t\t\t// no dummy nodes in edge, add node of other side of edge\n\t\t\t\tthis.nextLayerConnectedCells[0].push(edge.source);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Edge spans at least two layers, add edge\n\t\t\t\tthis.nextLayerConnectedCells[0].push(edge);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this.nextLayerConnectedCells[0];\n};\n\n/**\n * Function: getPreviousLayerConnectedCells\n * \n * Returns the cells this cell connects to on the next layer down\n */\nmxGraphHierarchyNode.prototype.getPreviousLayerConnectedCells = function(layer)\n{\n\tif (this.previousLayerConnectedCells == null)\n\t{\n\t\tthis.previousLayerConnectedCells = [];\n\t\tthis.previousLayerConnectedCells[0] = [];\n\t\t\n\t\tfor (var i = 0; i < this.connectsAsSource.length; i++)\n\t\t{\n\t\t\tvar edge = this.connectsAsSource[i];\n\n\t\t\tif (edge.minRank == -1 || edge.minRank == layer - 1)\n\t\t\t{\n\t\t\t\t// No dummy nodes in edge, add node of other side of edge\n\t\t\t\tthis.previousLayerConnectedCells[0].push(edge.target);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Edge spans at least two layers, add edge\n\t\t\t\tthis.previousLayerConnectedCells[0].push(edge);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this.previousLayerConnectedCells[0];\n};\n\n/**\n * Function: isVertex\n * \n * Returns true.\n */\nmxGraphHierarchyNode.prototype.isVertex = function()\n{\n\treturn true;\n};\n\n/**\n * Function: getGeneralPurposeVariable\n * \n * Gets the value of temp for the specified layer\n */\nmxGraphHierarchyNode.prototype.getGeneralPurposeVariable = function(layer)\n{\n\treturn this.temp[0];\n};\n\n/**\n * Function: setGeneralPurposeVariable\n * \n * Set the value of temp for the specified layer\n */\nmxGraphHierarchyNode.prototype.setGeneralPurposeVariable = function(layer, value)\n{\n\tthis.temp[0] = value;\n};\n\n/**\n * Function: isAncestor\n */\nmxGraphHierarchyNode.prototype.isAncestor = function(otherNode)\n{\n\t// Firstly, the hash code of this node needs to be shorter than the\n\t// other node\n\tif (otherNode != null && this.hashCode != null && otherNode.hashCode != null\n\t\t\t&& this.hashCode.length < otherNode.hashCode.length)\n\t{\n\t\tif (this.hashCode == otherNode.hashCode)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (this.hashCode == null || this.hashCode == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t// Secondly, this hash code must match the start of the other\n\t\t// node's hash code. Arrays.equals cannot be used here since\n\t\t// the arrays are different length, and we do not want to\n\t\t// perform another array copy.\n\t\tfor (var i = 0; i < this.hashCode.length; i++)\n\t\t{\n\t\t\tif (this.hashCode[i] != otherNode.hashCode[i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: getCoreCell\n * \n * Gets the core vertex associated with this wrapper\n */\nmxGraphHierarchyNode.prototype.getCoreCell = function()\n{\n\treturn this.cell;\n};\n\n__mxOutput.mxGraphHierarchyNode = typeof mxGraphHierarchyNode !== 'undefined' ? mxGraphHierarchyNode : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraphHierarchyEdge\n * \n * An abstraction of a hierarchical edge for the hierarchy layout\n * \n * Constructor: mxGraphHierarchyEdge\n *\n * Constructs a hierarchy edge\n *\n * Arguments:\n * \n * edges - a list of real graph edges this abstraction represents\n */\nfunction mxGraphHierarchyEdge(edges)\n{\n\tmxGraphAbstractHierarchyCell.apply(this, arguments);\n\tthis.edges = edges;\n\tthis.ids = [];\n\t\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tthis.ids.push(mxObjectIdentity.get(edges[i]));\n\t}\n};\n\n/**\n * Extends mxGraphAbstractHierarchyCell.\n */\nmxGraphHierarchyEdge.prototype = new mxGraphAbstractHierarchyCell();\nmxGraphHierarchyEdge.prototype.constructor = mxGraphHierarchyEdge;\n\n/**\n * Variable: edges\n * \n * The graph edge(s) this object represents. Parallel edges are all grouped\n * together within one hierarchy edge.\n */\nmxGraphHierarchyEdge.prototype.edges = null;\n\n/**\n * Variable: ids\n * \n * The object identities of the wrapped cells\n */\nmxGraphHierarchyEdge.prototype.ids = null;\n\n/**\n * Variable: source\n * \n * The node this edge is sourced at\n */\nmxGraphHierarchyEdge.prototype.source = null;\n\n/**\n * Variable: target\n * \n * The node this edge targets\n */\nmxGraphHierarchyEdge.prototype.target = null;\n\n/**\n * Variable: isReversed\n * \n * Whether or not the direction of this edge has been reversed\n * internally to create a DAG for the hierarchical layout\n */\nmxGraphHierarchyEdge.prototype.isReversed = false;\n\n/**\n * Function: invert\n * \n * Inverts the direction of this internal edge(s)\n */\nmxGraphHierarchyEdge.prototype.invert = function(layer)\n{\n\tvar temp = this.source;\n\tthis.source = this.target;\n\tthis.target = temp;\n\tthis.isReversed = !this.isReversed;\n};\n\n/**\n * Function: getNextLayerConnectedCells\n * \n * Returns the cells this cell connects to on the next layer up\n */\nmxGraphHierarchyEdge.prototype.getNextLayerConnectedCells = function(layer)\n{\n\tif (this.nextLayerConnectedCells == null)\n\t{\n\t\tthis.nextLayerConnectedCells = [];\n\t\t\n\t\tfor (var i = 0; i < this.temp.length; i++)\n\t\t{\n\t\t\tthis.nextLayerConnectedCells[i] = [];\n\t\t\t\n\t\t\tif (i == this.temp.length - 1)\n\t\t\t{\n\t\t\t\tthis.nextLayerConnectedCells[i].push(this.source);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.nextLayerConnectedCells[i].push(this);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this.nextLayerConnectedCells[layer - this.minRank - 1];\n};\n\n/**\n * Function: getPreviousLayerConnectedCells\n * \n * Returns the cells this cell connects to on the next layer down\n */\nmxGraphHierarchyEdge.prototype.getPreviousLayerConnectedCells = function(layer)\n{\n\tif (this.previousLayerConnectedCells == null)\n\t{\n\t\tthis.previousLayerConnectedCells = [];\n\n\t\tfor (var i = 0; i < this.temp.length; i++)\n\t\t{\n\t\t\tthis.previousLayerConnectedCells[i] = [];\n\t\t\t\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t\tthis.previousLayerConnectedCells[i].push(this.target);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.previousLayerConnectedCells[i].push(this);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this.previousLayerConnectedCells[layer - this.minRank - 1];\n};\n\n/**\n * Function: isEdge\n * \n * Returns true.\n */\nmxGraphHierarchyEdge.prototype.isEdge = function()\n{\n\treturn true;\n};\n\n/**\n * Function: getGeneralPurposeVariable\n * \n * Gets the value of temp for the specified layer\n */\nmxGraphHierarchyEdge.prototype.getGeneralPurposeVariable = function(layer)\n{\n\treturn this.temp[layer - this.minRank - 1];\n};\n\n/**\n * Function: setGeneralPurposeVariable\n * \n * Set the value of temp for the specified layer\n */\nmxGraphHierarchyEdge.prototype.setGeneralPurposeVariable = function(layer, value)\n{\n\tthis.temp[layer - this.minRank - 1] = value;\n};\n\n/**\n * Function: getCoreCell\n * \n * Gets the first core edge associated with this wrapper\n */\nmxGraphHierarchyEdge.prototype.getCoreCell = function()\n{\n\tif (this.edges != null && this.edges.length > 0)\n\t{\n\t\treturn this.edges[0];\n\t}\n\t\n\treturn null;\n};\n\n__mxOutput.mxGraphHierarchyEdge = typeof mxGraphHierarchyEdge !== 'undefined' ? mxGraphHierarchyEdge : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraphHierarchyModel\n *\n * Internal model of a hierarchical graph. This model stores nodes and edges\n * equivalent to the real graph nodes and edges, but also stores the rank of the\n * cells, the order within the ranks and the new candidate locations of cells.\n * The internal model also reverses edge direction were appropriate , ignores\n * self-loop and groups parallels together under one edge object.\n *\n * Constructor: mxGraphHierarchyModel\n *\n * Creates an internal ordered graph model using the vertices passed in. If\n * there are any, leftward edge need to be inverted in the internal model\n *\n * Arguments:\n *\n * graph - the facade describing the graph to be operated on\n * vertices - the vertices for this hierarchy\n * ordered - whether or not the vertices are already ordered\n * deterministic - whether or not this layout should be deterministic on each\n * tightenToSource - whether or not to tighten vertices towards the sources\n * scanRanksFromSinks - Whether rank assignment is from the sinks or sources.\n * usage\n */\nfunction mxGraphHierarchyModel(layout, vertices, roots, parent, tightenToSource)\n{\n\tvar graph = layout.getGraph();\n\tthis.tightenToSource = tightenToSource;\n\tthis.roots = roots;\n\tthis.parent = parent;\n\n\t// map of cells to internal cell needed for second run through\n\t// to setup the sink of edges correctly\n\tthis.vertexMapper = new mxDictionary();\n\tthis.edgeMapper = new mxDictionary();\n\tthis.maxRank = 0;\n\tvar internalVertices = [];\n\n\tif (vertices == null)\n\t{\n\t\tvertices = this.graph.getChildVertices(parent);\n\t}\n\n\tthis.maxRank = this.SOURCESCANSTARTRANK;\n\t// map of cells to internal cell needed for second run through\n\t// to setup the sink of edges correctly. Guess size by number\n\t// of edges is roughly same as number of vertices.\n\tthis.createInternalCells(layout, vertices, internalVertices);\n\n\t// Go through edges set their sink values. Also check the\n\t// ordering if and invert edges if necessary\n\tfor (var i = 0; i < vertices.length; i++)\n\t{\n\t\tvar edges = internalVertices[i].connectsAsSource;\n\n\t\tfor (var j = 0; j < edges.length; j++)\n\t\t{\n\t\t\tvar internalEdge = edges[j];\n\t\t\tvar realEdges = internalEdge.edges;\n\n\t\t\t// Only need to process the first real edge, since\n\t\t\t// all the edges connect to the same other vertex\n\t\t\tif (realEdges != null && realEdges.length > 0)\n\t\t\t{\n\t\t\t\tvar realEdge = realEdges[0];\n\t\t\t\tvar targetCell = layout.getVisibleTerminal(\n\t\t\t\t\t\trealEdge, false);\n\t\t\t\tvar internalTargetCell = this.vertexMapper.get(targetCell);\n\n\t\t\t\tif (internalVertices[i] == internalTargetCell)\n\t\t\t\t{\n\t\t\t\t\t// If there are parallel edges going between two vertices and not all are in the same direction\n\t\t\t\t\t// you can have navigated across one direction when doing the cycle reversal that isn't the same\n\t\t\t\t\t// direction as the first real edge in the array above. When that happens the if above catches\n\t\t\t\t\t// that and we correct the target cell before continuing.\n\t\t\t\t\t// This branch only detects this single case\n\t\t\t\t\ttargetCell = layout.getVisibleTerminal(\n\t\t\t\t\t\t\trealEdge, true);\n\t\t\t\t\tinternalTargetCell = this.vertexMapper.get(targetCell);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (internalTargetCell != null\n\t\t\t\t\t\t&& internalVertices[i] != internalTargetCell)\n\t\t\t\t{\n\t\t\t\t\tinternalEdge.target = internalTargetCell;\n\n\t\t\t\t\tif (internalTargetCell.connectsAsTarget.length == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tinternalTargetCell.connectsAsTarget = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mxUtils.indexOf(internalTargetCell.connectsAsTarget, internalEdge) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tinternalTargetCell.connectsAsTarget.push(internalEdge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Use the temp variable in the internal nodes to mark this\n\t\t// internal vertex as having been visited.\n\t\tinternalVertices[i].temp[0] = 1;\n\t}\n};\n\n/**\n * Variable: maxRank\n *\n * Stores the largest rank number allocated\n */\nmxGraphHierarchyModel.prototype.maxRank = null;\n\n/**\n * Variable: vertexMapper\n *\n * Map from graph vertices to internal model nodes.\n */\nmxGraphHierarchyModel.prototype.vertexMapper = null;\n\n/**\n * Variable: edgeMapper\n *\n * Map from graph edges to internal model edges\n */\nmxGraphHierarchyModel.prototype.edgeMapper = null;\n\n/**\n * Variable: ranks\n *\n * Mapping from rank number to actual rank\n */\nmxGraphHierarchyModel.prototype.ranks = null;\n\n/**\n * Variable: roots\n *\n * Store of roots of this hierarchy model, these are real graph cells, not\n * internal cells\n */\nmxGraphHierarchyModel.prototype.roots = null;\n\n/**\n * Variable: parent\n *\n * The parent cell whose children are being laid out\n */\nmxGraphHierarchyModel.prototype.parent = null;\n\n/**\n * Variable: dfsCount\n *\n * Count of the number of times the ancestor dfs has been used.\n */\nmxGraphHierarchyModel.prototype.dfsCount = 0;\n\n/**\n * Variable: SOURCESCANSTARTRANK\n *\n * High value to start source layering scan rank value from.\n */\nmxGraphHierarchyModel.prototype.SOURCESCANSTARTRANK = 100000000;\n\n/**\n * Variable: tightenToSource\n *\n * Whether or not to tighten the assigned ranks of vertices up towards\n * the source cells.\n */\nmxGraphHierarchyModel.prototype.tightenToSource = false;\n\n/**\n * Function: createInternalCells\n *\n * Creates all edges in the internal model\n *\n * Parameters:\n *\n * layout - Reference to the <mxHierarchicalLayout> algorithm.\n * vertices - Array of <mxCells> that represent the vertices whom are to\n * have an internal representation created.\n * internalVertices - The array of <mxGraphHierarchyNodes> to have their\n * information filled in using the real vertices.\n */\nmxGraphHierarchyModel.prototype.createInternalCells = function(layout, vertices, internalVertices)\n{\n\tvar graph = layout.getGraph();\n\n\t// Create internal edges\n\tfor (var i = 0; i < vertices.length; i++)\n\t{\n\t\tinternalVertices[i] = new mxGraphHierarchyNode(vertices[i]);\n\t\tthis.vertexMapper.put(vertices[i], internalVertices[i]);\n\n\t\t// If the layout is deterministic, order the cells\n\t\t//List outgoingCells = graph.getNeighbours(vertices[i], deterministic);\n\t\tvar conns = layout.getEdges(vertices[i]);\n\t\tinternalVertices[i].connectsAsSource = [];\n\n\t\t// Create internal edges, but don't do any rank assignment yet\n\t\t// First use the information from the greedy cycle remover to\n\t\t// invert the leftward edges internally\n\t\tfor (var j = 0; j < conns.length; j++)\n\t\t{\n\t\t\tvar cell = layout.getVisibleTerminal(conns[j], false);\n\n\t\t\t// Looking for outgoing edges only\n\t\t\tif (cell != vertices[i] && layout.graph.model.isVertex(cell) &&\n\t\t\t\t\t!layout.isVertexIgnored(cell))\n\t\t\t{\n\t\t\t\t// We process all edge between this source and its targets\n\t\t\t\t// If there are edges going both ways, we need to collect\n\t\t\t\t// them all into one internal edges to avoid looping problems\n\t\t\t\t// later. We assume this direction (source -> target) is the \n\t\t\t\t// natural direction if at least half the edges are going in\n\t\t\t\t// that direction.\n\n\t\t\t\t// The check below for edges[0] being in the vertex mapper is\n\t\t\t\t// in case we've processed this the other way around\n\t\t\t\t// (target -> source) and the number of edges in each direction\n\t\t\t\t// are the same. All the graph edges will have been assigned to\n\t\t\t\t// an internal edge going the other way, so we don't want to \n\t\t\t\t// process them again\n\t\t\t\tvar undirectedEdges = layout.getEdgesBetween(vertices[i],\n\t\t\t\t\t\tcell, false);\n\t\t\t\tvar directedEdges = layout.getEdgesBetween(vertices[i],\n\t\t\t\t\t\tcell, true);\n\t\t\t\t\n\t\t\t\tif (undirectedEdges != null &&\n\t\t\t\t\t\tundirectedEdges.length > 0 &&\n\t\t\t\t\t\tthis.edgeMapper.get(undirectedEdges[0]) == null &&\n\t\t\t\t\t\tdirectedEdges.length * 2 >= undirectedEdges.length)\n\t\t\t\t{\n\t\t\t\t\tvar internalEdge = new mxGraphHierarchyEdge(undirectedEdges);\n\n\t\t\t\t\tfor (var k = 0; k < undirectedEdges.length; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar edge = undirectedEdges[k];\n\t\t\t\t\t\tthis.edgeMapper.put(edge, internalEdge);\n\n\t\t\t\t\t\t// Resets all point on the edge and disables the edge style\n\t\t\t\t\t\t// without deleting it from the cell style\n\t\t\t\t\t\tgraph.resetEdge(edge);\n\n\t\t\t\t\t    if (layout.disableEdgeStyle)\n\t\t\t\t\t    {\n\t\t\t\t\t    \tlayout.setEdgeStyleEnabled(edge, false);\n\t\t\t\t\t    \tlayout.setOrthogonalEdge(edge,true);\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\n\t\t\t\t\tinternalEdge.source = internalVertices[i];\n\n\t\t\t\t\tif (mxUtils.indexOf(internalVertices[i].connectsAsSource, internalEdge) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tinternalVertices[i].connectsAsSource.push(internalEdge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Ensure temp variable is cleared from any previous use\n\t\tinternalVertices[i].temp[0] = 0;\n\t}\n};\n\n/**\n * Function: initialRank\n *\n * Basic determination of minimum layer ranking by working from from sources\n * or sinks and working through each node in the relevant edge direction.\n * Starting at the sinks is basically a longest path layering algorithm.\n*/\nmxGraphHierarchyModel.prototype.initialRank = function()\n{\n\tvar startNodes = [];\n\n\tif (this.roots != null)\n\t{\n\t\tfor (var i = 0; i < this.roots.length; i++)\n\t\t{\n\t\t\tvar internalNode = this.vertexMapper.get(this.roots[i]);\n\n\t\t\tif (internalNode != null)\n\t\t\t{\n\t\t\t\tstartNodes.push(internalNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar internalNodes = this.vertexMapper.getValues();\n\t\n\tfor (var i=0; i < internalNodes.length; i++)\n\t{\n\t\t// Mark the node as not having had a layer assigned\n\t\tinternalNodes[i].temp[0] = -1;\n\t}\n\n\tvar startNodesCopy = startNodes.slice();\n\n\twhile (startNodes.length > 0)\n\t{\n\t\tvar internalNode = startNodes[0];\n\t\tvar layerDeterminingEdges;\n\t\tvar edgesToBeMarked;\n\n\t\tlayerDeterminingEdges = internalNode.connectsAsTarget;\n\t\tedgesToBeMarked = internalNode.connectsAsSource;\n\n\t\t// flag to keep track of whether or not all layer determining\n\t\t// edges have been scanned\n\t\tvar allEdgesScanned = true;\n\n\t\t// Work out the layer of this node from the layer determining\n\t\t// edges. The minimum layer number of any node connected by one of\n\t\t// the layer determining edges variable\n\t\tvar minimumLayer = this.SOURCESCANSTARTRANK;\n\n\t\tfor (var i = 0; i < layerDeterminingEdges.length; i++)\n\t\t{\n\t\t\tvar internalEdge = layerDeterminingEdges[i];\n\n\t\t\tif (internalEdge.temp[0] == 5270620)\n\t\t\t{\n\t\t\t\t// This edge has been scanned, get the layer of the\n\t\t\t\t// node on the other end\n\t\t\t\tvar otherNode = internalEdge.source;\n\t\t\t\tminimumLayer = Math.min(minimumLayer, otherNode.temp[0] - 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tallEdgesScanned = false;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If all edge have been scanned, assign the layer, mark all\n\t\t// edges in the other direction and remove from the nodes list\n\t\tif (allEdgesScanned)\n\t\t{\n\t\t\tinternalNode.temp[0] = minimumLayer;\n\t\t\tthis.maxRank = Math.min(this.maxRank, minimumLayer);\n\n\t\t\tif (edgesToBeMarked != null)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < edgesToBeMarked.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar internalEdge = edgesToBeMarked[i];\n\n\t\t\t\t\t// Assign unique stamp ( y/m/d/h )\n\t\t\t\t\tinternalEdge.temp[0] = 5270620;\n\n\t\t\t\t\t// Add node on other end of edge to LinkedList of\n\t\t\t\t\t// nodes to be analysed\n\t\t\t\t\tvar otherNode = internalEdge.target;\n\n\t\t\t\t\t// Only add node if it hasn't been assigned a layer\n\t\t\t\t\tif (otherNode.temp[0] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartNodes.push(otherNode);\n\n\t\t\t\t\t\t// Mark this other node as neither being\n\t\t\t\t\t\t// unassigned nor assigned so it isn't\n\t\t\t\t\t\t// added to this list again, but it's\n\t\t\t\t\t\t// layer isn't used in any calculation.\n\t\t\t\t\t\totherNode.temp[0] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstartNodes.shift();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Not all the edges have been scanned, get to the back of\n\t\t\t// the class and put the dunces cap on\n\t\t\tvar removedCell = startNodes.shift();\n\t\t\tstartNodes.push(internalNode);\n\n\t\t\tif (removedCell == internalNode && startNodes.length == 1)\n\t\t\t{\n\t\t\t\t// This is an error condition, we can't get out of\n\t\t\t\t// this loop. It could happen for more than one node\n\t\t\t\t// but that's a lot harder to detect. Log the error\n\t\t\t\t// TODO make log comment\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize the ranks down from their large starting value to place\n\t// at least 1 sink on layer 0\n\tfor (var i=0; i < internalNodes.length; i++)\n\t{\n\t\t// Mark the node as not having had a layer assigned\n\t\tinternalNodes[i].temp[0] -= this.maxRank;\n\t}\n\t\n\t// Tighten the rank 0 nodes as far as possible\n\tfor ( var i = 0; i < startNodesCopy.length; i++)\n\t{\n\t\tvar internalNode = startNodesCopy[i];\n\t\tvar currentMaxLayer = 0;\n\t\tvar layerDeterminingEdges = internalNode.connectsAsSource;\n\n\t\tfor ( var j = 0; j < layerDeterminingEdges.length; j++)\n\t\t{\n\t\t\tvar internalEdge = layerDeterminingEdges[j];\n\t\t\tvar otherNode = internalEdge.target;\n\t\t\tinternalNode.temp[0] = Math.max(currentMaxLayer,\n\t\t\t\t\totherNode.temp[0] + 1);\n\t\t\tcurrentMaxLayer = internalNode.temp[0];\n\t\t}\n\t}\n\t\n\t// Reset the maxRank to that which would be expected for a from-sink\n\t// scan\n\tthis.maxRank = this.SOURCESCANSTARTRANK - this.maxRank;\n};\n\n/**\n * Function: fixRanks\n *\n * Fixes the layer assignments to the values stored in the nodes. Also needs\n * to create dummy nodes for edges that cross layers.\n */\nmxGraphHierarchyModel.prototype.fixRanks = function()\n{\n\tvar rankList = [];\n\tthis.ranks = [];\n\n\tfor (var i = 0; i < this.maxRank + 1; i++)\n\t{\n\t\trankList[i] = [];\n\t\tthis.ranks[i] = rankList[i];\n\t}\n\n\t// Perform a DFS to obtain an initial ordering for each rank.\n\t// Without doing this you would end up having to process\n\t// crossings for a standard tree.\n\tvar rootsArray = null;\n\n\tif (this.roots != null)\n\t{\n\t\tvar oldRootsArray = this.roots;\n\t\trootsArray = [];\n\n\t\tfor (var i = 0; i < oldRootsArray.length; i++)\n\t\t{\n\t\t\tvar cell = oldRootsArray[i];\n\t\t\tvar internalNode = this.vertexMapper.get(cell);\n\t\t\trootsArray[i] = internalNode;\n\t\t}\n\t}\n\n\tthis.visit(function(parent, node, edge, layer, seen)\n\t{\n\t\tif (seen == 0 && node.maxRank < 0 && node.minRank < 0)\n\t\t{\n\t\t\trankList[node.temp[0]].push(node);\n\t\t\tnode.maxRank = node.temp[0];\n\t\t\tnode.minRank = node.temp[0];\n\n\t\t\t// Set temp[0] to the nodes position in the rank\n\t\t\tnode.temp[0] = rankList[node.maxRank].length - 1;\n\t\t}\n\n\t\tif (parent != null && edge != null)\n\t\t{\n\t\t\tvar parentToCellRankDifference = parent.maxRank - node.maxRank;\n\n\t\t\tif (parentToCellRankDifference > 1)\n\t\t\t{\n\t\t\t\t// There are ranks in between the parent and current cell\n\t\t\t\tedge.maxRank = parent.maxRank;\n\t\t\t\tedge.minRank = node.maxRank;\n\t\t\t\tedge.temp = [];\n\t\t\t\tedge.x = [];\n\t\t\t\tedge.y = [];\n\n\t\t\t\tfor (var i = edge.minRank + 1; i < edge.maxRank; i++)\n\t\t\t\t{\n\t\t\t\t\t// The connecting edge must be added to the\n\t\t\t\t\t// appropriate ranks\n\t\t\t\t\trankList[i].push(edge);\n\t\t\t\t\tedge.setGeneralPurposeVariable(i, rankList[i]\n\t\t\t\t\t\t\t.length - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, rootsArray, false, null);\n};\n\n/**\n * Function: visit\n *\n * A depth first search through the internal heirarchy model.\n *\n * Parameters:\n *\n * visitor - The visitor function pattern to be called for each node.\n * trackAncestors - Whether or not the search is to keep track all nodes\n * directly above this one in the search path.\n */\nmxGraphHierarchyModel.prototype.visit = function(visitor, dfsRoots, trackAncestors, seenNodes)\n{\n\t// Run dfs through on all roots\n\tif (dfsRoots != null)\n\t{\n\t\tfor (var i = 0; i < dfsRoots.length; i++)\n\t\t{\n\t\t\tvar internalNode = dfsRoots[i];\n\n\t\t\tif (internalNode != null)\n\t\t\t{\n\t\t\t\tif (seenNodes == null)\n\t\t\t\t{\n\t\t\t\t\tseenNodes = new Object();\n\t\t\t\t}\n\n\t\t\t\tif (trackAncestors)\n\t\t\t\t{\n\t\t\t\t\t// Set up hash code for root\n\t\t\t\t\tinternalNode.hashCode = [];\n\t\t\t\t\tinternalNode.hashCode[0] = this.dfsCount;\n\t\t\t\t\tinternalNode.hashCode[1] = i;\n\t\t\t\t\tthis.extendedDfs(null, internalNode, null, visitor, seenNodes,\n\t\t\t\t\t\t\tinternalNode.hashCode, i, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.dfs(null, internalNode, null, visitor, seenNodes, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.dfsCount++;\n\t}\n};\n\n/**\n * Function: dfs\n *\n * Performs a depth first search on the internal hierarchy model\n *\n * Parameters:\n *\n * parent - the parent internal node of the current internal node\n * root - the current internal node\n * connectingEdge - the internal edge connecting the internal node and the parent\n * internal node, if any\n * visitor - the visitor pattern to be called for each node\n * seen - a set of all nodes seen by this dfs a set of all of the\n * ancestor node of the current node\n * layer - the layer on the dfs tree ( not the same as the model ranks )\n */\nmxGraphHierarchyModel.prototype.dfs = function(parent, root, connectingEdge, visitor, seen, layer)\n{\n\tif (root != null)\n\t{\n\t\tvar rootId = root.id;\n\n\t\tif (seen[rootId] == null)\n\t\t{\n\t\t\tseen[rootId] = root;\n\t\t\tvisitor(parent, root, connectingEdge, layer, 0);\n\n\t\t\t// Copy the connects as source list so that visitors\n\t\t\t// can change the original for edge direction inversions\n\t\t\tvar outgoingEdges = root.connectsAsSource.slice();\n\t\t\t\n\t\t\tfor (var i = 0; i< outgoingEdges.length; i++)\n\t\t\t{\n\t\t\t\tvar internalEdge = outgoingEdges[i];\n\t\t\t\tvar targetNode = internalEdge.target;\n\n\t\t\t\t// Root check is O(|roots|)\n\t\t\t\tthis.dfs(root, targetNode, internalEdge, visitor, seen,\n\t\t\t\t\t\tlayer + 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Use the int field to indicate this node has been seen\n\t\t\tvisitor(parent, root, connectingEdge, layer, 1);\n\t\t}\n\t}\n};\n\n/**\n * Function: extendedDfs\n *\n * Performs a depth first search on the internal hierarchy model. This dfs\n * extends the default version by keeping track of cells ancestors, but it\n * should be only used when necessary because of it can be computationally\n * intensive for deep searches.\n *\n * Parameters:\n *\n * parent - the parent internal node of the current internal node\n * root - the current internal node\n * connectingEdge - the internal edge connecting the internal node and the parent\n * internal node, if any\n * visitor - the visitor pattern to be called for each node\n * seen - a set of all nodes seen by this dfs\n * ancestors - the parent hash code\n * childHash - the new hash code for this node\n * layer - the layer on the dfs tree ( not the same as the model ranks )\n */\nmxGraphHierarchyModel.prototype.extendedDfs = function(parent, root, connectingEdge, visitor, seen, ancestors, childHash, layer)\n{\n\t// Explanation of custom hash set. Previously, the ancestors variable\n\t// was passed through the dfs as a HashSet. The ancestors were copied\n\t// into a new HashSet and when the new child was processed it was also\n\t// added to the set. If the current node was in its ancestor list it\n\t// meant there is a cycle in the graph and this information is passed\n\t// to the visitor.visit() in the seen parameter. The HashSet clone was\n\t// very expensive on CPU so a custom hash was developed using primitive\n\t// types. temp[] couldn't be used so hashCode[] was added to each node.\n\t// Each new child adds another int to the array, copying the prefix\n\t// from its parent. Child of the same parent add different ints (the\n\t// limit is therefore 2^32 children per parent...). If a node has a\n\t// child with the hashCode already set then the child code is compared\n\t// to the same portion of the current nodes array. If they match there\n\t// is a loop.\n\t// Note that the basic mechanism would only allow for 1 use of this\n\t// functionality, so the root nodes have two ints. The second int is\n\t// incremented through each node root and the first is incremented\n\t// through each run of the dfs algorithm (therefore the dfs is not\n\t// thread safe). The hash code of each node is set if not already set,\n\t// or if the first int does not match that of the current run.\n\tif (root != null)\n\t{\n\t\tif (parent != null)\n\t\t{\n\t\t\t// Form this nodes hash code if necessary, that is, if the\n\t\t\t// hashCode variable has not been initialized or if the\n\t\t\t// start of the parent hash code does not equal the start of\n\t\t\t// this nodes hash code, indicating the code was set on a\n\t\t\t// previous run of this dfs.\n\t\t\tif (root.hashCode == null ||\n\t\t\t\troot.hashCode[0] != parent.hashCode[0])\n\t\t\t{\n\t\t\t\tvar hashCodeLength = parent.hashCode.length + 1;\n\t\t\t\troot.hashCode = parent.hashCode.slice();\n\t\t\t\troot.hashCode[hashCodeLength - 1] = childHash;\n\t\t\t}\n\t\t}\n\n\t\tvar rootId = root.id;\n\n\t\tif (seen[rootId] == null)\n\t\t{\n\t\t\tseen[rootId] = root;\n\t\t\tvisitor(parent, root, connectingEdge, layer, 0);\n\n\t\t\t// Copy the connects as source list so that visitors\n\t\t\t// can change the original for edge direction inversions\n\t\t\tvar outgoingEdges = root.connectsAsSource.slice();\n\n\t\t\tfor (var i = 0; i < outgoingEdges.length; i++)\n\t\t\t{\n\t\t\t\tvar internalEdge = outgoingEdges[i];\n\t\t\t\tvar targetNode = internalEdge.target;\n\n\t\t\t\t// Root check is O(|roots|)\n\t\t\t\tthis.extendedDfs(root, targetNode, internalEdge, visitor, seen,\n\t\t\t\t\t\troot.hashCode, i, layer + 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Use the int field to indicate this node has been seen\n\t\t\tvisitor(parent, root, connectingEdge, layer, 1);\n\t\t}\n\t}\n};\n\n__mxOutput.mxGraphHierarchyModel = typeof mxGraphHierarchyModel !== 'undefined' ? mxGraphHierarchyModel : undefined;\n\n/**\n * Copyright (c) 2006-2018, JGraph Ltd\n * Copyright (c) 2006-2018, Gaudenz Alder\n */\n/**\n * Class: mxSwimlaneModel\n *\n * Internal model of a hierarchical graph. This model stores nodes and edges\n * equivalent to the real graph nodes and edges, but also stores the rank of the\n * cells, the order within the ranks and the new candidate locations of cells.\n * The internal model also reverses edge direction were appropriate , ignores\n * self-loop and groups parallels together under one edge object.\n *\n * Constructor: mxSwimlaneModel\n *\n * Creates an internal ordered graph model using the vertices passed in. If\n * there are any, leftward edge need to be inverted in the internal model\n *\n * Arguments:\n *\n * graph - the facade describing the graph to be operated on\n * vertices - the vertices for this hierarchy\n * ordered - whether or not the vertices are already ordered\n * deterministic - whether or not this layout should be deterministic on each\n * tightenToSource - whether or not to tighten vertices towards the sources\n * scanRanksFromSinks - Whether rank assignment is from the sinks or sources.\n * usage\n */\nfunction mxSwimlaneModel(layout, vertices, roots, parent, tightenToSource)\n{\n\tvar graph = layout.getGraph();\n\tthis.tightenToSource = tightenToSource;\n\tthis.roots = roots;\n\tthis.parent = parent;\n\n\t// map of cells to internal cell needed for second run through\n\t// to setup the sink of edges correctly\n\tthis.vertexMapper = new mxDictionary();\n\tthis.edgeMapper = new mxDictionary();\n\tthis.maxRank = 0;\n\tvar internalVertices = [];\n\n\tif (vertices == null)\n\t{\n\t\tvertices = this.graph.getChildVertices(parent);\n\t}\n\n\tthis.maxRank = this.SOURCESCANSTARTRANK;\n\t// map of cells to internal cell needed for second run through\n\t// to setup the sink of edges correctly. Guess size by number\n\t// of edges is roughly same as number of vertices.\n\tthis.createInternalCells(layout, vertices, internalVertices);\n\n\t// Go through edges set their sink values. Also check the\n\t// ordering if and invert edges if necessary\n\tfor (var i = 0; i < vertices.length; i++)\n\t{\n\t\tvar edges = internalVertices[i].connectsAsSource;\n\n\t\tfor (var j = 0; j < edges.length; j++)\n\t\t{\n\t\t\tvar internalEdge = edges[j];\n\t\t\tvar realEdges = internalEdge.edges;\n\n\t\t\t// Only need to process the first real edge, since\n\t\t\t// all the edges connect to the same other vertex\n\t\t\tif (realEdges != null && realEdges.length > 0)\n\t\t\t{\n\t\t\t\tvar realEdge = realEdges[0];\n\t\t\t\tvar targetCell = layout.getVisibleTerminal(\n\t\t\t\t\t\trealEdge, false);\n\t\t\t\tvar internalTargetCell = this.vertexMapper.get(targetCell);\n\n\t\t\t\tif (internalVertices[i] == internalTargetCell)\n\t\t\t\t{\n\t\t\t\t\t// If there are parallel edges going between two vertices and not all are in the same direction\n\t\t\t\t\t// you can have navigated across one direction when doing the cycle reversal that isn't the same\n\t\t\t\t\t// direction as the first real edge in the array above. When that happens the if above catches\n\t\t\t\t\t// that and we correct the target cell before continuing.\n\t\t\t\t\t// This branch only detects this single case\n\t\t\t\t\ttargetCell = layout.getVisibleTerminal(\n\t\t\t\t\t\t\trealEdge, true);\n\t\t\t\t\tinternalTargetCell = this.vertexMapper.get(targetCell);\n\t\t\t\t}\n\n\t\t\t\tif (internalTargetCell != null\n\t\t\t\t\t\t&& internalVertices[i] != internalTargetCell)\n\t\t\t\t{\n\t\t\t\t\tinternalEdge.target = internalTargetCell;\n\n\t\t\t\t\tif (internalTargetCell.connectsAsTarget.length == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tinternalTargetCell.connectsAsTarget = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mxUtils.indexOf(internalTargetCell.connectsAsTarget, internalEdge) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tinternalTargetCell.connectsAsTarget.push(internalEdge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Use the temp variable in the internal nodes to mark this\n\t\t// internal vertex as having been visited.\n\t\tinternalVertices[i].temp[0] = 1;\n\t}\n};\n\n/**\n * Variable: maxRank\n *\n * Stores the largest rank number allocated\n */\nmxSwimlaneModel.prototype.maxRank = null;\n\n/**\n * Variable: vertexMapper\n *\n * Map from graph vertices to internal model nodes.\n */\nmxSwimlaneModel.prototype.vertexMapper = null;\n\n/**\n * Variable: edgeMapper\n *\n * Map from graph edges to internal model edges\n */\nmxSwimlaneModel.prototype.edgeMapper = null;\n\n/**\n * Variable: ranks\n *\n * Mapping from rank number to actual rank\n */\nmxSwimlaneModel.prototype.ranks = null;\n\n/**\n * Variable: roots\n *\n * Store of roots of this hierarchy model, these are real graph cells, not\n * internal cells\n */\nmxSwimlaneModel.prototype.roots = null;\n\n/**\n * Variable: parent\n *\n * The parent cell whose children are being laid out\n */\nmxSwimlaneModel.prototype.parent = null;\n\n/**\n * Variable: dfsCount\n *\n * Count of the number of times the ancestor dfs has been used.\n */\nmxSwimlaneModel.prototype.dfsCount = 0;\n\n/**\n * Variable: SOURCESCANSTARTRANK\n *\n * High value to start source layering scan rank value from.\n */\nmxSwimlaneModel.prototype.SOURCESCANSTARTRANK = 100000000;\n\n/**\n * Variable: tightenToSource\n *\n * Whether or not to tighten the assigned ranks of vertices up towards\n * the source cells.\n */\nmxSwimlaneModel.prototype.tightenToSource = false;\n\n/**\n * Variable: ranksPerGroup\n *\n * An array of the number of ranks within each swimlane\n */\nmxSwimlaneModel.prototype.ranksPerGroup = null;\n\n/**\n * Function: createInternalCells\n *\n * Creates all edges in the internal model\n *\n * Parameters:\n *\n * layout - Reference to the <mxHierarchicalLayout> algorithm.\n * vertices - Array of <mxCells> that represent the vertices whom are to\n * have an internal representation created.\n * internalVertices - The array of <mxGraphHierarchyNodes> to have their\n * information filled in using the real vertices.\n */\nmxSwimlaneModel.prototype.createInternalCells = function(layout, vertices, internalVertices)\n{\n\tvar graph = layout.getGraph();\n\tvar swimlanes = layout.swimlanes;\n\n\t// Create internal edges\n\tfor (var i = 0; i < vertices.length; i++)\n\t{\n\t\tinternalVertices[i] = new mxGraphHierarchyNode(vertices[i]);\n\t\tthis.vertexMapper.put(vertices[i], internalVertices[i]);\n\t\tinternalVertices[i].swimlaneIndex = -1;\n\n\t\tfor (var ii = 0; ii < swimlanes.length; ii++)\n\t\t{\n\t\t\tif (graph.model.getParent(vertices[i]) == swimlanes[ii])\n\t\t\t{\n\t\t\t\tinternalVertices[i].swimlaneIndex = ii;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If the layout is deterministic, order the cells\n\t\t//List outgoingCells = graph.getNeighbours(vertices[i], deterministic);\n\t\tvar conns = layout.getEdges(vertices[i]);\n\t\tinternalVertices[i].connectsAsSource = [];\n\n\t\t// Create internal edges, but don't do any rank assignment yet\n\t\t// First use the information from the greedy cycle remover to\n\t\t// invert the leftward edges internally\n\t\tfor (var j = 0; j < conns.length; j++)\n\t\t{\n\t\t\tvar cell = layout.getVisibleTerminal(conns[j], false);\n\n\t\t\t// Looking for outgoing edges only\n\t\t\tif (cell != vertices[i] && layout.graph.model.isVertex(cell) &&\n\t\t\t\t\t!layout.isVertexIgnored(cell))\n\t\t\t{\n\t\t\t\t// We process all edge between this source and its targets\n\t\t\t\t// If there are edges going both ways, we need to collect\n\t\t\t\t// them all into one internal edges to avoid looping problems\n\t\t\t\t// later. We assume this direction (source -> target) is the \n\t\t\t\t// natural direction if at least half the edges are going in\n\t\t\t\t// that direction.\n\n\t\t\t\t// The check below for edges[0] being in the vertex mapper is\n\t\t\t\t// in case we've processed this the other way around\n\t\t\t\t// (target -> source) and the number of edges in each direction\n\t\t\t\t// are the same. All the graph edges will have been assigned to\n\t\t\t\t// an internal edge going the other way, so we don't want to \n\t\t\t\t// process them again\n\t\t\t\tvar undirectedEdges = layout.getEdgesBetween(vertices[i],\n\t\t\t\t\t\tcell, false);\n\t\t\t\tvar directedEdges = layout.getEdgesBetween(vertices[i],\n\t\t\t\t\t\tcell, true);\n\t\t\t\t\n\t\t\t\tif (undirectedEdges != null &&\n\t\t\t\t\t\tundirectedEdges.length > 0 &&\n\t\t\t\t\t\tthis.edgeMapper.get(undirectedEdges[0]) == null &&\n\t\t\t\t\t\tdirectedEdges.length * 2 >= undirectedEdges.length)\n\t\t\t\t{\n\t\t\t\t\tvar internalEdge = new mxGraphHierarchyEdge(undirectedEdges);\n\n\t\t\t\t\tfor (var k = 0; k < undirectedEdges.length; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar edge = undirectedEdges[k];\n\t\t\t\t\t\tthis.edgeMapper.put(edge, internalEdge);\n\n\t\t\t\t\t\t// Resets all point on the edge and disables the edge style\n\t\t\t\t\t\t// without deleting it from the cell style\n\t\t\t\t\t\tgraph.resetEdge(edge);\n\n\t\t\t\t\t    if (layout.disableEdgeStyle)\n\t\t\t\t\t    {\n\t\t\t\t\t    \tlayout.setEdgeStyleEnabled(edge, false);\n\t\t\t\t\t    \tlayout.setOrthogonalEdge(edge,true);\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\n\t\t\t\t\tinternalEdge.source = internalVertices[i];\n\n\t\t\t\t\tif (mxUtils.indexOf(internalVertices[i].connectsAsSource, internalEdge) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tinternalVertices[i].connectsAsSource.push(internalEdge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Ensure temp variable is cleared from any previous use\n\t\tinternalVertices[i].temp[0] = 0;\n\t}\n};\n\n/**\n * Function: initialRank\n *\n * Basic determination of minimum layer ranking by working from from sources\n * or sinks and working through each node in the relevant edge direction.\n * Starting at the sinks is basically a longest path layering algorithm.\n*/\nmxSwimlaneModel.prototype.initialRank = function()\n{\n\tthis.ranksPerGroup = [];\n\t\n\tvar startNodes = [];\n\tvar seen = new Object();\n\n\tif (this.roots != null)\n\t{\n\t\tfor (var i = 0; i < this.roots.length; i++)\n\t\t{\n\t\t\tvar internalNode = this.vertexMapper.get(this.roots[i]);\n\t\t\tthis.maxChainDfs(null, internalNode, null, seen, 0);\n\n\t\t\tif (internalNode != null)\n\t\t\t{\n\t\t\t\tstartNodes.push(internalNode);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the lower and upper rank bounds of each swimlane\n\tvar lowerRank = [];\n\tvar upperRank = [];\n\t\n\tfor (var i = this.ranksPerGroup.length - 1; i >= 0; i--)\n\t{\n\t\tif (i == this.ranksPerGroup.length - 1)\n\t\t{\n\t\t\tlowerRank[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlowerRank[i] = upperRank[i+1] + 1;\n\t\t}\n\t\t\n\t\tupperRank[i] = lowerRank[i] + this.ranksPerGroup[i];\n\t}\n\t\n\tthis.maxRank = upperRank[0];\n\n\tvar internalNodes = this.vertexMapper.getValues();\n\t\n\tfor (var i=0; i < internalNodes.length; i++)\n\t{\n\t\t// Mark the node as not having had a layer assigned\n\t\tinternalNodes[i].temp[0] = -1;\n\t}\n\n\tvar startNodesCopy = startNodes.slice();\n\t\n\twhile (startNodes.length > 0)\n\t{\n\t\tvar internalNode = startNodes[0];\n\t\tvar layerDeterminingEdges;\n\t\tvar edgesToBeMarked;\n\n\t\tlayerDeterminingEdges = internalNode.connectsAsTarget;\n\t\tedgesToBeMarked = internalNode.connectsAsSource;\n\n\t\t// flag to keep track of whether or not all layer determining\n\t\t// edges have been scanned\n\t\tvar allEdgesScanned = true;\n\n\t\t// Work out the layer of this node from the layer determining\n\t\t// edges. The minimum layer number of any node connected by one of\n\t\t// the layer determining edges variable\n\t\tvar minimumLayer = upperRank[0];\n\n\t\tfor (var i = 0; i < layerDeterminingEdges.length; i++)\n\t\t{\n\t\t\tvar internalEdge = layerDeterminingEdges[i];\n\n\t\t\tif (internalEdge.temp[0] == 5270620)\n\t\t\t{\n\t\t\t\t// This edge has been scanned, get the layer of the\n\t\t\t\t// node on the other end\n\t\t\t\tvar otherNode = internalEdge.source;\n\t\t\t\tminimumLayer = Math.min(minimumLayer, otherNode.temp[0] - 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tallEdgesScanned = false;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If all edge have been scanned, assign the layer, mark all\n\t\t// edges in the other direction and remove from the nodes list\n\t\tif (allEdgesScanned)\n\t\t{\n\t\t\tif (minimumLayer > upperRank[internalNode.swimlaneIndex])\n\t\t\t{\n\t\t\t\tminimumLayer = upperRank[internalNode.swimlaneIndex];\n\t\t\t}\n\n\t\t\tinternalNode.temp[0] = minimumLayer;\n\n\t\t\tif (edgesToBeMarked != null)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < edgesToBeMarked.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar internalEdge = edgesToBeMarked[i];\n\n\t\t\t\t\t// Assign unique stamp ( y/m/d/h )\n\t\t\t\t\tinternalEdge.temp[0] = 5270620;\n\n\t\t\t\t\t// Add node on other end of edge to LinkedList of\n\t\t\t\t\t// nodes to be analysed\n\t\t\t\t\tvar otherNode = internalEdge.target;\n\n\t\t\t\t\t// Only add node if it hasn't been assigned a layer\n\t\t\t\t\tif (otherNode.temp[0] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartNodes.push(otherNode);\n\n\t\t\t\t\t\t// Mark this other node as neither being\n\t\t\t\t\t\t// unassigned nor assigned so it isn't\n\t\t\t\t\t\t// added to this list again, but it's\n\t\t\t\t\t\t// layer isn't used in any calculation.\n\t\t\t\t\t\totherNode.temp[0] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstartNodes.shift();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Not all the edges have been scanned, get to the back of\n\t\t\t// the class and put the dunces cap on\n\t\t\tvar removedCell = startNodes.shift();\n\t\t\tstartNodes.push(internalNode);\n\n\t\t\tif (removedCell == internalNode && startNodes.length == 1)\n\t\t\t{\n\t\t\t\t// This is an error condition, we can't get out of\n\t\t\t\t// this loop. It could happen for more than one node\n\t\t\t\t// but that's a lot harder to detect. Log the error\n\t\t\t\t// TODO make log comment\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize the ranks down from their large starting value to place\n\t// at least 1 sink on layer 0\n//\tfor (var key in this.vertexMapper)\n//\t{\n//\t\tvar internalNode = this.vertexMapper[key];\n//\t\t// Mark the node as not having had a layer assigned\n//\t\tinternalNode.temp[0] -= this.maxRank;\n//\t}\n\t\n\t// Tighten the rank 0 nodes as far as possible\n//\tfor ( var i = 0; i < startNodesCopy.length; i++)\n//\t{\n//\t\tvar internalNode = startNodesCopy[i];\n//\t\tvar currentMaxLayer = 0;\n//\t\tvar layerDeterminingEdges = internalNode.connectsAsSource;\n//\n//\t\tfor ( var j = 0; j < layerDeterminingEdges.length; j++)\n//\t\t{\n//\t\t\tvar internalEdge = layerDeterminingEdges[j];\n//\t\t\tvar otherNode = internalEdge.target;\n//\t\t\tinternalNode.temp[0] = Math.max(currentMaxLayer,\n//\t\t\t\t\totherNode.temp[0] + 1);\n//\t\t\tcurrentMaxLayer = internalNode.temp[0];\n//\t\t}\n//\t}\n};\n\n/**\n * Function: maxChainDfs\n *\n * Performs a depth first search on the internal hierarchy model. This dfs\n * extends the default version by keeping track of chains within groups.\n * Any cycles should be removed prior to running, but previously seen cells\n * are ignored.\n *\n * Parameters:\n *\n * parent - the parent internal node of the current internal node\n * root - the current internal node\n * connectingEdge - the internal edge connecting the internal node and the parent\n * internal node, if any\n * seen - a set of all nodes seen by this dfs\n * chainCount - the number of edges in the chain of vertices going through\n * the current swimlane\n */\nmxSwimlaneModel.prototype.maxChainDfs = function(parent, root, connectingEdge, seen, chainCount)\n{\n\tif (root != null)\n\t{\n\t\tvar rootId = mxCellPath.create(root.cell);\n\n\t\tif (seen[rootId] == null)\n\t\t{\n\t\t\tseen[rootId] = root;\n\t\t\tvar slIndex = root.swimlaneIndex;\n\t\t\t\n\t\t\tif (this.ranksPerGroup[slIndex] == null || this.ranksPerGroup[slIndex] < chainCount)\n\t\t\t{\n\t\t\t\tthis.ranksPerGroup[slIndex] = chainCount;\n\t\t\t}\n\n\t\t\t// Copy the connects as source list so that visitors\n\t\t\t// can change the original for edge direction inversions\n\t\t\tvar outgoingEdges = root.connectsAsSource.slice();\n\n\t\t\tfor (var i = 0; i < outgoingEdges.length; i++)\n\t\t\t{\n\t\t\t\tvar internalEdge = outgoingEdges[i];\n\t\t\t\tvar targetNode = internalEdge.target;\n\n\t\t\t\t// Only navigate in source->target direction within the same\n\t\t\t\t// swimlane, or from a lower index swimlane to a higher one\n\t\t\t\tif (root.swimlaneIndex < targetNode.swimlaneIndex)\n\t\t\t\t{\n\t\t\t\t\tthis.maxChainDfs(root, targetNode, internalEdge, mxUtils.clone(seen, null , true), 0);\n\t\t\t\t}\n\t\t\t\telse if (root.swimlaneIndex == targetNode.swimlaneIndex)\n\t\t\t\t{\n\t\t\t\t\tthis.maxChainDfs(root, targetNode, internalEdge, mxUtils.clone(seen, null , true), chainCount + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: fixRanks\n *\n * Fixes the layer assignments to the values stored in the nodes. Also needs\n * to create dummy nodes for edges that cross layers.\n */\nmxSwimlaneModel.prototype.fixRanks = function()\n{\n\tvar rankList = [];\n\tthis.ranks = [];\n\n\tfor (var i = 0; i < this.maxRank + 1; i++)\n\t{\n\t\trankList[i] = [];\n\t\tthis.ranks[i] = rankList[i];\n\t}\n\n\t// Perform a DFS to obtain an initial ordering for each rank.\n\t// Without doing this you would end up having to process\n\t// crossings for a standard tree.\n\tvar rootsArray = null;\n\n\tif (this.roots != null)\n\t{\n\t\tvar oldRootsArray = this.roots;\n\t\trootsArray = [];\n\n\t\tfor (var i = 0; i < oldRootsArray.length; i++)\n\t\t{\n\t\t\tvar cell = oldRootsArray[i];\n\t\t\tvar internalNode = this.vertexMapper.get(cell);\n\t\t\trootsArray[i] = internalNode;\n\t\t}\n\t}\n\n\tthis.visit(function(parent, node, edge, layer, seen)\n\t{\n\t\tif (seen == 0 && node.maxRank < 0 && node.minRank < 0)\n\t\t{\n\t\t\trankList[node.temp[0]].push(node);\n\t\t\tnode.maxRank = node.temp[0];\n\t\t\tnode.minRank = node.temp[0];\n\n\t\t\t// Set temp[0] to the nodes position in the rank\n\t\t\tnode.temp[0] = rankList[node.maxRank].length - 1;\n\t\t}\n\n\t\tif (parent != null && edge != null)\n\t\t{\n\t\t\tvar parentToCellRankDifference = parent.maxRank - node.maxRank;\n\n\t\t\tif (parentToCellRankDifference > 1)\n\t\t\t{\n\t\t\t\t// There are ranks in between the parent and current cell\n\t\t\t\tedge.maxRank = parent.maxRank;\n\t\t\t\tedge.minRank = node.maxRank;\n\t\t\t\tedge.temp = [];\n\t\t\t\tedge.x = [];\n\t\t\t\tedge.y = [];\n\n\t\t\t\tfor (var i = edge.minRank + 1; i < edge.maxRank; i++)\n\t\t\t\t{\n\t\t\t\t\t// The connecting edge must be added to the\n\t\t\t\t\t// appropriate ranks\n\t\t\t\t\trankList[i].push(edge);\n\t\t\t\t\tedge.setGeneralPurposeVariable(i, rankList[i]\n\t\t\t\t\t\t\t.length - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, rootsArray, false, null);\n};\n\n/**\n * Function: visit\n *\n * A depth first search through the internal heirarchy model.\n *\n * Parameters:\n *\n * visitor - The visitor function pattern to be called for each node.\n * trackAncestors - Whether or not the search is to keep track all nodes\n * directly above this one in the search path.\n */\nmxSwimlaneModel.prototype.visit = function(visitor, dfsRoots, trackAncestors, seenNodes)\n{\n\t// Run dfs through on all roots\n\tif (dfsRoots != null)\n\t{\n\t\tfor (var i = 0; i < dfsRoots.length; i++)\n\t\t{\n\t\t\tvar internalNode = dfsRoots[i];\n\n\t\t\tif (internalNode != null)\n\t\t\t{\n\t\t\t\tif (seenNodes == null)\n\t\t\t\t{\n\t\t\t\t\tseenNodes = new Object();\n\t\t\t\t}\n\n\t\t\t\tif (trackAncestors)\n\t\t\t\t{\n\t\t\t\t\t// Set up hash code for root\n\t\t\t\t\tinternalNode.hashCode = [];\n\t\t\t\t\tinternalNode.hashCode[0] = this.dfsCount;\n\t\t\t\t\tinternalNode.hashCode[1] = i;\n\t\t\t\t\tthis.extendedDfs(null, internalNode, null, visitor, seenNodes,\n\t\t\t\t\t\t\tinternalNode.hashCode, i, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.dfs(null, internalNode, null, visitor, seenNodes, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.dfsCount++;\n\t}\n};\n\n/**\n * Function: dfs\n *\n * Performs a depth first search on the internal hierarchy model\n *\n * Parameters:\n *\n * parent - the parent internal node of the current internal node\n * root - the current internal node\n * connectingEdge - the internal edge connecting the internal node and the parent\n * internal node, if any\n * visitor - the visitor pattern to be called for each node\n * seen - a set of all nodes seen by this dfs a set of all of the\n * ancestor node of the current node\n * layer - the layer on the dfs tree ( not the same as the model ranks )\n */\nmxSwimlaneModel.prototype.dfs = function(parent, root, connectingEdge, visitor, seen, layer)\n{\n\tif (root != null)\n\t{\n\t\tvar rootId = root.id;\n\n\t\tif (seen[rootId] == null)\n\t\t{\n\t\t\tseen[rootId] = root;\n\t\t\tvisitor(parent, root, connectingEdge, layer, 0);\n\n\t\t\t// Copy the connects as source list so that visitors\n\t\t\t// can change the original for edge direction inversions\n\t\t\tvar outgoingEdges = root.connectsAsSource.slice();\n\t\t\t\n\t\t\tfor (var i = 0; i< outgoingEdges.length; i++)\n\t\t\t{\n\t\t\t\tvar internalEdge = outgoingEdges[i];\n\t\t\t\tvar targetNode = internalEdge.target;\n\n\t\t\t\t// Root check is O(|roots|)\n\t\t\t\tthis.dfs(root, targetNode, internalEdge, visitor, seen,\n\t\t\t\t\t\tlayer + 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Use the int field to indicate this node has been seen\n\t\t\tvisitor(parent, root, connectingEdge, layer, 1);\n\t\t}\n\t}\n};\n\n/**\n * Function: extendedDfs\n *\n * Performs a depth first search on the internal hierarchy model. This dfs\n * extends the default version by keeping track of cells ancestors, but it\n * should be only used when necessary because of it can be computationally\n * intensive for deep searches.\n *\n * Parameters:\n *\n * parent - the parent internal node of the current internal node\n * root - the current internal node\n * connectingEdge - the internal edge connecting the internal node and the parent\n * internal node, if any\n * visitor - the visitor pattern to be called for each node\n * seen - a set of all nodes seen by this dfs\n * ancestors - the parent hash code\n * childHash - the new hash code for this node\n * layer - the layer on the dfs tree ( not the same as the model ranks )\n */\nmxSwimlaneModel.prototype.extendedDfs = function(parent, root, connectingEdge, visitor, seen, ancestors, childHash, layer)\n{\n\t// Explanation of custom hash set. Previously, the ancestors variable\n\t// was passed through the dfs as a HashSet. The ancestors were copied\n\t// into a new HashSet and when the new child was processed it was also\n\t// added to the set. If the current node was in its ancestor list it\n\t// meant there is a cycle in the graph and this information is passed\n\t// to the visitor.visit() in the seen parameter. The HashSet clone was\n\t// very expensive on CPU so a custom hash was developed using primitive\n\t// types. temp[] couldn't be used so hashCode[] was added to each node.\n\t// Each new child adds another int to the array, copying the prefix\n\t// from its parent. Child of the same parent add different ints (the\n\t// limit is therefore 2^32 children per parent...). If a node has a\n\t// child with the hashCode already set then the child code is compared\n\t// to the same portion of the current nodes array. If they match there\n\t// is a loop.\n\t// Note that the basic mechanism would only allow for 1 use of this\n\t// functionality, so the root nodes have two ints. The second int is\n\t// incremented through each node root and the first is incremented\n\t// through each run of the dfs algorithm (therefore the dfs is not\n\t// thread safe). The hash code of each node is set if not already set,\n\t// or if the first int does not match that of the current run.\n\tif (root != null)\n\t{\n\t\tif (parent != null)\n\t\t{\n\t\t\t// Form this nodes hash code if necessary, that is, if the\n\t\t\t// hashCode variable has not been initialized or if the\n\t\t\t// start of the parent hash code does not equal the start of\n\t\t\t// this nodes hash code, indicating the code was set on a\n\t\t\t// previous run of this dfs.\n\t\t\tif (root.hashCode == null ||\n\t\t\t\troot.hashCode[0] != parent.hashCode[0])\n\t\t\t{\n\t\t\t\tvar hashCodeLength = parent.hashCode.length + 1;\n\t\t\t\troot.hashCode = parent.hashCode.slice();\n\t\t\t\troot.hashCode[hashCodeLength - 1] = childHash;\n\t\t\t}\n\t\t}\n\n\t\tvar rootId = root.id;\n\n\t\tif (seen[rootId] == null)\n\t\t{\n\t\t\tseen[rootId] = root;\n\t\t\tvisitor(parent, root, connectingEdge, layer, 0);\n\n\t\t\t// Copy the connects as source list so that visitors\n\t\t\t// can change the original for edge direction inversions\n\t\t\tvar outgoingEdges = root.connectsAsSource.slice();\n\t\t\tvar incomingEdges = root.connectsAsTarget.slice();\n\n\t\t\tfor (var i = 0; i < outgoingEdges.length; i++)\n\t\t\t{\n\t\t\t\tvar internalEdge = outgoingEdges[i];\n\t\t\t\tvar targetNode = internalEdge.target;\n\t\t\t\t\n\t\t\t\t// Only navigate in source->target direction within the same\n\t\t\t\t// swimlane, or from a lower index swimlane to a higher one\n\t\t\t\tif (root.swimlaneIndex <= targetNode.swimlaneIndex)\n\t\t\t\t{\n\t\t\t\t\tthis.extendedDfs(root, targetNode, internalEdge, visitor, seen,\n\t\t\t\t\t\t\troot.hashCode, i, layer + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (var i = 0; i < incomingEdges.length; i++)\n\t\t\t{\n\t\t\t\tvar internalEdge = incomingEdges[i];\n\t\t\t\tvar targetNode = internalEdge.source;\n\n\t\t\t\t// Only navigate in target->source direction from a lower index \n\t\t\t\t// swimlane to a higher one\n\t\t\t\tif (root.swimlaneIndex < targetNode.swimlaneIndex)\n\t\t\t\t{\n\t\t\t\t\tthis.extendedDfs(root, targetNode, internalEdge, visitor, seen,\n\t\t\t\t\t\t\troot.hashCode, i, layer + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Use the int field to indicate this node has been seen\n\t\t\tvisitor(parent, root, connectingEdge, layer, 1);\n\t\t}\n\t}\n};\n\n__mxOutput.mxSwimlaneModel = typeof mxSwimlaneModel !== 'undefined' ? mxSwimlaneModel : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxHierarchicalLayoutStage\n * \n * The specific layout interface for hierarchical layouts. It adds a\n * <code>run</code> method with a parameter for the hierarchical layout model\n * that is shared between the layout stages.\n * \n * Constructor: mxHierarchicalLayoutStage\n *\n * Constructs a new hierarchical layout stage.\n */\nfunction mxHierarchicalLayoutStage() { };\n\n/**\n * Function: execute\n * \n * Takes the graph detail and configuration information within the facade\n * and creates the resulting laid out graph within that facade for further\n * use.\n */\nmxHierarchicalLayoutStage.prototype.execute = function(parent) { };\n\n__mxOutput.mxHierarchicalLayoutStage = typeof mxHierarchicalLayoutStage !== 'undefined' ? mxHierarchicalLayoutStage : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxMedianHybridCrossingReduction\n * \n * Sets the horizontal locations of node and edge dummy nodes on each layer.\n * Uses median down and up weighings as well heuristic to straighten edges as\n * far as possible.\n * \n * Constructor: mxMedianHybridCrossingReduction\n *\n * Creates a coordinate assignment.\n * \n * Arguments:\n * \n * intraCellSpacing - the minimum buffer between cells on the same rank\n * interRankCellSpacing - the minimum distance between cells on adjacent ranks\n * orientation - the position of the root node(s) relative to the graph\n * initialX - the leftmost coordinate node placement starts at\n */\nfunction mxMedianHybridCrossingReduction(layout)\n{\n\tthis.layout = layout;\n};\n\n/**\n * Extends mxMedianHybridCrossingReduction.\n */\nmxMedianHybridCrossingReduction.prototype = new mxHierarchicalLayoutStage();\nmxMedianHybridCrossingReduction.prototype.constructor = mxMedianHybridCrossingReduction;\n\n/**\n * Variable: layout\n * \n * Reference to the enclosing <mxHierarchicalLayout>.\n */\nmxMedianHybridCrossingReduction.prototype.layout = null;\n\n/**\n * Variable: maxIterations\n * \n * The maximum number of iterations to perform whilst reducing edge\n * crossings. Default is 24.\n */\nmxMedianHybridCrossingReduction.prototype.maxIterations = 24;\n\n/**\n * Variable: nestedBestRanks\n * \n * Stores each rank as a collection of cells in the best order found for\n * each layer so far\n */\nmxMedianHybridCrossingReduction.prototype.nestedBestRanks = null;\n\n/**\n * Variable: currentBestCrossings\n * \n * The total number of crossings found in the best configuration so far\n */\nmxMedianHybridCrossingReduction.prototype.currentBestCrossings = 0;\n\n/**\n * Variable: iterationsWithoutImprovement\n * \n * The total number of crossings found in the best configuration so far\n */\nmxMedianHybridCrossingReduction.prototype.iterationsWithoutImprovement = 0;\n\n/**\n * Variable: maxNoImprovementIterations\n * \n * The total number of crossings found in the best configuration so far\n */\nmxMedianHybridCrossingReduction.prototype.maxNoImprovementIterations = 2;\n\n/**\n * Function: execute\n * \n * Performs a vertex ordering within ranks as described by Gansner et al\n * 1993\n */\nmxMedianHybridCrossingReduction.prototype.execute = function(parent)\n{\n\tvar model = this.layout.getModel();\n\n\t// Stores initial ordering as being the best one found so far\n\tthis.nestedBestRanks = [];\n\t\n\tfor (var i = 0; i < model.ranks.length; i++)\n\t{\n\t\tthis.nestedBestRanks[i] = model.ranks[i].slice();\n\t}\n\n\tvar iterationsWithoutImprovement = 0;\n\tvar currentBestCrossings = this.calculateCrossings(model);\n\n\tfor (var i = 0; i < this.maxIterations &&\n\t\titerationsWithoutImprovement < this.maxNoImprovementIterations; i++)\n\t{\n\t\tthis.weightedMedian(i, model);\n\t\tthis.transpose(i, model);\n\t\tvar candidateCrossings = this.calculateCrossings(model);\n\n\t\tif (candidateCrossings < currentBestCrossings)\n\t\t{\n\t\t\tcurrentBestCrossings = candidateCrossings;\n\t\t\titerationsWithoutImprovement = 0;\n\n\t\t\t// Store the current rankings as the best ones\n\t\t\tfor (var j = 0; j < this.nestedBestRanks.length; j++)\n\t\t\t{\n\t\t\t\tvar rank = model.ranks[j];\n\n\t\t\t\tfor (var k = 0; k < rank.length; k++)\n\t\t\t\t{\n\t\t\t\t\tvar cell = rank[k];\n\t\t\t\t\tthis.nestedBestRanks[j][cell.getGeneralPurposeVariable(j)] = cell;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Increase count of iterations where we haven't improved the\n\t\t\t// layout\n\t\t\titerationsWithoutImprovement++;\n\n\t\t\t// Restore the best values to the cells\n\t\t\tfor (var j = 0; j < this.nestedBestRanks.length; j++)\n\t\t\t{\n\t\t\t\tvar rank = model.ranks[j];\n\t\t\t\t\n\t\t\t\tfor (var k = 0; k < rank.length; k++)\n\t\t\t\t{\n\t\t\t\t\tvar cell = rank[k];\n\t\t\t\t\tcell.setGeneralPurposeVariable(j, k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (currentBestCrossings == 0)\n\t\t{\n\t\t\t// Do nothing further\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Store the best rankings but in the model\n\tvar ranks = [];\n\tvar rankList = [];\n\n\tfor (var i = 0; i < model.maxRank + 1; i++)\n\t{\n\t\trankList[i] = [];\n\t\tranks[i] = rankList[i];\n\t}\n\n\tfor (var i = 0; i < this.nestedBestRanks.length; i++)\n\t{\n\t\tfor (var j = 0; j < this.nestedBestRanks[i].length; j++)\n\t\t{\n\t\t\trankList[i].push(this.nestedBestRanks[i][j]);\n\t\t}\n\t}\n\n\tmodel.ranks = ranks;\n};\n\n\n/**\n * Function: calculateCrossings\n * \n * Calculates the total number of edge crossing in the current graph.\n * Returns the current number of edge crossings in the hierarchy graph\n * model in the current candidate layout\n * \n * Parameters:\n * \n * model - the internal model describing the hierarchy\n */\nmxMedianHybridCrossingReduction.prototype.calculateCrossings = function(model)\n{\n\tvar numRanks = model.ranks.length;\n\tvar totalCrossings = 0;\n\n\tfor (var i = 1; i < numRanks; i++)\n\t{\n\t\ttotalCrossings += this.calculateRankCrossing(i, model);\n\t}\n\t\n\treturn totalCrossings;\n};\n\n/**\n * Function: calculateRankCrossing\n * \n * Calculates the number of edges crossings between the specified rank and\n * the rank below it. Returns the number of edges crossings with the rank\n * beneath\n * \n * Parameters:\n * \n * i -  the topmost rank of the pair ( higher rank value )\n * model - the internal model describing the hierarchy\n */\nmxMedianHybridCrossingReduction.prototype.calculateRankCrossing = function(i, model)\n{\n\tvar totalCrossings = 0;\n\tvar rank = model.ranks[i];\n\tvar previousRank = model.ranks[i - 1];\n\n\tvar tmpIndices = [];\n\n\t// Iterate over the top rank and fill in the connection information\n\tfor (var j = 0; j < rank.length; j++)\n\t{\n\t\tvar node = rank[j];\n\t\tvar rankPosition = node.getGeneralPurposeVariable(i);\n\t\tvar connectedCells = node.getPreviousLayerConnectedCells(i);\n\t\tvar nodeIndices = [];\n\n\t\tfor (var k = 0; k < connectedCells.length; k++)\n\t\t{\n\t\t\tvar connectedNode = connectedCells[k];\n\t\t\tvar otherCellRankPosition = connectedNode.getGeneralPurposeVariable(i - 1);\n\t\t\tnodeIndices.push(otherCellRankPosition);\n\t\t}\n\t\t\n\t\tnodeIndices.sort(function(x, y) { return x - y; });\n\t\ttmpIndices[rankPosition] = nodeIndices;\n\t}\n\t\n\tvar indices = [];\n\n\tfor (var j = 0; j < tmpIndices.length; j++)\n\t{\n\t\tindices = indices.concat(tmpIndices[j]);\n\t}\n\n\tvar firstIndex = 1;\n\t\n\twhile (firstIndex < previousRank.length)\n\t{\n\t\tfirstIndex <<= 1;\n\t}\n\n\tvar treeSize = 2 * firstIndex - 1;\n\tfirstIndex -= 1;\n\n\tvar tree = [];\n\t\n\tfor (var j = 0; j < treeSize; ++j)\n\t{\n\t\ttree[j] = 0;\n\t}\n\n\tfor (var j = 0; j < indices.length; j++)\n\t{\n\t\tvar index = indices[j];\n\t    var treeIndex = index + firstIndex;\n\t    ++tree[treeIndex];\n\t    \n\t    while (treeIndex > 0)\n\t    {\n\t    \tif (treeIndex % 2)\n\t    \t{\n\t    \t\ttotalCrossings += tree[treeIndex + 1];\n\t    \t}\n\t      \n\t    \ttreeIndex = (treeIndex - 1) >> 1;\n\t    \t++tree[treeIndex];\n\t    }\n\t}\n\n\treturn totalCrossings;\n};\n\n/**\n * Function: transpose\n * \n * Takes each possible adjacent cell pair on each rank and checks if\n * swapping them around reduces the number of crossing\n * \n * Parameters:\n * \n * mainLoopIteration - the iteration number of the main loop\n * model - the internal model describing the hierarchy\n */\nmxMedianHybridCrossingReduction.prototype.transpose = function(mainLoopIteration, model)\n{\n\tvar improved = true;\n\n\t// Track the number of iterations in case of looping\n\tvar count = 0;\n\tvar maxCount = 10;\n\twhile (improved && count++ < maxCount)\n\t{\n\t\t// On certain iterations allow allow swapping of cell pairs with\n\t\t// equal edge crossings switched or not switched. This help to\n\t\t// nudge a stuck layout into a lower crossing total.\n\t\tvar nudge = mainLoopIteration % 2 == 1 && count % 2 == 1;\n\t\timproved = false;\n\t\t\n\t\tfor (var i = 0; i < model.ranks.length; i++)\n\t\t{\n\t\t\tvar rank = model.ranks[i];\n\t\t\tvar orderedCells = [];\n\t\t\t\n\t\t\tfor (var j = 0; j < rank.length; j++)\n\t\t\t{\n\t\t\t\tvar cell = rank[j];\n\t\t\t\tvar tempRank = cell.getGeneralPurposeVariable(i);\n\t\t\t\t\n\t\t\t\t// FIXME: Workaround to avoid negative tempRanks\n\t\t\t\tif (tempRank < 0)\n\t\t\t\t{\n\t\t\t\t\ttempRank = j;\n\t\t\t\t}\n\t\t\t\torderedCells[tempRank] = cell;\n\t\t\t}\n\t\t\t\n\t\t\tvar leftCellAboveConnections = null;\n\t\t\tvar leftCellBelowConnections = null;\n\t\t\tvar rightCellAboveConnections = null;\n\t\t\tvar rightCellBelowConnections = null;\n\t\t\t\n\t\t\tvar leftAbovePositions = null;\n\t\t\tvar leftBelowPositions = null;\n\t\t\tvar rightAbovePositions = null;\n\t\t\tvar rightBelowPositions = null;\n\t\t\t\n\t\t\tvar leftCell = null;\n\t\t\tvar rightCell = null;\n\n\t\t\tfor (var j = 0; j < (rank.length - 1); j++)\n\t\t\t{\n\t\t\t\t// For each intra-rank adjacent pair of cells\n\t\t\t\t// see if swapping them around would reduce the\n\t\t\t\t// number of edges crossing they cause in total\n\t\t\t\t// On every cell pair except the first on each rank, we\n\t\t\t\t// can save processing using the previous values for the\n\t\t\t\t// right cell on the new left cell\n\t\t\t\tif (j == 0)\n\t\t\t\t{\n\t\t\t\t\tleftCell = orderedCells[j];\n\t\t\t\t\tleftCellAboveConnections = leftCell\n\t\t\t\t\t\t\t.getNextLayerConnectedCells(i);\n\t\t\t\t\tleftCellBelowConnections = leftCell\n\t\t\t\t\t\t\t.getPreviousLayerConnectedCells(i);\n\t\t\t\t\tleftAbovePositions = [];\n\t\t\t\t\tleftBelowPositions = [];\n\t\t\t\t\t\n\t\t\t\t\tfor (var k = 0; k < leftCellAboveConnections.length; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tleftAbovePositions[k] = leftCellAboveConnections[k].getGeneralPurposeVariable(i + 1);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (var k = 0; k < leftCellBelowConnections.length; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tleftBelowPositions[k] = leftCellBelowConnections[k].getGeneralPurposeVariable(i - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tleftCellAboveConnections = rightCellAboveConnections;\n\t\t\t\t\tleftCellBelowConnections = rightCellBelowConnections;\n\t\t\t\t\tleftAbovePositions = rightAbovePositions;\n\t\t\t\t\tleftBelowPositions = rightBelowPositions;\n\t\t\t\t\tleftCell = rightCell;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trightCell = orderedCells[j + 1];\n\t\t\t\trightCellAboveConnections = rightCell\n\t\t\t\t\t\t.getNextLayerConnectedCells(i);\n\t\t\t\trightCellBelowConnections = rightCell\n\t\t\t\t\t\t.getPreviousLayerConnectedCells(i);\n\n\t\t\t\trightAbovePositions = [];\n\t\t\t\trightBelowPositions = [];\n\n\t\t\t\tfor (var k = 0; k < rightCellAboveConnections.length; k++)\n\t\t\t\t{\n\t\t\t\t\trightAbovePositions[k] = rightCellAboveConnections[k].getGeneralPurposeVariable(i + 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (var k = 0; k < rightCellBelowConnections.length; k++)\n\t\t\t\t{\n\t\t\t\t\trightBelowPositions[k] = rightCellBelowConnections[k].getGeneralPurposeVariable(i - 1);\n\t\t\t\t}\n\n\t\t\t\tvar totalCurrentCrossings = 0;\n\t\t\t\tvar totalSwitchedCrossings = 0;\n\t\t\t\t\n\t\t\t\tfor (var k = 0; k < leftAbovePositions.length; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (var ik = 0; ik < rightAbovePositions.length; ik++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (leftAbovePositions[k] > rightAbovePositions[ik])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttotalCurrentCrossings++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (leftAbovePositions[k] < rightAbovePositions[ik])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttotalSwitchedCrossings++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (var k = 0; k < leftBelowPositions.length; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (var ik = 0; ik < rightBelowPositions.length; ik++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (leftBelowPositions[k] > rightBelowPositions[ik])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttotalCurrentCrossings++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (leftBelowPositions[k] < rightBelowPositions[ik])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttotalSwitchedCrossings++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ((totalSwitchedCrossings < totalCurrentCrossings) ||\n\t\t\t\t\t(totalSwitchedCrossings == totalCurrentCrossings &&\n\t\t\t\t\tnudge))\n\t\t\t\t{\n\t\t\t\t\tvar temp = leftCell.getGeneralPurposeVariable(i);\n\t\t\t\t\tleftCell.setGeneralPurposeVariable(i, rightCell\n\t\t\t\t\t\t\t.getGeneralPurposeVariable(i));\n\t\t\t\t\trightCell.setGeneralPurposeVariable(i, temp);\n\n\t\t\t\t\t// With this pair exchanged we have to switch all of\n\t\t\t\t\t// values for the left cell to the right cell so the\n\t\t\t\t\t// next iteration for this rank uses it as the left\n\t\t\t\t\t// cell again\n\t\t\t\t\trightCellAboveConnections = leftCellAboveConnections;\n\t\t\t\t\trightCellBelowConnections = leftCellBelowConnections;\n\t\t\t\t\trightAbovePositions = leftAbovePositions;\n\t\t\t\t\trightBelowPositions = leftBelowPositions;\n\t\t\t\t\trightCell = leftCell;\n\t\t\t\t\t\n\t\t\t\t\tif (!nudge)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Don't count nudges as improvement or we'll end\n\t\t\t\t\t\t// up stuck in two combinations and not finishing\n\t\t\t\t\t\t// as early as we should\n\t\t\t\t\t\timproved = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: weightedMedian\n * \n * Sweeps up or down the layout attempting to minimise the median placement\n * of connected cells on adjacent ranks\n * \n * Parameters:\n * \n * iteration - the iteration number of the main loop\n * model - the internal model describing the hierarchy\n */\nmxMedianHybridCrossingReduction.prototype.weightedMedian = function(iteration, model)\n{\n\t// Reverse sweep direction each time through this method\n\tvar downwardSweep = (iteration % 2 == 0);\n\tif (downwardSweep)\n\t{\n\t\tfor (var j = model.maxRank - 1; j >= 0; j--)\n\t\t{\n\t\t\tthis.medianRank(j, downwardSweep);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (var j = 1; j < model.maxRank; j++)\n\t\t{\n\t\t\tthis.medianRank(j, downwardSweep);\n\t\t}\n\t}\n};\n\n/**\n * Function: medianRank\n * \n * Attempts to minimise the median placement of connected cells on this rank\n * and one of the adjacent ranks\n * \n * Parameters:\n * \n * rankValue - the layer number of this rank\n * downwardSweep - whether or not this is a downward sweep through the graph\n */\nmxMedianHybridCrossingReduction.prototype.medianRank = function(rankValue, downwardSweep)\n{\n\tvar numCellsForRank = this.nestedBestRanks[rankValue].length;\n\tvar medianValues = [];\n\tvar reservedPositions = [];\n\n\tfor (var i = 0; i < numCellsForRank; i++)\n\t{\n\t\tvar cell = this.nestedBestRanks[rankValue][i];\n\t\tvar sorterEntry = new MedianCellSorter();\n\t\tsorterEntry.cell = cell;\n\n\t\t// Flip whether or not equal medians are flipped on up and down\n\t\t// sweeps\n\t\t// TODO re-implement some kind of nudge\n\t\t// medianValues[i].nudge = !downwardSweep;\n\t\tvar nextLevelConnectedCells;\n\t\t\n\t\tif (downwardSweep)\n\t\t{\n\t\t\tnextLevelConnectedCells = cell\n\t\t\t\t\t.getNextLayerConnectedCells(rankValue);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnextLevelConnectedCells = cell\n\t\t\t\t\t.getPreviousLayerConnectedCells(rankValue);\n\t\t}\n\t\t\n\t\tvar nextRankValue;\n\t\t\n\t\tif (downwardSweep)\n\t\t{\n\t\t\tnextRankValue = rankValue + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnextRankValue = rankValue - 1;\n\t\t}\n\n\t\tif (nextLevelConnectedCells != null\n\t\t\t\t&& nextLevelConnectedCells.length != 0)\n\t\t{\n\t\t\tsorterEntry.medianValue = this.medianValue(\n\t\t\t\t\tnextLevelConnectedCells, nextRankValue);\n\t\t\tmedianValues.push(sorterEntry);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Nodes with no adjacent vertices are flagged in the reserved array\n\t\t\t// to indicate they should be left in their current position.\n\t\t\treservedPositions[cell.getGeneralPurposeVariable(rankValue)] = true;\n\t\t}\n\t}\n\t\n\tmedianValues.sort(MedianCellSorter.prototype.compare);\n\t\n\t// Set the new position of each node within the rank using\n\t// its temp variable\n\tfor (var i = 0; i < numCellsForRank; i++)\n\t{\n\t\tif (reservedPositions[i] == null)\n\t\t{\n\t\t\tvar cell = medianValues.shift().cell;\n\t\t\tcell.setGeneralPurposeVariable(rankValue, i);\n\t\t}\n\t}\n};\n\n/**\n * Function: medianValue\n * \n * Calculates the median rank order positioning for the specified cell using\n * the connected cells on the specified rank. Returns the median rank\n * ordering value of the connected cells\n * \n * Parameters:\n * \n * connectedCells - the cells on the specified rank connected to the\n * specified cell\n * rankValue - the rank that the connected cell lie upon\n */\nmxMedianHybridCrossingReduction.prototype.medianValue = function(connectedCells, rankValue)\n{\n\tvar medianValues = [];\n\tvar arrayCount = 0;\n\t\n\tfor (var i = 0; i < connectedCells.length; i++)\n\t{\n\t\tvar cell = connectedCells[i];\n\t\tmedianValues[arrayCount++] = cell.getGeneralPurposeVariable(rankValue);\n\t}\n\n\t// Sort() sorts lexicographically by default (i.e. 11 before 9) so force\n\t// numerical order sort\n\tmedianValues.sort(function(a,b){return a - b;});\n\t\n\tif (arrayCount % 2 == 1)\n\t{\n\t\t// For odd numbers of adjacent vertices return the median\n\t\treturn medianValues[Math.floor(arrayCount / 2)];\n\t}\n\telse if (arrayCount == 2)\n\t{\n\t\treturn ((medianValues[0] + medianValues[1]) / 2.0);\n\t}\n\telse\n\t{\n\t\tvar medianPoint = arrayCount / 2;\n\t\tvar leftMedian = medianValues[medianPoint - 1] - medianValues[0];\n\t\tvar rightMedian = medianValues[arrayCount - 1]\n\t\t\t\t- medianValues[medianPoint];\n\n\t\treturn (medianValues[medianPoint - 1] * rightMedian + medianValues[medianPoint]\n\t\t\t\t* leftMedian)\n\t\t\t\t/ (leftMedian + rightMedian);\n\t}\n};\n\n/**\n * Class: MedianCellSorter\n * \n * A utility class used to track cells whilst sorting occurs on the median\n * values. Does not violate (x.compareTo(y)==0) == (x.equals(y))\n *\n * Constructor: MedianCellSorter\n * \n * Constructs a new median cell sorter.\n */\nfunction MedianCellSorter()\n{\n\t// empty\n};\n\n/**\n * Variable: medianValue\n * \n * The weighted value of the cell stored.\n */\nMedianCellSorter.prototype.medianValue = 0;\n\n/**\n * Variable: cell\n * \n * The cell whose median value is being calculated\n */\nMedianCellSorter.prototype.cell = false;\n\n/**\n * Function: compare\n * \n * Compares two MedianCellSorters.\n */\nMedianCellSorter.prototype.compare = function(a, b)\n{\n\tif (a != null && b != null)\n\t{\n\t\tif (b.medianValue > a.medianValue)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\telse if (b.medianValue < a.medianValue)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n};\n\n__mxOutput.mxMedianHybridCrossingReduction = typeof mxMedianHybridCrossingReduction !== 'undefined' ? mxMedianHybridCrossingReduction : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxMinimumCycleRemover\n * \n * An implementation of the first stage of the Sugiyama layout. Straightforward\n * longest path calculation of layer assignment\n * \n * Constructor: mxMinimumCycleRemover\n *\n * Creates a cycle remover for the given internal model.\n */\nfunction mxMinimumCycleRemover(layout)\n{\n\tthis.layout = layout;\n};\n\n/**\n * Extends mxHierarchicalLayoutStage.\n */\nmxMinimumCycleRemover.prototype = new mxHierarchicalLayoutStage();\nmxMinimumCycleRemover.prototype.constructor = mxMinimumCycleRemover;\n\n/**\n * Variable: layout\n * \n * Reference to the enclosing <mxHierarchicalLayout>.\n */\nmxMinimumCycleRemover.prototype.layout = null;\n\n/**\n * Function: execute\n * \n * Takes the graph detail and configuration information within the facade\n * and creates the resulting laid out graph within that facade for further\n * use.\n */\nmxMinimumCycleRemover.prototype.execute = function(parent)\n{\n\tvar model = this.layout.getModel();\n\tvar seenNodes = new Object();\n\tvar unseenNodesArray = model.vertexMapper.getValues();\n\tvar unseenNodes = new Object();\n\t\n\tfor (var i = 0; i < unseenNodesArray.length; i++)\n\t{\n\t\tunseenNodes[unseenNodesArray[i].id] = unseenNodesArray[i];\n\t}\n\t\n\t// Perform a dfs through the internal model. If a cycle is found,\n\t// reverse it.\n\tvar rootsArray = null;\n\t\n\tif (model.roots != null)\n\t{\n\t\tvar modelRoots = model.roots;\n\t\trootsArray = [];\n\t\t\n\t\tfor (var i = 0; i < modelRoots.length; i++)\n\t\t{\n\t\t\trootsArray[i] = model.vertexMapper.get(modelRoots[i]);\n\t\t}\n\t}\n\n\tmodel.visit(function(parent, node, connectingEdge, layer, seen)\n\t{\n\t\t// Check if the cell is in it's own ancestor list, if so\n\t\t// invert the connecting edge and reverse the target/source\n\t\t// relationship to that edge in the parent and the cell\n\t\tif (node.isAncestor(parent))\n\t\t{\n\t\t\tconnectingEdge.invert();\n\t\t\tmxUtils.remove(connectingEdge, parent.connectsAsSource);\n\t\t\tparent.connectsAsTarget.push(connectingEdge);\n\t\t\tmxUtils.remove(connectingEdge, node.connectsAsTarget);\n\t\t\tnode.connectsAsSource.push(connectingEdge);\n\t\t}\n\t\t\n\t\tseenNodes[node.id] = node;\n\t\tdelete unseenNodes[node.id];\n\t}, rootsArray, true, null);\n\n\t// If there are any nodes that should be nodes that the dfs can miss\n\t// these need to be processed with the dfs and the roots assigned\n\t// correctly to form a correct internal model\n\tvar seenNodesCopy = mxUtils.clone(seenNodes, null, true);\n\n\t// Pick a random cell and dfs from it\n\tmodel.visit(function(parent, node, connectingEdge, layer, seen)\n\t{\n\t\t// Check if the cell is in it's own ancestor list, if so\n\t\t// invert the connecting edge and reverse the target/source\n\t\t// relationship to that edge in the parent and the cell\n\t\tif (node.isAncestor(parent))\n\t\t{\n\t\t\tconnectingEdge.invert();\n\t\t\tmxUtils.remove(connectingEdge, parent.connectsAsSource);\n\t\t\tnode.connectsAsSource.push(connectingEdge);\n\t\t\tparent.connectsAsTarget.push(connectingEdge);\n\t\t\tmxUtils.remove(connectingEdge, node.connectsAsTarget);\n\t\t}\n\t\t\n\t\tseenNodes[node.id] = node;\n\t\tdelete unseenNodes[node.id];\n\t}, unseenNodes, true, seenNodesCopy);\n};\n\n__mxOutput.mxMinimumCycleRemover = typeof mxMinimumCycleRemover !== 'undefined' ? mxMinimumCycleRemover : undefined;\n\n/**\n * Copyright (c) 2006-2018, JGraph Ltd\n * Copyright (c) 2006-2018, Gaudenz Alder\n */\n/**\n * Class: mxCoordinateAssignment\n * \n * Sets the horizontal locations of node and edge dummy nodes on each layer.\n * Uses median down and up weighings as well as heuristics to straighten edges as\n * far as possible.\n * \n * Constructor: mxCoordinateAssignment\n *\n * Creates a coordinate assignment.\n * \n * Arguments:\n * \n * intraCellSpacing - the minimum buffer between cells on the same rank\n * interRankCellSpacing - the minimum distance between cells on adjacent ranks\n * orientation - the position of the root node(s) relative to the graph\n * initialX - the leftmost coordinate node placement starts at\n */\nfunction mxCoordinateAssignment(layout, intraCellSpacing, interRankCellSpacing,\n\torientation, initialX, parallelEdgeSpacing)\n{\n\tthis.layout = layout;\n\tthis.intraCellSpacing = intraCellSpacing;\n\tthis.interRankCellSpacing = interRankCellSpacing;\n\tthis.orientation = orientation;\n\tthis.initialX = initialX;\n\tthis.parallelEdgeSpacing = parallelEdgeSpacing;\n};\n\n/**\n * Extends mxHierarchicalLayoutStage.\n */\nmxCoordinateAssignment.prototype = new mxHierarchicalLayoutStage();\nmxCoordinateAssignment.prototype.constructor = mxCoordinateAssignment;\n\n/**\n * Variable: layout\n * \n * Reference to the enclosing <mxHierarchicalLayout>.\n */\nmxCoordinateAssignment.prototype.layout = null;\n\n/**\n * Variable: intraCellSpacing\n * \n * The minimum buffer between cells on the same rank. Default is 30.\n */\nmxCoordinateAssignment.prototype.intraCellSpacing = 30;\n\n/**\n * Variable: interRankCellSpacing\n * \n * The minimum distance between cells on adjacent ranks. Default is 100.\n */\nmxCoordinateAssignment.prototype.interRankCellSpacing = 100;\n\n/**\n * Variable: parallelEdgeSpacing\n * \n * The distance between each parallel edge on each ranks for long edges.\n * Default is 10.\n */\nmxCoordinateAssignment.prototype.parallelEdgeSpacing = 10;\n\n/**\n * Variable: maxIterations\n * \n * The number of heuristic iterations to run. Default is 8.\n */\nmxCoordinateAssignment.prototype.maxIterations = 8;\n\n/**\n * Variable: prefHozEdgeSep\n * \n * The preferred horizontal distance between edges exiting a vertex Default is 5.\n */\nmxCoordinateAssignment.prototype.prefHozEdgeSep = 5;\n\n/**\n * Variable: prefVertEdgeOff\n * \n * The preferred vertical offset between edges exiting a vertex Default is 2.\n */\nmxCoordinateAssignment.prototype.prefVertEdgeOff = 2;\n\n/**\n * Variable: minEdgeJetty\n * \n * The minimum distance for an edge jetty from a vertex Default is 12.\n */\nmxCoordinateAssignment.prototype.minEdgeJetty = 12;\n\n/**\n * Variable: channelBuffer\n * \n * The size of the vertical buffer in the center of inter-rank channels\n * where edge control points should not be placed Default is 4.\n */\nmxCoordinateAssignment.prototype.channelBuffer = 4;\n\n/**\n * Variable: jettyPositions\n * \n * Map of internal edges and (x,y) pair of positions of the start and end jetty\n * for that edge where it connects to the source and target vertices.\n * Note this should technically be a WeakHashMap, but since JS does not\n * have an equivalent, housekeeping must be performed before using.\n * i.e. check all edges are still in the model and clear the values.\n * Note that the y co-ord is the offset of the jetty, not the\n * absolute point\n */\nmxCoordinateAssignment.prototype.jettyPositions = null;\n\n/**\n * Variable: orientation\n * \n * The position of the root ( start ) node(s) relative to the rest of the\n * laid out graph. Default is <mxConstants.DIRECTION_NORTH>.\n */\nmxCoordinateAssignment.prototype.orientation = mxConstants.DIRECTION_NORTH;\n\n/**\n * Variable: initialX\n * \n * The minimum x position node placement starts at\n */\nmxCoordinateAssignment.prototype.initialX = null;\n\n/**\n * Variable: limitX\n * \n * The maximum x value this positioning lays up to\n */\nmxCoordinateAssignment.prototype.limitX = null;\n\n/**\n * Variable: currentXDelta\n * \n * The sum of x-displacements for the current iteration\n */\nmxCoordinateAssignment.prototype.currentXDelta = null;\n\n/**\n * Variable: widestRank\n * \n * The rank that has the widest x position\n */\nmxCoordinateAssignment.prototype.widestRank = null;\n\n/**\n * Variable: rankTopY\n * \n * Internal cache of top-most values of Y for each rank\n */\nmxCoordinateAssignment.prototype.rankTopY = null;\n\n/**\n * Variable: rankBottomY\n * \n * Internal cache of bottom-most value of Y for each rank\n */\nmxCoordinateAssignment.prototype.rankBottomY = null;\n\n/**\n * Variable: widestRankValue\n * \n * The X-coordinate of the edge of the widest rank\n */\nmxCoordinateAssignment.prototype.widestRankValue = null;\n\n/**\n * Variable: rankWidths\n * \n * The width of all the ranks\n */\nmxCoordinateAssignment.prototype.rankWidths = null;\n\n/**\n * Variable: rankY\n * \n * The Y-coordinate of all the ranks\n */\nmxCoordinateAssignment.prototype.rankY = null;\n\n/**\n * Variable: fineTuning\n * \n * Whether or not to perform local optimisations and iterate multiple times\n * through the algorithm. Default is true.\n */\nmxCoordinateAssignment.prototype.fineTuning = true;\n\n/**\n * Variable: nextLayerConnectedCache\n * \n * A store of connections to the layer above for speed\n */\nmxCoordinateAssignment.prototype.nextLayerConnectedCache = null;\n\n/**\n * Variable: previousLayerConnectedCache\n * \n * A store of connections to the layer below for speed\n */\nmxCoordinateAssignment.prototype.previousLayerConnectedCache = null;\n\n/**\n * Variable: groupPadding\n * \n * Padding added to resized parents Default is 10.\n */\nmxCoordinateAssignment.prototype.groupPadding = 10;\n\n/**\n * Utility method to display current positions\n */\nmxCoordinateAssignment.prototype.printStatus = function()\n{\n\tvar model = this.layout.getModel();\n\tmxLog.show();\n\n\tmxLog.writeln('======Coord assignment debug=======');\n\n\tfor (var j = 0; j < model.ranks.length; j++)\n\t{\n\t\tmxLog.write('Rank ', j, ' : ' );\n\t\tvar rank = model.ranks[j];\n\t\t\n\t\tfor (var k = 0; k < rank.length; k++)\n\t\t{\n\t\t\tvar cell = rank[k];\n\t\t\t\n\t\t\tmxLog.write(cell.getGeneralPurposeVariable(j), '  ');\n\t\t}\n\t\tmxLog.writeln();\n\t}\n\t\n\tmxLog.writeln('====================================');\n};\n\n/**\n * Function: execute\n * \n * A basic horizontal coordinate assignment algorithm\n */\nmxCoordinateAssignment.prototype.execute = function(parent)\n{\n\tthis.jettyPositions = Object();\n\tvar model = this.layout.getModel();\n\tthis.currentXDelta = 0.0;\n\n\tthis.initialCoords(this.layout.getGraph(), model);\n\t\n//\tthis.printStatus();\n\t\n\tif (this.fineTuning)\n\t{\n\t\tthis.minNode(model);\n\t}\n\t\n\tvar bestXDelta = 100000000.0;\n\t\n\tif (this.fineTuning)\n\t{\n\t\tfor (var i = 0; i < this.maxIterations; i++)\n\t\t{\n//\t\t\tthis.printStatus();\n\t\t\n\t\t\t// Median Heuristic\n\t\t\tif (i != 0)\n\t\t\t{\n\t\t\t\tthis.medianPos(i, model);\n\t\t\t\tthis.minNode(model);\n\t\t\t}\n\t\t\t\n\t\t\t// if the total offset is less for the current positioning,\n\t\t\t// there are less heavily angled edges and so the current\n\t\t\t// positioning is used\n\t\t\tif (this.currentXDelta < bestXDelta)\n\t\t\t{\n\t\t\t\tfor (var j = 0; j < model.ranks.length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar rank = model.ranks[j];\n\t\t\t\t\t\n\t\t\t\t\tfor (var k = 0; k < rank.length; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar cell = rank[k];\n\t\t\t\t\t\tcell.setX(j, cell.getGeneralPurposeVariable(j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbestXDelta = this.currentXDelta;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Restore the best positions\n\t\t\t\tfor (var j = 0; j < model.ranks.length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar rank = model.ranks[j];\n\t\t\t\t\t\n\t\t\t\t\tfor (var k = 0; k < rank.length; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar cell = rank[k];\n\t\t\t\t\t\tcell.setGeneralPurposeVariable(j, cell.getX(j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.minPath(this.layout.getGraph(), model);\n\t\t\t\n\t\t\tthis.currentXDelta = 0;\n\t\t}\n\t}\n\t\n\tthis.setCellLocations(this.layout.getGraph(), model);\n};\n\n/**\n * Function: minNode\n * \n * Performs one median positioning sweep in both directions\n */\nmxCoordinateAssignment.prototype.minNode = function(model)\n{\n\t// Queue all nodes\n\tvar nodeList = [];\n\t\n\t// Need to be able to map from cell to cellWrapper\n\tvar map = new mxDictionary();\n\tvar rank = [];\n\t\n\tfor (var i = 0; i <= model.maxRank; i++)\n\t{\n\t\trank[i] = model.ranks[i];\n\t\t\n\t\tfor (var j = 0; j < rank[i].length; j++)\n\t\t{\n\t\t\t// Use the weight to store the rank and visited to store whether\n\t\t\t// or not the cell is in the list\n\t\t\tvar node = rank[i][j];\n\t\t\tvar nodeWrapper = new WeightedCellSorter(node, i);\n\t\t\tnodeWrapper.rankIndex = j;\n\t\t\tnodeWrapper.visited = true;\n\t\t\tnodeList.push(nodeWrapper);\n\t\t\t\n\t\t\tmap.put(node, nodeWrapper);\n\t\t}\n\t}\n\t\n\t// Set a limit of the maximum number of times we will access the queue\n\t// in case a loop appears\n\tvar maxTries = nodeList.length * 10;\n\tvar count = 0;\n\t\n\t// Don't move cell within this value of their median\n\tvar tolerance = 1;\n\t\n\twhile (nodeList.length > 0 && count <= maxTries)\n\t{\n\t\tvar cellWrapper = nodeList.shift();\n\t\tvar cell = cellWrapper.cell;\n\t\t\n\t\tvar rankValue = cellWrapper.weightedValue;\n\t\tvar rankIndex = parseInt(cellWrapper.rankIndex);\n\t\t\n\t\tvar nextLayerConnectedCells = cell.getNextLayerConnectedCells(rankValue);\n\t\tvar previousLayerConnectedCells = cell.getPreviousLayerConnectedCells(rankValue);\n\t\t\n\t\tvar numNextLayerConnected = nextLayerConnectedCells.length;\n\t\tvar numPreviousLayerConnected = previousLayerConnectedCells.length;\n\n\t\tvar medianNextLevel = this.medianXValue(nextLayerConnectedCells,\n\t\t\t\trankValue + 1);\n\t\tvar medianPreviousLevel = this.medianXValue(previousLayerConnectedCells,\n\t\t\t\trankValue - 1);\n\n\t\tvar numConnectedNeighbours = numNextLayerConnected\n\t\t\t\t+ numPreviousLayerConnected;\n\t\tvar currentPosition = cell.getGeneralPurposeVariable(rankValue);\n\t\tvar cellMedian = currentPosition;\n\t\t\n\t\tif (numConnectedNeighbours > 0)\n\t\t{\n\t\t\tcellMedian = (medianNextLevel * numNextLayerConnected + medianPreviousLevel\n\t\t\t\t\t* numPreviousLayerConnected)\n\t\t\t\t\t/ numConnectedNeighbours;\n\t\t}\n\n\t\t// Flag storing whether or not position has changed\n\t\tvar positionChanged = false;\n\t\t\n\t\tif (cellMedian < currentPosition - tolerance)\n\t\t{\n\t\t\tif (rankIndex == 0)\n\t\t\t{\n\t\t\t\tcell.setGeneralPurposeVariable(rankValue, cellMedian);\n\t\t\t\tpositionChanged = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar leftCell = rank[rankValue][rankIndex - 1];\n\t\t\t\tvar leftLimit = leftCell\n\t\t\t\t\t\t.getGeneralPurposeVariable(rankValue);\n\t\t\t\tleftLimit = leftLimit + leftCell.width / 2\n\t\t\t\t\t\t+ this.intraCellSpacing + cell.width / 2;\n\n\t\t\t\tif (leftLimit < cellMedian)\n\t\t\t\t{\n\t\t\t\t\tcell.setGeneralPurposeVariable(rankValue, cellMedian);\n\t\t\t\t\tpositionChanged = true;\n\t\t\t\t}\n\t\t\t\telse if (leftLimit < cell\n\t\t\t\t\t\t.getGeneralPurposeVariable(rankValue)\n\t\t\t\t\t\t- tolerance)\n\t\t\t\t{\n\t\t\t\t\tcell.setGeneralPurposeVariable(rankValue, leftLimit);\n\t\t\t\t\tpositionChanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (cellMedian > currentPosition + tolerance)\n\t\t{\n\t\t\tvar rankSize = rank[rankValue].length;\n\t\t\t\n\t\t\tif (rankIndex == rankSize - 1)\n\t\t\t{\n\t\t\t\tcell.setGeneralPurposeVariable(rankValue, cellMedian);\n\t\t\t\tpositionChanged = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar rightCell = rank[rankValue][rankIndex + 1];\n\t\t\t\tvar rightLimit = rightCell\n\t\t\t\t\t\t.getGeneralPurposeVariable(rankValue);\n\t\t\t\trightLimit = rightLimit - rightCell.width / 2\n\t\t\t\t\t\t- this.intraCellSpacing - cell.width / 2;\n\t\t\t\t\n\t\t\t\tif (rightLimit > cellMedian)\n\t\t\t\t{\n\t\t\t\t\tcell.setGeneralPurposeVariable(rankValue, cellMedian);\n\t\t\t\t\tpositionChanged = true;\n\t\t\t\t}\n\t\t\t\telse if (rightLimit > cell\n\t\t\t\t\t\t.getGeneralPurposeVariable(rankValue)\n\t\t\t\t\t\t+ tolerance)\n\t\t\t\t{\n\t\t\t\t\tcell.setGeneralPurposeVariable(rankValue, rightLimit);\n\t\t\t\t\tpositionChanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (positionChanged)\n\t\t{\n\t\t\t// Add connected nodes to map and list\n\t\t\tfor (var i = 0; i < nextLayerConnectedCells.length; i++)\n\t\t\t{\n\t\t\t\tvar connectedCell = nextLayerConnectedCells[i];\n\t\t\t\tvar connectedCellWrapper = map.get(connectedCell);\n\t\t\t\t\n\t\t\t\tif (connectedCellWrapper != null)\n\t\t\t\t{\n\t\t\t\t\tif (connectedCellWrapper.visited == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tconnectedCellWrapper.visited = true;\n\t\t\t\t\t\tnodeList.push(connectedCellWrapper);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add connected nodes to map and list\n\t\t\tfor (var i = 0; i < previousLayerConnectedCells.length; i++)\n\t\t\t{\n\t\t\t\tvar connectedCell = previousLayerConnectedCells[i];\n\t\t\t\tvar connectedCellWrapper = map.get(connectedCell);\n\n\t\t\t\tif (connectedCellWrapper != null)\n\t\t\t\t{\n\t\t\t\t\tif (connectedCellWrapper.visited == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tconnectedCellWrapper.visited = true;\n\t\t\t\t\t\tnodeList.push(connectedCellWrapper);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcellWrapper.visited = false;\n\t\tcount++;\n\t}\n};\n\n/**\n * Function: medianPos\n * \n * Performs one median positioning sweep in one direction\n * \n * Parameters:\n * \n * i - the iteration of the whole process\n * model - an internal model of the hierarchical layout\n */\nmxCoordinateAssignment.prototype.medianPos = function(i, model)\n{\n\t// Reverse sweep direction each time through this method\n\tvar downwardSweep = (i % 2 == 0);\n\t\n\tif (downwardSweep)\n\t{\n\t\tfor (var j = model.maxRank; j > 0; j--)\n\t\t{\n\t\t\tthis.rankMedianPosition(j - 1, model, j);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (var j = 0; j < model.maxRank - 1; j++)\n\t\t{\n\t\t\tthis.rankMedianPosition(j + 1, model, j);\n\t\t}\n\t}\n};\n\n/**\n * Function: rankMedianPosition\n * \n * Performs median minimisation over one rank.\n * \n * Parameters:\n * \n * rankValue - the layer number of this rank\n * model - an internal model of the hierarchical layout\n * nextRankValue - the layer number whose connected cels are to be laid out\n * relative to\n */\nmxCoordinateAssignment.prototype.rankMedianPosition = function(rankValue, model, nextRankValue)\n{\n\tvar rank = model.ranks[rankValue];\n\n\t// Form an array of the order in which the cell are to be processed\n\t// , the order is given by the weighted sum of the in or out edges,\n\t// depending on whether we're traveling up or down the hierarchy.\n\tvar weightedValues = [];\n\tvar cellMap = new Object();\n\n\tfor (var i = 0; i < rank.length; i++)\n\t{\n\t\tvar currentCell = rank[i];\n\t\tweightedValues[i] = new WeightedCellSorter();\n\t\tweightedValues[i].cell = currentCell;\n\t\tweightedValues[i].rankIndex = i;\n\t\tcellMap[currentCell.id] = weightedValues[i];\n\t\tvar nextLayerConnectedCells = null;\n\t\t\n\t\tif (nextRankValue < rankValue)\n\t\t{\n\t\t\tnextLayerConnectedCells = currentCell\n\t\t\t\t\t.getPreviousLayerConnectedCells(rankValue);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnextLayerConnectedCells = currentCell\n\t\t\t\t\t.getNextLayerConnectedCells(rankValue);\n\t\t}\n\n\t\t// Calculate the weighing based on this node type and those this\n\t\t// node is connected to on the next layer\n\t\tweightedValues[i].weightedValue = this.calculatedWeightedValue(\n\t\t\t\tcurrentCell, nextLayerConnectedCells);\n\t}\n\n\tweightedValues.sort(WeightedCellSorter.prototype.compare);\n\n\t// Set the new position of each node within the rank using\n\t// its temp variable\n\t\n\tfor (var i = 0; i < weightedValues.length; i++)\n\t{\n\t\tvar numConnectionsNextLevel = 0;\n\t\tvar cell = weightedValues[i].cell;\n\t\tvar nextLayerConnectedCells = null;\n\t\tvar medianNextLevel = 0;\n\n\t\tif (nextRankValue < rankValue)\n\t\t{\n\t\t\tnextLayerConnectedCells = cell.getPreviousLayerConnectedCells(\n\t\t\t\t\trankValue).slice();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnextLayerConnectedCells = cell.getNextLayerConnectedCells(\n\t\t\t\t\trankValue).slice();\n\t\t}\n\n\t\tif (nextLayerConnectedCells != null)\n\t\t{\n\t\t\tnumConnectionsNextLevel = nextLayerConnectedCells.length;\n\t\t\t\n\t\t\tif (numConnectionsNextLevel > 0)\n\t\t\t{\n\t\t\t\tmedianNextLevel = this.medianXValue(nextLayerConnectedCells,\n\t\t\t\t\t\tnextRankValue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// For case of no connections on the next level set the\n\t\t\t\t// median to be the current position and try to be\n\t\t\t\t// positioned there\n\t\t\t\tmedianNextLevel = cell.getGeneralPurposeVariable(rankValue);\n\t\t\t}\n\t\t}\n\n\t\tvar leftBuffer = 0.0;\n\t\tvar leftLimit = -100000000.0;\n\t\t\n\t\tfor (var j = weightedValues[i].rankIndex - 1; j >= 0;)\n\t\t{\n\t\t\tvar weightedValue = cellMap[rank[j].id];\n\t\t\t\n\t\t\tif (weightedValue != null)\n\t\t\t{\n\t\t\t\tvar leftCell = weightedValue.cell;\n\t\t\t\t\n\t\t\t\tif (weightedValue.visited)\n\t\t\t\t{\n\t\t\t\t\t// The left limit is the right hand limit of that\n\t\t\t\t\t// cell plus any allowance for unallocated cells\n\t\t\t\t\t// in-between\n\t\t\t\t\tleftLimit = leftCell\n\t\t\t\t\t\t\t.getGeneralPurposeVariable(rankValue)\n\t\t\t\t\t\t\t+ leftCell.width\n\t\t\t\t\t\t\t/ 2.0\n\t\t\t\t\t\t\t+ this.intraCellSpacing\n\t\t\t\t\t\t\t+ leftBuffer + cell.width / 2.0;\n\t\t\t\t\tj = -1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tleftBuffer += leftCell.width + this.intraCellSpacing;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar rightBuffer = 0.0;\n\t\tvar rightLimit = 100000000.0;\n\t\t\n\t\tfor (var j = weightedValues[i].rankIndex + 1; j < weightedValues.length;)\n\t\t{\n\t\t\tvar weightedValue = cellMap[rank[j].id];\n\t\t\t\n\t\t\tif (weightedValue != null)\n\t\t\t{\n\t\t\t\tvar rightCell = weightedValue.cell;\n\t\t\t\t\n\t\t\t\tif (weightedValue.visited)\n\t\t\t\t{\n\t\t\t\t\t// The left limit is the right hand limit of that\n\t\t\t\t\t// cell plus any allowance for unallocated cells\n\t\t\t\t\t// in-between\n\t\t\t\t\trightLimit = rightCell\n\t\t\t\t\t\t\t.getGeneralPurposeVariable(rankValue)\n\t\t\t\t\t\t\t- rightCell.width\n\t\t\t\t\t\t\t/ 2.0\n\t\t\t\t\t\t\t- this.intraCellSpacing\n\t\t\t\t\t\t\t- rightBuffer - cell.width / 2.0;\n\t\t\t\t\tj = weightedValues.length;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trightBuffer += rightCell.width + this.intraCellSpacing;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (medianNextLevel >= leftLimit && medianNextLevel <= rightLimit)\n\t\t{\n\t\t\tcell.setGeneralPurposeVariable(rankValue, medianNextLevel);\n\t\t}\n\t\telse if (medianNextLevel < leftLimit)\n\t\t{\n\t\t\t// Couldn't place at median value, place as close to that\n\t\t\t// value as possible\n\t\t\tcell.setGeneralPurposeVariable(rankValue, leftLimit);\n\t\t\tthis.currentXDelta += leftLimit - medianNextLevel;\n\t\t}\n\t\telse if (medianNextLevel > rightLimit)\n\t\t{\n\t\t\t// Couldn't place at median value, place as close to that\n\t\t\t// value as possible\n\t\t\tcell.setGeneralPurposeVariable(rankValue, rightLimit);\n\t\t\tthis.currentXDelta += medianNextLevel - rightLimit;\n\t\t}\n\n\t\tweightedValues[i].visited = true;\n\t}\n};\n\n/**\n * Function: calculatedWeightedValue\n * \n * Calculates the priority the specified cell has based on the type of its\n * cell and the cells it is connected to on the next layer\n * \n * Parameters:\n * \n * currentCell - the cell whose weight is to be calculated\n * collection - the cells the specified cell is connected to\n */\nmxCoordinateAssignment.prototype.calculatedWeightedValue = function(currentCell, collection)\n{\n\tvar totalWeight = 0;\n\t\n\tfor (var i = 0; i < collection.length; i++)\n\t{\n\t\tvar cell = collection[i];\n\n\t\tif (currentCell.isVertex() && cell.isVertex())\n\t\t{\n\t\t\ttotalWeight++;\n\t\t}\n\t\telse if (currentCell.isEdge() && cell.isEdge())\n\t\t{\n\t\t\ttotalWeight += 8;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttotalWeight += 2;\n\t\t}\n\t}\n\n\treturn totalWeight;\n};\n\n/**\n * Function: medianXValue\n * \n * Calculates the median position of the connected cell on the specified\n * rank\n * \n * Parameters:\n * \n * connectedCells - the cells the candidate connects to on this level\n * rankValue - the layer number of this rank\n */\nmxCoordinateAssignment.prototype.medianXValue = function(connectedCells, rankValue)\n{\n\tif (connectedCells.length == 0)\n\t{\n\t\treturn 0;\n\t}\n\n\tvar medianValues = [];\n\n\tfor (var i = 0; i < connectedCells.length; i++)\n\t{\n\t\tmedianValues[i] = connectedCells[i].getGeneralPurposeVariable(rankValue);\n\t}\n\n\tmedianValues.sort(function(a,b){return a - b;});\n\t\n\tif (connectedCells.length % 2 == 1)\n\t{\n\t\t// For odd numbers of adjacent vertices return the median\n\t\treturn medianValues[Math.floor(connectedCells.length / 2)];\n\t}\n\telse\n\t{\n\t\tvar medianPoint = connectedCells.length / 2;\n\t\tvar leftMedian = medianValues[medianPoint - 1];\n\t\tvar rightMedian = medianValues[medianPoint];\n\n\t\treturn ((leftMedian + rightMedian) / 2);\n\t}\n};\n\n/**\n * Function: initialCoords\n * \n * Sets up the layout in an initial positioning. The ranks are all centered\n * as much as possible along the middle vertex in each rank. The other cells\n * are then placed as close as possible on either side.\n * \n * Parameters:\n * \n * facade - the facade describing the input graph\n * model - an internal model of the hierarchical layout\n */\nmxCoordinateAssignment.prototype.initialCoords = function(facade, model)\n{\n\tthis.calculateWidestRank(facade, model);\n\n\t// Sweep up and down from the widest rank\n\tfor (var i = this.widestRank; i >= 0; i--)\n\t{\n\t\tif (i < model.maxRank)\n\t\t{\n\t\t\tthis.rankCoordinates(i, facade, model);\n\t\t}\n\t}\n\n\tfor (var i = this.widestRank+1; i <= model.maxRank; i++)\n\t{\n\t\tif (i > 0)\n\t\t{\n\t\t\tthis.rankCoordinates(i, facade, model);\n\t\t}\n\t}\n};\n\n/**\n * Function: rankCoordinates\n * \n * Sets up the layout in an initial positioning. All the first cells in each\n * rank are moved to the left and the rest of the rank inserted as close\n * together as their size and buffering permits. This method works on just\n * the specified rank.\n * \n * Parameters:\n * \n * rankValue - the current rank being processed\n * graph - the facade describing the input graph\n * model - an internal model of the hierarchical layout\n */\nmxCoordinateAssignment.prototype.rankCoordinates = function(rankValue, graph, model)\n{\n\tvar rank = model.ranks[rankValue];\n\tvar maxY = 0.0;\n\tvar localX = this.initialX + (this.widestRankValue - this.rankWidths[rankValue])\n\t\t\t/ 2;\n\n\t// Store whether or not any of the cells' bounds were unavailable so\n\t// to only issue the warning once for all cells\n\tvar boundsWarning = false;\n\t\n\tfor (var i = 0; i < rank.length; i++)\n\t{\n\t\tvar node = rank[i];\n\t\t\n\t\tif (node.isVertex())\n\t\t{\n\t\t\tvar bounds = this.layout.getVertexBounds(node.cell);\n\n\t\t\tif (bounds != null)\n\t\t\t{\n\t\t\t\tif (this.orientation == mxConstants.DIRECTION_NORTH ||\n\t\t\t\t\tthis.orientation == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t{\n\t\t\t\t\tnode.width = bounds.width;\n\t\t\t\t\tnode.height = bounds.height;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnode.width = bounds.height;\n\t\t\t\t\tnode.height = bounds.width;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tboundsWarning = true;\n\t\t\t}\n\n\t\t\tmaxY = Math.max(maxY, node.height);\n\t\t}\n\t\telse if (node.isEdge())\n\t\t{\n\t\t\t// The width is the number of additional parallel edges\n\t\t\t// time the parallel edge spacing\n\t\t\tvar numEdges = 1;\n\n\t\t\tif (node.edges != null)\n\t\t\t{\n\t\t\t\tnumEdges = node.edges.length;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmxLog.warn('edge.edges is null');\n\t\t\t}\n\n\t\t\tnode.width = (numEdges - 1) * this.parallelEdgeSpacing;\n\t\t}\n\n\t\t// Set the initial x-value as being the best result so far\n\t\tlocalX += node.width / 2.0;\n\t\tnode.setX(rankValue, localX);\n\t\tnode.setGeneralPurposeVariable(rankValue, localX);\n\t\tlocalX += node.width / 2.0;\n\t\tlocalX += this.intraCellSpacing;\n\t}\n\n\tif (boundsWarning == true)\n\t{\n\t\tmxLog.warn('At least one cell has no bounds');\n\t}\n};\n\n/**\n * Function: calculateWidestRank\n * \n * Calculates the width rank in the hierarchy. Also set the y value of each\n * rank whilst performing the calculation\n * \n * Parameters:\n * \n * graph - the facade describing the input graph\n * model - an internal model of the hierarchical layout\n */\nmxCoordinateAssignment.prototype.calculateWidestRank = function(graph, model)\n{\n\t// Starting y co-ordinate\n\tvar y = -this.interRankCellSpacing;\n\t\n\t// Track the widest cell on the last rank since the y\n\t// difference depends on it\n\tvar lastRankMaxCellHeight = 0.0;\n\tthis.rankWidths = [];\n\tthis.rankY = [];\n\n\tfor (var rankValue = model.maxRank; rankValue >= 0; rankValue--)\n\t{\n\t\t// Keep track of the widest cell on this rank\n\t\tvar maxCellHeight = 0.0;\n\t\tvar rank = model.ranks[rankValue];\n\t\tvar localX = this.initialX;\n\n\t\t// Store whether or not any of the cells' bounds were unavailable so\n\t\t// to only issue the warning once for all cells\n\t\tvar boundsWarning = false;\n\t\t\n\t\tfor (var i = 0; i < rank.length; i++)\n\t\t{\n\t\t\tvar node = rank[i];\n\n\t\t\tif (node.isVertex())\n\t\t\t{\n\t\t\t\tvar bounds = this.layout.getVertexBounds(node.cell);\n\n\t\t\t\tif (bounds != null)\n\t\t\t\t{\n\t\t\t\t\tif (this.orientation == mxConstants.DIRECTION_NORTH ||\n\t\t\t\t\t\tthis.orientation == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.width = bounds.width;\n\t\t\t\t\t\tnode.height = bounds.height;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.width = bounds.height;\n\t\t\t\t\t\tnode.height = bounds.width;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tboundsWarning = true;\n\t\t\t\t}\n\n\t\t\t\tmaxCellHeight = Math.max(maxCellHeight, node.height);\n\t\t\t}\n\t\t\telse if (node.isEdge())\n\t\t\t{\n\t\t\t\t// The width is the number of additional parallel edges\n\t\t\t\t// time the parallel edge spacing\n\t\t\t\tvar numEdges = 1;\n\n\t\t\t\tif (node.edges != null)\n\t\t\t\t{\n\t\t\t\t\tnumEdges = node.edges.length;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmxLog.warn('edge.edges is null');\n\t\t\t\t}\n\n\t\t\t\tnode.width = (numEdges - 1) * this.parallelEdgeSpacing;\n\t\t\t}\n\n\t\t\t// Set the initial x-value as being the best result so far\n\t\t\tlocalX += node.width / 2.0;\n\t\t\tnode.setX(rankValue, localX);\n\t\t\tnode.setGeneralPurposeVariable(rankValue, localX);\n\t\t\tlocalX += node.width / 2.0;\n\t\t\tlocalX += this.intraCellSpacing;\n\n\t\t\tif (localX > this.widestRankValue)\n\t\t\t{\n\t\t\t\tthis.widestRankValue = localX;\n\t\t\t\tthis.widestRank = rankValue;\n\t\t\t}\n\n\t\t\tthis.rankWidths[rankValue] = localX;\n\t\t}\n\n\t\tif (boundsWarning == true)\n\t\t{\n\t\t\tmxLog.warn('At least one cell has no bounds');\n\t\t}\n\n\t\tthis.rankY[rankValue] = y;\n\t\tvar distanceToNextRank = maxCellHeight / 2.0\n\t\t\t\t+ lastRankMaxCellHeight / 2.0 + this.interRankCellSpacing;\n\t\tlastRankMaxCellHeight = maxCellHeight;\n\n\t\tif (this.orientation == mxConstants.DIRECTION_NORTH ||\n\t\t\tthis.orientation == mxConstants.DIRECTION_WEST)\n\t\t{\n\t\t\ty += distanceToNextRank;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ty -= distanceToNextRank;\n\t\t}\n\n\t\tfor (var i = 0; i < rank.length; i++)\n\t\t{\n\t\t\tvar cell = rank[i];\n\t\t\tcell.setY(rankValue, y);\n\t\t}\n\t}\n};\n\n/**\n * Function: minPath\n * \n * Straightens out chains of virtual nodes where possibleacade to those stored after this layout\n * processing step has completed.\n * \n * Parameters:\n *\n * graph - the facade describing the input graph\n * model - an internal model of the hierarchical layout\n */\nmxCoordinateAssignment.prototype.minPath = function(graph, model)\n{\n\t// Work down and up each edge with at least 2 control points\n\t// trying to straighten each one out. If the same number of\n\t// straight segments are formed in both directions, the \n\t// preferred direction used is the one where the final\n\t// control points have the least offset from the connectable \n\t// region of the terminating vertices\n\tvar edges = model.edgeMapper.getValues();\n\t\n\tfor (var j = 0; j < edges.length; j++)\n\t{\n\t\tvar cell = edges[j];\n\t\t\n\t\tif (cell.maxRank - cell.minRank - 1 < 1)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t// At least two virtual nodes in the edge\n\t\t// Check first whether the edge is already straight\n\t\tvar referenceX = cell\n\t\t\t\t.getGeneralPurposeVariable(cell.minRank + 1);\n\t\tvar edgeStraight = true;\n\t\tvar refSegCount = 0;\n\t\t\n\t\tfor (var i = cell.minRank + 2; i < cell.maxRank; i++)\n\t\t{\n\t\t\tvar x = cell.getGeneralPurposeVariable(i);\n\n\t\t\tif (referenceX != x)\n\t\t\t{\n\t\t\t\tedgeStraight = false;\n\t\t\t\treferenceX = x;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trefSegCount++;\n\t\t\t}\n\t\t}\n\n\t\tif (!edgeStraight)\n\t\t{\n\t\t\tvar upSegCount = 0;\n\t\t\tvar downSegCount = 0;\n\t\t\tvar upXPositions = [];\n\t\t\tvar downXPositions = [];\n\n\t\t\tvar currentX = cell.getGeneralPurposeVariable(cell.minRank + 1);\n\n\t\t\tfor (var i = cell.minRank + 1; i < cell.maxRank - 1; i++)\n\t\t\t{\n\t\t\t\t// Attempt to straight out the control point on the\n\t\t\t\t// next segment up with the current control point.\n\t\t\t\tvar nextX = cell.getX(i + 1);\n\n\t\t\t\tif (currentX == nextX)\n\t\t\t\t{\n\t\t\t\t\tupXPositions[i - cell.minRank - 1] = currentX;\n\t\t\t\t\tupSegCount++;\n\t\t\t\t}\n\t\t\t\telse if (this.repositionValid(model, cell, i + 1, currentX))\n\t\t\t\t{\n\t\t\t\t\tupXPositions[i - cell.minRank - 1] = currentX;\n\t\t\t\t\tupSegCount++;\n\t\t\t\t\t// Leave currentX at same value\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupXPositions[i - cell.minRank - 1] = nextX;\n\t\t\t\t\tcurrentX = nextX;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\n\t\t\tcurrentX = cell.getX(i);\n\n\t\t\tfor (var i = cell.maxRank - 1; i > cell.minRank + 1; i--)\n\t\t\t{\n\t\t\t\t// Attempt to straight out the control point on the\n\t\t\t\t// next segment down with the current control point.\n\t\t\t\tvar nextX = cell.getX(i - 1);\n\n\t\t\t\tif (currentX == nextX)\n\t\t\t\t{\n\t\t\t\t\tdownXPositions[i - cell.minRank - 2] = currentX;\n\t\t\t\t\tdownSegCount++;\n\t\t\t\t}\n\t\t\t\telse if (this.repositionValid(model, cell, i - 1, currentX))\n\t\t\t\t{\n\t\t\t\t\tdownXPositions[i - cell.minRank - 2] = currentX;\n\t\t\t\t\tdownSegCount++;\n\t\t\t\t\t// Leave currentX at same value\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdownXPositions[i - cell.minRank - 2] = cell.getX(i-1);\n\t\t\t\t\tcurrentX = nextX;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (downSegCount > refSegCount || upSegCount > refSegCount)\n\t\t\t{\n\t\t\t\tif (downSegCount >= upSegCount)\n\t\t\t\t{\n\t\t\t\t\t// Apply down calculation values\n\t\t\t\t\tfor (var i = cell.maxRank - 2; i > cell.minRank; i--)\n\t\t\t\t\t{\n\t\t\t\t\t\tcell.setX(i, downXPositions[i - cell.minRank - 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (upSegCount > downSegCount)\n\t\t\t\t{\n\t\t\t\t\t// Apply up calculation values\n\t\t\t\t\tfor (var i = cell.minRank + 2; i < cell.maxRank; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcell.setX(i, upXPositions[i - cell.minRank - 2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Neither direction provided a favourable result\n\t\t\t\t\t// But both calculations are better than the\n\t\t\t\t\t// existing solution, so apply the one with minimal\n\t\t\t\t\t// offset to attached vertices at either end.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: repositionValid\n * \n * Determines whether or not a node may be moved to the specified x \n * position on the specified rank\n * \n * Parameters:\n *\n * model - the layout model\n * cell - the cell being analysed\n * rank - the layer of the cell\n * position - the x position being sought\n */\nmxCoordinateAssignment.prototype.repositionValid = function(model, cell, rank, position)\n{\n\tvar rankArray = model.ranks[rank];\n\tvar rankIndex = -1;\n\n\tfor (var i = 0; i < rankArray.length; i++)\n\t{\n\t\tif (cell == rankArray[i])\n\t\t{\n\t\t\trankIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rankIndex < 0)\n\t{\n\t\treturn false;\n\t}\n\n\tvar currentX = cell.getGeneralPurposeVariable(rank);\n\n\tif (position < currentX)\n\t{\n\t\t// Trying to move node to the left.\n\t\tif (rankIndex == 0)\n\t\t{\n\t\t\t// Left-most node, can move anywhere\n\t\t\treturn true;\n\t\t}\n\n\t\tvar leftCell = rankArray[rankIndex - 1];\n\t\tvar leftLimit = leftCell.getGeneralPurposeVariable(rank);\n\t\tleftLimit = leftLimit + leftCell.width / 2\n\t\t\t\t+ this.intraCellSpacing + cell.width / 2;\n\n\t\tif (leftLimit <= position)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\telse if (position > currentX)\n\t{\n\t\t// Trying to move node to the right.\n\t\tif (rankIndex == rankArray.length - 1)\n\t\t{\n\t\t\t// Right-most node, can move anywhere\n\t\t\treturn true;\n\t\t}\n\n\t\tvar rightCell = rankArray[rankIndex + 1];\n\t\tvar rightLimit = rightCell.getGeneralPurposeVariable(rank);\n\t\trightLimit = rightLimit - rightCell.width / 2\n\t\t\t\t- this.intraCellSpacing - cell.width / 2;\n\n\t\tif (rightLimit >= position)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\n/**\n * Function: setCellLocations\n * \n * Sets the cell locations in the facade to those stored after this layout\n * processing step has completed.\n * \n * Parameters:\n *\n * graph - the input graph\n * model - the layout model\n */\nmxCoordinateAssignment.prototype.setCellLocations = function(graph, model)\n{\n\tthis.rankTopY = [];\n\tthis.rankBottomY = [];\n\n\tfor (var i = 0; i < model.ranks.length; i++)\n\t{\n\t\tthis.rankTopY[i] = Number.MAX_VALUE;\n\t\tthis.rankBottomY[i] = -Number.MAX_VALUE;\n\t}\n\t\n\tvar vertices = model.vertexMapper.getValues();\n\n\t// Process vertices all first, since they define the lower and \n\t// limits of each rank. Between these limits lie the channels\n\t// where the edges can be routed across the graph\n\n\tfor (var i = 0; i < vertices.length; i++)\n\t{\n\t\tthis.setVertexLocation(vertices[i]);\n\t}\n\t\n\t// Post process edge styles. Needs the vertex locations set for initial\n\t// values of the top and bottoms of each rank\n\tif (this.layout.edgeStyle == mxHierarchicalEdgeStyle.ORTHOGONAL\n\t\t\t|| this.layout.edgeStyle == mxHierarchicalEdgeStyle.POLYLINE\n\t\t\t|| this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE)\n\t{\n\t\tthis.localEdgeProcessing(model);\n\t}\n\n\tvar edges = model.edgeMapper.getValues();\n\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tthis.setEdgePosition(edges[i]);\n\t}\n};\n\n/**\n * Function: localEdgeProcessing\n * \n * Separates the x position of edges as they connect to vertices\n * \n * Parameters:\n *\n * model - the layout model\n */\nmxCoordinateAssignment.prototype.localEdgeProcessing = function(model)\n{\n\t// Iterate through each vertex, look at the edges connected in\n\t// both directions.\n\tfor (var rankIndex = 0; rankIndex < model.ranks.length; rankIndex++)\n\t{\n\t\tvar rank = model.ranks[rankIndex];\n\n\t\tfor (var cellIndex = 0; cellIndex < rank.length; cellIndex++)\n\t\t{\n\t\t\tvar cell = rank[cellIndex];\n\n\t\t\tif (cell.isVertex())\n\t\t\t{\n\t\t\t\tvar currentCells = cell.getPreviousLayerConnectedCells(rankIndex);\n\n\t\t\t\tvar currentRank = rankIndex - 1;\n\n\t\t\t\t// Two loops, last connected cells, and next\n\t\t\t\tfor (var k = 0; k < 2; k++)\n\t\t\t\t{\n\t\t\t\t\tif (currentRank > -1\n\t\t\t\t\t\t\t&& currentRank < model.ranks.length\n\t\t\t\t\t\t\t&& currentCells != null\n\t\t\t\t\t\t\t&& currentCells.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar sortedCells = [];\n\n\t\t\t\t\t\tfor (var j = 0; j < currentCells.length; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar sorter = new WeightedCellSorter(\n\t\t\t\t\t\t\t\t\tcurrentCells[j], currentCells[j].getX(currentRank));\n\t\t\t\t\t\t\tsortedCells.push(sorter);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsortedCells.sort(WeightedCellSorter.prototype.compare);\n\n\t\t\t\t\t\tvar leftLimit = cell.x[0] - cell.width / 2;\n\t\t\t\t\t\tvar rightLimit = leftLimit + cell.width;\n\n\t\t\t\t\t\t// Connected edge count starts at 1 to allow for buffer\n\t\t\t\t\t\t// with edge of vertex\n\t\t\t\t\t\tvar connectedEdgeCount = 0;\n\t\t\t\t\t\tvar connectedEdgeGroupCount = 0;\n\t\t\t\t\t\tvar connectedEdges = [];\n\t\t\t\t\t\t// Calculate width requirements for all connected edges\n\t\t\t\t\t\tfor (var j = 0; j < sortedCells.length; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar innerCell = sortedCells[j].cell;\n\t\t\t\t\t\t\tvar connections;\n\n\t\t\t\t\t\t\tif (innerCell.isVertex())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Get the connecting edge\n\t\t\t\t\t\t\t\tif (k == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tconnections = cell.connectsAsSource;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tconnections = cell.connectsAsTarget;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfor (var connIndex = 0; connIndex < connections.length; connIndex++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (connections[connIndex].source == innerCell\n\t\t\t\t\t\t\t\t\t\t\t|| connections[connIndex].target == innerCell)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tconnectedEdgeCount += connections[connIndex].edges\n\t\t\t\t\t\t\t\t\t\t\t\t.length;\n\t\t\t\t\t\t\t\t\t\tconnectedEdgeGroupCount++;\n\n\t\t\t\t\t\t\t\t\t\tconnectedEdges.push(connections[connIndex]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tconnectedEdgeCount += innerCell.edges.length;\n\t\t\t\t\t\t\t\tconnectedEdgeGroupCount++;\n\t\t\t\t\t\t\t\tconnectedEdges.push(innerCell);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar requiredWidth = (connectedEdgeCount + 1)\n\t\t\t\t\t\t\t\t* this.prefHozEdgeSep;\n\n\t\t\t\t\t\t// Add a buffer on the edges of the vertex if the edge count allows\n\t\t\t\t\t\tif (cell.width > requiredWidth\n\t\t\t\t\t\t\t\t+ (2 * this.prefHozEdgeSep))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tleftLimit += this.prefHozEdgeSep;\n\t\t\t\t\t\t\trightLimit -= this.prefHozEdgeSep;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar availableWidth = rightLimit - leftLimit;\n\t\t\t\t\t\tvar edgeSpacing = availableWidth / connectedEdgeCount;\n\n\t\t\t\t\t\tvar currentX = leftLimit + edgeSpacing / 2.0;\n\t\t\t\t\t\tvar currentYOffset = this.minEdgeJetty - this.prefVertEdgeOff;\n\t\t\t\t\t\tvar maxYOffset = 0;\n\n\t\t\t\t\t\tfor (var j = 0; j < connectedEdges.length; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar numActualEdges = connectedEdges[j].edges\n\t\t\t\t\t\t\t\t\t.length;\n\t\t\t\t\t\t\tvar pos = this.jettyPositions[connectedEdges[j].ids[0]];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (pos == null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpos = [];\n\t\t\t\t\t\t\t\tthis.jettyPositions[connectedEdges[j].ids[0]] = pos;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (j < connectedEdgeCount / 2)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcurrentYOffset += this.prefVertEdgeOff;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (j > connectedEdgeCount / 2)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcurrentYOffset -= this.prefVertEdgeOff;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Ignore the case if equals, this means the second of 2\n\t\t\t\t\t\t\t// jettys with the same y (even number of edges)\n\n\t\t\t\t\t\t\tfor (var m = 0; m < numActualEdges; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpos[m * 4 + k * 2] = currentX;\n\t\t\t\t\t\t\t\tcurrentX += edgeSpacing;\n\t\t\t\t\t\t\t\tpos[m * 4 + k * 2 + 1] = currentYOffset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tmaxYOffset = Math.max(maxYOffset,\n\t\t\t\t\t\t\t\t\tcurrentYOffset);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentCells = cell.getNextLayerConnectedCells(rankIndex);\n\n\t\t\t\t\tcurrentRank = rankIndex + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: setEdgePosition\n * \n * Fixes the control points\n */\nmxCoordinateAssignment.prototype.setEdgePosition = function(cell)\n{\n\t// For parallel edges we need to seperate out the points a\n\t// little\n\tvar offsetX = 0;\n\t// Only set the edge control points once\n\n\tif (cell.temp[0] != 101207)\n\t{\n\t\tvar maxRank = cell.maxRank;\n\t\tvar minRank = cell.minRank;\n\t\t\n\t\tif (maxRank == minRank)\n\t\t{\n\t\t\tmaxRank = cell.source.maxRank;\n\t\t\tminRank = cell.target.minRank;\n\t\t}\n\t\t\n\t\tvar parallelEdgeCount = 0;\n\t\tvar jettys = this.jettyPositions[cell.ids[0]];\n\n\t\tvar source = cell.isReversed ? cell.target.cell : cell.source.cell;\n\t\tvar graph = this.layout.graph;\n\t\tvar layoutReversed = this.orientation == mxConstants.DIRECTION_EAST\n\t\t\t\t|| this.orientation == mxConstants.DIRECTION_SOUTH;\n\n\t\tfor (var i = 0; i < cell.edges.length; i++)\n\t\t{\n\t\t\tvar realEdge = cell.edges[i];\n\t\t\tvar realSource = this.layout.getVisibleTerminal(realEdge, true);\n\n\t\t\t//List oldPoints = graph.getPoints(realEdge);\n\t\t\tvar newPoints = [];\n\n\t\t\t// Single length reversed edges end up with the jettys in the wrong\n\t\t\t// places. Since single length edges only have jettys, not segment\n\t\t\t// control points, we just say the edge isn't reversed in this section\n\t\t\tvar reversed = cell.isReversed;\n\t\t\t\n\t\t\tif (realSource != source)\n\t\t\t{\n\t\t\t\t// The real edges include all core model edges and these can go\n\t\t\t\t// in both directions. If the source of the hierarchical model edge\n\t\t\t\t// isn't the source of the specific real edge in this iteration\n\t\t\t\t// treat if as reversed\n\t\t\t\treversed = !reversed;\n\t\t\t}\n\n\t\t\t// First jetty of edge\n\t\t\tif (jettys != null)\n\t\t\t{\n\t\t\t\tvar arrayOffset = reversed ? 2 : 0;\n\t\t\t\tvar y = reversed ?\n\t\t\t\t\t\t(layoutReversed ? this.rankBottomY[minRank] : this.rankTopY[minRank]) :\n\t\t\t\t\t\t\t(layoutReversed ? this.rankTopY[maxRank] : this.rankBottomY[maxRank]);\n\t\t\t\tvar jetty = jettys[parallelEdgeCount * 4 + 1 + arrayOffset];\n\t\t\t\t\n\t\t\t\tif (reversed != layoutReversed)\n\t\t\t\t{\n\t\t\t\t\tjetty = -jetty;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ty += jetty;\n\t\t\t\tvar x = jettys[parallelEdgeCount * 4 + arrayOffset];\n\t\t\t\t\n\t\t\t\tvar modelSource = graph.model.getTerminal(realEdge, true);\n\n\t\t\t\tif (this.layout.isPort(modelSource) && graph.model.getParent(modelSource) == realSource)\n\t\t\t\t{\n\t\t\t\t\tvar state = graph.view.getState(modelSource);\n\t\t\t\t\t\n\t\t\t\t\tif (state != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = state.x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tx = realSource.geometry.x + cell.source.width * modelSource.geometry.x;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.orientation == mxConstants.DIRECTION_NORTH\n\t\t\t\t\t\t|| this.orientation == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t{\n\t\t\t\t\tnewPoints.push(new mxPoint(x, y));\n\t\t\t\t\t\n\t\t\t\t\tif (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewPoints.push(new mxPoint(x, y + jetty));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnewPoints.push(new mxPoint(y, x));\n\t\t\t\t\t\n\t\t\t\t\tif (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewPoints.push(new mxPoint(y + jetty, x));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Declare variables to define loop through edge points and \n\t\t\t// change direction if edge is reversed\n\n\t\t\tvar loopStart = cell.x.length - 1;\n\t\t\tvar loopLimit = -1;\n\t\t\tvar loopDelta = -1;\n\t\t\tvar currentRank = cell.maxRank - 1;\n\n\t\t\tif (reversed)\n\t\t\t{\n\t\t\t\tloopStart = 0;\n\t\t\t\tloopLimit = cell.x.length;\n\t\t\t\tloopDelta = 1;\n\t\t\t\tcurrentRank = cell.minRank + 1;\n\t\t\t}\n\t\t\t// Reversed edges need the points inserted in\n\t\t\t// reverse order\n\t\t\tfor (var j = loopStart; (cell.maxRank != cell.minRank) && j != loopLimit; j += loopDelta)\n\t\t\t{\n\t\t\t\t// The horizontal position in a vertical layout\n\t\t\t\tvar positionX = cell.x[j] + offsetX;\n\n\t\t\t\t// Work out the vertical positions in a vertical layout\n\t\t\t\t// in the edge buffer channels above and below this rank\n\t\t\t\tvar topChannelY = (this.rankTopY[currentRank] + this.rankBottomY[currentRank + 1]) / 2.0;\n\t\t\t\tvar bottomChannelY = (this.rankTopY[currentRank - 1] + this.rankBottomY[currentRank]) / 2.0;\n\n\t\t\t\tif (reversed)\n\t\t\t\t{\n\t\t\t\t\tvar tmp = topChannelY;\n\t\t\t\t\ttopChannelY = bottomChannelY;\n\t\t\t\t\tbottomChannelY = tmp;\n\t\t\t\t}\n\n\t\t\t\tif (this.orientation == mxConstants.DIRECTION_NORTH ||\n\t\t\t\t\tthis.orientation == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t{\n\t\t\t\t\tnewPoints.push(new mxPoint(positionX, topChannelY));\n\t\t\t\t\tnewPoints.push(new mxPoint(positionX, bottomChannelY));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnewPoints.push(new mxPoint(topChannelY, positionX));\n\t\t\t\t\tnewPoints.push(new mxPoint(bottomChannelY, positionX));\n\t\t\t\t}\n\n\t\t\t\tthis.limitX = Math.max(this.limitX, positionX);\n\t\t\t\tcurrentRank += loopDelta;\n\t\t\t}\n\n\t\t\t// Second jetty of edge\n\t\t\tif (jettys != null)\n\t\t\t{\n\t\t\t\tvar arrayOffset = reversed ? 2 : 0;\n\t\t\t\tvar rankY = reversed ?\n\t\t\t\t\t\t(layoutReversed ? this.rankTopY[maxRank] : this.rankBottomY[maxRank]) :\n\t\t\t\t\t\t\t(layoutReversed ? this.rankBottomY[minRank] : this.rankTopY[minRank]);\n\t\t\t\tvar jetty = jettys[parallelEdgeCount * 4 + 3 - arrayOffset];\n\t\t\t\t\n\t\t\t\tif (reversed != layoutReversed)\n\t\t\t\t{\n\t\t\t\t\tjetty = -jetty;\n\t\t\t\t}\n\t\t\t\tvar y = rankY - jetty;\n\t\t\t\tvar x = jettys[parallelEdgeCount * 4 + 2 - arrayOffset];\n\t\t\t\t\n\t\t\t\tvar modelTarget = graph.model.getTerminal(realEdge, false);\n\t\t\t\tvar realTarget = this.layout.getVisibleTerminal(realEdge, false);\n\n\t\t\t\tif (this.layout.isPort(modelTarget) && graph.model.getParent(modelTarget) == realTarget)\n\t\t\t\t{\n\t\t\t\t\tvar state = graph.view.getState(modelTarget);\n\t\t\t\t\t\n\t\t\t\t\tif (state != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = state.x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tx = realTarget.geometry.x + cell.target.width * modelTarget.geometry.x;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.orientation == mxConstants.DIRECTION_NORTH ||\n\t\t\t\t\t\tthis.orientation == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t{\n\t\t\t\t\tif (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewPoints.push(new mxPoint(x, y - jetty));\n\t\t\t\t\t}\n\n\t\t\t\t\tnewPoints.push(new mxPoint(x, y));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewPoints.push(new mxPoint(y - jetty, x));\n\t\t\t\t\t}\n\n\t\t\t\t\tnewPoints.push(new mxPoint(y, x));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cell.isReversed)\n\t\t\t{\n\t\t\t\tthis.processReversedEdge(cell, realEdge);\n\t\t\t}\n\n\t\t\tthis.layout.setEdgePoints(realEdge, newPoints);\n\n\t\t\t// Increase offset so next edge is drawn next to\n\t\t\t// this one\n\t\t\tif (offsetX == 0.0)\n\t\t\t{\n\t\t\t\toffsetX = this.parallelEdgeSpacing;\n\t\t\t}\n\t\t\telse if (offsetX > 0)\n\t\t\t{\n\t\t\t\toffsetX = -offsetX;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\toffsetX = -offsetX + this.parallelEdgeSpacing;\n\t\t\t}\n\t\t\t\n\t\t\tparallelEdgeCount++;\n\t\t}\n\n\t\tcell.temp[0] = 101207;\n\t}\n};\n\n\n/**\n * Function: setVertexLocation\n * \n * Fixes the position of the specified vertex.\n * \n * Parameters:\n * \n * cell - the vertex to position\n */\nmxCoordinateAssignment.prototype.setVertexLocation = function(cell)\n{\n\tvar realCell = cell.cell;\n\tvar positionX = cell.x[0] - cell.width / 2;\n\tvar positionY = cell.y[0] - cell.height / 2;\n\n\tthis.rankTopY[cell.minRank] = Math.min(this.rankTopY[cell.minRank], positionY);\n\tthis.rankBottomY[cell.minRank] = Math.max(this.rankBottomY[cell.minRank],\n\t\t\tpositionY + cell.height);\n\n\tif (this.orientation == mxConstants.DIRECTION_NORTH ||\n\t\tthis.orientation == mxConstants.DIRECTION_SOUTH)\n\t{\n\t\tthis.layout.setVertexLocation(realCell, positionX, positionY);\n\t}\n\telse\n\t{\n\t\tthis.layout.setVertexLocation(realCell, positionY, positionX);\n\t}\n\n\tthis.limitX = Math.max(this.limitX, positionX + cell.width);\n};\n\n/**\n * Function: processReversedEdge\n * \n * Hook to add additional processing\n * \n * Parameters:\n * \n * edge - the hierarchical model edge\n * realEdge - the real edge in the graph\n */\nmxCoordinateAssignment.prototype.processReversedEdge = function(graph, model)\n{\n\t// hook for subclassers\n};\n\n__mxOutput.mxCoordinateAssignment = typeof mxCoordinateAssignment !== 'undefined' ? mxCoordinateAssignment : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxSwimlaneOrdering\n * \n * An implementation of the first stage of the Sugiyama layout. Straightforward\n * longest path calculation of layer assignment\n * \n * Constructor: mxSwimlaneOrdering\n *\n * Creates a cycle remover for the given internal model.\n */\nfunction mxSwimlaneOrdering(layout)\n{\n\tthis.layout = layout;\n};\n\n/**\n * Extends mxHierarchicalLayoutStage.\n */\nmxSwimlaneOrdering.prototype = new mxHierarchicalLayoutStage();\nmxSwimlaneOrdering.prototype.constructor = mxSwimlaneOrdering;\n\n/**\n * Variable: layout\n * \n * Reference to the enclosing <mxHierarchicalLayout>.\n */\nmxSwimlaneOrdering.prototype.layout = null;\n\n/**\n * Function: execute\n * \n * Takes the graph detail and configuration information within the facade\n * and creates the resulting laid out graph within that facade for further\n * use.\n */\nmxSwimlaneOrdering.prototype.execute = function(parent)\n{\n\tvar model = this.layout.getModel();\n\tvar seenNodes = new Object();\n\tvar unseenNodes = mxUtils.clone(model.vertexMapper, null, true);\n\t\n\t// Perform a dfs through the internal model. If a cycle is found,\n\t// reverse it.\n\tvar rootsArray = null;\n\t\n\tif (model.roots != null)\n\t{\n\t\tvar modelRoots = model.roots;\n\t\trootsArray = [];\n\t\t\n\t\tfor (var i = 0; i < modelRoots.length; i++)\n\t\t{\n\t\t\trootsArray[i] = model.vertexMapper.get(modelRoots[i]);\n\t\t}\n\t}\n\n\tmodel.visit(function(parent, node, connectingEdge, layer, seen)\n\t{\n\t\t// Check if the cell is in it's own ancestor list, if so\n\t\t// invert the connecting edge and reverse the target/source\n\t\t// relationship to that edge in the parent and the cell\n\t\t// Ancestor hashes only line up within a swimlane\n\t\tvar isAncestor = parent != null && parent.swimlaneIndex == node.swimlaneIndex && node.isAncestor(parent);\n\n\t\t// If the source->target swimlane indices go from higher to\n\t\t// lower, the edge is reverse\n\t\tvar reversedOverSwimlane = parent != null && connectingEdge != null &&\n\t\t\t\t\t\tparent.swimlaneIndex < node.swimlaneIndex && connectingEdge.source == node;\n\n\t\tif (isAncestor)\n\t\t{\n\t\t\tconnectingEdge.invert();\n\t\t\tmxUtils.remove(connectingEdge, parent.connectsAsSource);\n\t\t\tnode.connectsAsSource.push(connectingEdge);\n\t\t\tparent.connectsAsTarget.push(connectingEdge);\n\t\t\tmxUtils.remove(connectingEdge, node.connectsAsTarget);\n\t\t}\n\t\telse if (reversedOverSwimlane)\n\t\t{\n\t\t\tconnectingEdge.invert();\n\t\t\tmxUtils.remove(connectingEdge, parent.connectsAsTarget);\n\t\t\tnode.connectsAsTarget.push(connectingEdge);\n\t\t\tparent.connectsAsSource.push(connectingEdge);\n\t\t\tmxUtils.remove(connectingEdge, node.connectsAsSource);\n\t\t}\n\t\t\n\t\tvar cellId = mxCellPath.create(node.cell);\n\t\tseenNodes[cellId] = node;\n\t\tdelete unseenNodes[cellId];\n\t}, rootsArray, true, null);\n};\n\n__mxOutput.mxSwimlaneOrdering = typeof mxSwimlaneOrdering !== 'undefined' ? mxSwimlaneOrdering : undefined;\n\n/**\n * Copyright (c) 2006-2018, JGraph Ltd\n * Copyright (c) 2006-2018, Gaudenz Alder\n */\n/**\n * Class: mxHierarchicalLayout\n * \n * A hierarchical layout algorithm.\n * \n * Constructor: mxHierarchicalLayout\n *\n * Constructs a new hierarchical layout algorithm.\n *\n * Arguments:\n * \n * graph - Reference to the enclosing <mxGraph>.\n * orientation - Optional constant that defines the orientation of this\n * layout.\n * deterministic - Optional boolean that specifies if this layout should be\n * deterministic. Default is true.\n */\nfunction mxHierarchicalLayout(graph, orientation, deterministic)\n{\n\tmxGraphLayout.call(this, graph);\n\tthis.orientation = (orientation != null) ? orientation : mxConstants.DIRECTION_NORTH;\n\tthis.deterministic = (deterministic != null) ? deterministic : true;\n};\n\nvar mxHierarchicalEdgeStyle =\n{\n\tORTHOGONAL: 1,\n\tPOLYLINE: 2,\n\tSTRAIGHT: 3,\n\tCURVE: 4\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxHierarchicalLayout.prototype = new mxGraphLayout();\nmxHierarchicalLayout.prototype.constructor = mxHierarchicalLayout;\n\n/**\n * Variable: roots\n * \n * Holds the array of <mxCell> that this layout contains.\n */\nmxHierarchicalLayout.prototype.roots = null;\n\n/**\n * Variable: resizeParent\n * \n * Specifies if the parent should be resized after the layout so that it\n * contains all the child cells. Default is false. See also <parentBorder>.\n */\nmxHierarchicalLayout.prototype.resizeParent = false;\n\n/**\n * Variable: maintainParentLocation\n * \n * Specifies if the parent location should be maintained, so that the\n * top, left corner stays the same before and after execution of\n * the layout. Default is false for backwards compatibility.\n */\nmxHierarchicalLayout.prototype.maintainParentLocation = false;\n\n/**\n * Variable: moveParent\n * \n * Specifies if the parent should be moved if <resizeParent> is enabled.\n * Default is false.\n */\nmxHierarchicalLayout.prototype.moveParent = false;\n\n/**\n * Variable: parentBorder\n * \n * The border to be added around the children if the parent is to be\n * resized using <resizeParent>. Default is 0.\n */\nmxHierarchicalLayout.prototype.parentBorder = 0;\n\n/**\n * Variable: intraCellSpacing\n * \n * The spacing buffer added between cells on the same layer. Default is 30.\n */\nmxHierarchicalLayout.prototype.intraCellSpacing = 30;\n\n/**\n * Variable: interRankCellSpacing\n * \n * The spacing buffer added between cell on adjacent layers. Default is 100.\n */\nmxHierarchicalLayout.prototype.interRankCellSpacing = 100;\n\n/**\n * Variable: interHierarchySpacing\n * \n * The spacing buffer between unconnected hierarchies. Default is 60.\n */\nmxHierarchicalLayout.prototype.interHierarchySpacing = 60;\n\n/**\n * Variable: parallelEdgeSpacing\n * \n * The distance between each parallel edge on each ranks for long edges.\n * Default is 10.\n */\nmxHierarchicalLayout.prototype.parallelEdgeSpacing = 10;\n\n/**\n * Variable: orientation\n * \n * The position of the root node(s) relative to the laid out graph in.\n * Default is <mxConstants.DIRECTION_NORTH>.\n */\nmxHierarchicalLayout.prototype.orientation = mxConstants.DIRECTION_NORTH;\n\n/**\n * Variable: fineTuning\n * \n * Whether or not to perform local optimisations and iterate multiple times\n * through the algorithm. Default is true.\n */\nmxHierarchicalLayout.prototype.fineTuning = true;\n\n/**\n * \n * Variable: tightenToSource\n * \n * Whether or not to tighten the assigned ranks of vertices up towards\n * the source cells. Default is true.\n */\nmxHierarchicalLayout.prototype.tightenToSource = true;\n\n/**\n * Variable: disableEdgeStyle\n * \n * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are\n * modified by the result. Default is true.\n */\nmxHierarchicalLayout.prototype.disableEdgeStyle = true;\n\n/**\n * Variable: traverseAncestors\n * \n * Whether or not to drill into child cells and layout in reverse\n * group order. This also cause the layout to navigate edges whose \n * terminal vertices have different parents but are in the same \n * ancestry chain. Default is true.\n */\nmxHierarchicalLayout.prototype.traverseAncestors = true;\n\n/**\n * Variable: model\n * \n * The internal <mxGraphHierarchyModel> formed of the layout.\n */\nmxHierarchicalLayout.prototype.model = null;\n\n/**\n * Variable: edgesSet\n * \n * A cache of edges whose source terminal is the key\n */\nmxHierarchicalLayout.prototype.edgesCache = null;\n\n/**\n * Variable: edgesSet\n * \n * A cache of edges whose source terminal is the key\n */\nmxHierarchicalLayout.prototype.edgeSourceTermCache = null;\n\n/**\n * Variable: edgesSet\n * \n * A cache of edges whose source terminal is the key\n */\nmxHierarchicalLayout.prototype.edgesTargetTermCache = null;\n\n/**\n * Variable: edgeStyle\n * \n * The style to apply between cell layers to edge segments.\n * Default is <mxHierarchicalEdgeStyle.POLYLINE>.\n */\nmxHierarchicalLayout.prototype.edgeStyle = mxHierarchicalEdgeStyle.POLYLINE;\n\n/**\n * Function: getModel\n * \n * Returns the internal <mxGraphHierarchyModel> for this layout algorithm.\n */\nmxHierarchicalLayout.prototype.getModel = function()\n{\n\treturn this.model;\n};\n\n/**\n * Function: execute\n * \n * Executes the layout for the children of the specified parent.\n * \n * Parameters:\n * \n * parent - Parent <mxCell> that contains the children to be laid out.\n * roots - Optional starting roots of the layout.\n */\nmxHierarchicalLayout.prototype.execute = function(parent, roots)\n{\n\tthis.parent = parent;\n\tvar model = this.graph.model;\n\tthis.edgesCache = new mxDictionary();\n\tthis.edgeSourceTermCache = new mxDictionary();\n\tthis.edgesTargetTermCache = new mxDictionary();\n\n\tif (roots != null && !(roots instanceof Array))\n\t{\n\t\troots = [roots];\n\t}\n\t\n\t// If the roots are set and the parent is set, only\n\t// use the roots that are some dependent of the that\n\t// parent.\n\t// If just the root are set, use them as-is\n\t// If just the parent is set use it's immediate\n\t// children as the initial set\n\n\tif (roots == null && parent == null)\n\t{\n\t\t// TODO indicate the problem\n\t\treturn;\n\t}\n\t\n\t//  Maintaining parent location\n\tthis.parentX = null;\n\tthis.parentY = null;\n\t\n\tif (parent != this.root && model.isVertex(parent) != null && this.maintainParentLocation)\n\t{\n\t\tvar geo = this.graph.getCellGeometry(parent);\n\t\t\n\t\tif (geo != null)\n\t\t{\n\t\t\tthis.parentX = geo.x;\n\t\t\tthis.parentY = geo.y;\n\t\t}\n\t}\n\t\n\tif (roots != null)\n\t{\n\t\tvar rootsCopy = [];\n\n\t\tfor (var i = 0; i < roots.length; i++)\n\t\t{\n\t\t\tvar ancestor = parent != null ? model.isAncestor(parent, roots[i]) : true;\n\t\t\t\n\t\t\tif (ancestor && model.isVertex(roots[i]))\n\t\t\t{\n\t\t\t\trootsCopy.push(roots[i]);\n\t\t\t}\n\t\t}\n\n\t\tthis.roots = rootsCopy;\n\t}\n\t\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tthis.run(parent);\n\t\t\n\t\tif (this.resizeParent && !this.graph.isCellCollapsed(parent))\n\t\t{\n\t\t\tthis.graph.updateGroupBounds([parent], this.parentBorder, this.moveParent);\n\t\t}\n\t\t\n\t\t// Maintaining parent location\n\t\tif (this.parentX != null && this.parentY != null)\n\t\t{\n\t\t\tvar geo = this.graph.getCellGeometry(parent);\n\t\t\t\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tgeo = geo.clone();\n\t\t\t\tgeo.x = this.parentX;\n\t\t\t\tgeo.y = this.parentY;\n\t\t\t\tmodel.setGeometry(parent, geo);\n\t\t\t}\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n};\n\n/**\n * Function: findRoots\n * \n * Returns all visible children in the given parent which do not have\n * incoming edges. If the result is empty then the children with the\n * maximum difference between incoming and outgoing edges are returned.\n * This takes into account edges that are being promoted to the given\n * root due to invisible children or collapsed cells.\n * \n * Parameters:\n * \n * parent - <mxCell> whose children should be checked.\n * vertices - array of vertices to limit search to\n */\nmxHierarchicalLayout.prototype.findRoots = function(parent, vertices)\n{\n\tvar roots = [];\n\t\n\tif (parent != null && vertices != null)\n\t{\n\t\tvar model = this.graph.model;\n\t\tvar best = null;\n\t\tvar maxDiff = -100000;\n\t\t\n\t\tfor (var i in vertices)\n\t\t{\n\t\t\tvar cell = vertices[i];\n\n\t\t\tif (model.isVertex(cell) && this.graph.isCellVisible(cell))\n\t\t\t{\n\t\t\t\tvar conns = this.getEdges(cell);\n\t\t\t\tvar fanOut = 0;\n\t\t\t\tvar fanIn = 0;\n\n\t\t\t\tfor (var k = 0; k < conns.length; k++)\n\t\t\t\t{\n\t\t\t\t\tvar src = this.getVisibleTerminal(conns[k], true);\n\n\t\t\t\t\tif (src == cell)\n\t\t\t\t\t{\n\t\t\t\t\t\tfanOut++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfanIn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (fanIn == 0 && fanOut > 0)\n\t\t\t\t{\n\t\t\t\t\troots.push(cell);\n\t\t\t\t}\n\n\t\t\t\tvar diff = fanOut - fanIn;\n\n\t\t\t\tif (diff > maxDiff)\n\t\t\t\t{\n\t\t\t\t\tmaxDiff = diff;\n\t\t\t\t\tbest = cell;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (roots.length == 0 && best != null)\n\t\t{\n\t\t\troots.push(best);\n\t\t}\n\t}\n\t\n\treturn roots;\n};\n\n/**\n * Function: getEdges\n * \n * Returns the connected edges for the given cell.\n * \n * Parameters:\n * \n * cell - <mxCell> whose edges should be returned.\n */\nmxHierarchicalLayout.prototype.getEdges = function(cell)\n{\n\tvar cachedEdges = this.edgesCache.get(cell);\n\t\n\tif (cachedEdges != null)\n\t{\n\t\treturn cachedEdges;\n\t}\n\n\tvar model = this.graph.model;\n\tvar edges = [];\n\tvar isCollapsed = this.graph.isCellCollapsed(cell);\n\tvar childCount = model.getChildCount(cell);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = model.getChildAt(cell, i);\n\n\t\tif (this.isPort(child))\n\t\t{\n\t\t\tedges = edges.concat(model.getEdges(child, true, true));\n\t\t}\n\t\telse if (isCollapsed || !this.graph.isCellVisible(child))\n\t\t{\n\t\t\tedges = edges.concat(model.getEdges(child, true, true));\n\t\t}\n\t}\n\n\tedges = edges.concat(model.getEdges(cell, true, true));\n\tvar result = [];\n\t\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar source = this.getVisibleTerminal(edges[i], true);\n\t\tvar target = this.getVisibleTerminal(edges[i], false);\n\t\t\n\t\tif ((source == target) ||\n\t\t\t\t((source != target) &&\n\t\t\t\t\t\t((target == cell && (this.parent == null || this.isAncestor(this.parent, source, this.traverseAncestors))) ||\n\t\t\t\t\t\t \t(source == cell && (this.parent == null || this.isAncestor(this.parent, target, this.traverseAncestors))))))\n\t\t{\n\t\t\tresult.push(edges[i]);\n\t\t}\n\t}\n\n\tthis.edgesCache.put(cell, result);\n\n\treturn result;\n};\n\n/**\n * Function: getVisibleTerminal\n * \n * Helper function to return visible terminal for edge allowing for ports\n * \n * Parameters:\n * \n * edge - <mxCell> whose edges should be returned.\n * source - Boolean that specifies whether the source or target terminal is to be returned\n */\nmxHierarchicalLayout.prototype.getVisibleTerminal = function(edge, source)\n{\n\tvar terminalCache = this.edgesTargetTermCache;\n\t\n\tif (source)\n\t{\n\t\tterminalCache = this.edgeSourceTermCache;\n\t}\n\n\tvar term = terminalCache.get(edge);\n\n\tif (term != null)\n\t{\n\t\treturn term;\n\t}\n\n\tvar state = this.graph.view.getState(edge);\n\t\n\tvar terminal = (state != null) ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);\n\t\n\tif (terminal == null)\n\t{\n\t\tterminal = (state != null) ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);\n\t}\n\n\tif (terminal != null)\n\t{\n\t\tif (this.isPort(terminal))\n\t\t{\n\t\t\tterminal = this.graph.model.getParent(terminal);\n\t\t}\n\t\t\n\t\tterminalCache.put(edge, terminal);\n\t}\n\n\treturn terminal;\n};\n\n/**\n * Function: run\n * \n * The API method used to exercise the layout upon the graph description\n * and produce a separate description of the vertex position and edge\n * routing changes made. It runs each stage of the layout that has been\n * created.\n */\nmxHierarchicalLayout.prototype.run = function(parent)\n{\n\t// Separate out unconnected hierarchies\n\tvar hierarchyVertices = [];\n\tvar allVertexSet = [];\n\n\tif (this.roots == null && parent != null)\n\t{\n\t\tvar filledVertexSet = Object();\n\t\tthis.filterDescendants(parent, filledVertexSet);\n\n\t\tthis.roots = [];\n\t\tvar filledVertexSetEmpty = true;\n\n\t\t// Poor man's isSetEmpty\n\t\tfor (var key in filledVertexSet)\n\t\t{\n\t\t\tif (filledVertexSet[key] != null)\n\t\t\t{\n\t\t\t\tfilledVertexSetEmpty = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twhile (!filledVertexSetEmpty)\n\t\t{\n\t\t\tvar candidateRoots = this.findRoots(parent, filledVertexSet);\n\t\t\t\n\t\t\t// If the candidate root is an unconnected group cell, remove it from\n\t\t\t// the layout. We may need a custom set that holds such groups and forces\n\t\t\t// them to be processed for resizing and/or moving.\n\t\t\t\n\n\t\t\tfor (var i = 0; i < candidateRoots.length; i++)\n\t\t\t{\n\t\t\t\tvar vertexSet = Object();\n\t\t\t\thierarchyVertices.push(vertexSet);\n\n\t\t\t\tthis.traverse(candidateRoots[i], true, null, allVertexSet, vertexSet,\n\t\t\t\t\t\thierarchyVertices, filledVertexSet);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < candidateRoots.length; i++)\n\t\t\t{\n\t\t\t\tthis.roots.push(candidateRoots[i]);\n\t\t\t}\n\t\t\t\n\t\t\tfilledVertexSetEmpty = true;\n\t\t\t\n\t\t\t// Poor man's isSetEmpty\n\t\t\tfor (var key in filledVertexSet)\n\t\t\t{\n\t\t\t\tif (filledVertexSet[key] != null)\n\t\t\t\t{\n\t\t\t\t\tfilledVertexSetEmpty = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Find vertex set as directed traversal from roots\n\n\t\tfor (var i = 0; i < this.roots.length; i++)\n\t\t{\n\t\t\tvar vertexSet = Object();\n\t\t\thierarchyVertices.push(vertexSet);\n\n\t\t\tthis.traverse(this.roots[i], true, null, allVertexSet, vertexSet,\n\t\t\t\t\thierarchyVertices, null);\n\t\t}\n\t}\n\n\t// Iterate through the result removing parents who have children in this layout\n\t\n\t// Perform a layout for each seperate hierarchy\n\t// Track initial coordinate x-positioning\n\tvar initialX = 0;\n\n\tfor (var i = 0; i < hierarchyVertices.length; i++)\n\t{\n\t\tvar vertexSet = hierarchyVertices[i];\n\t\tvar tmp = [];\n\t\t\n\t\tfor (var key in vertexSet)\n\t\t{\n\t\t\ttmp.push(vertexSet[key]);\n\t\t}\n\t\t\n\t\tthis.model = new mxGraphHierarchyModel(this, tmp, this.roots,\n\t\t\tparent, this.tightenToSource);\n\n\t\tthis.cycleStage(parent);\n\t\tthis.layeringStage();\n\t\t\n\t\tthis.crossingStage(parent);\n\t\tinitialX = this.placementStage(initialX, parent);\n\t}\n};\n\n/**\n * Function: filterDescendants\n * \n * Creates an array of descendant cells\n */\nmxHierarchicalLayout.prototype.filterDescendants = function(cell, result)\n{\n\tvar model = this.graph.model;\n\n\tif (model.isVertex(cell) && cell != this.parent && this.graph.isCellVisible(cell))\n\t{\n\t\tresult[mxObjectIdentity.get(cell)] = cell;\n\t}\n\n\tif (this.traverseAncestors || cell == this.parent\n\t\t\t&& this.graph.isCellVisible(cell))\n\t{\n\t\tvar childCount = model.getChildCount(cell);\n\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar child = model.getChildAt(cell, i);\n\t\t\t\n\t\t\t// Ignore ports in the layout vertex list, they are dealt with\n\t\t\t// in the traversal mechanisms\n\t\t\tif (!this.isPort(child))\n\t\t\t{\n\t\t\t\tthis.filterDescendants(child, result);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: isPort\n * \n * Returns true if the given cell is a \"port\", that is, when connecting to\n * it, its parent is the connecting vertex in terms of graph traversal\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the port.\n */\nmxHierarchicalLayout.prototype.isPort = function(cell)\n{\n\tif (cell != null && cell.geometry != null)\n\t{\n\t\treturn cell.geometry.relative;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n};\n\n/**\n * Function: getEdgesBetween\n * \n * Returns the edges between the given source and target. This takes into\n * account collapsed and invisible cells and ports.\n * \n * Parameters:\n * \n * source -\n * target -\n * directed -\n */\nmxHierarchicalLayout.prototype.getEdgesBetween = function(source, target, directed)\n{\n\tdirected = (directed != null) ? directed : false;\n\tvar edges = this.getEdges(source);\n\tvar result = [];\n\n\t// Checks if the edge is connected to the correct\n\t// cell and returns the first match\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar src = this.getVisibleTerminal(edges[i], true);\n\t\tvar trg = this.getVisibleTerminal(edges[i], false);\n\n\t\tif ((src == source && trg == target) || (!directed && src == target && trg == source))\n\t\t{\n\t\t\tresult.push(edges[i]);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Traverses the (directed) graph invoking the given function for each\n * visited vertex and edge. The function is invoked with the current vertex\n * and the incoming edge as a parameter. This implementation makes sure\n * each vertex is only visited once. The function may return false if the\n * traversal should stop at the given vertex.\n * \n * Parameters:\n * \n * vertex - <mxCell> that represents the vertex where the traversal starts.\n * directed - boolean indicating if edges should only be traversed\n * from source to target. Default is true.\n * edge - Optional <mxCell> that represents the incoming edge. This is\n * null for the first step of the traversal.\n * allVertices - Array of cell paths for the visited cells.\n */\nmxHierarchicalLayout.prototype.traverse = function(vertex, directed, edge, allVertices, currentComp,\n\t\t\t\t\t\t\t\t\t\t\thierarchyVertices, filledVertexSet)\n{\n\tif (vertex != null && allVertices != null)\n\t{\n\t\t// Has this vertex been seen before in any traversal\n\t\t// And if the filled vertex set is populated, only \n\t\t// process vertices in that it contains\n\t\tvar vertexID = mxObjectIdentity.get(vertex);\n\t\t\n\t\tif ((allVertices[vertexID] == null)\n\t\t\t\t&& (filledVertexSet == null ? true : filledVertexSet[vertexID] != null))\n\t\t{\n\t\t\tif (currentComp[vertexID] == null)\n\t\t\t{\n\t\t\t\tcurrentComp[vertexID] = vertex;\n\t\t\t}\n\t\t\tif (allVertices[vertexID] == null)\n\t\t\t{\n\t\t\t\tallVertices[vertexID] = vertex;\n\t\t\t}\n\n\t\t\tif (filledVertexSet !== null)\n\t\t\t{\n\t\t\t\tdelete filledVertexSet[vertexID];\n\t\t\t}\n\n\t\t\tvar edges = this.getEdges(vertex);\n\t\t\tvar edgeIsSource = [];\n\n\t\t\tfor (var i = 0; i < edges.length; i++)\n\t\t\t{\n\t\t\t\tedgeIsSource[i] = (this.getVisibleTerminal(edges[i], true) == vertex);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < edges.length; i++)\n\t\t\t{\n\t\t\t\tif (!directed || edgeIsSource[i])\n\t\t\t\t{\n\t\t\t\t\tvar next = this.getVisibleTerminal(edges[i], !edgeIsSource[i]);\n\t\t\t\t\t\n\t\t\t\t\t// Check whether there are more edges incoming from the target vertex than outgoing\n\t\t\t\t\t// The hierarchical model treats bi-directional parallel edges as being sourced\n\t\t\t\t\t// from the more \"sourced\" terminal. If the directions are equal in number, the direction\n\t\t\t\t\t// is that of the natural direction from the roots of the layout.\n\t\t\t\t\t// The checks below are slightly more verbose than need be for performance reasons\n\t\t\t\t\tvar netCount = 1;\n\n\t\t\t\t\tfor (var j = 0; j < edges.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (j == i)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar isSource2 = edgeIsSource[j];\n\t\t\t\t\t\t\tvar otherTerm = this.getVisibleTerminal(edges[j], !isSource2);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (otherTerm == next)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (isSource2)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tnetCount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tnetCount--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (netCount >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentComp = this.traverse(next, directed, edges[i], allVertices,\n\t\t\t\t\t\t\tcurrentComp, hierarchyVertices,\n\t\t\t\t\t\t\tfilledVertexSet);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (currentComp[vertexID] == null)\n\t\t\t{\n\t\t\t\t// We've seen this vertex before, but not in the current component\n\t\t\t\t// This component and the one it's in need to be merged\n\n\t\t\t\tfor (var i = 0; i < hierarchyVertices.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar comp = hierarchyVertices[i];\n\n\t\t\t\t\tif (comp[vertexID] != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (var key in comp)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurrentComp[key] = comp[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Remove the current component from the hierarchy set\n\t\t\t\t\t\thierarchyVertices.splice(i, 1);\n\t\t\t\t\t\treturn currentComp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn currentComp;\n};\n\n/**\n * Function: cycleStage\n * \n * Executes the cycle stage using mxMinimumCycleRemover.\n */\nmxHierarchicalLayout.prototype.cycleStage = function(parent)\n{\n\tvar cycleStage = new mxMinimumCycleRemover(this);\n\tcycleStage.execute(parent);\n};\n\n/**\n * Function: layeringStage\n * \n * Implements first stage of a Sugiyama layout.\n */\nmxHierarchicalLayout.prototype.layeringStage = function()\n{\n\tthis.model.initialRank();\n\tthis.model.fixRanks();\n};\n\n/**\n * Function: crossingStage\n * \n * Executes the crossing stage using mxMedianHybridCrossingReduction.\n */\nmxHierarchicalLayout.prototype.crossingStage = function(parent)\n{\n\tvar crossingStage = new mxMedianHybridCrossingReduction(this);\n\tcrossingStage.execute(parent);\n};\n\n/**\n * Function: placementStage\n * \n * Executes the placement stage using mxCoordinateAssignment.\n */\nmxHierarchicalLayout.prototype.placementStage = function(initialX, parent)\n{\n\tvar placementStage = new mxCoordinateAssignment(this, this.intraCellSpacing,\n\t\t\tthis.interRankCellSpacing, this.orientation, initialX,\n\t\t\tthis.parallelEdgeSpacing);\n\tplacementStage.fineTuning = this.fineTuning;\n\tplacementStage.execute(parent);\n\t\n\treturn placementStage.limitX + this.interHierarchySpacing;\n};\n\n__mxOutput.mxHierarchicalLayout = typeof mxHierarchicalLayout !== 'undefined' ? mxHierarchicalLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxSwimlaneLayout\n * \n * A hierarchical layout algorithm.\n * \n * Constructor: mxSwimlaneLayout\n *\n * Constructs a new hierarchical layout algorithm.\n *\n * Arguments:\n * \n * graph - Reference to the enclosing <mxGraph>.\n * orientation - Optional constant that defines the orientation of this\n * layout.\n * deterministic - Optional boolean that specifies if this layout should be\n * deterministic. Default is true.\n */\nfunction mxSwimlaneLayout(graph, orientation, deterministic)\n{\n\tmxGraphLayout.call(this, graph);\n\tthis.orientation = (orientation != null) ? orientation : mxConstants.DIRECTION_NORTH;\n\tthis.deterministic = (deterministic != null) ? deterministic : true;\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxSwimlaneLayout.prototype = new mxGraphLayout();\nmxSwimlaneLayout.prototype.constructor = mxSwimlaneLayout;\n\n/**\n * Variable: roots\n * \n * Holds the array of <mxCell> that this layout contains.\n */\nmxSwimlaneLayout.prototype.roots = null;\n\n/**\n * Variable: swimlanes\n * \n * Holds the array of <mxCell> of the ordered swimlanes to lay out\n */\nmxSwimlaneLayout.prototype.swimlanes = null;\n\n/**\n * Variable: dummyVertexWidth\n * \n * The cell width of any dummy vertices inserted\n */\nmxSwimlaneLayout.prototype.dummyVertexWidth = 50;\n\n/**\n * Variable: resizeParent\n * \n * Specifies if the parent should be resized after the layout so that it\n * contains all the child cells. Default is false. See also <parentBorder>.\n */\nmxSwimlaneLayout.prototype.resizeParent = false;\n\n/**\n * Variable: maintainParentLocation\n * \n * Specifies if the parent location should be maintained, so that the\n * top, left corner stays the same before and after execution of\n * the layout. Default is false for backwards compatibility.\n */\nmxSwimlaneLayout.prototype.maintainParentLocation = false;\n\n/**\n * Variable: moveParent\n * \n * Specifies if the parent should be moved if <resizeParent> is enabled.\n * Default is false.\n */\nmxSwimlaneLayout.prototype.moveParent = false;\n\n/**\n * Variable: parentBorder\n * \n * The border to be added around the children if the parent is to be\n * resized using <resizeParent>. Default is 30.\n */\nmxSwimlaneLayout.prototype.parentBorder = 30;\n\n/**\n * Variable: intraCellSpacing\n * \n * The spacing buffer added between cells on the same layer. Default is 30.\n */\nmxSwimlaneLayout.prototype.intraCellSpacing = 30;\n\n/**\n * Variable: interRankCellSpacing\n * \n * The spacing buffer added between cell on adjacent layers. Default is 100.\n */\nmxSwimlaneLayout.prototype.interRankCellSpacing = 100;\n\n/**\n * Variable: interHierarchySpacing\n * \n * The spacing buffer between unconnected hierarchies. Default is 60.\n */\nmxSwimlaneLayout.prototype.interHierarchySpacing = 60;\n\n/**\n * Variable: parallelEdgeSpacing\n * \n * The distance between each parallel edge on each ranks for long edges.\n * Default is 10.\n */\nmxSwimlaneLayout.prototype.parallelEdgeSpacing = 10;\n\n/**\n * Variable: orientation\n * \n * The position of the root node(s) relative to the laid out graph in.\n * Default is <mxConstants.DIRECTION_NORTH>.\n */\nmxSwimlaneLayout.prototype.orientation = mxConstants.DIRECTION_NORTH;\n\n/**\n * Variable: fineTuning\n * \n * Whether or not to perform local optimisations and iterate multiple times\n * through the algorithm. Default is true.\n */\nmxSwimlaneLayout.prototype.fineTuning = true;\n\n/**\n * Variable: tightenToSource\n * \n * Whether or not to tighten the assigned ranks of vertices up towards\n * the source cells. Default is true.\n */\nmxSwimlaneLayout.prototype.tightenToSource = true;\n\n/**\n * Variable: disableEdgeStyle\n * \n * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are\n * modified by the result. Default is true.\n */\nmxSwimlaneLayout.prototype.disableEdgeStyle = true;\n\n/**\n * Variable: traverseAncestors\n * \n * Whether or not to drill into child cells and layout in reverse\n * group order. This also cause the layout to navigate edges whose \n * terminal vertices have different parents but are in the same\n * ancestry chain. Default is true.\n */\nmxSwimlaneLayout.prototype.traverseAncestors = true;\n\n/**\n * Variable: model\n * \n * The internal <mxSwimlaneModel> formed of the layout.\n */\nmxSwimlaneLayout.prototype.model = null;\n\n/**\n * Variable: edgesSet\n * \n * A cache of edges whose source terminal is the key\n */\nmxSwimlaneLayout.prototype.edgesCache = null;\n\n/**\n * Variable: edgesSet\n * \n * A cache of edges whose source terminal is the key\n */\nmxHierarchicalLayout.prototype.edgeSourceTermCache = null;\n\n/**\n * Variable: edgesSet\n * \n * A cache of edges whose source terminal is the key\n */\nmxHierarchicalLayout.prototype.edgesTargetTermCache = null;\n\n/**\n * Variable: edgeStyle\n * \n * The style to apply between cell layers to edge segments.\n * Default is <mxHierarchicalEdgeStyle.POLYLINE>.\n */\nmxHierarchicalLayout.prototype.edgeStyle = mxHierarchicalEdgeStyle.POLYLINE;\n\n/**\n * Function: getModel\n * \n * Returns the internal <mxSwimlaneModel> for this layout algorithm.\n */\nmxSwimlaneLayout.prototype.getModel = function()\n{\n\treturn this.model;\n};\n\n/**\n * Function: execute\n * \n * Executes the layout for the children of the specified parent.\n * \n * Parameters:\n * \n * parent - Parent <mxCell> that contains the children to be laid out.\n * swimlanes - Ordered array of swimlanes to be laid out\n */\nmxSwimlaneLayout.prototype.execute = function(parent, swimlanes)\n{\n\tthis.parent = parent;\n\tvar model = this.graph.model;\n\tthis.edgesCache = new mxDictionary();\n\tthis.edgeSourceTermCache = new mxDictionary();\n\tthis.edgesTargetTermCache = new mxDictionary();\n\n\t// If the roots are set and the parent is set, only\n\t// use the roots that are some dependent of the that\n\t// parent.\n\t// If just the root are set, use them as-is\n\t// If just the parent is set use it's immediate\n\t// children as the initial set\n\n\tif (swimlanes == null || swimlanes.length < 1)\n\t{\n\t\t// TODO indicate the problem\n\t\treturn;\n\t}\n\n\tif (parent == null)\n\t{\n\t\tparent = model.getParent(swimlanes[0]);\n\t}\n\n\t//  Maintaining parent location\n\tthis.parentX = null;\n\tthis.parentY = null;\n\t\n\tif (parent != this.root && model.isVertex(parent) != null && this.maintainParentLocation)\n\t{\n\t\tvar geo = this.graph.getCellGeometry(parent);\n\t\t\n\t\tif (geo != null)\n\t\t{\n\t\t\tthis.parentX = geo.x;\n\t\t\tthis.parentY = geo.y;\n\t\t}\n\t}\n\n\tthis.swimlanes = swimlanes;\n\tvar dummyVertices = [];\n\t// Check the swimlanes all have vertices\n\t// in them\n\tfor (var i = 0; i < swimlanes.length; i++)\n\t{\n\t\tvar children = this.graph.getChildCells(swimlanes[i]);\n\t\t\n\t\tif (children == null || children.length == 0)\n\t\t{\n\t\t\tvar vertex = this.graph.insertVertex(swimlanes[i], null, null, 0, 0, this.dummyVertexWidth, 0);\n\t\t\tdummyVertices.push(vertex);\n\t\t}\n\t}\n\t\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tthis.run(parent);\n\t\t\n\t\tif (this.resizeParent && !this.graph.isCellCollapsed(parent))\n\t\t{\n\t\t\tthis.graph.updateGroupBounds([parent], this.parentBorder, this.moveParent);\n\t\t}\n\t\t\n\t\t// Maintaining parent location\n\t\tif (this.parentX != null && this.parentY != null)\n\t\t{\n\t\t\tvar geo = this.graph.getCellGeometry(parent);\n\t\t\t\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tgeo = geo.clone();\n\t\t\t\tgeo.x = this.parentX;\n\t\t\t\tgeo.y = this.parentY;\n\t\t\t\tmodel.setGeometry(parent, geo);\n\t\t\t}\n\t\t}\n\n\t\tthis.graph.removeCells(dummyVertices);\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n};\n\n/**\n * Function: updateGroupBounds\n * \n * Updates the bounds of the given array of groups so that it includes\n * all child vertices.\n * \n */\nmxSwimlaneLayout.prototype.updateGroupBounds = function()\n{\n\t// Get all vertices and edge in the layout\n\tvar cells = [];\n\tvar model = this.model;\n\t\n\tfor (var key in model.edgeMapper)\n\t{\n\t\tvar edge = model.edgeMapper[key];\n\t\t\n\t\tfor (var i = 0; i < edge.edges.length; i++)\n\t\t{\n\t\t\tcells.push(edge.edges[i]);\n\t\t}\n\t}\n\t\n\tvar layoutBounds = this.graph.getBoundingBoxFromGeometry(cells, true);\n\tvar childBounds = [];\n\n\tfor (var i = 0; i < this.swimlanes.length; i++)\n\t{\n\t\tvar lane = this.swimlanes[i];\n\t\tvar geo = this.graph.getCellGeometry(lane);\n\t\t\n\t\tif (geo != null)\n\t\t{\n\t\t\tvar children = this.graph.getChildCells(lane);\n\t\t\t\n\t\t\tvar size = (this.graph.isSwimlane(lane)) ?\n\t\t\t\t\tthis.graph.getStartSize(lane) : new mxRectangle();\n\n\t\t\tvar bounds = this.graph.getBoundingBoxFromGeometry(children);\n\t\t\tchildBounds[i] = bounds;\n\t\t\tvar childrenY = bounds.y + geo.y - size.height - this.parentBorder;\n\t\t\tvar maxChildrenY = bounds.y + geo.y + bounds.height;\n\n\t\t\tif (layoutBounds == null)\n\t\t\t{\n\t\t\t\tlayoutBounds = new mxRectangle(0, childrenY, 0, maxChildrenY - childrenY);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlayoutBounds.y = Math.min(layoutBounds.y, childrenY);\n\t\t\t\tvar maxY = Math.max(layoutBounds.y + layoutBounds.height, maxChildrenY);\n\t\t\t\tlayoutBounds.height = maxY - layoutBounds.y;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tfor (var i = 0; i < this.swimlanes.length; i++)\n\t{\n\t\tvar lane = this.swimlanes[i];\n\t\tvar geo = this.graph.getCellGeometry(lane);\n\t\t\n\t\tif (geo != null)\n\t\t{\n\t\t\tvar children = this.graph.getChildCells(lane);\n\t\t\t\n\t\t\tvar size = (this.graph.isSwimlane(lane)) ?\n\t\t\t\t\tthis.graph.getStartSize(lane) : new mxRectangle();\n\n\t\t\tvar newGeo = geo.clone();\n\t\t\t\n\t\t\tvar leftGroupBorder = (i == 0) ? this.parentBorder : this.interRankCellSpacing/2;\n\t\t\tvar w = size.width + leftGroupBorder;\n\t\t\tvar x = childBounds[i].x - w;\n\t\t\tvar y = layoutBounds.y - this.parentBorder;\n\n\t\t\tnewGeo.x += x;\n\t\t\tnewGeo.y = y;\n\t\t\t\n\t\t\tnewGeo.width = childBounds[i].width + w + this.interRankCellSpacing/2;\n\t\t\tnewGeo.height = layoutBounds.height + size.height + 2 * this.parentBorder;\n\t\t\t\n\t\t\tthis.graph.model.setGeometry(lane, newGeo);\n\t\t\tthis.graph.moveCells(children, -x, geo.y - y);\n\t\t}\n\t}\n};\n\n/**\n * Function: findRoots\n * \n * Returns all visible children in the given parent which do not have\n * incoming edges. If the result is empty then the children with the\n * maximum difference between incoming and outgoing edges are returned.\n * This takes into account edges that are being promoted to the given\n * root due to invisible children or collapsed cells.\n * \n * Parameters:\n * \n * parent - <mxCell> whose children should be checked.\n * vertices - array of vertices to limit search to\n */\nmxSwimlaneLayout.prototype.findRoots = function(parent, vertices)\n{\n\tvar roots = [];\n\t\n\tif (parent != null && vertices != null)\n\t{\n\t\tvar model = this.graph.model;\n\t\tvar best = null;\n\t\tvar maxDiff = -100000;\n\t\t\n\t\tfor (var i in vertices)\n\t\t{\n\t\t\tvar cell = vertices[i];\n\n\t\t\tif (cell != null && model.isVertex(cell) && this.graph.isCellVisible(cell) && model.isAncestor(parent, cell))\n\t\t\t{\n\t\t\t\tvar conns = this.getEdges(cell);\n\t\t\t\tvar fanOut = 0;\n\t\t\t\tvar fanIn = 0;\n\n\t\t\t\tfor (var k = 0; k < conns.length; k++)\n\t\t\t\t{\n\t\t\t\t\tvar src = this.getVisibleTerminal(conns[k], true);\n\n\t\t\t\t\tif (src == cell)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Only count connection within this swimlane\n\t\t\t\t\t\tvar other = this.getVisibleTerminal(conns[k], false);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (model.isAncestor(parent, other))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfanOut++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (model.isAncestor(parent, src))\n\t\t\t\t\t{\n\t\t\t\t\t\tfanIn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (fanIn == 0 && fanOut > 0)\n\t\t\t\t{\n\t\t\t\t\troots.push(cell);\n\t\t\t\t}\n\n\t\t\t\tvar diff = fanOut - fanIn;\n\n\t\t\t\tif (diff > maxDiff)\n\t\t\t\t{\n\t\t\t\t\tmaxDiff = diff;\n\t\t\t\t\tbest = cell;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (roots.length == 0 && best != null)\n\t\t{\n\t\t\troots.push(best);\n\t\t}\n\t}\n\t\n\treturn roots;\n};\n\n/**\n * Function: getEdges\n * \n * Returns the connected edges for the given cell.\n * \n * Parameters:\n * \n * cell - <mxCell> whose edges should be returned.\n */\nmxSwimlaneLayout.prototype.getEdges = function(cell)\n{\n\tvar cachedEdges = this.edgesCache.get(cell);\n\t\n\tif (cachedEdges != null)\n\t{\n\t\treturn cachedEdges;\n\t}\n\n\tvar model = this.graph.model;\n\tvar edges = [];\n\tvar isCollapsed = this.graph.isCellCollapsed(cell);\n\tvar childCount = model.getChildCount(cell);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = model.getChildAt(cell, i);\n\n\t\tif (this.isPort(child))\n\t\t{\n\t\t\tedges = edges.concat(model.getEdges(child, true, true));\n\t\t}\n\t\telse if (isCollapsed || !this.graph.isCellVisible(child))\n\t\t{\n\t\t\tedges = edges.concat(model.getEdges(child, true, true));\n\t\t}\n\t}\n\n\tedges = edges.concat(model.getEdges(cell, true, true));\n\tvar result = [];\n\t\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar source = this.getVisibleTerminal(edges[i], true);\n\t\tvar target = this.getVisibleTerminal(edges[i], false);\n\t\t\n\t\tif ((source == target) || ((source != target) && ((target == cell && (this.parent == null || this.graph.isValidAncestor(source, this.parent, this.traverseAncestors))) ||\n\t\t\t(source == cell && (this.parent == null ||\n\t\t\t\t\tthis.graph.isValidAncestor(target, this.parent, this.traverseAncestors))))))\n\t\t{\n\t\t\tresult.push(edges[i]);\n\t\t}\n\t}\n\n\tthis.edgesCache.put(cell, result);\n\n\treturn result;\n};\n\n/**\n * Function: getVisibleTerminal\n * \n * Helper function to return visible terminal for edge allowing for ports\n * \n * Parameters:\n * \n * edge - <mxCell> whose edges should be returned.\n * source - Boolean that specifies whether the source or target terminal is to be returned\n */\nmxSwimlaneLayout.prototype.getVisibleTerminal = function(edge, source)\n{\n\tvar terminalCache = this.edgesTargetTermCache;\n\t\n\tif (source)\n\t{\n\t\tterminalCache = this.edgeSourceTermCache;\n\t}\n\n\tvar term = terminalCache.get(edge);\n\n\tif (term != null)\n\t{\n\t\treturn term;\n\t}\n\n\tvar state = this.graph.view.getState(edge);\n\t\n\tvar terminal = (state != null) ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);\n\t\n\tif (terminal == null)\n\t{\n\t\tterminal = (state != null) ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);\n\t}\n\n\tif (terminal != null)\n\t{\n\t\tif (this.isPort(terminal))\n\t\t{\n\t\t\tterminal = this.graph.model.getParent(terminal);\n\t\t}\n\t\t\n\t\tterminalCache.put(edge, terminal);\n\t}\n\n\treturn terminal;\n};\n\n/**\n * Function: run\n * \n * The API method used to exercise the layout upon the graph description\n * and produce a separate description of the vertex position and edge\n * routing changes made. It runs each stage of the layout that has been\n * created.\n */\nmxSwimlaneLayout.prototype.run = function(parent)\n{\n\t// Separate out unconnected hierarchies\n\tvar hierarchyVertices = [];\n\tvar allVertexSet = Object();\n\n\tif (this.swimlanes != null && this.swimlanes.length > 0 && parent != null)\n\t{\n\t\tvar filledVertexSet = Object();\n\t\t\n\t\tfor (var i = 0; i < this.swimlanes.length; i++)\n\t\t{\n\t\t\tthis.filterDescendants(this.swimlanes[i], filledVertexSet);\n\t\t}\n\n\t\tthis.roots = [];\n\t\tvar filledVertexSetEmpty = true;\n\n\t\t// Poor man's isSetEmpty\n\t\tfor (var key in filledVertexSet)\n\t\t{\n\t\t\tif (filledVertexSet[key] != null)\n\t\t\t{\n\t\t\t\tfilledVertexSetEmpty = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Only test for candidates in each swimlane in order\n\t\tvar laneCounter = 0;\n\n\t\twhile (!filledVertexSetEmpty && laneCounter < this.swimlanes.length)\n\t\t{\n\t\t\tvar candidateRoots = this.findRoots(this.swimlanes[laneCounter], filledVertexSet);\n\t\t\t\n\t\t\tif (candidateRoots.length == 0)\n\t\t\t{\n\t\t\t\tlaneCounter++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// If the candidate root is an unconnected group cell, remove it from\n\t\t\t// the layout. We may need a custom set that holds such groups and forces\n\t\t\t// them to be processed for resizing and/or moving.\n\t\t\tfor (var i = 0; i < candidateRoots.length; i++)\n\t\t\t{\n\t\t\t\tvar vertexSet = Object();\n\t\t\t\thierarchyVertices.push(vertexSet);\n\n\t\t\t\tthis.traverse(candidateRoots[i], true, null, allVertexSet, vertexSet,\n\t\t\t\t\t\thierarchyVertices, filledVertexSet, laneCounter);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < candidateRoots.length; i++)\n\t\t\t{\n\t\t\t\tthis.roots.push(candidateRoots[i]);\n\t\t\t}\n\t\t\t\n\t\t\tfilledVertexSetEmpty = true;\n\t\t\t\n\t\t\t// Poor man's isSetEmpty\n\t\t\tfor (var key in filledVertexSet)\n\t\t\t{\n\t\t\t\tif (filledVertexSet[key] != null)\n\t\t\t\t{\n\t\t\t\t\tfilledVertexSetEmpty = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Find vertex set as directed traversal from roots\n\n\t\tfor (var i = 0; i < this.roots.length; i++)\n\t\t{\n\t\t\tvar vertexSet = Object();\n\t\t\thierarchyVertices.push(vertexSet);\n\n\t\t\tthis.traverse(this.roots[i], true, null, allVertexSet, vertexSet,\n\t\t\t\t\thierarchyVertices, null);\n\t\t}\n\t}\n\n\tvar tmp = [];\n\t\n\tfor (var key in allVertexSet)\n\t{\n\t\ttmp.push(allVertexSet[key]);\n\t}\n\t\n\tthis.model = new mxSwimlaneModel(this, tmp, this.roots,\n\t\tparent, this.tightenToSource);\n\n\tthis.cycleStage(parent);\n\tthis.layeringStage();\n\t\n\tthis.crossingStage(parent);\n\tthis.placementStage(0, parent);\n};\n\n/**\n * Function: filterDescendants\n * \n * Creates an array of descendant cells\n */\nmxSwimlaneLayout.prototype.filterDescendants = function(cell, result)\n{\n\tvar model = this.graph.model;\n\n\tif (model.isVertex(cell) && cell != this.parent && model.getParent(cell) != this.parent && this.graph.isCellVisible(cell))\n\t{\n\t\tresult[mxObjectIdentity.get(cell)] = cell;\n\t}\n\n\tif (this.traverseAncestors || cell == this.parent\n\t\t\t&& this.graph.isCellVisible(cell))\n\t{\n\t\tvar childCount = model.getChildCount(cell);\n\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar child = model.getChildAt(cell, i);\n\t\t\t\n\t\t\t// Ignore ports in the layout vertex list, they are dealt with\n\t\t\t// in the traversal mechanisms\n\t\t\tif (!this.isPort(child))\n\t\t\t{\n\t\t\t\tthis.filterDescendants(child, result);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: isPort\n * \n * Returns true if the given cell is a \"port\", that is, when connecting to\n * it, its parent is the connecting vertex in terms of graph traversal\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the port.\n */\nmxSwimlaneLayout.prototype.isPort = function(cell)\n{\n\tif (cell.geometry.relative)\n\t{\n\t\treturn true;\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: getEdgesBetween\n * \n * Returns the edges between the given source and target. This takes into\n * account collapsed and invisible cells and ports.\n * \n * Parameters:\n * \n * source -\n * target -\n * directed -\n */\nmxSwimlaneLayout.prototype.getEdgesBetween = function(source, target, directed)\n{\n\tdirected = (directed != null) ? directed : false;\n\tvar edges = this.getEdges(source);\n\tvar result = [];\n\n\t// Checks if the edge is connected to the correct\n\t// cell and returns the first match\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar src = this.getVisibleTerminal(edges[i], true);\n\t\tvar trg = this.getVisibleTerminal(edges[i], false);\n\n\t\tif ((src == source && trg == target) || (!directed && src == target && trg == source))\n\t\t{\n\t\t\tresult.push(edges[i]);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Traverses the (directed) graph invoking the given function for each\n * visited vertex and edge. The function is invoked with the current vertex\n * and the incoming edge as a parameter. This implementation makes sure\n * each vertex is only visited once. The function may return false if the\n * traversal should stop at the given vertex.\n * \n * Parameters:\n * \n * vertex - <mxCell> that represents the vertex where the traversal starts.\n * directed - boolean indicating if edges should only be traversed\n * from source to target. Default is true.\n * edge - Optional <mxCell> that represents the incoming edge. This is\n * null for the first step of the traversal.\n * allVertices - Array of cell paths for the visited cells.\n * swimlaneIndex - the laid out order index of the swimlane vertex is contained in\n */\nmxSwimlaneLayout.prototype.traverse = function(vertex, directed, edge, allVertices, currentComp,\n\t\t\t\t\t\t\t\t\t\t\thierarchyVertices, filledVertexSet, swimlaneIndex)\n{\n\tif (vertex != null && allVertices != null)\n\t{\n\t\t// Has this vertex been seen before in any traversal\n\t\t// And if the filled vertex set is populated, only \n\t\t// process vertices in that it contains\n\t\tvar vertexID = mxObjectIdentity.get(vertex);\n\t\t\n\t\tif ((allVertices[vertexID] == null)\n\t\t\t\t&& (filledVertexSet == null ? true : filledVertexSet[vertexID] != null))\n\t\t{\n\t\t\tif (currentComp[vertexID] == null)\n\t\t\t{\n\t\t\t\tcurrentComp[vertexID] = vertex;\n\t\t\t}\n\t\t\tif (allVertices[vertexID] == null)\n\t\t\t{\n\t\t\t\tallVertices[vertexID] = vertex;\n\t\t\t}\n\n\t\t\tif (filledVertexSet !== null)\n\t\t\t{\n\t\t\t\tdelete filledVertexSet[vertexID];\n\t\t\t}\n\n\t\t\tvar edges = this.getEdges(vertex);\n\t\t\tvar model = this.graph.model;\n\n\t\t\tfor (var i = 0; i < edges.length; i++)\n\t\t\t{\n\t\t\t\tvar otherVertex = this.getVisibleTerminal(edges[i], true);\n\t\t\t\tvar isSource = otherVertex == vertex;\n\t\t\t\t\n\t\t\t\tif (isSource)\n\t\t\t\t{\n\t\t\t\t\totherVertex = this.getVisibleTerminal(edges[i], false);\n\t\t\t\t}\n\n\t\t\t\tvar otherIndex = 0;\n\t\t\t\t// Get the swimlane index of the other terminal\n\t\t\t\tfor (otherIndex = 0; otherIndex < this.swimlanes.length; otherIndex++)\n\t\t\t\t{\n\t\t\t\t\tif (model.isAncestor(this.swimlanes[otherIndex], otherVertex))\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (otherIndex >= this.swimlanes.length)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Traverse if the other vertex is within the same swimlane as\n\t\t\t\t// as the current vertex, or if the swimlane index of the other\n\t\t\t\t// vertex is greater than that of this vertex\n\t\t\t\tif ((otherIndex > swimlaneIndex) ||\n\t\t\t\t\t\t((!directed || isSource) && otherIndex == swimlaneIndex))\n\t\t\t\t{\n\t\t\t\t\tcurrentComp = this.traverse(otherVertex, directed, edges[i], allVertices,\n\t\t\t\t\t\t\tcurrentComp, hierarchyVertices,\n\t\t\t\t\t\t\tfilledVertexSet, otherIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (currentComp[vertexID] == null)\n\t\t\t{\n\t\t\t\t// We've seen this vertex before, but not in the current component\n\t\t\t\t// This component and the one it's in need to be merged\n\t\t\t\tfor (var i = 0; i < hierarchyVertices.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar comp = hierarchyVertices[i];\n\n\t\t\t\t\tif (comp[vertexID] != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (var key in comp)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurrentComp[key] = comp[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Remove the current component from the hierarchy set\n\t\t\t\t\t\thierarchyVertices.splice(i, 1);\n\t\t\t\t\t\treturn currentComp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn currentComp;\n};\n\n/**\n * Function: cycleStage\n * \n * Executes the cycle stage using mxMinimumCycleRemover.\n */\nmxSwimlaneLayout.prototype.cycleStage = function(parent)\n{\n\tvar cycleStage = new mxSwimlaneOrdering(this);\n\tcycleStage.execute(parent);\n};\n\n/**\n * Function: layeringStage\n * \n * Implements first stage of a Sugiyama layout.\n */\nmxSwimlaneLayout.prototype.layeringStage = function()\n{\n\tthis.model.initialRank();\n\tthis.model.fixRanks();\n};\n\n/**\n * Function: crossingStage\n * \n * Executes the crossing stage using mxMedianHybridCrossingReduction.\n */\nmxSwimlaneLayout.prototype.crossingStage = function(parent)\n{\n\tvar crossingStage = new mxMedianHybridCrossingReduction(this);\n\tcrossingStage.execute(parent);\n};\n\n/**\n * Function: placementStage\n * \n * Executes the placement stage using mxCoordinateAssignment.\n */\nmxSwimlaneLayout.prototype.placementStage = function(initialX, parent)\n{\n\tvar placementStage = new mxCoordinateAssignment(this, this.intraCellSpacing,\n\t\t\tthis.interRankCellSpacing, this.orientation, initialX,\n\t\t\tthis.parallelEdgeSpacing);\n\tplacementStage.fineTuning = this.fineTuning;\n\tplacementStage.execute(parent);\n\t\n\treturn placementStage.limitX + this.interHierarchySpacing;\n};\n\n__mxOutput.mxSwimlaneLayout = typeof mxSwimlaneLayout !== 'undefined' ? mxSwimlaneLayout : undefined;\n\n/**\n * Copyright (c) 2006-2018, JGraph Ltd\n * Copyright (c) 2006-2018, Gaudenz Alder\n */\n/**\n * Class: mxGraphModel\n * \n * Extends <mxEventSource> to implement a graph model. The graph model acts as\n * a wrapper around the cells which are in charge of storing the actual graph\n * datastructure. The model acts as a transactional wrapper with event\n * notification for all changes, whereas the cells contain the atomic\n * operations for updating the actual datastructure.\n * \n * Layers:\n * \n * The cell hierarchy in the model must have a top-level root cell which\n * contains the layers (typically one default layer), which in turn contain the\n * top-level cells of the layers. This means each cell is contained in a layer.\n * If no layers are required, then all new cells should be added to the default\n * layer.\n * \n * Layers are useful for hiding and showing groups of cells, or for placing\n * groups of cells on top of other cells in the display. To identify a layer,\n * the <isLayer> function is used. It returns true if the parent of the given\n * cell is the root of the model.\n * \n * Events:\n * \n * See events section for more details. There is a new set of events for\n * tracking transactional changes as they happen. The events are called\n * startEdit for the initial beginUpdate, executed for each executed change\n * and endEdit for the terminal endUpdate. The executed event contains a\n * property called change which represents the change after execution.\n * \n * Encoding the model:\n * \n * To encode a graph model, use the following code:\n * \n * (code)\n * var enc = new mxCodec();\n * var node = enc.encode(graph.getModel());\n * (end)\n * \n * This will create an XML node that contains all the model information.\n * \n * Encoding and decoding changes:\n * \n * For the encoding of changes, a graph model listener is required that encodes\n * each change from the given array of changes.\n * \n * (code)\n * model.addListener(mxEvent.CHANGE, function(sender, evt)\n * {\n *   var changes = evt.getProperty('edit').changes;\n *   var nodes = [];\n *   var codec = new mxCodec();\n * \n *   for (var i = 0; i < changes.length; i++)\n *   {\n *     nodes.push(codec.encode(changes[i]));\n *   }\n *   // do something with the nodes\n * });\n * (end)\n * \n * For the decoding and execution of changes, the codec needs a lookup function\n * that allows it to resolve cell IDs as follows:\n * \n * (code)\n * var codec = new mxCodec();\n * codec.lookup = function(id)\n * {\n *   return model.getCell(id);\n * }\n * (end)\n * \n * For each encoded change (represented by a node), the following code can be\n * used to carry out the decoding and create a change object.\n * \n * (code)\n * var changes = [];\n * var change = codec.decode(node);\n * change.model = model;\n * change.execute();\n * changes.push(change);\n * (end)\n * \n * The changes can then be dispatched using the model as follows.\n * \n * (code)\n * var edit = new mxUndoableEdit(model, false);\n * edit.changes = changes;\n * \n * edit.notify = function()\n * {\n *   edit.source.fireEvent(new mxEventObject(mxEvent.CHANGE,\n *   \t'edit', edit, 'changes', edit.changes));\n *   edit.source.fireEvent(new mxEventObject(mxEvent.NOTIFY,\n *   \t'edit', edit, 'changes', edit.changes));\n * }\n * \n * model.fireEvent(new mxEventObject(mxEvent.UNDO, 'edit', edit));\n * model.fireEvent(new mxEventObject(mxEvent.CHANGE,\n * \t\t'edit', edit, 'changes', changes));\n * (end)\n *\n * Event: mxEvent.CHANGE\n *\n * Fires when an undoable edit is dispatched. The <code>edit</code> property\n * contains the <mxUndoableEdit>. The <code>changes</code> property contains\n * the array of atomic changes inside the undoable edit. The changes property\n * is <strong>deprecated</strong>, please use edit.changes instead.\n *\n * Example:\n * \n * For finding newly inserted cells, the following code can be used:\n * \n * (code)\n * graph.model.addListener(mxEvent.CHANGE, function(sender, evt)\n * {\n *   var changes = evt.getProperty('edit').changes;\n * \n *   for (var i = 0; i < changes.length; i++)\n *   {\n *     var change = changes[i];\n *     \n *     if (change instanceof mxChildChange &&\n *       change.change.previous == null)\n *     {\n *       graph.startEditingAtCell(change.child);\n *       break;\n *     }\n *   }\n * });\n * (end)\n * \n * \n * Event: mxEvent.NOTIFY\n *\n * Same as <mxEvent.CHANGE>, this event can be used for classes that need to\n * implement a sync mechanism between this model and, say, a remote model. In\n * such a setup, only local changes should trigger a notify event and all\n * changes should trigger a change event.\n * \n * Event: mxEvent.EXECUTE\n * \n * Fires between begin- and endUpdate and after an atomic change was executed\n * in the model. The <code>change</code> property contains the atomic change\n * that was executed.\n * \n * Event: mxEvent.EXECUTED\n * \n * Fires between START_EDIT and END_EDIT after an atomic change was executed.\n * The <code>change</code> property contains the change that was executed.\n *\n * Event: mxEvent.BEGIN_UPDATE\n *\n * Fires after the <updateLevel> was incremented in <beginUpdate>. This event\n * contains no properties.\n * \n * Event: mxEvent.START_EDIT\n *\n * Fires after the <updateLevel> was changed from 0 to 1. This event\n * contains no properties.\n * \n * Event: mxEvent.END_UPDATE\n * \n * Fires after the <updateLevel> was decreased in <endUpdate> but before any\n * notification or change dispatching. The <code>edit</code> property contains\n * the <currentEdit>.\n * \n * Event: mxEvent.END_EDIT\n *\n * Fires after the <updateLevel> was changed from 1 to 0. This event\n * contains no properties.\n * \n * Event: mxEvent.BEFORE_UNDO\n * \n * Fires before the change is dispatched after the update level has reached 0\n * in <endUpdate>. The <code>edit</code> property contains the <curreneEdit>.\n * \n * Event: mxEvent.UNDO\n * \n * Fires after the change was dispatched in <endUpdate>. The <code>edit</code>\n * property contains the <currentEdit>.\n * \n * Constructor: mxGraphModel\n * \n * Constructs a new graph model. If no root is specified then a new root\n * <mxCell> with a default layer is created.\n * \n * Parameters:\n * \n * root - <mxCell> that represents the root cell.\n */\nfunction mxGraphModel(root)\n{\n\tthis.currentEdit = this.createUndoableEdit();\n\t\n\tif (root != null)\n\t{\n\t\tthis.setRoot(root);\n\t}\n\telse\n\t{\n\t\tthis.clear();\n\t}\n};\n\n/**\n * Extends mxEventSource.\n */\nmxGraphModel.prototype = new mxEventSource();\nmxGraphModel.prototype.constructor = mxGraphModel;\n\n/**\n * Variable: root\n * \n * Holds the root cell, which in turn contains the cells that represent the\n * layers of the diagram as child cells. That is, the actual elements of the\n * diagram are supposed to live in the third generation of cells and below.\n */\nmxGraphModel.prototype.root = null;\n\n/**\n * Variable: cells\n * \n * Maps from Ids to cells.\n */\nmxGraphModel.prototype.cells = null;\n\n/**\n * Variable: maintainEdgeParent\n * \n * Specifies if edges should automatically be moved into the nearest common\n * ancestor of their terminals. Default is true.\n */\nmxGraphModel.prototype.maintainEdgeParent = true;\n\n/**\n * Variable: ignoreRelativeEdgeParent\n * \n * Specifies if relative edge parents should be ignored for finding the nearest\n * common ancestors of an edge's terminals. Default is true.\n */\nmxGraphModel.prototype.ignoreRelativeEdgeParent = true;\n\n/**\n * Variable: createIds\n * \n * Specifies if the model should automatically create Ids for new cells.\n * Default is true.\n */\nmxGraphModel.prototype.createIds = true;\n\n/**\n * Variable: prefix\n * \n * Defines the prefix of new Ids. Default is an empty string.\n */\nmxGraphModel.prototype.prefix = '';\n\n/**\n * Variable: postfix\n * \n * Defines the postfix of new Ids. Default is an empty string.\n */\nmxGraphModel.prototype.postfix = '';\n\n/**\n * Variable: nextId\n * \n * Specifies the next Id to be created. Initial value is 0.\n */\nmxGraphModel.prototype.nextId = 0;\n\n/**\n * Variable: currentEdit\n * \n * Holds the changes for the current transaction. If the transaction is\n * closed then a new object is created for this variable using\n * <createUndoableEdit>.\n */\nmxGraphModel.prototype.currentEdit = null;\n\n/**\n * Variable: updateLevel\n * \n * Counter for the depth of nested transactions. Each call to <beginUpdate>\n * will increment this number and each call to <endUpdate> will decrement\n * it. When the counter reaches 0, the transaction is closed and the\n * respective events are fired. Initial value is 0.\n */\nmxGraphModel.prototype.updateLevel = 0;\n\n/**\n * Variable: endingUpdate\n * \n * True if the program flow is currently inside endUpdate.\n */\nmxGraphModel.prototype.endingUpdate = false;\n\n/**\n * Function: clear\n *\n * Sets a new root using <createRoot>.\n */\nmxGraphModel.prototype.clear = function()\n{\n\tthis.setRoot(this.createRoot());\n};\n\n/**\n * Function: isCreateIds\n *\n * Returns <createIds>.\n */\nmxGraphModel.prototype.isCreateIds = function()\n{\n\treturn this.createIds;\n};\n\n/**\n * Function: setCreateIds\n *\n * Sets <createIds>.\n */\nmxGraphModel.prototype.setCreateIds = function(value)\n{\n\tthis.createIds = value;\n};\n\n/**\n * Function: createRoot\n *\n * Creates a new root cell with a default layer (child 0).\n */\nmxGraphModel.prototype.createRoot = function()\n{\n\tvar cell = new mxCell();\n\tcell.insert(new mxCell());\n\t\n\treturn cell;\n};\n\n/**\n * Function: getCell\n *\n * Returns the <mxCell> for the specified Id or null if no cell can be\n * found for the given Id.\n *\n * Parameters:\n * \n * id - A string representing the Id of the cell.\n */\nmxGraphModel.prototype.getCell = function(id)\n{\n\treturn (this.cells != null) ? this.cells[id] : null;\n};\n\n/**\n * Function: filterCells\n * \n * Returns the cells from the given array where the given filter function\n * returns true.\n */\nmxGraphModel.prototype.filterCells = function(cells, filter)\n{\n\tvar result = null;\n\t\n\tif (cells != null)\n\t{\n\t\tresult = [];\n\t\t\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (filter(cells[i]))\n\t\t\t{\n\t\t\t\tresult.push(cells[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getDescendants\n * \n * Returns all descendants of the given cell and the cell itself in an array.\n * \n * Parameters:\n * \n * parent - <mxCell> whose descendants should be returned.\n */\nmxGraphModel.prototype.getDescendants = function(parent)\n{\n\treturn this.filterDescendants(null, parent);\n};\n\n/**\n * Function: filterDescendants\n * \n * Visits all cells recursively and applies the specified filter function\n * to each cell. If the function returns true then the cell is added\n * to the resulting array. The parent and result paramters are optional.\n * If parent is not specified then the recursion starts at <root>.\n * \n * Example:\n * The following example extracts all vertices from a given model:\n * (code)\n * var filter = function(cell)\n * {\n * \treturn model.isVertex(cell);\n * }\n * var vertices = model.filterDescendants(filter);\n * (end)\n * \n * Parameters:\n * \n * filter - JavaScript function that takes an <mxCell> as an argument\n * and returns a boolean.\n * parent - Optional <mxCell> that is used as the root of the recursion.\n */\nmxGraphModel.prototype.filterDescendants = function(filter, parent)\n{\n\t// Creates a new array for storing the result\n\tvar result = [];\n\n\t// Recursion starts at the root of the model\n\tparent = parent || this.getRoot();\n\t\n\t// Checks if the filter returns true for the cell\n\t// and adds it to the result array\n\tif (filter == null || filter(parent))\n\t{\n\t\tresult.push(parent);\n\t}\n\t\n\t// Visits the children of the cell\n\tvar childCount = this.getChildCount(parent);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = this.getChildAt(parent, i);\n\t\tresult = result.concat(this.filterDescendants(filter, child));\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getRoot\n * \n * Returns the root of the model or the topmost parent of the given cell.\n *\n * Parameters:\n * \n * cell - Optional <mxCell> that specifies the child.\n */\nmxGraphModel.prototype.getRoot = function(cell)\n{\n\tvar root = cell || this.root;\n\t\n\tif (cell != null)\n\t{\n\t\twhile (cell != null)\n\t\t{\n\t\t\troot = cell;\n\t\t\tcell = this.getParent(cell);\n\t\t}\n\t}\n\t\n\treturn root;\n};\n\n/**\n * Function: setRoot\n * \n * Sets the <root> of the model using <mxRootChange> and adds the change to\n * the current transaction. This resets all datastructures in the model and\n * is the preferred way of clearing an existing model. Returns the new\n * root.\n * \n * Example:\n * \n * (code)\n * var root = new mxCell();\n * root.insert(new mxCell());\n * model.setRoot(root);\n * (end)\n *\n * Parameters:\n * \n * root - <mxCell> that specifies the new root.\n */\nmxGraphModel.prototype.setRoot = function(root)\n{\n\tthis.execute(new mxRootChange(this, root));\n\t\n\treturn root;\n};\n\n/**\n * Function: rootChanged\n * \n * Inner callback to change the root of the model and update the internal\n * datastructures, such as <cells> and <nextId>. Returns the previous root.\n *\n * Parameters:\n * \n * root - <mxCell> that specifies the new root.\n */\nmxGraphModel.prototype.rootChanged = function(root)\n{\n\tvar oldRoot = this.root;\n\tthis.root = root;\n\t\n\t// Resets counters and datastructures\n\tthis.nextId = 0;\n\tthis.cells = null;\n\tthis.cellAdded(root);\n\t\n\treturn oldRoot;\n};\n\n/**\n * Function: isRoot\n * \n * Returns true if the given cell is the root of the model and a non-null\n * value.\n *\n * Parameters:\n * \n * cell - <mxCell> that represents the possible root.\n */\nmxGraphModel.prototype.isRoot = function(cell)\n{\n\treturn cell != null && this.root == cell;\n};\n\n/**\n * Function: isLayer\n * \n * Returns true if <isRoot> returns true for the parent of the given cell.\n *\n * Parameters:\n * \n * cell - <mxCell> that represents the possible layer.\n */\nmxGraphModel.prototype.isLayer = function(cell)\n{\n\treturn this.isRoot(this.getParent(cell));\n};\n\n/**\n * Function: isAncestor\n * \n * Returns true if the given parent is an ancestor of the given child. Note \n * returns true if child == parent.\n *\n * Parameters:\n * \n * parent - <mxCell> that specifies the parent.\n * child - <mxCell> that specifies the child.\n */\nmxGraphModel.prototype.isAncestor = function(parent, child)\n{\n\twhile (child != null && child != parent)\n\t{\n\t\tchild = this.getParent(child);\n\t}\n\t\n\treturn child == parent;\n};\n\n/**\n * Function: contains\n * \n * Returns true if the model contains the given <mxCell>.\n *\n * Parameters:\n * \n * cell - <mxCell> that specifies the cell.\n */\nmxGraphModel.prototype.contains = function(cell)\n{\n\treturn this.isAncestor(this.root, cell);\n};\n\n/**\n * Function: getParent\n * \n * Returns the parent of the given cell.\n *\n * Parameters:\n * \n * cell - <mxCell> whose parent should be returned.\n */\nmxGraphModel.prototype.getParent = function(cell)\n{\n\treturn (cell != null) ? cell.getParent() : null;\n};\n\n/**\n * Function: add\n * \n * Adds the specified child to the parent at the given index using\n * <mxChildChange> and adds the change to the current transaction. If no\n * index is specified then the child is appended to the parent's array of\n * children. Returns the inserted child.\n * \n * Parameters:\n * \n * parent - <mxCell> that specifies the parent to contain the child.\n * child - <mxCell> that specifies the child to be inserted.\n * index - Optional integer that specifies the index of the child.\n */\nmxGraphModel.prototype.add = function(parent, child, index)\n{\n\tif (child != parent && parent != null && child != null)\n\t{\t\n\t\t// Appends the child if no index was specified\n\t\tif (index == null)\n\t\t{\n\t\t\tindex = this.getChildCount(parent);\n\t\t}\n\t\t\n\t\tvar parentChanged = parent != this.getParent(child);\n\t\tthis.execute(new mxChildChange(this, parent, child, index));\n\n\t\t// Maintains the edges parents by moving the edges\n\t\t// into the nearest common ancestor of its terminals\n\t\tif (this.maintainEdgeParent && parentChanged)\n\t\t{\n\t\t\tthis.updateEdgeParents(child);\n\t\t}\n\t}\n\t\n\treturn child;\n};\n\n/**\n * Function: cellAdded\n * \n * Inner callback to update <cells> when a cell has been added. This\n * implementation resolves collisions by creating new Ids. To change the\n * ID of a cell after it was inserted into the model, use the following\n * code:\n * \n * (code\n * delete model.cells[cell.getId()];\n * cell.setId(newId);\n * model.cells[cell.getId()] = cell;\n * (end)\n *\n * If the change of the ID should be part of the command history, then the\n * cell should be removed from the model and a clone with the new ID should\n * be reinserted into the model instead.\n *\n * Parameters:\n * \n * cell - <mxCell> that specifies the cell that has been added.\n */\nmxGraphModel.prototype.cellAdded = function(cell)\n{\n\tif (cell != null)\n\t{\n\t\t// Creates an Id for the cell if not Id exists\n\t\tif (cell.getId() == null && this.createIds)\n\t\t{\n\t\t\tcell.setId(this.createId(cell));\n\t\t}\n\t\t\n\t\tif (cell.getId() != null)\n\t\t{\n\t\t\tvar collision = this.getCell(cell.getId());\n\t\t\t\n\t\t\tif (collision != cell)\n\t\t\t{\t\n\t\t\t\t// Creates new Id for the cell\n\t\t\t\t// as long as there is a collision\n\t\t\t\twhile (collision != null)\n\t\t\t\t{\n\t\t\t\t\tcell.setId(this.createId(cell));\n\t\t\t\t\tcollision = this.getCell(cell.getId());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Lazily creates the cells dictionary\n\t\t\t\tif (this.cells == null)\n\t\t\t\t{\n\t\t\t\t\tthis.cells = new Object();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.cells[cell.getId()] = cell;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Makes sure IDs of deleted cells are not reused\n\t\tif (mxUtils.isNumeric(cell.getId()))\n\t\t{\n\t\t\tthis.nextId = Math.max(this.nextId, cell.getId());\n\t\t}\n\t\t\n\t\t// Recursively processes child cells\n\t\tvar childCount = this.getChildCount(cell);\n\t\t\n\t\tfor (var i=0; i<childCount; i++)\n\t\t{\n\t\t\tthis.cellAdded(this.getChildAt(cell, i));\n\t\t}\n\t}\n};\n\n/**\n * Function: createId\n * \n * Hook method to create an Id for the specified cell. This implementation\n * concatenates <prefix>, id and <postfix> to create the Id and increments\n * <nextId>. The cell is ignored by this implementation, but can be used in\n * overridden methods to prefix the Ids with eg. the cell type.\n *\n * Parameters:\n *\n * cell - <mxCell> to create the Id for.\n */\nmxGraphModel.prototype.createId = function(cell)\n{\n\tvar id = this.nextId;\n\tthis.nextId++;\n\t\n\treturn this.prefix + id + this.postfix;\n};\n\n/**\n * Function: updateEdgeParents\n * \n * Updates the parent for all edges that are connected to cell or one of\n * its descendants using <updateEdgeParent>.\n */\nmxGraphModel.prototype.updateEdgeParents = function(cell, root)\n{\n\t// Gets the topmost node of the hierarchy\n\troot = root || this.getRoot(cell);\n\t\n\t// Updates edges on children first\n\tvar childCount = this.getChildCount(cell);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = this.getChildAt(cell, i);\n\t\tthis.updateEdgeParents(child, root);\n\t}\n\t\n\t// Updates the parents of all connected edges\n\tvar edgeCount = this.getEdgeCount(cell);\n\tvar edges = [];\n\n\tfor (var i = 0; i < edgeCount; i++)\n\t{\n\t\tedges.push(this.getEdgeAt(cell, i));\n\t}\n\t\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar edge = edges[i];\n\t\t\n\t\t// Updates edge parent if edge and child have\n\t\t// a common root node (does not need to be the\n\t\t// model root node)\n\t\tif (this.isAncestor(root, edge))\n\t\t{\n\t\t\tthis.updateEdgeParent(edge, root);\n\t\t}\n\t}\n};\n\n/**\n * Function: updateEdgeParent\n *\n * Inner callback to update the parent of the specified <mxCell> to the\n * nearest-common-ancestor of its two terminals.\n *\n * Parameters:\n * \n * edge - <mxCell> that specifies the edge.\n * root - <mxCell> that represents the current root of the model.\n */\nmxGraphModel.prototype.updateEdgeParent = function(edge, root)\n{\n\tvar source = this.getTerminal(edge, true);\n\tvar target = this.getTerminal(edge, false);\n\tvar cell = null;\n\t\n\t// Uses the first non-relative descendants of the source terminal\n\twhile (source != null && !this.isEdge(source) &&\n\t\tsource.geometry != null && source.geometry.relative)\n\t{\n\t\tsource = this.getParent(source);\n\t}\n\t\n\t// Uses the first non-relative descendants of the target terminal\n\twhile (target != null && this.ignoreRelativeEdgeParent &&\n\t\t!this.isEdge(target) && target.geometry != null && \n\t\ttarget.geometry.relative)\n\t{\n\t\ttarget = this.getParent(target);\n\t}\n\t\n\tif (this.isAncestor(root, source) && this.isAncestor(root, target))\n\t{\n\t\tif (source == target)\n\t\t{\n\t\t\tcell = this.getParent(source);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcell = this.getNearestCommonAncestor(source, target);\n\t\t}\n\n\t\tif (cell != null && (this.getParent(cell) != this.root ||\n\t\t\tthis.isAncestor(cell, edge)) && this.getParent(edge) != cell)\n\t\t{\n\t\t\tvar geo = this.getGeometry(edge);\n\t\t\t\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tvar origin1 = this.getOrigin(this.getParent(edge));\n\t\t\t\tvar origin2 = this.getOrigin(cell);\n\t\t\t\t\n\t\t\t\tvar dx = origin2.x - origin1.x;\n\t\t\t\tvar dy = origin2.y - origin1.y;\n\t\t\t\t\n\t\t\t\tgeo = geo.clone();\n\t\t\t\tgeo.translate(-dx, -dy);\n\t\t\t\tthis.setGeometry(edge, geo);\n\t\t\t}\n\n\t\t\tthis.add(cell, edge, this.getChildCount(cell));\n\t\t}\n\t}\n};\n\n/**\n * Function: getOrigin\n * \n * Returns the absolute, accumulated origin for the children inside the\n * given parent as an <mxPoint>.\n */\nmxGraphModel.prototype.getOrigin = function(cell)\n{\n\tvar result = null;\n\t\n\tif (cell != null)\n\t{\n\t\tresult = this.getOrigin(this.getParent(cell));\n\t\t\n\t\tif (!this.isEdge(cell))\n\t\t{\n\t\t\tvar geo = this.getGeometry(cell);\n\t\t\t\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tresult.x += geo.x;\n\t\t\t\tresult.y += geo.y;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tresult = new mxPoint();\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getNearestCommonAncestor\n * \n * Returns the nearest common ancestor for the specified cells.\n *\n * Parameters:\n * \n * cell1 - <mxCell> that specifies the first cell in the tree.\n * cell2 - <mxCell> that specifies the second cell in the tree.\n */\nmxGraphModel.prototype.getNearestCommonAncestor = function(cell1, cell2)\n{\n\tif (cell1 != null && cell2 != null)\n\t{\t\t\n\t\t// Creates the cell path for the second cell\n\t\tvar path = mxCellPath.create(cell2);\n\n\t\tif (path != null && path.length > 0)\n\t\t{\n\t\t\t// Bubbles through the ancestors of the first\n\t\t\t// cell to find the nearest common ancestor.\n\t\t\tvar cell = cell1;\n\t\t\tvar current = mxCellPath.create(cell);\n\t\t\t\n\t\t\t// Inverts arguments\n\t\t\tif (path.length < current.length)\n\t\t\t{\n\t\t\t\tcell = cell2;\n\t\t\t\tvar tmp = current;\n\t\t\t\tcurrent = path;\n\t\t\t\tpath = tmp;\n\t\t\t}\n\t\t\t\n\t\t\twhile (cell != null)\n\t\t\t{\n\t\t\t\tvar parent = this.getParent(cell);\n\t\t\t\t\n\t\t\t\t// Checks if the cell path is equal to the beginning of the given cell path\n\t\t\t\tif (path.indexOf(current + mxCellPath.PATH_SEPARATOR) == 0 && parent != null)\n\t\t\t\t{\n\t\t\t\t\treturn cell;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcurrent = mxCellPath.getParentPath(current);\n\t\t\t\tcell = parent;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: remove\n * \n * Removes the specified cell from the model using <mxChildChange> and adds\n * the change to the current transaction. This operation will remove the\n * cell and all of its children from the model. Returns the removed cell.\n *\n * Parameters:\n * \n * cell - <mxCell> that should be removed.\n */\nmxGraphModel.prototype.remove = function(cell)\n{\n\tif (cell == this.root)\n\t{\n\t\tthis.setRoot(null);\n\t}\n\telse if (this.getParent(cell) != null)\n\t{\n\t\tthis.execute(new mxChildChange(this, null, cell));\n\t}\n\t\n\treturn cell;\n};\n\n/**\n * Function: cellRemoved\n * \n * Inner callback to update <cells> when a cell has been removed.\n *\n * Parameters:\n * \n * cell - <mxCell> that specifies the cell that has been removed.\n */\nmxGraphModel.prototype.cellRemoved = function(cell)\n{\n\tif (cell != null && this.cells != null)\n\t{\n\t\t// Recursively processes child cells\n\t\tvar childCount = this.getChildCount(cell);\n\t\t\n\t\tfor (var i = childCount - 1; i >= 0; i--)\n\t\t{\n\t\t\tthis.cellRemoved(this.getChildAt(cell, i));\n\t\t}\n\t\t\n\t\t// Removes the dictionary entry for the cell\n\t\tif (this.cells != null && cell.getId() != null)\n\t\t{\n\t\t\tdelete this.cells[cell.getId()];\n\t\t}\n\t}\n};\n\n/**\n * Function: parentForCellChanged\n * \n * Inner callback to update the parent of a cell using <mxCell.insert>\n * on the parent and return the previous parent.\n *\n * Parameters:\n * \n * cell - <mxCell> to update the parent for.\n * parent - <mxCell> that specifies the new parent of the cell.\n * index - Optional integer that defines the index of the child\n * in the parent's child array.\n */\nmxGraphModel.prototype.parentForCellChanged = function(cell, parent, index)\n{\n\tvar previous = this.getParent(cell);\n\t\n\tif (parent != null)\n\t{\n\t\tif (parent != previous || previous.getIndex(cell) != index)\n\t\t{\n\t\t\tparent.insert(cell, index);\n\t\t}\n\t}\n\telse if (previous != null)\n\t{\n\t\tvar oldIndex = previous.getIndex(cell);\n\t\tprevious.remove(oldIndex);\n\t}\n\t\n\t// Adds or removes the cell from the model\n\tvar par = this.contains(parent);\n\tvar pre = this.contains(previous);\n\t\n\tif (par && !pre)\n\t{\n\t\tthis.cellAdded(cell);\n\t}\n\telse if (pre && !par)\n\t{\n\t\tthis.cellRemoved(cell);\n\t}\n\t\n\treturn previous;\n};\n\n/**\n * Function: getChildCount\n *\n * Returns the number of children in the given cell.\n *\n * Parameters:\n * \n * cell - <mxCell> whose number of children should be returned.\n */\nmxGraphModel.prototype.getChildCount = function(cell)\n{\n\treturn (cell != null) ? cell.getChildCount() : 0;\n};\n\n/**\n * Function: getChildAt\n *\n * Returns the child of the given <mxCell> at the given index.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the parent.\n * index - Integer that specifies the index of the child to be returned.\n */\nmxGraphModel.prototype.getChildAt = function(cell, index)\n{\n\treturn (cell != null) ? cell.getChildAt(index) : null;\n};\n\n/**\n * Function: getChildren\n * \n * Returns all children of the given <mxCell> as an array of <mxCells>. The\n * return value should be only be read.\n *\n * Parameters:\n * \n * cell - <mxCell> the represents the parent.\n */\nmxGraphModel.prototype.getChildren = function(cell)\n{\n\treturn (cell != null) ? cell.children : null;\n};\n\t\n/**\n * Function: getChildVertices\n * \n * Returns the child vertices of the given parent.\n *\n * Parameters:\n * \n * cell - <mxCell> whose child vertices should be returned.\n */\nmxGraphModel.prototype.getChildVertices = function(parent)\n{\n\treturn this.getChildCells(parent, true, false);\n};\n\t\t\n/**\n * Function: getChildEdges\n * \n * Returns the child edges of the given parent.\n *\n * Parameters:\n * \n * cell - <mxCell> whose child edges should be returned.\n */\nmxGraphModel.prototype.getChildEdges = function(parent)\n{\n\treturn this.getChildCells(parent, false, true);\n};\n\n/**\n * Function: getChildCells\n * \n * Returns the children of the given cell that are vertices and/or edges\n * depending on the arguments.\n *\n * Parameters:\n * \n * cell - <mxCell> the represents the parent.\n * vertices - Boolean indicating if child vertices should be returned.\n * Default is false.\n * edges - Boolean indicating if child edges should be returned.\n * Default is false.\n */\nmxGraphModel.prototype.getChildCells = function(parent, vertices, edges)\n{\n\tvertices = (vertices != null) ? vertices : false;\n\tedges = (edges != null) ? edges : false;\n\t\n\tvar childCount = this.getChildCount(parent);\n\tvar result = [];\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = this.getChildAt(parent, i);\n\n\t\tif ((!edges && !vertices) || (edges && this.isEdge(child)) ||\n\t\t\t(vertices && this.isVertex(child)))\n\t\t{\n\t\t\tresult.push(child);\n\t\t}\n\t}\n\n\treturn result;\n};\n\t\t\n/**\n * Function: getTerminal\n * \n * Returns the source or target <mxCell> of the given edge depending on the\n * value of the boolean parameter.\n *\n * Parameters:\n * \n * edge - <mxCell> that specifies the edge.\n * isSource - Boolean indicating which end of the edge should be returned.\n */\nmxGraphModel.prototype.getTerminal = function(edge, isSource)\n{\n\treturn (edge != null) ? edge.getTerminal(isSource) : null;\n};\n\n/**\n * Function: setTerminal\n * \n * Sets the source or target terminal of the given <mxCell> using\n * <mxTerminalChange> and adds the change to the current transaction.\n * This implementation updates the parent of the edge using <updateEdgeParent>\n * if required.\n *\n * Parameters:\n * \n * edge - <mxCell> that specifies the edge.\n * terminal - <mxCell> that specifies the new terminal.\n * isSource - Boolean indicating if the terminal is the new source or\n * target terminal of the edge.\n */\nmxGraphModel.prototype.setTerminal = function(edge, terminal, isSource)\n{\n\tvar terminalChanged = terminal != this.getTerminal(edge, isSource);\n\tthis.execute(new mxTerminalChange(this, edge, terminal, isSource));\n\t\n\tif (this.maintainEdgeParent && terminalChanged)\n\t{\n\t\tthis.updateEdgeParent(edge, this.getRoot());\n\t}\n\t\n\treturn terminal;\n};\n\t\n/**\n * Function: setTerminals\n * \n * Sets the source and target <mxCell> of the given <mxCell> in a single\n * transaction using <setTerminal> for each end of the edge.\n *\n * Parameters:\n * \n * edge - <mxCell> that specifies the edge.\n * source - <mxCell> that specifies the new source terminal.\n * target - <mxCell> that specifies the new target terminal.\n */\nmxGraphModel.prototype.setTerminals = function(edge, source, target)\n{\n\tthis.beginUpdate();\n\ttry\n\t{\n\t\tthis.setTerminal(edge, source, true);\n\t\tthis.setTerminal(edge, target, false);\n\t}\n\tfinally\n\t{\n\t\tthis.endUpdate();\n\t}\n};\n\n/**\n * Function: terminalForCellChanged\n * \n * Inner helper function to update the terminal of the edge using\n * <mxCell.insertEdge> and return the previous terminal.\n * \n * Parameters:\n * \n * edge - <mxCell> that specifies the edge to be updated.\n * terminal - <mxCell> that specifies the new terminal.\n * isSource - Boolean indicating if the terminal is the new source or\n * target terminal of the edge.\n */\nmxGraphModel.prototype.terminalForCellChanged = function(edge, terminal, isSource)\n{\n\tvar previous = this.getTerminal(edge, isSource);\n\t\n\tif (terminal != null)\n\t{\n\t\tterminal.insertEdge(edge, isSource);\n\t}\n\telse if (previous != null)\n\t{\n\t\tprevious.removeEdge(edge, isSource);\n\t}\n\t\n\treturn previous;\n};\n\n/**\n * Function: getEdgeCount\n * \n * Returns the number of distinct edges connected to the given cell.\n *\n * Parameters:\n * \n * cell - <mxCell> that represents the vertex.\n */\nmxGraphModel.prototype.getEdgeCount = function(cell)\n{\n\treturn (cell != null) ? cell.getEdgeCount() : 0;\n};\n\n/**\n * Function: getEdgeAt\n * \n * Returns the edge of cell at the given index.\n *\n * Parameters:\n * \n * cell - <mxCell> that specifies the vertex.\n * index - Integer that specifies the index of the edge\n * to return.\n */\nmxGraphModel.prototype.getEdgeAt = function(cell, index)\n{\n\treturn (cell != null) ? cell.getEdgeAt(index) : null;\n};\n\t\n/**\n * Function: getDirectedEdgeCount\n * \n * Returns the number of incoming or outgoing edges, ignoring the given\n * edge.\n * \n * Parameters:\n * \n * cell - <mxCell> whose edge count should be returned.\n * outgoing - Boolean that specifies if the number of outgoing or\n * incoming edges should be returned.\n * ignoredEdge - <mxCell> that represents an edge to be ignored.\n */\nmxGraphModel.prototype.getDirectedEdgeCount = function(cell, outgoing, ignoredEdge)\n{\n\tvar count = 0;\n\tvar edgeCount = this.getEdgeCount(cell);\n\n\tfor (var i = 0; i < edgeCount; i++)\n\t{\n\t\tvar edge = this.getEdgeAt(cell, i);\n\n\t\tif (edge != ignoredEdge && this.getTerminal(edge, outgoing) == cell)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn count;\n};\n\n/**\n * Function: getConnections\n * \n * Returns all edges of the given cell without loops.\n * \n * Parameters:\n * \n * cell - <mxCell> whose edges should be returned.\n * \n */\nmxGraphModel.prototype.getConnections = function(cell)\n{\n\treturn this.getEdges(cell, true, true, false);\n};\n\n/**\n * Function: getIncomingEdges\n * \n * Returns the incoming edges of the given cell without loops.\n * \n * Parameters:\n * \n * cell - <mxCell> whose incoming edges should be returned.\n * \n */\nmxGraphModel.prototype.getIncomingEdges = function(cell)\n{\n\treturn this.getEdges(cell, true, false, false);\n};\n\n/**\n * Function: getOutgoingEdges\n * \n * Returns the outgoing edges of the given cell without loops.\n * \n * Parameters:\n * \n * cell - <mxCell> whose outgoing edges should be returned.\n * \n */\nmxGraphModel.prototype.getOutgoingEdges = function(cell)\n{\n\treturn this.getEdges(cell, false, true, false);\n};\n\n/**\n * Function: getEdges\n * \n * Returns all distinct edges connected to this cell as a new array of\n * <mxCells>. If at least one of incoming or outgoing is true, then loops\n * are ignored, otherwise if both are false, then all edges connected to\n * the given cell are returned including loops.\n * \n * Parameters:\n * \n * cell - <mxCell> that specifies the cell.\n * incoming - Optional boolean that specifies if incoming edges should be\n * returned. Default is true.\n * outgoing - Optional boolean that specifies if outgoing edges should be\n * returned. Default is true.\n * includeLoops - Optional boolean that specifies if loops should be returned.\n * Default is true. \n */\nmxGraphModel.prototype.getEdges = function(cell, incoming, outgoing, includeLoops)\n{\n\tincoming = (incoming != null) ? incoming : true;\n\toutgoing = (outgoing != null) ? outgoing : true;\n\tincludeLoops = (includeLoops != null) ? includeLoops : true;\n\t\n\tvar edgeCount = this.getEdgeCount(cell);\n\tvar result = [];\n\n\tfor (var i = 0; i < edgeCount; i++)\n\t{\n\t\tvar edge = this.getEdgeAt(cell, i);\n\t\tvar source = this.getTerminal(edge, true);\n\t\tvar target = this.getTerminal(edge, false);\n\n\t\tif ((includeLoops && source == target) || ((source != target) && ((incoming && target == cell) ||\n\t\t\t(outgoing && source == cell))))\n\t\t{\n\t\t\tresult.push(edge);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getEdgesBetween\n * \n * Returns all edges between the given source and target pair. If directed\n * is true, then only edges from the source to the target are returned,\n * otherwise, all edges between the two cells are returned.\n * \n * Parameters:\n * \n * source - <mxCell> that defines the source terminal of the edge to be\n * returned.\n * target - <mxCell> that defines the target terminal of the edge to be\n * returned.\n * directed - Optional boolean that specifies if the direction of the\n * edge should be taken into account. Default is false.\n */\nmxGraphModel.prototype.getEdgesBetween = function(source, target, directed)\n{\n\tdirected = (directed != null) ? directed : false;\n\t\n\tvar tmp1 = this.getEdgeCount(source);\n\tvar tmp2 = this.getEdgeCount(target);\n\t\n\t// Assumes the source has less connected edges\n\tvar terminal = source;\n\tvar edgeCount = tmp1;\n\t\n\t// Uses the smaller array of connected edges\n\t// for searching the edge\n\tif (tmp2 < tmp1)\n\t{\n\t\tedgeCount = tmp2;\n\t\tterminal = target;\n\t}\n\t\n\tvar result = [];\n\t\n\t// Checks if the edge is connected to the correct\n\t// cell and returns the first match\n\tfor (var i = 0; i < edgeCount; i++)\n\t{\n\t\tvar edge = this.getEdgeAt(terminal, i);\n\t\tvar src = this.getTerminal(edge, true);\n\t\tvar trg = this.getTerminal(edge, false);\n\t\tvar directedMatch = (src == source) && (trg == target);\n\t\tvar oppositeMatch = (trg == source) && (src == target);\n\n\t\tif (directedMatch || (!directed && oppositeMatch))\n\t\t{\n\t\t\tresult.push(edge);\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getOpposites\n * \n * Returns all opposite vertices wrt terminal for the given edges, only\n * returning sources and/or targets as specified. The result is returned\n * as an array of <mxCells>.\n * \n * Parameters:\n * \n * edges - Array of <mxCells> that contain the edges to be examined.\n * terminal - <mxCell> that specifies the known end of the edges.\n * sources - Boolean that specifies if source terminals should be contained\n * in the result. Default is true.\n * targets - Boolean that specifies if target terminals should be contained\n * in the result. Default is true.\n */\nmxGraphModel.prototype.getOpposites = function(edges, terminal, sources, targets)\n{\n\tsources = (sources != null) ? sources : true;\n\ttargets = (targets != null) ? targets : true;\n\t\n\tvar terminals = [];\n\t\n\tif (edges != null)\n\t{\n\t\tfor (var i = 0; i < edges.length; i++)\n\t\t{\n\t\t\tvar source = this.getTerminal(edges[i], true);\n\t\t\tvar target = this.getTerminal(edges[i], false);\n\t\t\t\n\t\t\t// Checks if the terminal is the source of\n\t\t\t// the edge and if the target should be\n\t\t\t// stored in the result\n\t\t\tif (source == terminal && target != null && target != terminal && targets)\n\t\t\t{\n\t\t\t\tterminals.push(target);\n\t\t\t}\n\t\t\t\n\t\t\t// Checks if the terminal is the taget of\n\t\t\t// the edge and if the source should be\n\t\t\t// stored in the result\n\t\t\telse if (target == terminal && source != null && source != terminal && sources)\n\t\t\t{\n\t\t\t\tterminals.push(source);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn terminals;\n};\n\n/**\n * Function: getTopmostCells\n * \n * Returns the topmost cells of the hierarchy in an array that contains no\n * descendants for each <mxCell> that it contains. Duplicates should be\n * removed in the cells array to improve performance.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> whose topmost ancestors should be returned.\n */\nmxGraphModel.prototype.getTopmostCells = function(cells)\n{\n\tvar dict = new mxDictionary();\n\tvar tmp = [];\n\t\n\tfor (var i = 0; i < cells.length; i++)\n\t{\n\t\tdict.put(cells[i], true);\n\t}\n\t\n\tfor (var i = 0; i < cells.length; i++)\n\t{\n\t\tvar cell = cells[i];\n\t\tvar topmost = true;\n\t\tvar parent = this.getParent(cell);\n\t\t\n\t\twhile (parent != null)\n\t\t{\n\t\t\tif (dict.get(parent))\n\t\t\t{\n\t\t\t\ttopmost = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tparent = this.getParent(parent);\n\t\t}\n\t\t\n\t\tif (topmost)\n\t\t{\n\t\t\ttmp.push(cell);\n\t\t}\n\t}\n\t\n\treturn tmp;\n};\n\n/**\n * Function: isVertex\n * \n * Returns true if the given cell is a vertex.\n *\n * Parameters:\n * \n * cell - <mxCell> that represents the possible vertex.\n */\nmxGraphModel.prototype.isVertex = function(cell)\n{\n\treturn (cell != null) ? cell.isVertex() : false;\n};\n\n/**\n * Function: isEdge\n * \n * Returns true if the given cell is an edge.\n *\n * Parameters:\n * \n * cell - <mxCell> that represents the possible edge.\n */\nmxGraphModel.prototype.isEdge = function(cell)\n{\n\treturn (cell != null) ? cell.isEdge() : false;\n};\n\n/**\n * Function: isConnectable\n * \n * Returns true if the given <mxCell> is connectable. If <edgesConnectable>\n * is false, then this function returns false for all edges else it returns\n * the return value of <mxCell.isConnectable>.\n *\n * Parameters:\n * \n * cell - <mxCell> whose connectable state should be returned.\n */\nmxGraphModel.prototype.isConnectable = function(cell)\n{\n\treturn (cell != null) ? cell.isConnectable() : false;\n};\n\n/**\n * Function: getValue\n * \n * Returns the user object of the given <mxCell> using <mxCell.getValue>.\n *\n * Parameters:\n * \n * cell - <mxCell> whose user object should be returned.\n */\nmxGraphModel.prototype.getValue = function(cell)\n{\n\treturn (cell != null) ? cell.getValue() : null;\n};\n\n/**\n * Function: setValue\n * \n * Sets the user object of then given <mxCell> using <mxValueChange>\n * and adds the change to the current transaction.\n *\n * Parameters:\n * \n * cell - <mxCell> whose user object should be changed.\n * value - Object that defines the new user object.\n */\nmxGraphModel.prototype.setValue = function(cell, value)\n{\n\tthis.execute(new mxValueChange(this, cell, value));\n\t\n\treturn value;\n};\n\n/**\n * Function: valueForCellChanged\n * \n * Inner callback to update the user object of the given <mxCell>\n * using <mxCell.valueChanged> and return the previous value,\n * that is, the return value of <mxCell.valueChanged>.\n * \n * To change a specific attribute in an XML node, the following code can be\n * used.\n * \n * (code)\n * graph.getModel().valueForCellChanged = function(cell, value)\n * {\n *   var previous = cell.value.getAttribute('label');\n *   cell.value.setAttribute('label', value);\n *   \n *   return previous;\n * };\n * (end) \n */\nmxGraphModel.prototype.valueForCellChanged = function(cell, value)\n{\n\treturn cell.valueChanged(value);\n};\n\n/**\n * Function: getGeometry\n * \n * Returns the <mxGeometry> of the given <mxCell>.\n *\n * Parameters:\n * \n * cell - <mxCell> whose geometry should be returned.\n */\nmxGraphModel.prototype.getGeometry = function(cell)\n{\n\treturn (cell != null) ? cell.getGeometry() : null;\n};\n\n/**\n * Function: setGeometry\n * \n * Sets the <mxGeometry> of the given <mxCell>. The actual update\n * of the cell is carried out in <geometryForCellChanged>. The\n * <mxGeometryChange> action is used to encapsulate the change.\n * \n * Parameters:\n * \n * cell - <mxCell> whose geometry should be changed.\n * geometry - <mxGeometry> that defines the new geometry.\n */\nmxGraphModel.prototype.setGeometry = function(cell, geometry)\n{\n\tif (geometry != this.getGeometry(cell))\n\t{\n\t\tthis.execute(new mxGeometryChange(this, cell, geometry));\n\t}\n\t\n\treturn geometry;\n};\n\n/**\n * Function: geometryForCellChanged\n * \n * Inner callback to update the <mxGeometry> of the given <mxCell> using\n * <mxCell.setGeometry> and return the previous <mxGeometry>.\n */\nmxGraphModel.prototype.geometryForCellChanged = function(cell, geometry)\n{\n\tvar previous = this.getGeometry(cell);\n\tcell.setGeometry(geometry);\n\t\n\treturn previous;\n};\n\n/**\n * Function: getStyle\n * \n * Returns the style of the given <mxCell>.\n *\n * Parameters:\n * \n * cell - <mxCell> whose style should be returned.\n */\nmxGraphModel.prototype.getStyle = function(cell)\n{\n\treturn (cell != null) ? cell.getStyle() : null;\n};\n\n/**\n * Function: setStyle\n * \n * Sets the style of the given <mxCell> using <mxStyleChange> and\n * adds the change to the current transaction.\n *\n * Parameters:\n * \n * cell - <mxCell> whose style should be changed.\n * style - String of the form [stylename;|key=value;] to specify\n * the new cell style.\n */\nmxGraphModel.prototype.setStyle = function(cell, style)\n{\n\tif (style != this.getStyle(cell))\n\t{\n\t\tthis.execute(new mxStyleChange(this, cell, style));\n\t}\n\t\n\treturn style;\n};\n\n/**\n * Function: styleForCellChanged\n * \n * Inner callback to update the style of the given <mxCell>\n * using <mxCell.setStyle> and return the previous style.\n *\n * Parameters:\n * \n * cell - <mxCell> that specifies the cell to be updated.\n * style - String of the form [stylename;|key=value;] to specify\n * the new cell style.\n */\nmxGraphModel.prototype.styleForCellChanged = function(cell, style)\n{\n\tvar previous = this.getStyle(cell);\n\tcell.setStyle(style);\n\t\n\treturn previous;\n};\n\n/**\n * Function: isCollapsed\n * \n * Returns true if the given <mxCell> is collapsed.\n *\n * Parameters:\n * \n * cell - <mxCell> whose collapsed state should be returned.\n */\nmxGraphModel.prototype.isCollapsed = function(cell)\n{\n\treturn (cell != null) ? cell.isCollapsed() : false;\n};\n\n/**\n * Function: setCollapsed\n * \n * Sets the collapsed state of the given <mxCell> using <mxCollapseChange>\n * and adds the change to the current transaction.\n *\n * Parameters:\n * \n * cell - <mxCell> whose collapsed state should be changed.\n * collapsed - Boolean that specifies the new collpased state.\n */\nmxGraphModel.prototype.setCollapsed = function(cell, collapsed)\n{\n\tif (collapsed != this.isCollapsed(cell))\n\t{\n\t\tthis.execute(new mxCollapseChange(this, cell, collapsed));\n\t}\n\t\n\treturn collapsed;\n};\n\t\n/**\n * Function: collapsedStateForCellChanged\n *\n * Inner callback to update the collapsed state of the\n * given <mxCell> using <mxCell.setCollapsed> and return\n * the previous collapsed state.\n *\n * Parameters:\n * \n * cell - <mxCell> that specifies the cell to be updated.\n * collapsed - Boolean that specifies the new collpased state.\n */\nmxGraphModel.prototype.collapsedStateForCellChanged = function(cell, collapsed)\n{\n\tvar previous = this.isCollapsed(cell);\n\tcell.setCollapsed(collapsed);\n\t\n\treturn previous;\n};\n\n/**\n * Function: isVisible\n * \n * Returns true if the given <mxCell> is visible.\n * \n * Parameters:\n * \n * cell - <mxCell> whose visible state should be returned.\n */\nmxGraphModel.prototype.isVisible = function(cell)\n{\n\treturn (cell != null) ? cell.isVisible() : false;\n};\n\n/**\n * Function: setVisible\n * \n * Sets the visible state of the given <mxCell> using <mxVisibleChange> and\n * adds the change to the current transaction.\n *\n * Parameters:\n * \n * cell - <mxCell> whose visible state should be changed.\n * visible - Boolean that specifies the new visible state.\n */\nmxGraphModel.prototype.setVisible = function(cell, visible)\n{\n\tif (visible != this.isVisible(cell))\n\t{\n\t\tthis.execute(new mxVisibleChange(this, cell, visible));\n\t}\n\t\n\treturn visible;\n};\n\t\n/**\n * Function: visibleStateForCellChanged\n *\n * Inner callback to update the visible state of the\n * given <mxCell> using <mxCell.setCollapsed> and return\n * the previous visible state.\n *\n * Parameters:\n * \n * cell - <mxCell> that specifies the cell to be updated.\n * visible - Boolean that specifies the new visible state.\n */\nmxGraphModel.prototype.visibleStateForCellChanged = function(cell, visible)\n{\n\tvar previous = this.isVisible(cell);\n\tcell.setVisible(visible);\n\t\n\treturn previous;\n};\n\n/**\n * Function: execute\n * \n * Executes the given edit and fires events if required. The edit object\n * requires an execute function which is invoked. The edit is added to the\n * <currentEdit> between <beginUpdate> and <endUpdate> calls, so that\n * events will be fired if this execute is an individual transaction, that\n * is, if no previous <beginUpdate> calls have been made without calling\n * <endUpdate>. This implementation fires an <execute> event before\n * executing the given change.\n * \n * Parameters:\n * \n * change - Object that described the change.\n */\nmxGraphModel.prototype.execute = function(change)\n{\n\tchange.execute();\n\tthis.beginUpdate();\n\tthis.currentEdit.add(change);\n\tthis.fireEvent(new mxEventObject(mxEvent.EXECUTE, 'change', change));\n\t// New global executed event\n\tthis.fireEvent(new mxEventObject(mxEvent.EXECUTED, 'change', change));\n\tthis.endUpdate();\n};\n\n/**\n * Function: beginUpdate\n * \n * Increments the <updateLevel> by one. The event notification\n * is queued until <updateLevel> reaches 0 by use of\n * <endUpdate>.\n *\n * All changes on <mxGraphModel> are transactional,\n * that is, they are executed in a single undoable change\n * on the model (without transaction isolation).\n * Therefore, if you want to combine any\n * number of changes into a single undoable change,\n * you should group any two or more API calls that\n * modify the graph model between <beginUpdate>\n * and <endUpdate> calls as shown here:\n * \n * (code)\n * var model = graph.getModel();\n * var parent = graph.getDefaultParent();\n * var index = model.getChildCount(parent);\n * model.beginUpdate();\n * try\n * {\n *   model.add(parent, v1, index);\n *   model.add(parent, v2, index+1);\n * }\n * finally\n * {\n *   model.endUpdate();\n * }\n * (end)\n * \n * Of course there is a shortcut for appending a\n * sequence of cells into the default parent:\n * \n * (code)\n * graph.addCells([v1, v2]).\n * (end)\n */\nmxGraphModel.prototype.beginUpdate = function()\n{\n\tthis.updateLevel++;\n\tthis.fireEvent(new mxEventObject(mxEvent.BEGIN_UPDATE));\n\t\n\tif (this.updateLevel == 1)\n\t{\n\t\tthis.fireEvent(new mxEventObject(mxEvent.START_EDIT));\n\t}\n};\n\n/**\n * Function: endUpdate\n * \n * Decrements the <updateLevel> by one and fires an <undo>\n * event if the <updateLevel> reaches 0. This function\n * indirectly fires a <change> event by invoking the notify\n * function on the <currentEdit> und then creates a new\n * <currentEdit> using <createUndoableEdit>.\n *\n * The <undo> event is fired only once per edit, whereas\n * the <change> event is fired whenever the notify\n * function is invoked, that is, on undo and redo of\n * the edit.\n */\nmxGraphModel.prototype.endUpdate = function()\n{\n\tthis.updateLevel--;\n\t\n\tif (this.updateLevel == 0)\n\t{\n\t\tthis.fireEvent(new mxEventObject(mxEvent.END_EDIT));\n\t}\n\t\n\tif (!this.endingUpdate)\n\t{\n\t\tthis.endingUpdate = this.updateLevel == 0;\n\t\tthis.fireEvent(new mxEventObject(mxEvent.END_UPDATE, 'edit', this.currentEdit));\n\n\t\ttry\n\t\t{\t\t\n\t\t\tif (this.endingUpdate && !this.currentEdit.isEmpty())\n\t\t\t{\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.BEFORE_UNDO, 'edit', this.currentEdit));\n\t\t\t\tvar tmp = this.currentEdit;\n\t\t\t\tthis.currentEdit = this.createUndoableEdit();\n\t\t\t\ttmp.notify();\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.UNDO, 'edit', tmp));\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.endingUpdate = false;\n\t\t}\n\t}\n};\n\n/**\n * Function: createUndoableEdit\n * \n * Creates a new <mxUndoableEdit> that implements the\n * notify function to fire a <change> and <notify> event\n * through the <mxUndoableEdit>'s source.\n * \n * Parameters:\n * \n * significant - Optional boolean that specifies if the edit to be created is\n * significant. Default is true.\n */\nmxGraphModel.prototype.createUndoableEdit = function(significant)\n{\n\tvar edit = new mxUndoableEdit(this, (significant != null) ? significant : true);\n\t\n\tedit.notify = function()\n\t{\n\t\t// LATER: Remove changes property (deprecated)\n\t\tedit.source.fireEvent(new mxEventObject(mxEvent.CHANGE,\n\t\t\t'edit', edit, 'changes', edit.changes));\n\t\tedit.source.fireEvent(new mxEventObject(mxEvent.NOTIFY,\n\t\t\t'edit', edit, 'changes', edit.changes));\n\t};\n\t\n\treturn edit;\n};\n\n/**\n * Function: mergeChildren\n * \n * Merges the children of the given cell into the given target cell inside\n * this model. All cells are cloned unless there is a corresponding cell in\n * the model with the same id, in which case the source cell is ignored and\n * all edges are connected to the corresponding cell in this model. Edges\n * are considered to have no identity and are always cloned unless the\n * cloneAllEdges flag is set to false, in which case edges with the same\n * id in the target model are reconnected to reflect the terminals of the\n * source edges.\n */\nmxGraphModel.prototype.mergeChildren = function(from, to, cloneAllEdges)\n{\n\tcloneAllEdges = (cloneAllEdges != null) ? cloneAllEdges : true;\n\t\n\tthis.beginUpdate();\n\ttry\n\t{\n\t\tvar mapping = new Object();\n\t\tthis.mergeChildrenImpl(from, to, cloneAllEdges, mapping);\n\t\t\n\t\t// Post-processes all edges in the mapping and\n\t\t// reconnects the terminals to the corresponding\n\t\t// cells in the target model\n\t\tfor (var key in mapping)\n\t\t{\n\t\t\tvar cell = mapping[key];\n\t\t\tvar terminal = this.getTerminal(cell, true);\n\n\t\t\tif (terminal != null)\n\t\t\t{\n\t\t\t\tterminal = mapping[mxCellPath.create(terminal)];\n\t\t\t\tthis.setTerminal(cell, terminal, true);\n\t\t\t}\n\t\t\t\n\t\t\tterminal = this.getTerminal(cell, false);\n\t\t\t\n\t\t\tif (terminal != null)\n\t\t\t{\n\t\t\t\tterminal = mapping[mxCellPath.create(terminal)];\n\t\t\t\tthis.setTerminal(cell, terminal, false);\n\t\t\t}\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tthis.endUpdate();\n\t}\n};\n\n/**\n * Function: mergeChildren\n * \n * Clones the children of the source cell into the given target cell in\n * this model and adds an entry to the mapping that maps from the source\n * cell to the target cell with the same id or the clone of the source cell\n * that was inserted into this model.\n */\nmxGraphModel.prototype.mergeChildrenImpl = function(from, to, cloneAllEdges, mapping)\n{\n\tthis.beginUpdate();\n\ttry\n\t{\n\t\tvar childCount = from.getChildCount();\n\t\t\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar cell = from.getChildAt(i);\n\t\t\t\n\t\t\tif (typeof(cell.getId) == 'function')\n\t\t\t{\n\t\t\t\tvar id = cell.getId();\n\t\t\t\tvar target = (id != null && (!this.isEdge(cell) || !cloneAllEdges)) ?\n\t\t\t\t\t\tthis.getCell(id) : null;\n\t\t\t\t\n\t\t\t\t// Clones and adds the child if no cell exists for the id\n\t\t\t\tif (target == null)\n\t\t\t\t{\n\t\t\t\t\tvar clone = cell.clone();\n\t\t\t\t\tclone.setId(id);\n\t\t\t\t\t\n\t\t\t\t\t// Sets the terminals from the original cell to the clone\n\t\t\t\t\t// because the lookup uses strings not cells in JS\n\t\t\t\t\tclone.setTerminal(cell.getTerminal(true), true);\n\t\t\t\t\tclone.setTerminal(cell.getTerminal(false), false);\n\t\t\t\t\t\n\t\t\t\t\t// Do *NOT* use model.add as this will move the edge away\n\t\t\t\t\t// from the parent in updateEdgeParent if maintainEdgeParent\n\t\t\t\t\t// is enabled in the target model\n\t\t\t\t\ttarget = to.insert(clone);\n\t\t\t\t\tthis.cellAdded(target);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Stores the mapping for later reconnecting edges\n\t\t\t\tmapping[mxCellPath.create(cell)] = target;\n\t\t\t\t\n\t\t\t\t// Recurses\n\t\t\t\tthis.mergeChildrenImpl(cell, target, cloneAllEdges, mapping);\n\t\t\t}\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tthis.endUpdate();\n\t}\n};\n\n/**\n * Function: getParents\n * \n * Returns an array that represents the set (no duplicates) of all parents\n * for the given array of cells.\n * \n * Parameters:\n * \n * cells - Array of cells whose parents should be returned.\n */\nmxGraphModel.prototype.getParents = function(cells)\n{\n\tvar parents = [];\n\t\n\tif (cells != null)\n\t{\n\t\tvar dict = new mxDictionary();\n\t\t\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tvar parent = this.getParent(cells[i]);\n\t\t\t\n\t\t\tif (parent != null && !dict.get(parent))\n\t\t\t{\n\t\t\t\tdict.put(parent, true);\n\t\t\t\tparents.push(parent);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn parents;\n};\n\n//\n// Cell Cloning\n//\n\n/**\n * Function: cloneCell\n * \n * Returns a deep clone of the given <mxCell> (including\n * the children) which is created using <cloneCells>.\n *\n * Parameters:\n * \n * cell - <mxCell> to be cloned.\n * includeChildren - Optional boolean indicating if the cells should be cloned\n * with all descendants. Default is true.\n */\nmxGraphModel.prototype.cloneCell = function(cell, includeChildren)\n{\n\tif (cell != null)\n\t{\n\t\treturn this.cloneCells([cell], includeChildren)[0];\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: cloneCells\n * \n * Returns an array of clones for the given array of <mxCells>.\n * Depending on the value of includeChildren, a deep clone is created for\n * each cell. Connections are restored based if the corresponding\n * cell is contained in the passed in array.\n *\n * Parameters:\n * \n * cells - Array of <mxCell> to be cloned.\n * includeChildren - Optional boolean indicating if the cells should be cloned\n * with all descendants. Default is true.\n * mapping - Optional mapping for existing clones.\n */\nmxGraphModel.prototype.cloneCells = function(cells, includeChildren, mapping)\n{\n\tincludeChildren = (includeChildren != null) ? includeChildren : true;\n\tmapping = (mapping != null) ? mapping : new Object();\n\tvar clones = [];\n\t\n\tfor (var i = 0; i < cells.length; i++)\n\t{\n\t\tif (cells[i] != null)\n\t\t{\n\t\t\tclones.push(this.cloneCellImpl(cells[i], mapping, includeChildren));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tclones.push(null);\n\t\t}\n\t}\n\t\n\tfor (var i = 0; i < clones.length; i++)\n\t{\n\t\tif (clones[i] != null)\n\t\t{\n\t\t\tthis.restoreClone(clones[i], cells[i], mapping);\n\t\t}\n\t}\n\t\n\treturn clones;\n};\n\t\t\t\n/**\n * Function: cloneCellImpl\n * \n * Inner helper method for cloning cells recursively.\n */\nmxGraphModel.prototype.cloneCellImpl = function(cell, mapping, includeChildren)\n{\n\tvar ident = mxObjectIdentity.get(cell);\n\tvar clone = mapping[ident];\n\t\n\tif (clone == null)\n\t{\n\t\tclone = this.cellCloned(cell);\n\t\tmapping[ident] = clone;\n\n\t\tif (includeChildren)\n\t\t{\n\t\t\tvar childCount = this.getChildCount(cell);\n\t\t\t\n\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t{\n\t\t\t\tvar cloneChild = this.cloneCellImpl(\n\t\t\t\t\tthis.getChildAt(cell, i), mapping, true);\n\t\t\t\tclone.insert(cloneChild);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn clone;\n};\n\n/**\n * Function: cellCloned\n * \n * Hook for cloning the cell. This returns cell.clone() or\n * any possible exceptions.\n */\nmxGraphModel.prototype.cellCloned = function(cell)\n{\n\treturn cell.clone();\n};\n\n/**\n * Function: restoreClone\n * \n * Inner helper method for restoring the connections in\n * a network of cloned cells.\n */\nmxGraphModel.prototype.restoreClone = function(clone, cell, mapping)\n{\n\tvar source = this.getTerminal(cell, true);\n\t\n\tif (source != null)\n\t{\n\t\tvar tmp = mapping[mxObjectIdentity.get(source)];\n\t\t\n\t\tif (tmp != null)\n\t\t{\n\t\t\ttmp.insertEdge(clone, true);\n\t\t}\n\t}\n\t\n\tvar target = this.getTerminal(cell, false);\n\t\n\tif (target != null)\n\t{\n\t\tvar tmp = mapping[mxObjectIdentity.get(target)];\n\t\t\n\t\tif (tmp != null)\n\t\t{\t\n\t\t\ttmp.insertEdge(clone, false);\n\t\t}\n\t}\n\t\n\tvar childCount = this.getChildCount(clone);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tthis.restoreClone(this.getChildAt(clone, i),\n\t\t\tthis.getChildAt(cell, i), mapping);\n\t}\n};\n\n//\n// Atomic changes\n//\n\n/**\n * Class: mxRootChange\n * \n * Action to change the root in a model.\n *\n * Constructor: mxRootChange\n * \n * Constructs a change of the root in the\n * specified model.\n */\nfunction mxRootChange(model, root)\n{\n\tthis.model = model;\n\tthis.root = root;\n\tthis.previous = root;\n};\n\n/**\n * Function: execute\n * \n * Carries out a change of the root using\n * <mxGraphModel.rootChanged>.\n */\nmxRootChange.prototype.execute = function()\n{\n\tthis.root = this.previous;\n\tthis.previous = this.model.rootChanged(this.previous);\n};\n\n/**\n * Class: mxChildChange\n * \n * Action to add or remove a child in a model.\n *\n * Constructor: mxChildChange\n * \n * Constructs a change of a child in the\n * specified model.\n */\nfunction mxChildChange(model, parent, child, index)\n{\n\tthis.model = model;\n\tthis.parent = parent;\n\tthis.previous = parent;\n\tthis.child = child;\n\tthis.index = index;\n\tthis.previousIndex = index;\n};\n\n/**\n * Function: execute\n * \n * Changes the parent of <child> using\n * <mxGraphModel.parentForCellChanged> and\n * removes or restores the cell's\n * connections.\n */\nmxChildChange.prototype.execute = function()\n{\n\tif (this.child != null)\n\t{\n\t\tvar tmp = this.model.getParent(this.child);\n\t\tvar tmp2 = (tmp != null) ? tmp.getIndex(this.child) : 0;\n\t\t\n\t\tif (this.previous == null)\n\t\t{\n\t\t\tthis.connect(this.child, false);\n\t\t}\n\t\t\n\t\ttmp = this.model.parentForCellChanged(\n\t\t\tthis.child, this.previous, this.previousIndex);\n\t\t\t\n\t\tif (this.previous != null)\n\t\t{\n\t\t\tthis.connect(this.child, true);\n\t\t}\n\t\t\n\t\tthis.parent = this.previous;\n\t\tthis.previous = tmp;\n\t\tthis.index = this.previousIndex;\n\t\tthis.previousIndex = tmp2;\n\t}\n};\n\n/**\n * Function: disconnect\n * \n * Disconnects the given cell recursively from its\n * terminals and stores the previous terminal in the\n * cell's terminals.\n */\nmxChildChange.prototype.connect = function(cell, isConnect)\n{\n\tisConnect = (isConnect != null) ? isConnect : true;\n\t\n\tvar source = cell.getTerminal(true);\n\tvar target = cell.getTerminal(false);\n\t\n\tif (source != null)\n\t{\n\t\tif (isConnect)\n\t\t{\n\t\t\tthis.model.terminalForCellChanged(cell, source, true);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.model.terminalForCellChanged(cell, null, true);\n\t\t}\n\t}\n\t\n\tif (target != null)\n\t{\n\t\tif (isConnect)\n\t\t{\n\t\t\tthis.model.terminalForCellChanged(cell, target, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.model.terminalForCellChanged(cell, null, false);\n\t\t}\n\t}\n\t\n\tcell.setTerminal(source, true);\n\tcell.setTerminal(target, false);\n\t\n\tvar childCount = this.model.getChildCount(cell);\n\t\n\tfor (var i=0; i<childCount; i++)\n\t{\n\t\tthis.connect(this.model.getChildAt(cell, i), isConnect);\n\t}\n};\n\n/**\n * Class: mxTerminalChange\n * \n * Action to change a terminal in a model.\n *\n * Constructor: mxTerminalChange\n * \n * Constructs a change of a terminal in the \n * specified model.\n */\nfunction mxTerminalChange(model, cell, terminal, source)\n{\n\tthis.model = model;\n\tthis.cell = cell;\n\tthis.terminal = terminal;\n\tthis.previous = terminal;\n\tthis.source = source;\n};\n\n/**\n * Function: execute\n * \n * Changes the terminal of <cell> to <previous> using\n * <mxGraphModel.terminalForCellChanged>.\n */\nmxTerminalChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tthis.terminal = this.previous;\n\t\tthis.previous = this.model.terminalForCellChanged(\n\t\t\tthis.cell, this.previous, this.source);\n\t}\n};\n\n/**\n * Class: mxValueChange\n * \n * Action to change a user object in a model.\n *\n * Constructor: mxValueChange\n * \n * Constructs a change of a user object in the \n * specified model.\n */\nfunction mxValueChange(model, cell, value)\n{\n\tthis.model = model;\n\tthis.cell = cell;\n\tthis.value = value;\n\tthis.previous = value;\n};\n\n/**\n * Function: execute\n * \n * Changes the value of <cell> to <previous> using\n * <mxGraphModel.valueForCellChanged>.\n */\nmxValueChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tthis.value = this.previous;\n\t\tthis.previous = this.model.valueForCellChanged(\n\t\t\tthis.cell, this.previous);\n\t}\n};\n\n/**\n * Class: mxStyleChange\n * \n * Action to change a cell's style in a model.\n *\n * Constructor: mxStyleChange\n * \n * Constructs a change of a style in the\n * specified model.\n */\nfunction mxStyleChange(model, cell, style)\n{\n\tthis.model = model;\n\tthis.cell = cell;\n\tthis.style = style;\n\tthis.previous = style;\n};\n\n/**\n * Function: execute\n * \n * Changes the style of <cell> to <previous> using\n * <mxGraphModel.styleForCellChanged>.\n */\nmxStyleChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tthis.style = this.previous;\n\t\tthis.previous = this.model.styleForCellChanged(\n\t\t\tthis.cell, this.previous);\n\t}\n};\n\n/**\n * Class: mxGeometryChange\n * \n * Action to change a cell's geometry in a model.\n *\n * Constructor: mxGeometryChange\n * \n * Constructs a change of a geometry in the\n * specified model.\n */\nfunction mxGeometryChange(model, cell, geometry)\n{\n\tthis.model = model;\n\tthis.cell = cell;\n\tthis.geometry = geometry;\n\tthis.previous = geometry;\n};\n\n/**\n * Function: execute\n * \n * Changes the geometry of <cell> ro <previous> using\n * <mxGraphModel.geometryForCellChanged>.\n */\nmxGeometryChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tthis.geometry = this.previous;\n\t\tthis.previous = this.model.geometryForCellChanged(\n\t\t\tthis.cell, this.previous);\n\t}\n};\n\n/**\n * Class: mxCollapseChange\n * \n * Action to change a cell's collapsed state in a model.\n *\n * Constructor: mxCollapseChange\n * \n * Constructs a change of a collapsed state in the\n * specified model.\n */\nfunction mxCollapseChange(model, cell, collapsed)\n{\n\tthis.model = model;\n\tthis.cell = cell;\n\tthis.collapsed = collapsed;\n\tthis.previous = collapsed;\n};\n\n/**\n * Function: execute\n * \n * Changes the collapsed state of <cell> to <previous> using\n * <mxGraphModel.collapsedStateForCellChanged>.\n */\nmxCollapseChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tthis.collapsed = this.previous;\n\t\tthis.previous = this.model.collapsedStateForCellChanged(\n\t\t\tthis.cell, this.previous);\n\t}\n};\n\n/**\n * Class: mxVisibleChange\n * \n * Action to change a cell's visible state in a model.\n *\n * Constructor: mxVisibleChange\n * \n * Constructs a change of a visible state in the\n * specified model.\n */\nfunction mxVisibleChange(model, cell, visible)\n{\n\tthis.model = model;\n\tthis.cell = cell;\n\tthis.visible = visible;\n\tthis.previous = visible;\n};\n\n/**\n * Function: execute\n * \n * Changes the visible state of <cell> to <previous> using\n * <mxGraphModel.visibleStateForCellChanged>.\n */\nmxVisibleChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tthis.visible = this.previous;\n\t\tthis.previous = this.model.visibleStateForCellChanged(\n\t\t\tthis.cell, this.previous);\n\t}\n};\n\n/**\n * Class: mxCellAttributeChange\n * \n * Action to change the attribute of a cell's user object.\n * There is no method on the graph model that uses this\n * action. To use the action, you can use the code shown\n * in the example below.\n * \n * Example:\n * \n * To change the attributeName in the cell's user object\n * to attributeValue, use the following code:\n * \n * (code)\n * model.beginUpdate();\n * try\n * {\n *   var edit = new mxCellAttributeChange(\n *     cell, attributeName, attributeValue);\n *   model.execute(edit);\n * }\n * finally\n * {\n *   model.endUpdate();\n * } \n * (end)\n *\n * Constructor: mxCellAttributeChange\n * \n * Constructs a change of a attribute of the DOM node\n * stored as the value of the given <mxCell>.\n */\nfunction mxCellAttributeChange(cell, attribute, value)\n{\n\tthis.cell = cell;\n\tthis.attribute = attribute;\n\tthis.value = value;\n\tthis.previous = value;\n};\n\n/**\n * Function: execute\n * \n * Changes the attribute of the cell's user object by\n * using <mxCell.setAttribute>.\n */\nmxCellAttributeChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tvar tmp = this.cell.getAttribute(this.attribute);\n\t\t\n\t\tif (this.previous == null)\n\t\t{\n\t\t\tthis.cell.value.removeAttribute(this.attribute);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.cell.setAttribute(this.attribute, this.previous);\n\t\t}\n\t\t\n\t\tthis.previous = tmp;\n\t}\n};\n\n__mxOutput.mxGraphModel = typeof mxGraphModel !== 'undefined' ? mxGraphModel : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCell\n *\n * Cells are the elements of the graph model. They represent the state\n * of the groups, vertices and edges in a graph.\n * \n * Custom attributes:\n * \n * For custom attributes we recommend using an XML node as the value of a cell.\n * The following code can be used to create a cell with an XML node as the\n * value:\n * \n * (code)\n * var doc = mxUtils.createXmlDocument();\n * var node = doc.createElement('MyNode')\n * node.setAttribute('label', 'MyLabel');\n * node.setAttribute('attribute1', 'value1');\n * graph.insertVertex(graph.getDefaultParent(), null, node, 40, 40, 80, 30);\n * (end)\n * \n * For the label to work, <mxGraph.convertValueToString> and\n * <mxGraph.cellLabelChanged> should be overridden as follows:\n * \n * (code)\n * graph.convertValueToString = function(cell)\n * {\n *   if (mxUtils.isNode(cell.value))\n *   {\n *     return cell.getAttribute('label', '')\n *   }\n * };\n * \n * var cellLabelChanged = graph.cellLabelChanged;\n * graph.cellLabelChanged = function(cell, newValue, autoSize)\n * {\n *   if (mxUtils.isNode(cell.value))\n *   {\n *     // Clones the value for correct undo/redo\n *     var elt = cell.value.cloneNode(true);\n *     elt.setAttribute('label', newValue);\n *     newValue = elt;\n *   }\n *   \n *   cellLabelChanged.apply(this, arguments);\n * };\n * (end)\n * \n * Callback: onInit\n *\n * Called from within the constructor.\n * \n * Constructor: mxCell\n *\n * Constructs a new cell to be used in a graph model.\n * This method invokes <onInit> upon completion.\n * \n * Parameters:\n * \n * value - Optional object that represents the cell value.\n * geometry - Optional <mxGeometry> that specifies the geometry.\n * style - Optional formatted string that defines the style.\n */\nfunction mxCell(value, geometry, style)\n{\n\tthis.value = value;\n\tthis.setGeometry(geometry);\n\tthis.setStyle(style);\n\t\n\tif (this.onInit != null)\n\t{\n\t\tthis.onInit();\n\t}\n};\n\n/**\n * Variable: id\n *\n * Holds the Id. Default is null.\n */\nmxCell.prototype.id = null;\n\n/**\n * Variable: value\n *\n * Holds the user object. Default is null.\n */\nmxCell.prototype.value = null;\n\n/**\n * Variable: geometry\n *\n * Holds the <mxGeometry>. Default is null.\n */\nmxCell.prototype.geometry = null;\n\n/**\n * Variable: style\n *\n * Holds the style as a string of the form [(stylename|key=value);]. Default is\n * null.\n */\nmxCell.prototype.style = null;\n\n/**\n * Variable: vertex\n *\n * Specifies whether the cell is a vertex. Default is false.\n */\nmxCell.prototype.vertex = false;\n\n/**\n * Variable: edge\n *\n * Specifies whether the cell is an edge. Default is false.\n */\nmxCell.prototype.edge = false;\n\n/**\n * Variable: connectable\n *\n * Specifies whether the cell is connectable. Default is true.\n */\nmxCell.prototype.connectable = true;\n\n/**\n * Variable: visible\n *\n * Specifies whether the cell is visible. Default is true.\n */\nmxCell.prototype.visible = true;\n\n/**\n * Variable: collapsed\n *\n * Specifies whether the cell is collapsed. Default is false.\n */\nmxCell.prototype.collapsed = false;\n\n/**\n * Variable: parent\n *\n * Reference to the parent cell.\n */\nmxCell.prototype.parent = null;\n\n/**\n * Variable: source\n *\n * Reference to the source terminal.\n */\nmxCell.prototype.source = null;\n\n/**\n * Variable: target\n *\n * Reference to the target terminal.\n */\nmxCell.prototype.target = null;\n\n/**\n * Variable: children\n *\n * Holds the child cells.\n */\nmxCell.prototype.children = null;\n\n/**\n * Variable: edges\n *\n * Holds the edges.\n */\nmxCell.prototype.edges = null;\n\n/**\n * Variable: mxTransient\n *\n * List of members that should not be cloned inside <clone>. This field is\n * passed to <mxUtils.clone> and is not made persistent in <mxCellCodec>.\n * This is not a convention for all classes, it is only used in this class\n * to mark transient fields since transient modifiers are not supported by\n * the language.\n */\nmxCell.prototype.mxTransient = ['id', 'value', 'parent', 'source',\n                                'target', 'children', 'edges'];\n\n/**\n * Function: getId\n *\n * Returns the Id of the cell as a string.\n */\nmxCell.prototype.getId = function()\n{\n\treturn this.id;\n};\n\t\t\n/**\n * Function: setId\n *\n * Sets the Id of the cell to the given string.\n */\nmxCell.prototype.setId = function(id)\n{\n\tthis.id = id;\n};\n\n/**\n * Function: getValue\n *\n * Returns the user object of the cell. The user\n * object is stored in <value>.\n */\nmxCell.prototype.getValue = function()\n{\n\treturn this.value;\n};\n\t\t\n/**\n * Function: setValue\n *\n * Sets the user object of the cell. The user object\n * is stored in <value>.\n */\nmxCell.prototype.setValue = function(value)\n{\n\tthis.value = value;\n};\n\n/**\n * Function: valueChanged\n *\n * Changes the user object after an in-place edit\n * and returns the previous value. This implementation\n * replaces the user object with the given value and\n * returns the old user object.\n */\nmxCell.prototype.valueChanged = function(newValue)\n{\n\tvar previous = this.getValue();\n\tthis.setValue(newValue);\n\t\n\treturn previous;\n};\n\n/**\n * Function: getGeometry\n *\n * Returns the <mxGeometry> that describes the <geometry>.\n */\nmxCell.prototype.getGeometry = function()\n{\n\treturn this.geometry;\n};\n\n/**\n * Function: setGeometry\n *\n * Sets the <mxGeometry> to be used as the <geometry>.\n */\nmxCell.prototype.setGeometry = function(geometry)\n{\n\tthis.geometry = geometry;\n};\n\n/**\n * Function: getStyle\n *\n * Returns a string that describes the <style>.\n */\nmxCell.prototype.getStyle = function()\n{\n\treturn this.style;\n};\n\n/**\n * Function: setStyle\n *\n * Sets the string to be used as the <style>.\n */\nmxCell.prototype.setStyle = function(style)\n{\n\tthis.style = style;\n};\n\n/**\n * Function: isVertex\n *\n * Returns true if the cell is a vertex.\n */\nmxCell.prototype.isVertex = function()\n{\n\treturn this.vertex != 0;\n};\n\n/**\n * Function: setVertex\n *\n * Specifies if the cell is a vertex. This should only be assigned at\n * construction of the cell and not be changed during its lifecycle.\n * \n * Parameters:\n * \n * vertex - Boolean that specifies if the cell is a vertex.\n */\nmxCell.prototype.setVertex = function(vertex)\n{\n\tthis.vertex = vertex;\n};\n\n/**\n * Function: isEdge\n *\n * Returns true if the cell is an edge.\n */\nmxCell.prototype.isEdge = function()\n{\n\treturn this.edge != 0;\n};\n\t\n/**\n * Function: setEdge\n * \n * Specifies if the cell is an edge. This should only be assigned at\n * construction of the cell and not be changed during its lifecycle.\n * \n * Parameters:\n * \n * edge - Boolean that specifies if the cell is an edge.\n */\nmxCell.prototype.setEdge = function(edge)\n{\n\tthis.edge = edge;\n};\n\n/**\n * Function: isConnectable\n *\n * Returns true if the cell is connectable.\n */\nmxCell.prototype.isConnectable = function()\n{\n\treturn this.connectable != 0;\n};\n\n/**\n * Function: setConnectable\n *\n * Sets the connectable state.\n * \n * Parameters:\n * \n * connectable - Boolean that specifies the new connectable state.\n */\nmxCell.prototype.setConnectable = function(connectable)\n{\n\tthis.connectable = connectable;\n};\n\n/**\n * Function: isVisible\n *\n * Returns true if the cell is visibile.\n */\nmxCell.prototype.isVisible = function()\n{\n\treturn this.visible != 0;\n};\n\n/**\n * Function: setVisible\n *\n * Specifies if the cell is visible.\n * \n * Parameters:\n * \n * visible - Boolean that specifies the new visible state.\n */\nmxCell.prototype.setVisible = function(visible)\n{\n\tthis.visible = visible;\n};\n\n/**\n * Function: isCollapsed\n *\n * Returns true if the cell is collapsed.\n */\nmxCell.prototype.isCollapsed = function()\n{\n\treturn this.collapsed != 0;\n};\n\n/**\n * Function: setCollapsed\n *\n * Sets the collapsed state.\n * \n * Parameters:\n * \n * collapsed - Boolean that specifies the new collapsed state.\n */\nmxCell.prototype.setCollapsed = function(collapsed)\n{\n\tthis.collapsed = collapsed;\n};\n\n/**\n * Function: getParent\n *\n * Returns the cell's parent.\n */\nmxCell.prototype.getParent = function()\n{\n\treturn this.parent;\n};\n\n/**\n * Function: setParent\n *\n * Sets the parent cell.\n * \n * Parameters:\n * \n * parent - <mxCell> that represents the new parent.\n */\nmxCell.prototype.setParent = function(parent)\n{\n\tthis.parent = parent;\n};\n\n/**\n * Function: getTerminal\n *\n * Returns the source or target terminal.\n * \n * Parameters:\n * \n * source - Boolean that specifies if the source terminal should be\n * returned.\n */\nmxCell.prototype.getTerminal = function(source)\n{\n\treturn (source) ? this.source : this.target;\n};\n\n/**\n * Function: setTerminal\n *\n * Sets the source or target terminal and returns the new terminal.\n * \n * Parameters:\n * \n * terminal - <mxCell> that represents the new source or target terminal.\n * isSource - Boolean that specifies if the source or target terminal\n * should be set.\n */\nmxCell.prototype.setTerminal = function(terminal, isSource)\n{\n\tif (isSource)\n\t{\n\t\tthis.source = terminal;\n\t}\n\telse\n\t{\n\t\tthis.target = terminal;\n\t}\n\t\n\treturn terminal;\n};\n\n/**\n * Function: getChildCount\n *\n * Returns the number of child cells.\n */\nmxCell.prototype.getChildCount = function()\n{\n\treturn (this.children == null) ? 0 : this.children.length;\n};\n\n/**\n * Function: getIndex\n *\n * Returns the index of the specified child in the child array.\n * \n * Parameters:\n * \n * child - Child whose index should be returned.\n */\nmxCell.prototype.getIndex = function(child)\n{\n\treturn mxUtils.indexOf(this.children, child);\n};\n\n/**\n * Function: getChildAt\n *\n * Returns the child at the specified index.\n * \n * Parameters:\n * \n * index - Integer that specifies the child to be returned.\n */\nmxCell.prototype.getChildAt = function(index)\n{\n\treturn (this.children == null) ? null : this.children[index];\n};\n\n/**\n * Function: insert\n *\n * Inserts the specified child into the child array at the specified index\n * and updates the parent reference of the child. If not childIndex is\n * specified then the child is appended to the child array. Returns the\n * inserted child.\n * \n * Parameters:\n * \n * child - <mxCell> to be inserted or appended to the child array.\n * index - Optional integer that specifies the index at which the child\n * should be inserted into the child array.\n */\nmxCell.prototype.insert = function(child, index)\n{\n\tif (child != null)\n\t{\n\t\tif (index == null)\n\t\t{\n\t\t\tindex = this.getChildCount();\n\t\t\t\n\t\t\tif (child.getParent() == this)\n\t\t\t{\n\t\t\t\tindex--;\n\t\t\t}\n\t\t}\n\n\t\tchild.removeFromParent();\n\t\tchild.setParent(this);\n\t\t\n\t\tif (this.children == null)\n\t\t{\n\t\t\tthis.children = [];\n\t\t\tthis.children.push(child);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.children.splice(index, 0, child);\n\t\t}\n\t}\n\t\n\treturn child;\n};\n\n/**\n * Function: remove\n *\n * Removes the child at the specified index from the child array and\n * returns the child that was removed. Will remove the parent reference of\n * the child.\n * \n * Parameters:\n * \n * index - Integer that specifies the index of the child to be\n * removed.\n */\nmxCell.prototype.remove = function(index)\n{\n\tvar child = null;\n\t\n\tif (this.children != null && index >= 0)\n\t{\n\t\tchild = this.getChildAt(index);\n\t\t\n\t\tif (child != null)\n\t\t{\n\t\t\tthis.children.splice(index, 1);\n\t\t\tchild.setParent(null);\n\t\t}\n\t}\n\t\n\treturn child;\n};\n\n/**\n * Function: removeFromParent\n *\n * Removes the cell from its parent.\n */\nmxCell.prototype.removeFromParent = function()\n{\n\tif (this.parent != null)\n\t{\n\t\tvar index = this.parent.getIndex(this);\n\t\tthis.parent.remove(index);\n\t}\n};\n\n/**\n * Function: getEdgeCount\n *\n * Returns the number of edges in the edge array.\n */\nmxCell.prototype.getEdgeCount = function()\n{\n\treturn (this.edges == null) ? 0 : this.edges.length;\n};\n\n/**\n * Function: getEdgeIndex\n *\n * Returns the index of the specified edge in <edges>.\n * \n * Parameters:\n * \n * edge - <mxCell> whose index in <edges> should be returned.\n */\nmxCell.prototype.getEdgeIndex = function(edge)\n{\n\treturn mxUtils.indexOf(this.edges, edge);\n};\n\n/**\n * Function: getEdgeAt\n *\n * Returns the edge at the specified index in <edges>.\n * \n * Parameters:\n * \n * index - Integer that specifies the index of the edge to be returned.\n */\nmxCell.prototype.getEdgeAt = function(index)\n{\n\treturn (this.edges == null) ? null : this.edges[index];\n};\n\n/**\n * Function: insertEdge\n *\n * Inserts the specified edge into the edge array and returns the edge.\n * Will update the respective terminal reference of the edge.\n * \n * Parameters:\n * \n * edge - <mxCell> to be inserted into the edge array.\n * isOutgoing - Boolean that specifies if the edge is outgoing.\n */\nmxCell.prototype.insertEdge = function(edge, isOutgoing)\n{\n\tif (edge != null)\n\t{\n\t\tedge.removeFromTerminal(isOutgoing);\n\t\tedge.setTerminal(this, isOutgoing);\n\t\t\n\t\tif (this.edges == null ||\n\t\t\tedge.getTerminal(!isOutgoing) != this ||\n\t\t\tmxUtils.indexOf(this.edges, edge) < 0)\n\t\t{\n\t\t\tif (this.edges == null)\n\t\t\t{\n\t\t\t\tthis.edges = [];\n\t\t\t}\n\t\t\t\n\t\t\tthis.edges.push(edge);\n\t\t}\n\t}\n\t\n\treturn edge;\n};\n\n/**\n * Function: removeEdge\n *\n * Removes the specified edge from the edge array and returns the edge.\n * Will remove the respective terminal reference from the edge.\n * \n * Parameters:\n * \n * edge - <mxCell> to be removed from the edge array.\n * isOutgoing - Boolean that specifies if the edge is outgoing.\n */\nmxCell.prototype.removeEdge = function(edge, isOutgoing)\n{\n\tif (edge != null)\n\t{\n\t\tif (edge.getTerminal(!isOutgoing) != this &&\n\t\t\tthis.edges != null)\n\t\t{\n\t\t\tvar index = this.getEdgeIndex(edge);\n\t\t\t\n\t\t\tif (index >= 0)\n\t\t\t{\n\t\t\t\tthis.edges.splice(index, 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tedge.setTerminal(null, isOutgoing);\n\t}\n\t\n\treturn edge;\n};\n\n/**\n * Function: removeFromTerminal\n *\n * Removes the edge from its source or target terminal.\n * \n * Parameters:\n * \n * isSource - Boolean that specifies if the edge should be removed from its\n * source or target terminal.\n */\nmxCell.prototype.removeFromTerminal = function(isSource)\n{\n\tvar terminal = this.getTerminal(isSource);\n\t\n\tif (terminal != null)\n\t{\n\t\tterminal.removeEdge(this, isSource);\n\t}\n};\n\n/**\n * Function: hasAttribute\n * \n * Returns true if the user object is an XML node that contains the given\n * attribute.\n * \n * Parameters:\n * \n * name - Name of the attribute.\n */\nmxCell.prototype.hasAttribute = function(name)\n{\n\tvar userObject = this.getValue();\n\t\n\treturn (userObject != null &&\n\t\tuserObject.nodeType == mxConstants.NODETYPE_ELEMENT && userObject.hasAttribute) ?\n\t\tuserObject.hasAttribute(name) : userObject.getAttribute(name) != null;\n};\n\n/**\n * Function: getAttribute\n *\n * Returns the specified attribute from the user object if it is an XML\n * node.\n * \n * Parameters:\n * \n * name - Name of the attribute whose value should be returned.\n * defaultValue - Optional default value to use if the attribute has no\n * value.\n */\nmxCell.prototype.getAttribute = function(name, defaultValue)\n{\n\tvar userObject = this.getValue();\n\t\n\tvar val = (userObject != null &&\n\t\tuserObject.nodeType == mxConstants.NODETYPE_ELEMENT) ?\n\t\tuserObject.getAttribute(name) : null;\n\t\t\n\treturn (val != null) ? val : defaultValue;\n};\n\n/**\n * Function: setAttribute\n *\n * Sets the specified attribute on the user object if it is an XML node.\n * \n * Parameters:\n * \n * name - Name of the attribute whose value should be set.\n * value - New value of the attribute.\n */\nmxCell.prototype.setAttribute = function(name, value)\n{\n\tvar userObject = this.getValue();\n\t\n\tif (userObject != null &&\n\t\tuserObject.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t{\n\t\tuserObject.setAttribute(name, value);\n\t}\n};\n\n/**\n * Function: clone\n *\n * Returns a clone of the cell. Uses <cloneValue> to clone\n * the user object. All fields in <mxTransient> are ignored\n * during the cloning.\n */\nmxCell.prototype.clone = function()\n{\n\tvar clone = mxUtils.clone(this, this.mxTransient);\n\tclone.setValue(this.cloneValue());\n\t\n\treturn clone;\n};\n\n/**\n * Function: cloneValue\n *\n * Returns a clone of the cell's user object.\n */\nmxCell.prototype.cloneValue = function()\n{\n\tvar value = this.getValue();\n\t\n\tif (value != null)\n\t{\n\t\tif (typeof(value.clone) == 'function')\n\t\t{\n\t\t\tvalue = value.clone();\n\t\t}\n\t\telse if (!isNaN(value.nodeType))\n\t\t{\n\t\t\tvalue = value.cloneNode(true);\n\t\t}\n\t}\n\t\n\treturn value;\n};\n\n__mxOutput.mxCell = typeof mxCell !== 'undefined' ? mxCell : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGeometry\n * \n * Extends <mxRectangle> to represent the geometry of a cell.\n * \n * For vertices, the geometry consists of the x- and y-location, and the width\n * and height. For edges, the geometry consists of the optional terminal- and\n * control points. The terminal points are only required if an edge is\n * unconnected, and are stored in the <sourcePoint> and <targetPoint>\n * variables, respectively.\n * \n * Example:\n * \n * If an edge is unconnected, that is, it has no source or target terminal,\n * then a geometry with terminal points for a new edge can be defined as\n * follows.\n * \n * (code)\n * geometry.setTerminalPoint(new mxPoint(x1, y1), true);\n * geometry.points = [new mxPoint(x2, y2)];\n * geometry.setTerminalPoint(new mxPoint(x3, y3), false);\n * (end)\n * \n * Control points are used regardless of the connected state of an edge and may\n * be ignored or interpreted differently depending on the edge's <mxEdgeStyle>.\n * \n * To disable automatic reset of control points after a cell has been moved or\n * resized, the the <mxGraph.resizeEdgesOnMove> and\n * <mxGraph.resetEdgesOnResize> may be used.\n *\n * Edge Labels:\n * \n * Using the x- and y-coordinates of a cell's geometry, it is possible to\n * position the label on edges on a specific location on the actual edge shape\n * as it appears on the screen. The x-coordinate of an edge's geometry is used\n * to describe the distance from the center of the edge from -1 to 1 with 0\n * being the center of the edge and the default value. The y-coordinate of an\n * edge's geometry is used to describe the absolute, orthogonal distance in\n * pixels from that point. In addition, the <mxGeometry.offset> is used as an\n * absolute offset vector from the resulting point.\n * \n * This coordinate system is applied if <relative> is true, otherwise the\n * offset defines the absolute vector from the edge's center point to the\n * label and the values for <x> and <y> are ignored.\n * \n * The width and height parameter for edge geometries can be used to set the\n * label width and height (eg. for word wrapping).\n * \n * Ports:\n * \n * The term \"port\" refers to a relatively positioned, connectable child cell,\n * which is used to specify the connection between the parent and another cell\n * in the graph. Ports are typically modeled as vertices with relative\n * geometries.\n * \n * Offsets:\n * \n * The <offset> field is interpreted in 3 different ways, depending on the cell\n * and the geometry. For edges, the offset defines the absolute offset for the\n * edge label. For relative geometries, the offset defines the absolute offset\n * for the origin (top, left corner) of the vertex, otherwise the offset\n * defines the absolute offset for the label inside the vertex or group.\n * \n * Constructor: mxGeometry\n *\n * Constructs a new object to describe the size and location of a vertex or\n * the control points of an edge.\n */\nfunction mxGeometry(x, y, width, height)\n{\n\tmxRectangle.call(this, x, y, width, height);\n};\n\n/**\n * Extends mxRectangle.\n */\nmxGeometry.prototype = new mxRectangle();\nmxGeometry.prototype.constructor = mxGeometry;\n\n/**\n * Variable: TRANSLATE_CONTROL_POINTS\n * \n * Global switch to translate the points in translate. Default is true.\n */\nmxGeometry.prototype.TRANSLATE_CONTROL_POINTS = true;\n\n/**\n * Variable: alternateBounds\n *\n * Stores alternate values for x, y, width and height in a rectangle. See\n * <swap> to exchange the values. Default is null.\n */\nmxGeometry.prototype.alternateBounds = null;\n\n/**\n * Variable: sourcePoint\n *\n * Defines the source <mxPoint> of the edge. This is used if the\n * corresponding edge does not have a source vertex. Otherwise it is\n * ignored. Default is  null.\n */\nmxGeometry.prototype.sourcePoint = null;\n\n/**\n * Variable: targetPoint\n *\n * Defines the target <mxPoint> of the edge. This is used if the\n * corresponding edge does not have a target vertex. Otherwise it is\n * ignored. Default is null.\n */\nmxGeometry.prototype.targetPoint = null;\n\n/**\n * Variable: points\n *\n * Array of <mxPoints> which specifies the control points along the edge.\n * These points are the intermediate points on the edge, for the endpoints\n * use <targetPoint> and <sourcePoint> or set the terminals of the edge to\n * a non-null value. Default is null.\n */\nmxGeometry.prototype.points = null;\n\n/**\n * Variable: offset\n *\n * For edges, this holds the offset (in pixels) from the position defined\n * by <x> and <y> on the edge. For relative geometries (for vertices), this\n * defines the absolute offset from the point defined by the relative\n * coordinates. For absolute geometries (for vertices), this defines the\n * offset for the label. Default is null.\n */\nmxGeometry.prototype.offset = null;\n\n/**\n * Variable: relative\n *\n * Specifies if the coordinates in the geometry are to be interpreted as\n * relative coordinates. For edges, this is used to define the location of\n * the edge label relative to the edge as rendered on the display. For\n * vertices, this specifies the relative location inside the bounds of the\n * parent cell.\n * \n * If this is false, then the coordinates are relative to the origin of the\n * parent cell or, for edges, the edge label position is relative to the\n * center of the edge as rendered on screen.\n * \n * Default is false.\n */\nmxGeometry.prototype.relative = false;\n\n/**\n * Function: swap\n * \n * Swaps the x, y, width and height with the values stored in\n * <alternateBounds> and puts the previous values into <alternateBounds> as\n * a rectangle. This operation is carried-out in-place, that is, using the\n * existing geometry instance. If this operation is called during a graph\n * model transactional change, then the geometry should be cloned before\n * calling this method and setting the geometry of the cell using\n * <mxGraphModel.setGeometry>.\n */\nmxGeometry.prototype.swap = function()\n{\n\tif (this.alternateBounds != null)\n\t{\n\t\tvar old = new mxRectangle(\n\t\t\tthis.x, this.y, this.width, this.height);\n\n\t\tthis.x = this.alternateBounds.x;\n\t\tthis.y = this.alternateBounds.y;\n\t\tthis.width = this.alternateBounds.width;\n\t\tthis.height = this.alternateBounds.height;\n\n\t\tthis.alternateBounds = old;\n\t}\n};\n\n/**\n * Function: getTerminalPoint\n * \n * Returns the <mxPoint> representing the source or target point of this\n * edge. This is only used if the edge has no source or target vertex.\n * \n * Parameters:\n * \n * isSource - Boolean that specifies if the source or target point\n * should be returned.\n */\nmxGeometry.prototype.getTerminalPoint = function(isSource)\n{\n\treturn (isSource) ? this.sourcePoint : this.targetPoint;\n};\n\n/**\n * Function: setTerminalPoint\n * \n * Sets the <sourcePoint> or <targetPoint> to the given <mxPoint> and\n * returns the new point.\n * \n * Parameters:\n * \n * point - Point to be used as the new source or target point.\n * isSource - Boolean that specifies if the source or target point\n * should be set.\n */\nmxGeometry.prototype.setTerminalPoint = function(point, isSource)\n{\n\tif (isSource)\n\t{\n\t\tthis.sourcePoint = point;\n\t}\n\telse\n\t{\n\t\tthis.targetPoint = point;\n\t}\n\t\n\treturn point;\n};\n\n/**\n * Function: rotate\n * \n * Rotates the geometry by the given angle around the given center. That is,\n * <x> and <y> of the geometry, the <sourcePoint>, <targetPoint> and all\n * <points> are translated by the given amount. <x> and <y> are only\n * translated if <relative> is false.\n * \n * Parameters:\n * \n * angle - Number that specifies the rotation angle in degrees.\n * cx - <mxPoint> that specifies the center of the rotation.\n */\nmxGeometry.prototype.rotate = function(angle, cx)\n{\n\tvar rad = mxUtils.toRadians(angle);\n\tvar cos = Math.cos(rad);\n\tvar sin = Math.sin(rad);\n\t\n\t// Rotates the geometry\n\tif (!this.relative)\n\t{\n\t\tvar ct = new mxPoint(this.getCenterX(), this.getCenterY());\n\t\tvar pt = mxUtils.getRotatedPoint(ct, cos, sin, cx);\n\t\t\n\t\tthis.x = Math.round(pt.x - this.width / 2);\n\t\tthis.y = Math.round(pt.y - this.height / 2);\n\t}\n\n\t// Rotates the source point\n\tif (this.sourcePoint != null)\n\t{\n\t\tvar pt = mxUtils.getRotatedPoint(this.sourcePoint, cos, sin, cx);\n\t\tthis.sourcePoint.x = Math.round(pt.x);\n\t\tthis.sourcePoint.y = Math.round(pt.y);\n\t}\n\t\n\t// Translates the target point\n\tif (this.targetPoint != null)\n\t{\n\t\tvar pt = mxUtils.getRotatedPoint(this.targetPoint, cos, sin, cx);\n\t\tthis.targetPoint.x = Math.round(pt.x);\n\t\tthis.targetPoint.y = Math.round(pt.y);\t\n\t}\n\t\n\t// Translate the control points\n\tif (this.points != null)\n\t{\n\t\tfor (var i = 0; i < this.points.length; i++)\n\t\t{\n\t\t\tif (this.points[i] != null)\n\t\t\t{\n\t\t\t\tvar pt = mxUtils.getRotatedPoint(this.points[i], cos, sin, cx);\n\t\t\t\tthis.points[i].x = Math.round(pt.x);\n\t\t\t\tthis.points[i].y = Math.round(pt.y);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: translate\n * \n * Translates the geometry by the specified amount. That is, <x> and <y> of the\n * geometry, the <sourcePoint>, <targetPoint> and all <points> are translated\n * by the given amount. <x> and <y> are only translated if <relative> is false.\n * If <TRANSLATE_CONTROL_POINTS> is false, then <points> are not modified by\n * this function.\n * \n * Parameters:\n * \n * dx - Number that specifies the x-coordinate of the translation.\n * dy - Number that specifies the y-coordinate of the translation.\n */\nmxGeometry.prototype.translate = function(dx, dy)\n{\n\tdx = parseFloat(dx);\n\tdy = parseFloat(dy);\n\t\n\t// Translates the geometry\n\tif (!this.relative)\n\t{\n\t\tthis.x = parseFloat(this.x) + dx;\n\t\tthis.y = parseFloat(this.y) + dy;\n\t}\n\n\t// Translates the source point\n\tif (this.sourcePoint != null)\n\t{\n\t\tthis.sourcePoint.x = parseFloat(this.sourcePoint.x) + dx;\n\t\tthis.sourcePoint.y = parseFloat(this.sourcePoint.y) + dy;\n\t}\n\t\n\t// Translates the target point\n\tif (this.targetPoint != null)\n\t{\n\t\tthis.targetPoint.x = parseFloat(this.targetPoint.x) + dx;\n\t\tthis.targetPoint.y = parseFloat(this.targetPoint.y) + dy;\t\t\n\t}\n\n\t// Translate the control points\n\tif (this.TRANSLATE_CONTROL_POINTS && this.points != null)\n\t{\n\t\tfor (var i = 0; i < this.points.length; i++)\n\t\t{\n\t\t\tif (this.points[i] != null)\n\t\t\t{\n\t\t\t\tthis.points[i].x = parseFloat(this.points[i].x) + dx;\n\t\t\t\tthis.points[i].y = parseFloat(this.points[i].y) + dy;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: scale\n * \n * Scales the geometry by the given amount. That is, <x> and <y> of the\n * geometry, the <sourcePoint>, <targetPoint> and all <points> are scaled\n * by the given amount. <x>, <y>, <width> and <height> are only scaled if\n * <relative> is false. If <fixedAspect> is true, then the smaller value\n * is used to scale the width and the height.\n * \n * Parameters:\n * \n * sx - Number that specifies the horizontal scale factor.\n * sy - Number that specifies the vertical scale factor.\n * fixedAspect - Optional boolean to keep the aspect ratio fixed.\n */\nmxGeometry.prototype.scale = function(sx, sy, fixedAspect)\n{\n\tsx = parseFloat(sx);\n\tsy = parseFloat(sy);\n\n\t// Translates the source point\n\tif (this.sourcePoint != null)\n\t{\n\t\tthis.sourcePoint.x = parseFloat(this.sourcePoint.x) * sx;\n\t\tthis.sourcePoint.y = parseFloat(this.sourcePoint.y) * sy;\n\t}\n\t\n\t// Translates the target point\n\tif (this.targetPoint != null)\n\t{\n\t\tthis.targetPoint.x = parseFloat(this.targetPoint.x) * sx;\n\t\tthis.targetPoint.y = parseFloat(this.targetPoint.y) * sy;\t\t\n\t}\n\n\t// Translate the control points\n\tif (this.points != null)\n\t{\n\t\tfor (var i = 0; i < this.points.length; i++)\n\t\t{\n\t\t\tif (this.points[i] != null)\n\t\t\t{\n\t\t\t\tthis.points[i].x = parseFloat(this.points[i].x) * sx;\n\t\t\t\tthis.points[i].y = parseFloat(this.points[i].y) * sy;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Translates the geometry\n\tif (!this.relative)\n\t{\n\t\tthis.x = parseFloat(this.x) * sx;\n\t\tthis.y = parseFloat(this.y) * sy;\n\n\t\tif (fixedAspect)\n\t\t{\n\t\t\tsy = sx = Math.min(sx, sy);\n\t\t}\n\t\t\n\t\tthis.width = parseFloat(this.width) * sx;\n\t\tthis.height = parseFloat(this.height) * sy;\n\t}\n};\n\n/**\n * Function: equals\n * \n * Returns true if the given object equals this geometry.\n */\nmxGeometry.prototype.equals = function(obj)\n{\n\treturn mxRectangle.prototype.equals.apply(this, arguments) &&\n\t\tthis.relative == obj.relative &&\n\t\t((this.sourcePoint == null && obj.sourcePoint == null) || (this.sourcePoint != null && this.sourcePoint.equals(obj.sourcePoint))) &&\n\t\t((this.targetPoint == null && obj.targetPoint == null) || (this.targetPoint != null && this.targetPoint.equals(obj.targetPoint))) &&\n\t\t((this.points == null && obj.points == null) || (this.points != null && mxUtils.equalPoints(this.points, obj.points))) &&\n\t\t((this.alternateBounds == null && obj.alternateBounds == null) || (this.alternateBounds != null && this.alternateBounds.equals(obj.alternateBounds))) &&\n\t\t((this.offset == null && obj.offset == null) || (this.offset != null && this.offset.equals(obj.offset)));\n};\n\n__mxOutput.mxGeometry = typeof mxGeometry !== 'undefined' ? mxGeometry : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxCellPath =\n{\n\n\t/**\n\t * Class: mxCellPath\n\t * \n\t * Implements a mechanism for temporary cell Ids.\n\t * \n\t * Variable: PATH_SEPARATOR\n\t * \n\t * Defines the separator between the path components. Default is \".\".\n\t */\n\tPATH_SEPARATOR: '.',\n\t\n\t/**\n\t * Function: create\n\t * \n\t * Creates the cell path for the given cell. The cell path is a\n\t * concatenation of the indices of all ancestors on the (finite) path to\n\t * the root, eg. \"0.0.0.1\".\n\t * \n\t * Parameters:\n\t * \n\t * cell - Cell whose path should be returned.\n\t */\n\tcreate: function(cell)\n\t{\n\t\tvar result = '';\n\t\t\n\t\tif (cell != null)\n\t\t{\n\t\t\tvar parent = cell.getParent();\n\t\t\t\n\t\t\twhile (parent != null)\n\t\t\t{\n\t\t\t\tvar index = parent.getIndex(cell);\n\t\t\t\tresult = index + mxCellPath.PATH_SEPARATOR + result;\n\t\t\t\t\n\t\t\t\tcell = parent;\n\t\t\t\tparent = cell.getParent();\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Removes trailing separator\n\t\tvar n = result.length;\n\t\t\n\t\tif (n > 1)\n\t\t{\n\t\t\tresult = result.substring(0, n - 1);\n\t\t}\n\t\t\n\t\treturn result;\n\t},\n\t\n\t/**\n\t * Function: getParentPath\n\t * \n\t * Returns the path for the parent of the cell represented by the given\n\t * path. Returns null if the given path has no parent.\n\t * \n\t * Parameters:\n\t * \n\t * path - Path whose parent path should be returned.\n\t */\n\tgetParentPath: function(path)\n\t{\n\t\tif (path != null)\n\t\t{\n\t\t\tvar index = path.lastIndexOf(mxCellPath.PATH_SEPARATOR);\n\n\t\t\tif (index >= 0)\n\t\t\t{\n\t\t\t\treturn path.substring(0, index);\n\t\t\t}\n\t\t\telse if (path.length > 0)\n\t\t\t{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t},\n\n\t/**\n\t * Function: resolve\n\t * \n\t * Returns the cell for the specified cell path using the given root as the\n\t * root of the path.\n\t * \n\t * Parameters:\n\t * \n\t * root - Root cell of the path to be resolved.\n\t * path - String that defines the path.\n\t */\n\tresolve: function(root, path)\n\t{\n\t\tvar parent = root;\n\t\t\n\t\tif (path != null)\n\t\t{\n\t\t\tvar tokens = path.split(mxCellPath.PATH_SEPARATOR);\n\t\t\t\n\t\t\tfor (var i=0; i<tokens.length; i++)\n\t\t\t{\n\t\t\t\tparent = parent.getChildAt(parseInt(tokens[i]));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn parent;\n\t},\n\t\n\t/**\n\t * Function: compare\n\t * \n\t * Compares the given cell paths and returns -1 if p1 is smaller, 0 if\n\t * p1 is equal and 1 if p1 is greater than p2.\n\t */\n\tcompare: function(p1, p2)\n\t{\n\t\tvar min = Math.min(p1.length, p2.length);\n\t\tvar comp = 0;\n\t\t\n\t\tfor (var i = 0; i < min; i++)\n\t\t{\n\t\t\tif (p1[i] != p2[i])\n\t\t\t{\n\t\t\t\tif (p1[i].length == 0 ||\n\t\t\t\t\tp2[i].length == 0)\n\t\t\t\t{\n\t\t\t\t\tcomp = (p1[i] == p2[i]) ? 0 : ((p1[i] > p2[i]) ? 1 : -1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar t1 = parseInt(p1[i]);\n\t\t\t\t\tvar t2 = parseInt(p2[i]);\n\t\t\t\t\t\n\t\t\t\t\tcomp = (t1 == t2) ? 0 : ((t1 > t2) ? 1 : -1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Compares path length if both paths are equal to this point\n\t\tif (comp == 0)\n\t\t{\n\t\t\tvar t1 = p1.length;\n\t\t\tvar t2 = p2.length;\n\t\t\t\n\t\t\tif (t1 != t2)\n\t\t\t{\n\t\t\t\tcomp = (t1 > t2) ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn comp;\n\t}\n\n};\n\n__mxOutput.mxCellPath = typeof mxCellPath !== 'undefined' ? mxCellPath : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxPerimeter =\n{\n\t/**\n\t * Class: mxPerimeter\n\t * \n\t * Provides various perimeter functions to be used in a style\n\t * as the value of <mxConstants.STYLE_PERIMETER>. Perimeters for\n\t * rectangle, circle, rhombus and triangle are available.\n\t *\n\t * Example:\n\t * \n\t * (code)\n\t * <add as=\"perimeter\">mxPerimeter.RectanglePerimeter</add>\n\t * (end)\n\t * \n\t * Or programmatically:\n\t * \n\t * (code)\n\t * style[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;\n\t * (end)\n\t * \n\t * When adding new perimeter functions, it is recommended to use the \n\t * mxPerimeter-namespace as follows:\n\t * \n\t * (code)\n\t * mxPerimeter.CustomPerimeter = function (bounds, vertex, next, orthogonal)\n\t * {\n\t *   var x = 0; // Calculate x-coordinate\n\t *   var y = 0; // Calculate y-coordainte\n\t *   \n\t *   return new mxPoint(x, y);\n\t * }\n\t * (end)\n\t * \n\t * The new perimeter should then be registered in the <mxStyleRegistry> as follows:\n\t * (code)\n\t * mxStyleRegistry.putValue('customPerimeter', mxPerimeter.CustomPerimeter);\n\t * (end)\n\t * \n\t * The custom perimeter above can now be used in a specific vertex as follows:\n\t * \n\t * (code)\n\t * model.setStyle(vertex, 'perimeter=customPerimeter');\n\t * (end)\n\t * \n\t * Note that the key of the <mxStyleRegistry> entry for the function should\n\t * be used in string values, unless <mxGraphView.allowEval> is true, in\n\t * which case you can also use mxPerimeter.CustomPerimeter for the value in\n\t * the cell style above.\n\t * \n\t * Or it can be used for all vertices in the graph as follows:\n\t * \n\t * (code)\n\t * var style = graph.getStylesheet().getDefaultVertexStyle();\n\t * style[mxConstants.STYLE_PERIMETER] = mxPerimeter.CustomPerimeter;\n\t * (end)\n\t * \n\t * Note that the object can be used directly when programmatically setting\n\t * the value, but the key in the <mxStyleRegistry> should be used when\n\t * setting the value via a key, value pair in a cell style.\n\t * \n\t * The parameters are explained in <RectanglePerimeter>.\n\t * \n\t * Function: RectanglePerimeter\n\t * \n\t * Describes a rectangular perimeter for the given bounds.\n\t *\n\t * Parameters:\n\t * \n\t * bounds - <mxRectangle> that represents the absolute bounds of the\n\t * vertex.\n\t * vertex - <mxCellState> that represents the vertex.\n\t * next - <mxPoint> that represents the nearest neighbour point on the\n\t * given edge.\n\t * orthogonal - Boolean that specifies if the orthogonal projection onto\n\t * the perimeter should be returned. If this is false then the intersection\n\t * of the perimeter and the line between the next and the center point is\n\t * returned.\n\t */\n\tRectanglePerimeter: function (bounds, vertex, next, orthogonal)\n\t{\n\t\tvar cx = bounds.getCenterX();\n\t\tvar cy = bounds.getCenterY();\n\t\tvar dx = next.x - cx;\n\t\tvar dy = next.y - cy;\n\t\tvar alpha = Math.atan2(dy, dx);\n\t\tvar p = new mxPoint(0, 0);\n\t\tvar pi = Math.PI;\n\t\tvar pi2 = Math.PI/2;\n\t\tvar beta = pi2 - alpha;\n\t\tvar t = Math.atan2(bounds.height, bounds.width);\n\t\t\n\t\tif (alpha < -pi + t || alpha > pi - t)\n\t\t{\n\t\t\t// Left edge\n\t\t\tp.x = bounds.x;\n\t\t\tp.y = cy - bounds.width * Math.tan(alpha) / 2;\n\t\t}\n\t\telse if (alpha < -t)\n\t\t{\n\t\t\t// Top Edge\n\t\t\tp.y = bounds.y;\n\t\t\tp.x = cx - bounds.height * Math.tan(beta) / 2;\n\t\t}\n\t\telse if (alpha < t)\n\t\t{\n\t\t\t// Right Edge\n\t\t\tp.x = bounds.x + bounds.width;\n\t\t\tp.y = cy + bounds.width * Math.tan(alpha) / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Bottom Edge\n\t\t\tp.y = bounds.y + bounds.height;\n\t\t\tp.x = cx + bounds.height * Math.tan(beta) / 2;\n\t\t}\n\t\t\n\t\tif (orthogonal)\n\t\t{\n\t\t\tif (next.x >= bounds.x &&\n\t\t\t\tnext.x <= bounds.x + bounds.width)\n\t\t\t{\n\t\t\t\tp.x = next.x;\n\t\t\t}\n\t\t\telse if (next.y >= bounds.y &&\n\t\t\t\t\t   next.y <= bounds.y + bounds.height)\n\t\t\t{\n\t\t\t\tp.y = next.y;\n\t\t\t}\n\t\t\tif (next.x < bounds.x)\n\t\t\t{\n\t\t\t\tp.x = bounds.x;\n\t\t\t}\n\t\t\telse if (next.x > bounds.x + bounds.width)\n\t\t\t{\n\t\t\t\tp.x = bounds.x + bounds.width;\n\t\t\t}\n\t\t\tif (next.y < bounds.y)\n\t\t\t{\n\t\t\t\tp.y = bounds.y;\n\t\t\t}\n\t\t\telse if (next.y > bounds.y + bounds.height)\n\t\t\t{\n\t\t\t\tp.y = bounds.y + bounds.height;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn p;\n\t},\n\n\t/**\n\t * Function: EllipsePerimeter\n\t * \n\t * Describes an elliptic perimeter. See <RectanglePerimeter>\n\t * for a description of the parameters.\n\t */\n\tEllipsePerimeter: function (bounds, vertex, next, orthogonal)\n\t{\n\t\tvar x = bounds.x;\n\t\tvar y = bounds.y;\n\t\tvar a = bounds.width / 2;\n\t\tvar b = bounds.height / 2;\n\t\tvar cx = x + a;\n\t\tvar cy = y + b;\n\t\tvar px = next.x;\n\t\tvar py = next.y;\n\t\t\n\t\t// Calculates straight line equation through\n\t\t// point and ellipse center y = d * x + h\n\t\tvar dx = parseInt(px - cx);\n\t\tvar dy = parseInt(py - cy);\n\t\t\n\t\tif (dx == 0 && dy != 0)\n\t\t{\n\t\t\treturn new mxPoint(cx, cy + b * dy / Math.abs(dy));\n\t\t}\n\t\telse if (dx == 0 && dy == 0)\n\t\t{\n\t\t\treturn new mxPoint(px, py);\n\t\t}\n\n\t\tif (orthogonal)\n\t\t{\n\t\t\tif (py >= y && py <= y + bounds.height)\n\t\t\t{\n\t\t\t\tvar ty = py - cy;\n\t\t\t\tvar tx = Math.sqrt(a*a*(1-(ty*ty)/(b*b))) || 0;\n\t\t\t\t\n\t\t\t\tif (px <= x)\n\t\t\t\t{\n\t\t\t\t\ttx = -tx;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn new mxPoint(cx+tx, py);\n\t\t\t}\n\t\t\t\n\t\t\tif (px >= x && px <= x + bounds.width)\n\t\t\t{\n\t\t\t\tvar tx = px - cx;\n\t\t\t\tvar ty = Math.sqrt(b*b*(1-(tx*tx)/(a*a))) || 0;\n\t\t\t\t\n\t\t\t\tif (py <= y)\n\t\t\t\t{\n\t\t\t\t\tty = -ty;\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn new mxPoint(px, cy+ty);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Calculates intersection\n\t\tvar d = dy / dx;\n\t\tvar h = cy - d * cx;\n\t\tvar e = a * a * d * d + b * b;\n\t\tvar f = -2 * cx * e;\n\t\tvar g = a * a * d * d * cx * cx +\n\t\t\t\tb * b * cx * cx -\n\t\t\t\ta * a * b * b;\n\t\tvar det = Math.sqrt(f * f - 4 * e * g);\n\t\t\n\t\t// Two solutions (perimeter points)\n\t\tvar xout1 = (-f + det) / (2 * e);\n\t\tvar xout2 = (-f - det) / (2 * e);\n\t\tvar yout1 = d * xout1 + h;\n\t\tvar yout2 = d * xout2 + h;\n\t\tvar dist1 = Math.sqrt(Math.pow((xout1 - px), 2)\n\t\t\t\t\t+ Math.pow((yout1 - py), 2));\n\t\tvar dist2 = Math.sqrt(Math.pow((xout2 - px), 2)\n\t\t\t\t\t+ Math.pow((yout2 - py), 2));\n\t\t\t\t\t\n\t\t// Correct solution\n\t\tvar xout = 0;\n\t\tvar yout = 0;\n\t\t\n\t\tif (dist1 < dist2)\n\t\t{\n\t\t\txout = xout1;\n\t\t\tyout = yout1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\txout = xout2;\n\t\t\tyout = yout2;\n\t\t}\n\t\t\n\t\treturn new mxPoint(xout, yout);\n\t},\n\n\t/**\n\t * Function: RhombusPerimeter\n\t * \n\t * Describes a rhombus (aka diamond) perimeter. See <RectanglePerimeter>\n\t * for a description of the parameters.\n\t */\n\tRhombusPerimeter: function (bounds, vertex, next, orthogonal)\n\t{\n\t\tvar x = bounds.x;\n\t\tvar y = bounds.y;\n\t\tvar w = bounds.width;\n\t\tvar h = bounds.height;\n\t\t\n\t\tvar cx = x + w / 2;\n\t\tvar cy = y + h / 2;\n\n\t\tvar px = next.x;\n\t\tvar py = next.y;\n\n\t\t// Special case for intersecting the diamond's corners\n\t\tif (cx == px)\n\t\t{\n\t\t\tif (cy > py)\n\t\t\t{\n\t\t\t\treturn new mxPoint(cx, y); // top\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn new mxPoint(cx, y + h); // bottom\n\t\t\t}\n\t\t}\n\t\telse if (cy == py)\n\t\t{\n\t\t\tif (cx > px)\n\t\t\t{\n\t\t\t\treturn new mxPoint(x, cy); // left\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn new mxPoint(x + w, cy); // right\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar tx = cx;\n\t\tvar ty = cy;\n\t\t\n\t\tif (orthogonal)\n\t\t{\n\t\t\tif (px >= x && px <= x + w)\n\t\t\t{\n\t\t\t\ttx = px;\n\t\t\t}\n\t\t\telse if (py >= y && py <= y + h)\n\t\t\t{\n\t\t\t\tty = py;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// In which quadrant will the intersection be?\n\t\t// set the slope and offset of the border line accordingly\n\t\tif (px < cx)\n\t\t{\n\t\t\tif (py < cy)\n\t\t\t{\n\t\t\t\treturn mxUtils.intersection(px, py, tx, ty, cx, y, x, cy);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn mxUtils.intersection(px, py, tx, ty, cx, y + h, x, cy);\n\t\t\t}\n\t\t}\n\t\telse if (py < cy)\n\t\t{\n\t\t\treturn mxUtils.intersection(px, py, tx, ty, cx, y, x + w, cy);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn mxUtils.intersection(px, py, tx, ty, cx, y + h, x + w, cy);\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: TrianglePerimeter\n\t * \n\t * Describes a triangle perimeter. See <RectanglePerimeter>\n\t * for a description of the parameters.\n\t */\n\tTrianglePerimeter: function (bounds, vertex, next, orthogonal)\n\t{\n\t\tvar direction = (vertex != null) ?\n\t\t\tvertex.style[mxConstants.STYLE_DIRECTION] : null;\n\t\tvar vertical = direction == mxConstants.DIRECTION_NORTH ||\n\t\t\tdirection == mxConstants.DIRECTION_SOUTH;\n\n\t\tvar x = bounds.x;\n\t\tvar y = bounds.y;\n\t\tvar w = bounds.width;\n\t\tvar h = bounds.height;\n\t\t\n\t\tvar cx = x + w / 2;\n\t\tvar cy = y + h / 2;\n\t\t\n\t\tvar start = new mxPoint(x, y);\n\t\tvar corner = new mxPoint(x + w, cy);\n\t\tvar end = new mxPoint(x, y + h);\n\t\t\n\t\tif (direction == mxConstants.DIRECTION_NORTH)\n\t\t{\n\t\t\tstart = end;\n\t\t\tcorner = new mxPoint(cx, y);\n\t\t\tend = new mxPoint(x + w, y + h);\n\t\t}\n\t\telse if (direction == mxConstants.DIRECTION_SOUTH)\n\t\t{\n\t\t\tcorner = new mxPoint(cx, y + h);\n\t\t\tend = new mxPoint(x + w, y);\n\t\t}\n\t\telse if (direction == mxConstants.DIRECTION_WEST)\n\t\t{\n\t\t\tstart = new mxPoint(x + w, y);\n\t\t\tcorner = new mxPoint(x, cy);\n\t\t\tend = new mxPoint(x + w, y + h);\n\t\t}\n\n\t\tvar dx = next.x - cx;\n\t\tvar dy = next.y - cy;\n\n\t\tvar alpha = (vertical) ? Math.atan2(dx, dy) : Math.atan2(dy, dx);\n\t\tvar t = (vertical) ? Math.atan2(w, h) : Math.atan2(h, w);\n\t\t\n\t\tvar base = false;\n\t\t\n\t\tif (direction == mxConstants.DIRECTION_NORTH ||\n\t\t\tdirection == mxConstants.DIRECTION_WEST)\n\t\t{\n\t\t\tbase = alpha > -t && alpha < t;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbase = alpha < -Math.PI + t || alpha > Math.PI - t;\t\n\t\t}\n\n\t\tvar result = null;\t\t\t\n\n\t\tif (base)\n\t\t{\n\t\t\tif (orthogonal && ((vertical && next.x >= start.x && next.x <= end.x) ||\n\t\t\t\t(!vertical && next.y >= start.y && next.y <= end.y)))\n\t\t\t{\n\t\t\t\tif (vertical)\n\t\t\t\t{\n\t\t\t\t\tresult = new mxPoint(next.x, start.y);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult = new mxPoint(start.x, next.y);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (direction == mxConstants.DIRECTION_NORTH)\n\t\t\t\t{\n\t\t\t\t\tresult = new mxPoint(x + w / 2 + h * Math.tan(alpha) / 2,\n\t\t\t\t\t\ty + h);\n\t\t\t\t}\n\t\t\t\telse if (direction == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t{\n\t\t\t\t\tresult = new mxPoint(x + w / 2 - h * Math.tan(alpha) / 2,\n\t\t\t\t\t\ty);\n\t\t\t\t}\n\t\t\t\telse if (direction == mxConstants.DIRECTION_WEST)\n\t\t\t\t{\n\t\t\t\t\tresult = new mxPoint(x + w, y + h / 2 +\n\t\t\t\t\t\tw * Math.tan(alpha) / 2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult = new mxPoint(x, y + h / 2 -\n\t\t\t\t\t\tw * Math.tan(alpha) / 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (orthogonal)\n\t\t\t{\n\t\t\t\tvar pt = new mxPoint(cx, cy);\n\t\t\n\t\t\t\tif (next.y >= y && next.y <= y + h)\n\t\t\t\t{\n\t\t\t\t\tpt.x = (vertical) ? cx : (\n\t\t\t\t\t\t(direction == mxConstants.DIRECTION_WEST) ?\n\t\t\t\t\t\t\tx + w : x);\n\t\t\t\t\tpt.y = next.y;\n\t\t\t\t}\n\t\t\t\telse if (next.x >= x && next.x <= x + w)\n\t\t\t\t{\n\t\t\t\t\tpt.x = next.x;\n\t\t\t\t\tpt.y = (!vertical) ? cy : (\n\t\t\t\t\t\t(direction == mxConstants.DIRECTION_NORTH) ?\n\t\t\t\t\t\t\ty + h : y);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Compute angle\n\t\t\t\tdx = next.x - pt.x;\n\t\t\t\tdy = next.y - pt.y;\n\t\t\t\t\n\t\t\t\tcx = pt.x;\n\t\t\t\tcy = pt.y;\n\t\t\t}\n\n\t\t\tif ((vertical && next.x <= x + w / 2) ||\n\t\t\t\t(!vertical && next.y <= y + h / 2))\n\t\t\t{\n\t\t\t\tresult = mxUtils.intersection(next.x, next.y, cx, cy,\n\t\t\t\t\tstart.x, start.y, corner.x, corner.y);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = mxUtils.intersection(next.x, next.y, cx, cy,\n\t\t\t\t\tcorner.x, corner.y, end.x, end.y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (result == null)\n\t\t{\n\t\t\tresult = new mxPoint(cx, cy);\n\t\t}\n\t\t\n\t\treturn result;\n\t},\n\t\n\t/**\n\t * Function: HexagonPerimeter\n\t * \n\t * Describes a hexagon perimeter. See <RectanglePerimeter>\n\t * for a description of the parameters.\n\t */\n\tHexagonPerimeter: function (bounds, vertex, next, orthogonal)\n\t{\n\t\tvar x = bounds.x;\n\t\tvar y = bounds.y;\n\t\tvar w = bounds.width;\n\t\tvar h = bounds.height;\n\n\t\tvar cx = bounds.getCenterX();\n\t\tvar cy = bounds.getCenterY();\n\t\tvar px = next.x;\n\t\tvar py = next.y;\n\t\tvar dx = px - cx;\n\t\tvar dy = py - cy;\n\t\tvar alpha = -Math.atan2(dy, dx);\n\t\tvar pi = Math.PI;\n\t\tvar pi2 = Math.PI / 2;\n\n\t\tvar result = new mxPoint(cx, cy);\n\n\t\tvar direction = (vertex != null) ? mxUtils.getValue(\n\t\t\t\tvertex.style, mxConstants.STYLE_DIRECTION,\n\t\t\t\tmxConstants.DIRECTION_EAST) : mxConstants.DIRECTION_EAST;\n\t\tvar vertical = direction == mxConstants.DIRECTION_NORTH\n\t\t\t\t|| direction == mxConstants.DIRECTION_SOUTH;\n\t\tvar a = new mxPoint();\n\t\tvar b = new mxPoint();\n\n\t\t//Only consider corrects quadrants for the orthogonal case.\n\t\tif ((px < x) && (py < y) || (px < x) && (py > y + h)\n\t\t\t\t|| (px > x + w) && (py < y) || (px > x + w) && (py > y + h))\n\t\t{\n\t\t\torthogonal = false;\n\t\t}\n\n\t\tif (orthogonal)\n\t\t{\n\t\t\tif (vertical)\n\t\t\t{\n\t\t\t\t//Special cases where intersects with hexagon corners\n\t\t\t\tif (px == cx)\n\t\t\t\t{\n\t\t\t\t\tif (py <= y)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(cx, y);\n\t\t\t\t\t}\n\t\t\t\t\telse if (py >= y + h)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(cx, y + h);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (px < x)\n\t\t\t\t{\n\t\t\t\t\tif (py == y + h / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x, y + h / 4);\n\t\t\t\t\t}\n\t\t\t\t\telse if (py == y + 3 * h / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x, y + 3 * h / 4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (px > x + w)\n\t\t\t\t{\n\t\t\t\t\tif (py == y + h / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + w, y + h / 4);\n\t\t\t\t\t}\n\t\t\t\t\telse if (py == y + 3 * h / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + w, y + 3 * h / 4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (px == x)\n\t\t\t\t{\n\t\t\t\t\tif (py < cy)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x, y + h / 4);\n\t\t\t\t\t}\n\t\t\t\t\telse if (py > cy)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x, y + 3 * h / 4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (px == x + w)\n\t\t\t\t{\n\t\t\t\t\tif (py < cy)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + w, y + h / 4);\n\t\t\t\t\t}\n\t\t\t\t\telse if (py > cy)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + w, y + 3 * h / 4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (py == y)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(cx, y);\n\t\t\t\t}\n\t\t\t\telse if (py == y + h)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(cx, y + h);\n\t\t\t\t}\n\n\t\t\t\tif (px < cx)\n\t\t\t\t{\n\t\t\t\t\tif ((py > y + h / 4) && (py < y + 3 * h / 4))\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x, y);\n\t\t\t\t\t\tb = new mxPoint(x, y + h);\n\t\t\t\t\t}\n\t\t\t\t\telse if (py < y + h / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x - Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t\t+ Math.floor(0.5 * h));\n\t\t\t\t\t\tb = new mxPoint(x + w, y - Math.floor(0.25 * h));\n\t\t\t\t\t}\n\t\t\t\t\telse if (py > y + 3 * h / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x - Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t\t+ Math.floor(0.5 * h));\n\t\t\t\t\t\tb = new mxPoint(x + w, y + Math.floor(1.25 * h));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (px > cx)\n\t\t\t\t{\n\t\t\t\t\tif ((py > y + h / 4) && (py < y + 3 * h / 4))\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x + w, y);\n\t\t\t\t\t\tb = new mxPoint(x + w, y + h);\n\t\t\t\t\t}\n\t\t\t\t\telse if (py < y + h / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x, y - Math.floor(0.25 * h));\n\t\t\t\t\t\tb = new mxPoint(x + Math.floor(1.5 * w), y\n\t\t\t\t\t\t\t\t+ Math.floor(0.5 * h));\n\t\t\t\t\t}\n\t\t\t\t\telse if (py > y + 3 * h / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x + Math.floor(1.5 * w), y\n\t\t\t\t\t\t\t\t+ Math.floor(0.5 * h));\n\t\t\t\t\t\tb = new mxPoint(x, y + Math.floor(1.25 * h));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Special cases where intersects with hexagon corners\n\t\t\t\tif (py == cy)\n\t\t\t\t{\n\t\t\t\t\tif (px <= x)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x, y + h / 2);\n\t\t\t\t\t}\n\t\t\t\t\telse if (px >= x + w)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + w, y + h / 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (py < y)\n\t\t\t\t{\n\t\t\t\t\tif (px == x + w / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + w / 4, y);\n\t\t\t\t\t}\n\t\t\t\t\telse if (px == x + 3 * w / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + 3 * w / 4, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (py > y + h)\n\t\t\t\t{\n\t\t\t\t\tif (px == x + w / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + w / 4, y + h);\n\t\t\t\t\t}\n\t\t\t\t\telse if (px == x + 3 * w / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + 3 * w / 4, y + h);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (py == y)\n\t\t\t\t{\n\t\t\t\t\tif (px < cx)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + w / 4, y);\n\t\t\t\t\t}\n\t\t\t\t\telse if (px > cx)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + 3 * w / 4, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (py == y + h)\n\t\t\t\t{\n\t\t\t\t\tif (px < cx)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + w / 4, y + h);\n\t\t\t\t\t}\n\t\t\t\t\telse if (py > cy)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + 3 * w / 4, y + h);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (px == x)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x, cy);\n\t\t\t\t}\n\t\t\t\telse if (px == x + w)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + w, cy);\n\t\t\t\t}\n\n\t\t\t\tif (py < cy)\n\t\t\t\t{\n\t\t\t\t\tif ((px > x + w / 4) && (px < x + 3 * w / 4))\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x, y);\n\t\t\t\t\t\tb = new mxPoint(x + w, y);\n\t\t\t\t\t}\n\t\t\t\t\telse if (px < x + w / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x - Math.floor(0.25 * w), y + h);\n\t\t\t\t\t\tb = new mxPoint(x + Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t\t- Math.floor(0.5 * h));\n\t\t\t\t\t}\n\t\t\t\t\telse if (px > x + 3 * w / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x + Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t\t- Math.floor(0.5 * h));\n\t\t\t\t\t\tb = new mxPoint(x + Math.floor(1.25 * w), y + h);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (py > cy)\n\t\t\t\t{\n\t\t\t\t\tif ((px > x + w / 4) && (px < x + 3 * w / 4))\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x, y + h);\n\t\t\t\t\t\tb = new mxPoint(x + w, y + h);\n\t\t\t\t\t}\n\t\t\t\t\telse if (px < x + w / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x - Math.floor(0.25 * w), y);\n\t\t\t\t\t\tb = new mxPoint(x + Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t\t+ Math.floor(1.5 * h));\n\t\t\t\t\t}\n\t\t\t\t\telse if (px > x + 3 * w / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x + Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t\t+ Math.floor(1.5 * h));\n\t\t\t\t\t\tb = new mxPoint(x + Math.floor(1.25 * w), y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar tx = cx;\n\t\t\tvar ty = cy;\n\n\t\t\tif (px >= x && px <= x + w)\n\t\t\t{\n\t\t\t\ttx = px;\n\t\t\t\t\n\t\t\t\tif (py < cy)\n\t\t\t\t{\n\t\t\t\t\tty = y + h;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tty = y;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (py >= y && py <= y + h)\n\t\t\t{\n\t\t\t\tty = py;\n\t\t\t\t\n\t\t\t\tif (px < cx)\n\t\t\t\t{\n\t\t\t\t\ttx = x + w;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttx = x;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult = mxUtils.intersection(tx, ty, next.x, next.y, a.x, a.y, b.x, b.y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (vertical)\n\t\t\t{\n\t\t\t\tvar beta = Math.atan2(h / 4, w / 2);\n\n\t\t\t\t//Special cases where intersects with hexagon corners\n\t\t\t\tif (alpha == beta)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + w, y + Math.floor(0.25 * h));\n\t\t\t\t}\n\t\t\t\telse if (alpha == pi2)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + Math.floor(0.5 * w), y);\n\t\t\t\t}\n\t\t\t\telse if (alpha == (pi - beta))\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x, y + Math.floor(0.25 * h));\n\t\t\t\t}\n\t\t\t\telse if (alpha == -beta)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + w, y + Math.floor(0.75 * h));\n\t\t\t\t}\n\t\t\t\telse if (alpha == (-pi2))\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + Math.floor(0.5 * w), y + h);\n\t\t\t\t}\n\t\t\t\telse if (alpha == (-pi + beta))\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x, y + Math.floor(0.75 * h));\n\t\t\t\t}\n\n\t\t\t\tif ((alpha < beta) && (alpha > -beta))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x + w, y);\n\t\t\t\t\tb = new mxPoint(x + w, y + h);\n\t\t\t\t}\n\t\t\t\telse if ((alpha > beta) && (alpha < pi2))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x, y - Math.floor(0.25 * h));\n\t\t\t\t\tb = new mxPoint(x + Math.floor(1.5 * w), y\n\t\t\t\t\t\t\t+ Math.floor(0.5 * h));\n\t\t\t\t}\n\t\t\t\telse if ((alpha > pi2) && (alpha < (pi - beta)))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x - Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t+ Math.floor(0.5 * h));\n\t\t\t\t\tb = new mxPoint(x + w, y - Math.floor(0.25 * h));\n\t\t\t\t}\n\t\t\t\telse if (((alpha > (pi - beta)) && (alpha <= pi))\n\t\t\t\t\t\t|| ((alpha < (-pi + beta)) && (alpha >= -pi)))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x, y);\n\t\t\t\t\tb = new mxPoint(x, y + h);\n\t\t\t\t}\n\t\t\t\telse if ((alpha < -beta) && (alpha > -pi2))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x + Math.floor(1.5 * w), y\n\t\t\t\t\t\t\t+ Math.floor(0.5 * h));\n\t\t\t\t\tb = new mxPoint(x, y + Math.floor(1.25 * h));\n\t\t\t\t}\n\t\t\t\telse if ((alpha < -pi2) && (alpha > (-pi + beta)))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x - Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t+ Math.floor(0.5 * h));\n\t\t\t\t\tb = new mxPoint(x + w, y + Math.floor(1.25 * h));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar beta = Math.atan2(h / 2, w / 4);\n\n\t\t\t\t//Special cases where intersects with hexagon corners\n\t\t\t\tif (alpha == beta)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + Math.floor(0.75 * w), y);\n\t\t\t\t}\n\t\t\t\telse if (alpha == (pi - beta))\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + Math.floor(0.25 * w), y);\n\t\t\t\t}\n\t\t\t\telse if ((alpha == pi) || (alpha == -pi))\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x, y + Math.floor(0.5 * h));\n\t\t\t\t}\n\t\t\t\telse if (alpha == 0)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + w, y + Math.floor(0.5 * h));\n\t\t\t\t}\n\t\t\t\telse if (alpha == -beta)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + Math.floor(0.75 * w), y + h);\n\t\t\t\t}\n\t\t\t\telse if (alpha == (-pi + beta))\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + Math.floor(0.25 * w), y + h);\n\t\t\t\t}\n\n\t\t\t\tif ((alpha > 0) && (alpha < beta))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x + Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t- Math.floor(0.5 * h));\n\t\t\t\t\tb = new mxPoint(x + Math.floor(1.25 * w), y + h);\n\t\t\t\t}\n\t\t\t\telse if ((alpha > beta) && (alpha < (pi - beta)))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x, y);\n\t\t\t\t\tb = new mxPoint(x + w, y);\n\t\t\t\t}\n\t\t\t\telse if ((alpha > (pi - beta)) && (alpha < pi))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x - Math.floor(0.25 * w), y + h);\n\t\t\t\t\tb = new mxPoint(x + Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t- Math.floor(0.5 * h));\n\t\t\t\t}\n\t\t\t\telse if ((alpha < 0) && (alpha > -beta))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x + Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t+ Math.floor(1.5 * h));\n\t\t\t\t\tb = new mxPoint(x + Math.floor(1.25 * w), y);\n\t\t\t\t}\n\t\t\t\telse if ((alpha < -beta) && (alpha > (-pi + beta)))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x, y + h);\n\t\t\t\t\tb = new mxPoint(x + w, y + h);\n\t\t\t\t}\n\t\t\t\telse if ((alpha < (-pi + beta)) && (alpha > -pi))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x - Math.floor(0.25 * w), y);\n\t\t\t\t\tb = new mxPoint(x + Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t+ Math.floor(1.5 * h));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult = mxUtils.intersection(cx, cy, next.x, next.y, a.x, a.y, b.x, b.y);\n\t\t}\n\t\t\n\t\tif (result == null)\n\t\t{\n\t\t\treturn new mxPoint(cx, cy);\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n};\n\n__mxOutput.mxPerimeter = typeof mxPerimeter !== 'undefined' ? mxPerimeter : undefined;\n\n/**\n * Copyright (c) 2006-2019, JGraph Ltd\n * Copyright (c) 2006-2017, draw.io AG\n */\n/**\n * Class: mxPrintPreview\n * \n * Implements printing of a diagram across multiple pages. The following opens\n * a print preview for an existing graph:\n * \n * (code)\n * var preview = new mxPrintPreview(graph);\n * preview.open();\n * (end)\n * \n * Use <mxUtils.getScaleForPageCount> as follows in order to print the graph\n * across a given number of pages:\n * \n * (code)\n * var pageCount = mxUtils.prompt('Enter page count', '1');\n * \n * if (pageCount != null)\n * {\n *   var scale = mxUtils.getScaleForPageCount(pageCount, graph);\n *   var preview = new mxPrintPreview(graph, scale);\n *   preview.open();\n * }\n * (end)\n * \n * Additional pages:\n * \n * To add additional pages before and after the output, <getCoverPages> and\n * <getAppendices> can be used, respectively.\n * \n * (code)\n * var preview = new mxPrintPreview(graph, 1);\n * \n * preview.getCoverPages = function(w, h)\n * {\n *   return [this.renderPage(w, h, 0, 0, mxUtils.bind(this, function(div)\n *   {\n *     div.innerHTML = '<div style=\"position:relative;margin:4px;\">Cover Page</p>'\n *   }))];\n * };\n * \n * preview.getAppendices = function(w, h)\n * {\n *   return [this.renderPage(w, h, 0, 0, mxUtils.bind(this, function(div)\n *   {\n *     div.innerHTML = '<div style=\"position:relative;margin:4px;\">Appendix</p>'\n *   }))];\n * };\n * \n * preview.open();\n * (end)\n * \n * CSS:\n * \n * The CSS from the original page is not carried over to the print preview.\n * To add CSS to the page, use the css argument in the <open> function or\n * override <writeHead> to add the respective link tags as follows:\n * \n * (code)\n * var writeHead = preview.writeHead;\n * preview.writeHead = function(doc, css)\n * {\n *   writeHead.apply(this, arguments);\n *   doc.writeln('<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">');\n * };\n * (end)\n * \n * Padding:\n * \n * To add a padding to the page in the preview (but not the print output), use\n * the following code:\n * \n * (code)\n * preview.writeHead = function(doc)\n * {\n *   writeHead.apply(this, arguments);\n *   \n *   doc.writeln('<style type=\"text/css\">');\n *   doc.writeln('@media screen {');\n *   doc.writeln('  body > div { padding-top:30px;padding-left:40px;box-sizing:content-box; }');\n *   doc.writeln('}');\n *   doc.writeln('</style>');\n * };\n * (end)\n * \n * Headers:\n * \n * Apart from setting the title argument in the mxPrintPreview constructor you\n * can override <renderPage> as follows to add a header to any page:\n * \n * (code)\n * var oldRenderPage = mxPrintPreview.prototype.renderPage;\n * mxPrintPreview.prototype.renderPage = function(w, h, x, y, content, pageNumber)\n * {\n *   var div = oldRenderPage.apply(this, arguments);\n *   \n *   var header = document.createElement('div');\n *   header.style.position = 'absolute';\n *   header.style.top = '0px';\n *   header.style.width = '100%';\n *   header.style.textAlign = 'right';\n *   mxUtils.write(header, 'Your header here');\n *   div.firstChild.appendChild(header);\n *   \n *   return div;\n * };\n * (end)\n * \n * The pageNumber argument contains the number of the current page, starting at\n * 1. To display a header on the first page only, check pageNumber and add a\n * vertical offset in the constructor call for the height of the header.\n * \n * Page Format:\n * \n * For landscape printing, use <mxConstants.PAGE_FORMAT_A4_LANDSCAPE> as\n * the pageFormat in <mxUtils.getScaleForPageCount> and <mxPrintPreview>.\n * Keep in mind that one can not set the defaults for the print dialog\n * of the operating system from JavaScript so the user must manually choose\n * a page format that matches this setting.\n * \n * You can try passing the following CSS directive to <open> to set the\n * page format in the print dialog to landscape. However, this CSS\n * directive seems to be ignored in most major browsers, including IE.\n * \n * (code)\n * @page {\n *   size: landscape;\n * }\n * (end)\n * \n * Note that the print preview behaves differently in IE when used from the\n * filesystem or via HTTP so printing should always be tested via HTTP.\n * \n * If you are using a DOCTYPE in the source page you can override <getDoctype>\n * and provide the same DOCTYPE for the print preview if required. Here is\n * an example for IE8 standards mode.\n * \n * (code)\n * var preview = new mxPrintPreview(graph);\n * preview.getDoctype = function()\n * {\n *   return '<!--[if IE]><meta http-equiv=\"X-UA-Compatible\" content=\"IE=5,IE=8\" ><![endif]-->';\n * };\n * preview.open();\n * (end)\n * \n * Constructor: mxPrintPreview\n *\n * Constructs a new print preview for the given parameters.\n * \n * Parameters:\n * \n * graph - <mxGraph> to be previewed.\n * scale - Optional scale of the output. Default is 1 / <mxGraph.pageScale>.\n * pageFormat - <mxRectangle> that specifies the page format (in pixels).\n * border - Border in pixels along each side of every page. Note that the\n * actual print function in the browser will add another border for\n * printing.\n * This should match the page format of the printer. Default uses the\n * <mxGraph.pageFormat> of the given graph.\n * x0 - Optional left offset of the output. Default is 0.\n * y0 - Optional top offset of the output. Default is 0.\n * borderColor - Optional color of the page border. Default is no border.\n * Note that a border is sometimes useful to highlight the printed page\n * border in the print preview of the browser.\n * title - Optional string that is used for the window title. Default\n * is 'Printer-friendly version'.\n * pageSelector - Optional boolean that specifies if the page selector\n * should appear in the window with the print preview. Default is true.\n */\nfunction mxPrintPreview(graph, scale, pageFormat, border, x0, y0, borderColor, title, pageSelector)\n{\n\tthis.graph = graph;\n\tthis.scale = (scale != null) ? scale : 1 / graph.pageScale;\n\tthis.border = (border != null) ? border : 0;\n\tthis.pageFormat = mxRectangle.fromRectangle((pageFormat != null) ? pageFormat : graph.pageFormat);\n\tthis.title = (title != null) ? title : 'Printer-friendly version';\n\tthis.x0 = (x0 != null) ? x0 : 0;\n\tthis.y0 = (y0 != null) ? y0 : 0;\n\tthis.borderColor = borderColor;\n\tthis.pageSelector = (pageSelector != null) ? pageSelector : true;\n};\n\n/**\n * Variable: graph\n * \n * Reference to the <mxGraph> that should be previewed.\n */\nmxPrintPreview.prototype.graph = null;\n\n/**\n * Variable: pageFormat\n *\n * Holds the <mxRectangle> that defines the page format.\n */\nmxPrintPreview.prototype.pageFormat = null;\n\n/**\n * Variable: scale\n * \n * Holds the scale of the print preview.\n */\nmxPrintPreview.prototype.scale = null;\n\n/**\n * Variable: border\n * \n * The border inset around each side of every page in the preview. This is set\n * to 0 if autoOrigin is false.\n */\nmxPrintPreview.prototype.border = 0;\n\n/**\n * Variable: marginTop\n * \n * The margin at the top of the page (number). Default is 0.\n */\nmxPrintPreview.prototype.marginTop = 0;\n\n/**\n * Variable: marginBottom\n * \n * The margin at the bottom of the page (number). Default is 0.\n */\nmxPrintPreview.prototype.marginBottom = 0;\n\n/**\n * Variable: x0\n * \n * Holds the horizontal offset of the output.\n */\nmxPrintPreview.prototype.x0 = 0;\n\n/**\n * Variable: y0\n *\n * Holds the vertical offset of the output.\n */\nmxPrintPreview.prototype.y0 = 0;\n\n/**\n * Variable: autoOrigin\n * \n * Specifies if the origin should be automatically computed based on the top,\n * left corner of the actual diagram contents. The required offset will be added\n * to <x0> and <y0> in <open>. Default is true.\n */\nmxPrintPreview.prototype.autoOrigin = true;\n\n/**\n * Variable: printOverlays\n * \n * Specifies if overlays should be printed. Default is false.\n */\nmxPrintPreview.prototype.printOverlays = false;\n\n/**\n * Variable: printControls\n * \n * Specifies if controls (such as folding icons) should be printed. Default is\n * false.\n */\nmxPrintPreview.prototype.printControls = false;\n\n/**\n * Variable: printBackgroundImage\n * \n * Specifies if the background image should be printed. Default is false.\n */\nmxPrintPreview.prototype.printBackgroundImage = false;\n\n/**\n * Variable: backgroundColor\n * \n * Holds the color value for the page background color. Default is #ffffff.\n */\nmxPrintPreview.prototype.backgroundColor = '#ffffff';\n\n/**\n * Variable: borderColor\n * \n * Holds the color value for the page border.\n */\nmxPrintPreview.prototype.borderColor = null;\n\n/**\n * Variable: title\n * \n * Holds the title of the preview window.\n */\nmxPrintPreview.prototype.title = null;\n\n/**\n * Variable: pageSelector\n * \n * Boolean that specifies if the page selector should be\n * displayed. Default is true.\n */\nmxPrintPreview.prototype.pageSelector = null;\n\n/**\n * Variable: wnd\n * \n * Reference to the preview window.\n */\nmxPrintPreview.prototype.wnd = null;\n\n/**\n * Variable: targetWindow\n * \n * Assign any window here to redirect the rendering in <open>.\n */\nmxPrintPreview.prototype.targetWindow = null;\n\n/**\n * Variable: pageCount\n * \n * Holds the actual number of pages in the preview.\n */\nmxPrintPreview.prototype.pageCount = 0;\n\n/**\n * Variable: clipping\n * \n * Specifies is clipping should be used to avoid creating too many cell states\n * in large diagrams. The bounding box of the cells in the original diagram is\n * used if this is enabled. Default is true.\n */\nmxPrintPreview.prototype.clipping = true;\n\n/**\n * Function: getWindow\n * \n * Returns <wnd>.\n */\nmxPrintPreview.prototype.getWindow = function()\n{\n\treturn this.wnd;\n};\n\n/**\n * Function: getDocType\n * \n * Returns the string that should go before the HTML tag in the print preview\n * page. This implementation returns an X-UA meta tag for IE5 in quirks mode,\n * IE8 in IE8 standards mode and edge in IE9 standards mode.\n */\nmxPrintPreview.prototype.getDoctype = function()\n{\n\tvar dt = '';\n\t\n\tif (document.documentMode == 5)\n\t{\n\t\tdt = '<meta http-equiv=\"X-UA-Compatible\" content=\"IE=5\">';\n\t}\n\telse if (document.documentMode == 8)\n\t{\n\t\tdt = '<meta http-equiv=\"X-UA-Compatible\" content=\"IE=8\">';\n\t}\n\telse if (document.documentMode > 8)\n\t{\n\t\t// Comment needed to make standards doctype apply in IE\n\t\tdt = '<!--[if IE]><meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"><![endif]-->';\n\t}\n\t\n\treturn dt;\n};\n\n/**\n * Function: appendGraph\n * \n * Adds the given graph to the existing print preview.\n * \n * Parameters:\n * \n * css - Optional CSS string to be used in the head section.\n * targetWindow - Optional window that should be used for rendering. If\n * this is specified then no HEAD tag, CSS and BODY tag will be written.\n */\nmxPrintPreview.prototype.appendGraph = function(graph, scale, x0, y0, forcePageBreaks, keepOpen)\n{\n\tthis.graph = graph;\n\tthis.scale = (scale != null) ? scale : 1 / graph.pageScale;\n\tthis.x0 = x0;\n\tthis.y0 = y0;\n\tthis.open(null, null, forcePageBreaks, keepOpen);\n};\n\n/**\n * Function: open\n * \n * Shows the print preview window. The window is created here if it does\n * not exist.\n * \n * Parameters:\n * \n * css - Optional CSS string to be used in the head section.\n * targetWindow - Optional window that should be used for rendering. If\n * this is specified then no HEAD tag, CSS and BODY tag will be written.\n */\nmxPrintPreview.prototype.open = function(css, targetWindow, forcePageBreaks, keepOpen)\n{\n\t// Closing the window while the page is being rendered may cause an\n\t// exception in IE. This and any other exceptions are simply ignored.\n\tvar previousInitializeOverlay = this.graph.cellRenderer.initializeOverlay;\n\tvar div = null;\n\t\n\ttry\n\t{\n\t\t// Temporarily overrides the method to redirect rendering of overlays\n\t\t// to the draw pane so that they are visible in the printout\n\t\tif (this.printOverlays)\n\t\t{\n\t\t\tthis.graph.cellRenderer.initializeOverlay = function(state, overlay)\n\t\t\t{\n\t\t\t\toverlay.init(state.view.getDrawPane());\n\t\t\t};\n\t\t}\n\t\t\n\t\tif (this.printControls)\n\t\t{\n\t\t\tthis.graph.cellRenderer.initControl = function(state, control, handleEvents, clickHandler)\n\t\t\t{\n\t\t\t\tcontrol.dialect = state.view.graph.dialect;\n\t\t\t\tcontrol.init(state.view.getDrawPane());\n\t\t\t};\n\t\t}\n\t\t\n\t\tthis.wnd = (targetWindow != null) ? targetWindow : this.wnd;\n\t\tvar isNewWindow = false;\n\t\t\n\t\tif (this.wnd == null)\n\t\t{\n\t\t\tisNewWindow = true;\n\t\t\tthis.wnd = window.open();\n\t\t}\n\t\t\n\t\tvar doc = this.wnd.document;\n\t\t\n\t\tif (isNewWindow)\n\t\t{\n\t\t\tvar dt = this.getDoctype();\n\t\t\t\n\t\t\tif (dt != null && dt.length > 0)\n\t\t\t{\n\t\t\t\tdoc.writeln(dt);\n\t\t\t}\n\t\t\t\n\t\t\tif (mxClient.IS_VML)\n\t\t\t{\n\t\t\t\tdoc.writeln('<html xmlns:v=\"urn:schemas-microsoft-com:vml\" xmlns:o=\"urn:schemas-microsoft-com:office:office\">');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (document.compatMode === 'CSS1Compat')\n\t\t\t\t{\n\t\t\t\t\tdoc.writeln('<!DOCTYPE html>');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdoc.writeln('<html>');\n\t\t\t}\n\t\t\t\n\t\t\tdoc.writeln('<head>');\n\t\t\tthis.writeHead(doc, css);\n\t\t\tdoc.writeln('</head>');\n\t\t\tdoc.writeln('<body class=\"mxPage\">');\n\t\t}\n\n\t\t// Computes the horizontal and vertical page count\n\t\tvar bounds = this.graph.getGraphBounds().clone();\n\t\tvar currentScale = this.graph.getView().getScale();\n\t\tvar sc = currentScale / this.scale;\n\t\tvar tr = this.graph.getView().getTranslate();\n\t\t\n\t\t// Uses the absolute origin with no offset for all printing\n\t\tif (!this.autoOrigin)\n\t\t{\n\t\t\tthis.x0 -= tr.x * this.scale;\n\t\t\tthis.y0 -= tr.y * this.scale;\n\t\t\tbounds.width += bounds.x;\n\t\t\tbounds.height += bounds.y;\n\t\t\tbounds.x = 0;\n\t\t\tbounds.y = 0;\n\t\t\tthis.border = 0;\n\t\t}\n\t\t\n\t\t// Store the available page area\n\t\tvar availableWidth = this.pageFormat.width - (this.border * 2);\n\t\tvar availableHeight = this.pageFormat.height - (this.border * 2);\n\t\n\t\t// Adds margins to page format\n\t\tthis.pageFormat.height += this.marginTop + this.marginBottom;\n\n\t\t// Compute the unscaled, untranslated bounds to find\n\t\t// the number of vertical and horizontal pages\n\t\tbounds.width /= sc;\n\t\tbounds.height /= sc;\n\n\t\tvar hpages = Math.max(1, Math.ceil((bounds.width + this.x0) / availableWidth));\n\t\tvar vpages = Math.max(1, Math.ceil((bounds.height + this.y0) / availableHeight));\n\t\tthis.pageCount = hpages * vpages;\n\t\t\n\t\tvar writePageSelector = mxUtils.bind(this, function()\n\t\t{\n\t\t\tif (this.pageSelector && (vpages > 1 || hpages > 1))\n\t\t\t{\n\t\t\t\tvar table = this.createPageSelector(vpages, hpages);\n\t\t\t\tdoc.body.appendChild(table);\n\t\t\t\t\n\t\t\t\t// Implements position: fixed in IE quirks mode\n\t\t\t\tif (mxClient.IS_IE && doc.documentMode == null || doc.documentMode == 5 || doc.documentMode == 8 || doc.documentMode == 7)\n\t\t\t\t{\n\t\t\t\t\ttable.style.position = 'absolute';\n\t\t\t\t\t\n\t\t\t\t\tvar update = function()\n\t\t\t\t\t{\n\t\t\t\t\t\ttable.style.top = ((doc.body.scrollTop || doc.documentElement.scrollTop) + 10) + 'px';\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tmxEvent.addListener(this.wnd, 'scroll', function(evt)\n\t\t\t\t\t{\n\t\t\t\t\t\tupdate();\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tmxEvent.addListener(this.wnd, 'resize', function(evt)\n\t\t\t\t\t{\n\t\t\t\t\t\tupdate();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\tvar addPage = mxUtils.bind(this, function(div, addBreak)\n\t\t{\n\t\t\t// Border of the DIV (aka page) inside the document\n\t\t\tif (this.borderColor != null)\n\t\t\t{\n\t\t\t\tdiv.style.borderColor = this.borderColor;\n\t\t\t\tdiv.style.borderStyle = 'solid';\n\t\t\t\tdiv.style.borderWidth = '1px';\n\t\t\t}\n\t\t\t\n\t\t\t// Needs to be assigned directly because IE doesn't support\n\t\t\t// child selectors, eg. body > div { background: white; }\n\t\t\tdiv.style.background = this.backgroundColor;\n\t\t\t\n\t\t\tif (forcePageBreaks || addBreak)\n\t\t\t{\n\t\t\t\tdiv.style.pageBreakAfter = 'always';\n\t\t\t}\n\n\t\t\t// NOTE: We are dealing with cross-window DOM here, which\n\t\t\t// is a problem in IE, so we copy the HTML markup instead.\n\t\t\t// The underlying problem is that the graph display markup\n\t\t\t// creation (in mxShape, mxGraphView) is hardwired to using\n\t\t\t// document.createElement and hence we must use this document\n\t\t\t// to create the complete page and then copy it over to the\n\t\t\t// new window.document. This can be fixed later by using the\n\t\t\t// ownerDocument of the container in mxShape and mxGraphView.\n\t\t\tif (isNewWindow && (mxClient.IS_IE || document.documentMode >= 11 || mxClient.IS_EDGE))\n\t\t\t{\n\t\t\t\t// For some obscure reason, removing the DIV from the\n\t\t\t\t// parent before fetching its outerHTML has missing\n\t\t\t\t// fillcolor properties and fill children, so the div\n\t\t\t\t// must be removed afterwards to keep the fillcolors.\n\t\t\t\tdoc.writeln(div.outerHTML);\n\t\t\t\tdiv.parentNode.removeChild(div);\n\t\t\t}\n\t\t\telse if (mxClient.IS_IE || document.documentMode >= 11 || mxClient.IS_EDGE)\n\t\t\t{\n\t\t\t\tvar clone = doc.createElement('div');\n\t\t\t\tclone.innerHTML = div.outerHTML;\n\t\t\t\tclone = clone.getElementsByTagName('div')[0];\n\t\t\t\tdoc.body.appendChild(clone);\n\t\t\t\tdiv.parentNode.removeChild(div);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdiv.parentNode.removeChild(div);\n\t\t\t\tdoc.body.appendChild(div);\n\t\t\t}\n\n\t\t\tif (forcePageBreaks || addBreak)\n\t\t\t{\n\t\t\t\tthis.addPageBreak(doc);\n\t\t\t}\n\t\t});\n\t\t\n\t\tvar cov = this.getCoverPages(this.pageFormat.width, this.pageFormat.height);\n\t\t\n\t\tif (cov != null)\n\t\t{\n\t\t\tfor (var i = 0; i < cov.length; i++)\n\t\t\t{\n\t\t\t\taddPage(cov[i], true);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar apx = this.getAppendices(this.pageFormat.width, this.pageFormat.height);\n\t\t\n\t\t// Appends each page to the page output for printing, making\n\t\t// sure there will be a page break after each page (ie. div)\n\t\tfor (var i = 0; i < vpages; i++)\n\t\t{\n\t\t\tvar dy = i * availableHeight / this.scale - this.y0 / this.scale +\n\t\t\t\t\t(bounds.y - tr.y * currentScale) / currentScale;\n\t\t\t\n\t\t\tfor (var j = 0; j < hpages; j++)\n\t\t\t{\n\t\t\t\tif (this.wnd == null)\n\t\t\t\t{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar dx = j * availableWidth / this.scale - this.x0 / this.scale +\n\t\t\t\t\t\t(bounds.x - tr.x * currentScale) / currentScale;\n\t\t\t\tvar pageNum = i * hpages + j + 1;\n\t\t\t\tvar clip = new mxRectangle(dx, dy, availableWidth, availableHeight);\n\t\t\t\tdiv = this.renderPage(this.pageFormat.width, this.pageFormat.height, 0, 0, mxUtils.bind(this, function(div)\n\t\t\t\t{\n\t\t\t\t\tthis.addGraphFragment(-dx, -dy, this.scale, pageNum, div, clip);\n\t\t\t\t\t\n\t\t\t\t\tif (this.printBackgroundImage)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.insertBackgroundImage(div, -dx, -dy);\n\t\t\t\t\t}\n\t\t\t\t}), pageNum);\n\n\t\t\t\t// Gives the page a unique ID for later accessing the page\n\t\t\t\tdiv.setAttribute('id', 'mxPage-'+pageNum);\n\n\t\t\t\taddPage(div, apx != null || i < vpages - 1 || j < hpages - 1);\n\t\t\t}\n\t\t}\n\n\t\tif (apx != null)\n\t\t{\n\t\t\tfor (var i = 0; i < apx.length; i++)\n\t\t\t{\n\t\t\t\taddPage(apx[i], i < apx.length - 1);\n\t\t\t}\n\t\t}\n\n\t\tif (isNewWindow && !keepOpen)\n\t\t{\n\t\t\tthis.closeDocument();\n\t\t\twritePageSelector();\n\t\t}\n\t\t\n\t\tthis.wnd.focus();\n\t}\n\tcatch (e)\n\t{\n\t\t// Removes the DIV from the document in case of an error\n\t\tif (div != null && div.parentNode != null)\n\t\t{\n\t\t\tdiv.parentNode.removeChild(div);\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tthis.graph.cellRenderer.initializeOverlay = previousInitializeOverlay;\n\t}\n\n\treturn this.wnd;\n};\n\n/**\n * Function: addPageBreak\n * \n * Adds a page break to the given document.\n */\nmxPrintPreview.prototype.addPageBreak = function(doc)\n{\n\tvar hr = doc.createElement('hr');\n\thr.className = 'mxPageBreak';\n\tdoc.body.appendChild(hr);\n};\n\n/**\n * Function: closeDocument\n * \n * Writes the closing tags for body and page after calling <writePostfix>.\n */\nmxPrintPreview.prototype.closeDocument = function()\n{\n\ttry\n\t{\n\t\tif (this.wnd != null && this.wnd.document != null)\n\t\t{\n\t\t\tvar doc = this.wnd.document;\n\t\t\t\n\t\t\tthis.writePostfix(doc);\n\t\t\tdoc.writeln('</body>');\n\t\t\tdoc.writeln('</html>');\n\t\t\tdoc.close();\n\t\t\t\n\t\t\t// Removes all event handlers in the print output\n\t\t\tmxEvent.release(doc.body);\n\t\t}\n\t}\n\tcatch (e)\n\t{\n\t\t// ignore any errors resulting from wnd no longer being available\n\t}\n};\n\n/**\n * Function: writeHead\n * \n * Writes the HEAD section into the given document, without the opening\n * and closing HEAD tags.\n */\nmxPrintPreview.prototype.writeHead = function(doc, css)\n{\n\tif (this.title != null)\n\t{\n\t\tdoc.writeln('<title>' + this.title + '</title>');\n\t}\n\t\n\t// Adds required namespaces\n\tif (mxClient.IS_VML)\n\t{\n\t\tdoc.writeln('<style type=\"text/css\">v\\\\:*{behavior:url(#default#VML)}o\\\\:*{behavior:url(#default#VML)}</style>');\n\t}\n\n\t// Adds all required stylesheets\n\tmxClient.link('stylesheet', mxClient.basePath + '/css/common.css', doc);\n\n\t// Removes horizontal rules and page selector from print output\n\tdoc.writeln('<style type=\"text/css\">');\n\tdoc.writeln('@media print {');\n\tdoc.writeln('  * { -webkit-print-color-adjust: exact; }');\n\tdoc.writeln('  table.mxPageSelector { display: none; }');\n\tdoc.writeln('  hr.mxPageBreak { display: none; }');\n\tdoc.writeln('}');\n\tdoc.writeln('@media screen {');\n\t\n\t// NOTE: position: fixed is not supported in IE, so the page selector\n\t// position (absolute) needs to be updated in IE (see below)\n\tdoc.writeln('  table.mxPageSelector { position: fixed; right: 10px; top: 10px;' +\n\t\t\t'font-family: Arial; font-size:10pt; border: solid 1px darkgray;' +\n\t\t\t'background: white; border-collapse:collapse; }');\n\tdoc.writeln('  table.mxPageSelector td { border: solid 1px gray; padding:4px; }');\n\tdoc.writeln('  body.mxPage { background: gray; }');\n\tdoc.writeln('}');\n\t\n\tif (css != null)\n\t{\n\t\tdoc.writeln(css);\n\t}\n\t\n\tdoc.writeln('</style>');\n};\n\n/**\n * Function: writePostfix\n * \n * Called before closing the body of the page. This implementation is empty.\n */\nmxPrintPreview.prototype.writePostfix = function(doc)\n{\n\t// empty\n};\n\n/**\n * Function: createPageSelector\n * \n * Creates the page selector table.\n */\nmxPrintPreview.prototype.createPageSelector = function(vpages, hpages)\n{\n\tvar doc = this.wnd.document;\n\tvar table = doc.createElement('table');\n\ttable.className = 'mxPageSelector';\n\ttable.setAttribute('border', '0');\n\n\tvar tbody = doc.createElement('tbody');\n\t\n\tfor (var i = 0; i < vpages; i++)\n\t{\n\t\tvar row = doc.createElement('tr');\n\t\t\n\t\tfor (var j = 0; j < hpages; j++)\n\t\t{\n\t\t\tvar pageNum = i * hpages + j + 1;\n\t\t\tvar cell = doc.createElement('td');\n\t\t\tvar a = doc.createElement('a');\n\t\t\ta.setAttribute('href', '#mxPage-' + pageNum);\n\n\t\t\t// Workaround for FF where the anchor is appended to the URL of the original document\n\t\t\tif (mxClient.IS_NS && !mxClient.IS_SF && !mxClient.IS_GC)\n\t\t\t{\n\t\t\t\tvar js = 'var page = document.getElementById(\\'mxPage-' + pageNum + '\\');page.scrollIntoView(true);event.preventDefault();';\n\t\t\t\ta.setAttribute('onclick', js);\n\t\t\t}\n\t\t\t\n\t\t\tmxUtils.write(a, pageNum, doc);\n\t\t\tcell.appendChild(a);\n\t\t\trow.appendChild(cell);\n\t\t}\n\t\t\n\t\ttbody.appendChild(row);\n\t}\n\t\n\ttable.appendChild(tbody);\n\t\n\treturn table;\n};\n\n/**\n * Function: renderPage\n * \n * Creates a DIV that prints a single page of the given\n * graph using the given scale and returns the DIV that\n * represents the page.\n * \n * Parameters:\n * \n * w - Width of the page in pixels.\n * h - Height of the page in pixels.\n * dx - Optional horizontal page offset in pixels (used internally).\n * dy - Optional vertical page offset in pixels (used internally).\n * content - Callback that adds the HTML content to the inner div of a page.\n * Takes the inner div as the argument.\n * pageNumber - Integer representing the page number.\n */\nmxPrintPreview.prototype.renderPage = function(w, h, dx, dy, content, pageNumber)\n{\n\tvar doc = this.wnd.document;\n\tvar div = document.createElement('div');\n\tvar arg = null;\n\n\ttry\n\t{\n\t\t// Workaround for ignored clipping in IE 9 standards\n\t\t// when printing with page breaks and HTML labels.\n\t\tif (dx != 0 || dy != 0)\n\t\t{\n\t\t\tdiv.style.position = 'relative';\n\t\t\tdiv.style.width = w + 'px';\n\t\t\tdiv.style.height = h + 'px';\n\t\t\tdiv.style.pageBreakInside = 'avoid';\n\t\t\t\n\t\t\tvar innerDiv = document.createElement('div');\n\t\t\tinnerDiv.style.position = 'relative';\n\t\t\tinnerDiv.style.top = this.border + 'px';\n\t\t\tinnerDiv.style.left = this.border + 'px';\n\t\t\tinnerDiv.style.width = (w - 2 * this.border) + 'px';\n\t\t\tinnerDiv.style.height = (h - 2 * this.border) + 'px';\n\t\t\tinnerDiv.style.overflow = 'hidden';\n\t\t\t\n\t\t\tvar viewport = document.createElement('div');\n\t\t\tviewport.style.position = 'relative';\n\t\t\tviewport.style.marginLeft = dx + 'px';\n\t\t\tviewport.style.marginTop = dy + 'px';\n\n\t\t\t// FIXME: IE8 standards output problems\n\t\t\tif (doc.documentMode == 8)\n\t\t\t{\n\t\t\t\tinnerDiv.style.position = 'absolute';\n\t\t\t\tviewport.style.position = 'absolute';\n\t\t\t}\n\t\t\n\t\t\tif (doc.documentMode == 10)\n\t\t\t{\n\t\t\t\tviewport.style.width = '100%';\n\t\t\t\tviewport.style.height = '100%';\n\t\t\t}\n\t\t\t\n\t\t\tinnerDiv.appendChild(viewport);\n\t\t\tdiv.appendChild(innerDiv);\n\t\t\tdocument.body.appendChild(div);\n\t\t\targ = viewport;\n\t\t}\n\t\t// FIXME: IE10/11 too many pages\n\t\telse\n\t\t{\n\t\t\tdiv.style.width = w + 'px';\n\t\t\tdiv.style.height = h + 'px';\n\t\t\tdiv.style.overflow = 'hidden';\n\t\t\tdiv.style.pageBreakInside = 'avoid';\n\t\t\t\n\t\t\t// IE8 uses above branch currently\n\t\t\tif (doc.documentMode == 8)\n\t\t\t{\n\t\t\t\tdiv.style.position = 'relative';\n\t\t\t}\n\t\t\t\n\t\t\tvar innerDiv = document.createElement('div');\n\t\t\tinnerDiv.style.width = (w - 2 * this.border) + 'px';\n\t\t\tinnerDiv.style.height = (h - 2 * this.border) + 'px';\n\t\t\tinnerDiv.style.overflow = 'hidden';\n\n\t\t\tif (mxClient.IS_IE && (doc.documentMode == null || doc.documentMode == 5 ||\n\t\t\t\tdoc.documentMode == 8 || doc.documentMode == 7))\n\t\t\t{\n\t\t\t\tinnerDiv.style.marginTop = this.border + 'px';\n\t\t\t\tinnerDiv.style.marginLeft = this.border + 'px';\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinnerDiv.style.top = this.border + 'px';\n\t\t\t\tinnerDiv.style.left = this.border + 'px';\n\t\t\t}\n\t\n\t\t\tif (this.graph.dialect == mxConstants.DIALECT_VML)\n\t\t\t{\n\t\t\t\tinnerDiv.style.position = 'absolute';\n\t\t\t}\n\n\t\t\tdiv.appendChild(innerDiv);\n\t\t\tdocument.body.appendChild(div);\n\t\t\targ = innerDiv;\n\t\t}\n\t}\n\tcatch (e)\n\t{\n\t\tdiv.parentNode.removeChild(div);\n\t\tdiv = null;\n\t\t\n\t\tthrow e;\n\t}\n\n\tcontent(arg);\n\t \n\treturn div;\n};\n\n/**\n * Function: getRoot\n * \n * Returns the root cell for painting the graph.\n */\nmxPrintPreview.prototype.getRoot = function()\n{\n\tvar root = this.graph.view.currentRoot;\n\t\n\tif (root == null)\n\t{\n\t\troot = this.graph.getModel().getRoot();\n\t}\n\t\n\treturn root;\n};\n\n/**\n * Function: useCssTransforms\n * \n * Returns true if CSS transforms should be used for scaling content.\n * This returns true if foreignObject is supported and we're not in Safari\n * as it has clipping bugs for transformed CSS content with foreignObjects.\n */\nmxPrintPreview.prototype.useCssTransforms = function()\n{\n\treturn !mxClient.NO_FO && !mxClient.IS_SF;\n};\n\n/**\n * Function: addGraphFragment\n * \n * Adds a graph fragment to the given div.\n * \n * Parameters:\n * \n * dx - Horizontal translation for the diagram.\n * dy - Vertical translation for the diagram.\n * scale - Scale for the diagram.\n * pageNumber - Number of the page to be rendered.\n * div - Div that contains the output.\n * clip - Contains the clipping rectangle as an <mxRectangle>.\n */\nmxPrintPreview.prototype.addGraphFragment = function(dx, dy, scale, pageNumber, div, clip)\n{\n\tvar view = this.graph.getView();\n\tvar previousContainer = this.graph.container;\n\tthis.graph.container = div;\n\t\n\tvar canvas = view.getCanvas();\n\tvar backgroundPane = view.getBackgroundPane();\n\tvar drawPane = view.getDrawPane();\n\tvar overlayPane = view.getOverlayPane();\n\tvar realScale = scale;\n\n\tif (this.graph.dialect == mxConstants.DIALECT_SVG)\n\t{\n\t\tview.createSvg();\n\t\t\n\t\t// Uses CSS transform for scaling\n\t\tif (this.useCssTransforms())\n\t\t{\n\t\t\tvar g = view.getDrawPane().parentNode;\n\t\t\tvar prev = g.getAttribute('transform');\n\t\t\tg.setAttribute('transformOrigin', '0 0');\n\t\t\tg.setAttribute('transform', 'scale(' + scale + ',' + scale + ')' +\n\t\t\t\t'translate(' + dx + ',' + dy + ')');\n\t\t\t\n\t\t\tscale = 1;\n\t\t\tdx = 0;\n\t\t\tdy = 0;\n\t\t}\n\t}\n\telse if (this.graph.dialect == mxConstants.DIALECT_VML)\n\t{\n\t\tview.createVml();\n\t}\n\telse\n\t{\n\t\tview.createHtml();\n\t}\n\t\n\t// Disables events on the view\n\tvar eventsEnabled = view.isEventsEnabled();\n\tview.setEventsEnabled(false);\n\t\n\t// Disables the graph to avoid cursors\n\tvar graphEnabled = this.graph.isEnabled();\n\tthis.graph.setEnabled(false);\n\n\t// Resets the translation\n\tvar translate = view.getTranslate();\n\tview.translate = new mxPoint(dx, dy);\n\t\n\t// Redraws only states that intersect the clip\n\tvar redraw = this.graph.cellRenderer.redraw;\n\tvar states = view.states;\n\tvar s = view.scale;\n\n\t// Gets the transformed clip for intersection check below\n\tif (this.clipping)\n\t{\n\t\tvar tempClip = new mxRectangle((clip.x + translate.x) * s, (clip.y + translate.y) * s,\n\t\t\t\tclip.width * s / realScale, clip.height * s / realScale);\n\n\t\t// Checks clipping rectangle for speedup\n\t\t// Must create terminal states for edge clipping even if terminal outside of clip\n\t\tthis.graph.cellRenderer.redraw = function(state, force, rendering)\n\t\t{\n\t\t\tif (state != null)\n\t\t\t{\n\t\t\t\t// Gets original state from graph to find bounding box\n\t\t\t\tvar orig = states.get(state.cell);\n\t\t\t\t\n\t\t\t\tif (orig != null)\n\t\t\t\t{\n\t\t\t\t\tvar bbox = view.getBoundingBox(orig, false);\n\t\t\t\t\t\n\t\t\t\t\t// Stops rendering if outside clip for speedup but ignores\n\t\t\t\t\t// edge labels where width and height is set to 0\n\t\t\t\t\tif (bbox != null && bbox.width > 0 && bbox.height > 0 &&\n\t\t\t\t\t\t!mxUtils.intersects(tempClip, bbox))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tredraw.apply(this, arguments);\n\t\t};\n\t}\n\t\n\tvar temp = null;\n\t\n\ttry\n\t{\n\t\t// Creates the temporary cell states in the view and\n\t\t// draws them onto the temporary DOM nodes in the view\n\t\tvar cells = [this.getRoot()];\n\t\ttemp = new mxTemporaryCellStates(view, scale, cells, null, mxUtils.bind(this, function(state)\n\t\t{\n\t\t\treturn this.getLinkForCellState(state);\n\t\t}));\n\t}\n\tfinally\n\t{\n\t\t// Removes overlay pane with selection handles\n\t\t// controls and icons from the print output\n\t\tif (mxClient.IS_IE)\n\t\t{\n\t\t\tview.overlayPane.innerHTML = '';\n\t\t\tview.canvas.style.overflow = 'hidden';\n\t\t\tview.canvas.style.position = 'relative';\n\t\t\tview.canvas.style.top = this.marginTop + 'px';\n\t\t\tview.canvas.style.width = clip.width + 'px';\n\t\t\tview.canvas.style.height = clip.height + 'px';\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Removes everything but the SVG node\n\t\t\tvar tmp = div.firstChild;\n\n\t\t\twhile (tmp != null)\n\t\t\t{\n\t\t\t\tvar next = tmp.nextSibling;\n\t\t\t\tvar name = tmp.nodeName.toLowerCase();\n\n\t\t\t\t// Note: Width and height are required in FF 11\n\t\t\t\tif (name == 'svg')\n\t\t\t\t{\n\t\t\t\t\ttmp.style.overflow = 'hidden';\n\t\t\t\t\ttmp.style.position = 'relative';\n\t\t\t\t\ttmp.style.top = this.marginTop + 'px';\n\t\t\t\t\ttmp.setAttribute('width', clip.width);\n\t\t\t\t\ttmp.setAttribute('height', clip.height);\n\t\t\t\t\ttmp.style.width = '';\n\t\t\t\t\ttmp.style.height = '';\n\t\t\t\t}\n\t\t\t\t// Tries to fetch all text labels and only text labels\n\t\t\t\telse if (tmp.style.cursor != 'default' && name != 'div')\n\t\t\t\t{\n\t\t\t\t\ttmp.parentNode.removeChild(tmp);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttmp = next;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Puts background image behind SVG output\n\t\tif (this.printBackgroundImage)\n\t\t{\n\t\t\tvar svgs = div.getElementsByTagName('svg');\n\t\t\t\n\t\t\tif (svgs.length > 0)\n\t\t\t{\n\t\t\t\tsvgs[0].style.position = 'absolute';\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Completely removes the overlay pane to remove more handles\n\t\tview.overlayPane.parentNode.removeChild(view.overlayPane);\n\n\t\t// Restores the state of the view\n\t\tthis.graph.setEnabled(graphEnabled);\n\t\tthis.graph.container = previousContainer;\n\t\tthis.graph.cellRenderer.redraw = redraw;\n\t\tview.canvas = canvas;\n\t\tview.backgroundPane = backgroundPane;\n\t\tview.drawPane = drawPane;\n\t\tview.overlayPane = overlayPane;\n\t\tview.translate = translate;\n\t\ttemp.destroy();\n\t\tview.setEventsEnabled(eventsEnabled);\n\t}\n};\n\n/**\n * Function: getLinkForCellState\n * \n * Returns the link for the given cell state. This returns null.\n */\nmxPrintPreview.prototype.getLinkForCellState = function(state)\n{\n\treturn this.graph.getLinkForCell(state.cell);\n};\n\n/**\n * Function: insertBackgroundImage\n * \n * Inserts the background image into the given div.\n */\nmxPrintPreview.prototype.insertBackgroundImage = function(div, dx, dy)\n{\n\tvar bg = this.graph.backgroundImage;\n\t\n\tif (bg != null)\n\t{\n\t\tvar img = document.createElement('img');\n\t\timg.style.position = 'absolute';\n\t\timg.style.marginLeft = Math.round(dx * this.scale) + 'px';\n\t\timg.style.marginTop = Math.round(dy * this.scale) + 'px';\n\t\timg.setAttribute('width', Math.round(this.scale * bg.width));\n\t\timg.setAttribute('height', Math.round(this.scale * bg.height));\n\t\timg.src = bg.src;\n\t\t\n\t\tdiv.insertBefore(img, div.firstChild);\n\t}\n};\n\n/**\n * Function: getCoverPages\n * \n * Returns the pages to be added before the print output. This returns null.\n */\nmxPrintPreview.prototype.getCoverPages = function()\n{\n\treturn null;\n};\n\n/**\n * Function: getAppendices\n * \n * Returns the pages to be added after the print output. This returns null.\n */\nmxPrintPreview.prototype.getAppendices = function()\n{\n\treturn null;\n};\n\n/**\n * Function: print\n * \n * Opens the print preview and shows the print dialog.\n * \n * Parameters:\n * \n * css - Optional CSS string to be used in the head section.\n */\nmxPrintPreview.prototype.print = function(css)\n{\n\tvar wnd = this.open(css);\n\t\n\tif (wnd != null)\n\t{\n\t\twnd.print();\n\t}\n};\n\n/**\n * Function: close\n * \n * Closes the print preview window.\n */\nmxPrintPreview.prototype.close = function()\n{\n\tif (this.wnd != null)\n\t{\n\t\tthis.wnd.close();\n\t\tthis.wnd = null;\n\t}\n};\n\n__mxOutput.mxPrintPreview = typeof mxPrintPreview !== 'undefined' ? mxPrintPreview : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxStylesheet\n *\n * Defines the appearance of the cells in a graph. See <putCellStyle> for an\n * example of creating a new cell style. It is recommended to use objects, not\n * arrays for holding cell styles. Existing styles can be cloned using\n * <mxUtils.clone> and turned into a string for debugging using\n * <mxUtils.toString>.\n *\n * Default Styles:\n *\n * The stylesheet contains two built-in styles, which are used if no style is\n * defined for a cell:\n *\n *   defaultVertex - Default style for vertices\n *   defaultEdge - Default style for edges\n *\n * Example:\n *\n * (code)\n * var vertexStyle = stylesheet.getDefaultVertexStyle();\n * vertexStyle[mxConstants.STYLE_ROUNDED] = true;\n * var edgeStyle = stylesheet.getDefaultEdgeStyle();\n * edgeStyle[mxConstants.STYLE_EDGE] = mxEdgeStyle.EntityRelation;\n * (end)\n *\n * Modifies the built-in default styles.\n *\n * To avoid the default style for a cell, add a leading semicolon\n * to the style definition, eg.\n *\n * (code)\n * ;shadow=1\n * (end)\n *\n * Removing keys:\n *\n * For removing a key in a cell style of the form [stylename;|key=value;] the\n * special value none can be used, eg. highlight;fillColor=none\n *\n * See also the helper methods in mxUtils to modify strings of this format,\n * namely <mxUtils.setStyle>, <mxUtils.indexOfStylename>,\n * <mxUtils.addStylename>, <mxUtils.removeStylename>,\n * <mxUtils.removeAllStylenames> and <mxUtils.setStyleFlag>.\n *\n * Constructor: mxStylesheet\n *\n * Constructs a new stylesheet and assigns default styles.\n */\nfunction mxStylesheet()\n{\n\tthis.styles = new Object();\n\n\tthis.putDefaultVertexStyle(this.createDefaultVertexStyle());\n\tthis.putDefaultEdgeStyle(this.createDefaultEdgeStyle());\n};\n\n/**\n * Function: styles\n *\n * Maps from names to cell styles. Each cell style is a map of key,\n * value pairs.\n */\nmxStylesheet.prototype.styles;\n\n/**\n * Function: createDefaultVertexStyle\n *\n * Creates and returns the default vertex style.\n */\nmxStylesheet.prototype.createDefaultVertexStyle = function()\n{\n\tvar style = new Object();\n\n\tstyle[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;\n\tstyle[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;\n\tstyle[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE;\n\tstyle[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;\n\tstyle[mxConstants.STYLE_FILLCOLOR] = '#C3D9FF';\n\tstyle[mxConstants.STYLE_STROKECOLOR] = '#6482B9';\n\tstyle[mxConstants.STYLE_FONTCOLOR] = '#774400';\n\n\treturn style;\n};\n\n/**\n * Function: createDefaultEdgeStyle\n *\n * Creates and returns the default edge style.\n */\nmxStylesheet.prototype.createDefaultEdgeStyle = function()\n{\n\tvar style = new Object();\n\n\tstyle[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_CONNECTOR;\n\tstyle[mxConstants.STYLE_ENDARROW] = mxConstants.ARROW_CLASSIC;\n\tstyle[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE;\n\tstyle[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;\n\tstyle[mxConstants.STYLE_STROKECOLOR] = '#6482B9';\n\tstyle[mxConstants.STYLE_FONTCOLOR] = '#446299';\n\n\treturn style;\n};\n\n/**\n * Function: putDefaultVertexStyle\n *\n * Sets the default style for vertices using defaultVertex as the\n * stylename.\n *\n * Parameters:\n * style - Key, value pairs that define the style.\n */\nmxStylesheet.prototype.putDefaultVertexStyle = function(style)\n{\n\tthis.putCellStyle('defaultVertex', style);\n};\n\n/**\n * Function: putDefaultEdgeStyle\n *\n * Sets the default style for edges using defaultEdge as the stylename.\n */\nmxStylesheet.prototype.putDefaultEdgeStyle = function(style)\n{\n\tthis.putCellStyle('defaultEdge', style);\n};\n\n/**\n * Function: getDefaultVertexStyle\n *\n * Returns the default style for vertices.\n */\nmxStylesheet.prototype.getDefaultVertexStyle = function()\n{\n\treturn this.styles['defaultVertex'];\n};\n\n/**\n * Function: getDefaultEdgeStyle\n *\n * Sets the default style for edges.\n */\nmxStylesheet.prototype.getDefaultEdgeStyle = function()\n{\n\treturn this.styles['defaultEdge'];\n};\n\n/**\n * Function: putCellStyle\n *\n * Stores the given map of key, value pairs under the given name in\n * <styles>.\n *\n * Example:\n *\n * The following example adds a new style called 'rounded' into an\n * existing stylesheet:\n *\n * (code)\n * var style = new Object();\n * style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;\n * style[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;\n * style[mxConstants.STYLE_ROUNDED] = true;\n * graph.getStylesheet().putCellStyle('rounded', style);\n * (end)\n *\n * In the above example, the new style is an object. The possible keys of\n * the object are all the constants in <mxConstants> that start with STYLE\n * and the values are either JavaScript objects, such as\n * <mxPerimeter.RightAngleRectanglePerimeter> (which is in fact a function)\n * or expressions, such as true. Note that not all keys will be\n * interpreted by all shapes (eg. the line shape ignores the fill color).\n * The final call to this method associates the style with a name in the\n * stylesheet. The style is used in a cell with the following code:\n *\n * (code)\n * model.setStyle(cell, 'rounded');\n * (end)\n *\n * Parameters:\n *\n * name - Name for the style to be stored.\n * style - Key, value pairs that define the style.\n */\nmxStylesheet.prototype.putCellStyle = function(name, style)\n{\n\tthis.styles[name] = style;\n};\n\n/**\n * Function: getCellStyle\n *\n * Returns the cell style for the specified stylename or the given\n * defaultStyle if no style can be found for the given stylename.\n *\n * Parameters:\n *\n * name - String of the form [(stylename|key=value);] that represents the\n * style.\n * defaultStyle - Default style to be returned if no style can be found.\n */\nmxStylesheet.prototype.getCellStyle = function(name, defaultStyle)\n{\n\tvar style = defaultStyle;\n\n\tif (name != null && name.length > 0)\n\t{\n\t\tvar pairs = name.split(';');\n\n\t\tif (style != null &&\n\t\t\tname.charAt(0) != ';')\n\t\t{\n\t\t\tstyle = mxUtils.clone(style);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstyle = new Object();\n\t\t}\n\n\t\t// Parses each key, value pair into the existing style\n\t \tfor (var i = 0; i < pairs.length; i++)\n\t \t{\n\t \t\tvar tmp = pairs[i];\n\t \t\tvar pos = tmp.indexOf('=');\n\n\t \t\tif (pos >= 0)\n\t \t\t{\n\t\t \t\tvar key = tmp.substring(0, pos);\n\t\t \t\tvar value = tmp.substring(pos + 1);\n\n\t\t \t\tif (value == mxConstants.NONE)\n\t\t \t\t{\n\t\t \t\t\tdelete style[key];\n\t\t \t\t}\n\t\t \t\telse if (mxUtils.isNumeric(value))\n\t\t \t\t{\n\t\t \t\t\tstyle[key] = parseFloat(value);\n\t\t \t\t}\n\t\t \t\telse\n\t\t \t\t{\n\t\t\t \t\tstyle[key] = value;\n\t\t \t\t}\n\t\t\t}\n\t \t\telse\n\t \t\t{\n\t \t\t\t// Merges the entries from a named style\n\t\t\t\tvar tmpStyle = this.styles[tmp];\n\n\t\t\t\tif (tmpStyle != null)\n\t\t\t\t{\n\t\t\t\t\tfor (var key in tmpStyle)\n\t\t\t\t\t{\n\t\t\t\t\t\tstyle[key] = tmpStyle[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t \t\t}\n\t\t}\n\t}\n\n\treturn style;\n};\n\n__mxOutput.mxStylesheet = typeof mxStylesheet !== 'undefined' ? mxStylesheet : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCellState\n * \n * Represents the current state of a cell in a given <mxGraphView>.\n * \n * For edges, the edge label position is stored in <absoluteOffset>.\n * \n * The size for oversize labels can be retrieved using the boundingBox property\n * of the <text> field as shown below.\n * \n * (code)\n * var bbox = (state.text != null) ? state.text.boundingBox : null;\n * (end)\n * \n * Constructor: mxCellState\n * \n * Constructs a new object that represents the current state of the given\n * cell in the specified view.\n * \n * Parameters:\n * \n * view - <mxGraphView> that contains the state.\n * cell - <mxCell> that this state represents.\n * style - Array of key, value pairs that constitute the style.\n */\nfunction mxCellState(view, cell, style)\n{\n\tthis.view = view;\n\tthis.cell = cell;\n\tthis.style = (style != null) ? style : {};\n\t\n\tthis.origin = new mxPoint();\n\tthis.absoluteOffset = new mxPoint();\n};\n\n/**\n * Extends mxRectangle.\n */\nmxCellState.prototype = new mxRectangle();\nmxCellState.prototype.constructor = mxCellState;\n\n/**\n * Variable: view\n * \n * Reference to the enclosing <mxGraphView>.\n */\nmxCellState.prototype.view = null;\n\n/**\n * Variable: cell\n *\n * Reference to the <mxCell> that is represented by this state.\n */\nmxCellState.prototype.cell = null;\n\n/**\n * Variable: style\n * \n * Contains an array of key, value pairs that represent the style of the\n * cell.\n */\nmxCellState.prototype.style = null;\n\n/**\n * Variable: invalidStyle\n * \n * Specifies if the style is invalid. Default is false.\n */\nmxCellState.prototype.invalidStyle = false;\n\n/**\n * Variable: invalid\n * \n * Specifies if the state is invalid. Default is true.\n */\nmxCellState.prototype.invalid = true;\n\n/**\n * Variable: origin\n *\n * <mxPoint> that holds the origin for all child cells. Default is a new\n * empty <mxPoint>.\n */\nmxCellState.prototype.origin = null;\n\n/**\n * Variable: absolutePoints\n * \n * Holds an array of <mxPoints> that represent the absolute points of an\n * edge.\n */\nmxCellState.prototype.absolutePoints = null;\n\n/**\n * Variable: absoluteOffset\n *\n * <mxPoint> that holds the absolute offset. For edges, this is the\n * absolute coordinates of the label position. For vertices, this is the\n * offset of the label relative to the top, left corner of the vertex. \n */\nmxCellState.prototype.absoluteOffset = null;\n\n/**\n * Variable: visibleSourceState\n * \n * Caches the visible source terminal state.\n */\nmxCellState.prototype.visibleSourceState = null;\n\n/**\n * Variable: visibleTargetState\n * \n * Caches the visible target terminal state.\n */\nmxCellState.prototype.visibleTargetState = null;\n\n/**\n * Variable: terminalDistance\n * \n * Caches the distance between the end points for an edge.\n */\nmxCellState.prototype.terminalDistance = 0;\n\n/**\n * Variable: length\n *\n * Caches the length of an edge.\n */\nmxCellState.prototype.length = 0;\n\n/**\n * Variable: segments\n * \n * Array of numbers that represent the cached length of each segment of the\n * edge.\n */\nmxCellState.prototype.segments = null;\n\n/**\n * Variable: shape\n * \n * Holds the <mxShape> that represents the cell graphically.\n */\nmxCellState.prototype.shape = null;\n\n/**\n * Variable: text\n * \n * Holds the <mxText> that represents the label of the cell. Thi smay be\n * null if the cell has no label.\n */\nmxCellState.prototype.text = null;\n\n/**\n * Variable: unscaledWidth\n * \n * Holds the unscaled width of the state.\n */\nmxCellState.prototype.unscaledWidth = null;\n\n/**\n * Variable: unscaledHeight\n * \n * Holds the unscaled height of the state.\n */\nmxCellState.prototype.unscaledHeight = null;\n\n/**\n * Function: getPerimeterBounds\n * \n * Returns the <mxRectangle> that should be used as the perimeter of the\n * cell.\n * \n * Parameters:\n * \n * border - Optional border to be added around the perimeter bounds.\n * bounds - Optional <mxRectangle> to be used as the initial bounds.\n */\nmxCellState.prototype.getPerimeterBounds = function(border, bounds)\n{\n\tborder = border || 0;\n\tbounds = (bounds != null) ? bounds : new mxRectangle(this.x, this.y, this.width, this.height);\n\t\n\tif (this.shape != null && this.shape.stencil != null && this.shape.stencil.aspect == 'fixed')\n\t{\n\t\tvar aspect = this.shape.stencil.computeAspect(this.style, bounds.x, bounds.y, bounds.width, bounds.height);\n\t\t\n\t\tbounds.x = aspect.x;\n\t\tbounds.y = aspect.y;\n\t\tbounds.width = this.shape.stencil.w0 * aspect.width;\n\t\tbounds.height = this.shape.stencil.h0 * aspect.height;\n\t}\n\t\n\tif (border != 0)\n\t{\n\t\tbounds.grow(border);\n\t}\n\t\n\treturn bounds;\n};\n\n/**\n * Function: setAbsoluteTerminalPoint\n * \n * Sets the first or last point in <absolutePoints> depending on isSource.\n * \n * Parameters:\n * \n * point - <mxPoint> that represents the terminal point.\n * isSource - Boolean that specifies if the first or last point should\n * be assigned.\n */\nmxCellState.prototype.setAbsoluteTerminalPoint = function(point, isSource)\n{\n\tif (isSource)\n\t{\n\t\tif (this.absolutePoints == null)\n\t\t{\n\t\t\tthis.absolutePoints = [];\n\t\t}\n\t\t\n\t\tif (this.absolutePoints.length == 0)\n\t\t{\n\t\t\tthis.absolutePoints.push(point);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.absolutePoints[0] = point;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (this.absolutePoints == null)\n\t\t{\n\t\t\tthis.absolutePoints = [];\n\t\t\tthis.absolutePoints.push(null);\n\t\t\tthis.absolutePoints.push(point);\n\t\t}\n\t\telse if (this.absolutePoints.length == 1)\n\t\t{\n\t\t\tthis.absolutePoints.push(point);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.absolutePoints[this.absolutePoints.length - 1] = point;\n\t\t}\n\t}\n};\n\n/**\n * Function: setCursor\n * \n * Sets the given cursor on the shape and text shape.\n */\nmxCellState.prototype.setCursor = function(cursor)\n{\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.setCursor(cursor);\n\t}\n\t\n\tif (this.text != null)\n\t{\n\t\tthis.text.setCursor(cursor);\n\t}\n};\n\n/**\n * Function: getVisibleTerminal\n * \n * Returns the visible source or target terminal cell.\n * \n * Parameters:\n * \n * source - Boolean that specifies if the source or target cell should be\n * returned.\n */\nmxCellState.prototype.getVisibleTerminal = function(source)\n{\n\tvar tmp = this.getVisibleTerminalState(source);\n\t\n\treturn (tmp != null) ? tmp.cell : null;\n};\n\n/**\n * Function: getVisibleTerminalState\n * \n * Returns the visible source or target terminal state.\n * \n * Parameters:\n * \n * source - Boolean that specifies if the source or target state should be\n * returned.\n */\nmxCellState.prototype.getVisibleTerminalState = function(source)\n{\n\treturn (source) ? this.visibleSourceState : this.visibleTargetState;\n};\n\n/**\n * Function: setVisibleTerminalState\n * \n * Sets the visible source or target terminal state.\n * \n * Parameters:\n * \n * terminalState - <mxCellState> that represents the terminal.\n * source - Boolean that specifies if the source or target state should be set.\n */\nmxCellState.prototype.setVisibleTerminalState = function(terminalState, source)\n{\n\tif (source)\n\t{\n\t\tthis.visibleSourceState = terminalState;\n\t}\n\telse\n\t{\n\t\tthis.visibleTargetState = terminalState;\n\t}\n};\n\n/**\n * Function: getCellBounds\n * \n * Returns the unscaled, untranslated bounds.\n */\nmxCellState.prototype.getCellBounds = function()\n{\n\treturn this.cellBounds;\n};\n\n/**\n * Function: getPaintBounds\n * \n * Returns the unscaled, untranslated paint bounds. This is the same as\n * <getCellBounds> but with a 90 degree rotation if the shape's\n * isPaintBoundsInverted returns true.\n */\nmxCellState.prototype.getPaintBounds = function()\n{\n\treturn this.paintBounds;\n};\n\n/**\n * Function: updateCachedBounds\n * \n * Updates the cellBounds and paintBounds.\n */\nmxCellState.prototype.updateCachedBounds = function()\n{\n\tvar tr = this.view.translate;\n\tvar s = this.view.scale;\n\tthis.cellBounds = new mxRectangle(this.x / s - tr.x, this.y / s - tr.y, this.width / s, this.height / s);\n\tthis.paintBounds = mxRectangle.fromRectangle(this.cellBounds);\n\t\n\tif (this.shape != null && this.shape.isPaintBoundsInverted())\n\t{\n\t\tthis.paintBounds.rotate90();\n\t}\n};\n\n/**\n * Destructor: setState\n * \n * Copies all fields from the given state to this state.\n */\nmxCellState.prototype.setState = function(state)\n{\n\tthis.view = state.view;\n\tthis.cell = state.cell;\n\tthis.style = state.style;\n\tthis.absolutePoints = state.absolutePoints;\n\tthis.origin = state.origin;\n\tthis.absoluteOffset = state.absoluteOffset;\n\tthis.boundingBox = state.boundingBox;\n\tthis.terminalDistance = state.terminalDistance;\n\tthis.segments = state.segments;\n\tthis.length = state.length;\n\tthis.x = state.x;\n\tthis.y = state.y;\n\tthis.width = state.width;\n\tthis.height = state.height;\n\tthis.unscaledWidth = state.unscaledWidth;\n\tthis.unscaledHeight = state.unscaledHeight;\n};\n\n/**\n * Function: clone\n *\n * Returns a clone of this <mxPoint>.\n */\nmxCellState.prototype.clone = function()\n{\n \tvar clone = new mxCellState(this.view, this.cell, this.style);\n\n\t// Clones the absolute points\n\tif (this.absolutePoints != null)\n\t{\n\t\tclone.absolutePoints = [];\n\t\t\n\t\tfor (var i = 0; i < this.absolutePoints.length; i++)\n\t\t{\n\t\t\tclone.absolutePoints[i] = this.absolutePoints[i].clone();\n\t\t}\n\t}\n\n\tif (this.origin != null)\n\t{\n\t\tclone.origin = this.origin.clone();\n\t}\n\n\tif (this.absoluteOffset != null)\n\t{\n\t\tclone.absoluteOffset = this.absoluteOffset.clone();\n\t}\n\n\tif (this.boundingBox != null)\n\t{\n\t\tclone.boundingBox = this.boundingBox.clone();\n\t}\n\n\tclone.terminalDistance = this.terminalDistance;\n\tclone.segments = this.segments;\n\tclone.length = this.length;\n\tclone.x = this.x;\n\tclone.y = this.y;\n\tclone.width = this.width;\n\tclone.height = this.height;\n\tclone.unscaledWidth = this.unscaledWidth;\n\tclone.unscaledHeight = this.unscaledHeight;\n\t\n\treturn clone;\n};\n\n/**\n * Destructor: destroy\n * \n * Destroys the state and all associated resources.\n */\nmxCellState.prototype.destroy = function()\n{\n\tthis.view.graph.cellRenderer.destroy(this);\n};\n\n__mxOutput.mxCellState = typeof mxCellState !== 'undefined' ? mxCellState : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraphSelectionModel\n *\n * Implements the selection model for a graph. Here is a listener that handles\n * all removed selection cells.\n * \n * (code)\n * graph.getSelectionModel().addListener(mxEvent.CHANGE, function(sender, evt)\n * {\n *   var cells = evt.getProperty('added');\n *   \n *   for (var i = 0; i < cells.length; i++)\n *   {\n *     // Handle cells[i]...\n *   }\n * });\n * (end)\n * \n * Event: mxEvent.UNDO\n * \n * Fires after the selection was changed in <changeSelection>. The\n * <code>edit</code> property contains the <mxUndoableEdit> which contains the\n * <mxSelectionChange>.\n * \n * Event: mxEvent.CHANGE\n * \n * Fires after the selection changes by executing an <mxSelectionChange>. The\n * <code>added</code> and <code>removed</code> properties contain arrays of\n * cells that have been added to or removed from the selection, respectively.\n * The names are inverted due to historic reasons. This cannot be changed.\n * \n * Constructor: mxGraphSelectionModel\n *\n * Constructs a new graph selection model for the given <mxGraph>.\n * \n * Parameters:\n * \n * graph - Reference to the enclosing <mxGraph>.\n */\nfunction mxGraphSelectionModel(graph)\n{\n\tthis.graph = graph;\n\tthis.cells = [];\n};\n\n/**\n * Extends mxEventSource.\n */\nmxGraphSelectionModel.prototype = new mxEventSource();\nmxGraphSelectionModel.prototype.constructor = mxGraphSelectionModel;\n\n/**\n * Variable: doneResource\n * \n * Specifies the resource key for the status message after a long operation.\n * If the resource for this key does not exist then the value is used as\n * the status message. Default is 'done'.\n */\nmxGraphSelectionModel.prototype.doneResource = (mxClient.language != 'none') ? 'done' : '';\n\n/**\n * Variable: updatingSelectionResource\n *\n * Specifies the resource key for the status message while the selection is\n * being updated. If the resource for this key does not exist then the\n * value is used as the status message. Default is 'updatingSelection'.\n */\nmxGraphSelectionModel.prototype.updatingSelectionResource = (mxClient.language != 'none') ? 'updatingSelection' : '';\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxGraphSelectionModel.prototype.graph = null;\n\n/**\n * Variable: singleSelection\n *\n * Specifies if only one selected item at a time is allowed.\n * Default is false.\n */\nmxGraphSelectionModel.prototype.singleSelection = false;\n\n/**\n * Function: isSingleSelection\n *\n * Returns <singleSelection> as a boolean.\n */\nmxGraphSelectionModel.prototype.isSingleSelection = function()\n{\n\treturn this.singleSelection;\n};\n\n/**\n * Function: setSingleSelection\n *\n * Sets the <singleSelection> flag.\n * \n * Parameters:\n * \n * singleSelection - Boolean that specifies the new value for\n * <singleSelection>.\n */\nmxGraphSelectionModel.prototype.setSingleSelection = function(singleSelection)\n{\n\tthis.singleSelection = singleSelection;\n};\n\n/**\n * Function: isSelected\n *\n * Returns true if the given <mxCell> is selected.\n */\nmxGraphSelectionModel.prototype.isSelected = function(cell)\n{\n\tif (cell != null)\n\t{\n\t\treturn mxUtils.indexOf(this.cells, cell) >= 0;\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: isEmpty\n *\n * Returns true if no cells are currently selected.\n */\nmxGraphSelectionModel.prototype.isEmpty = function()\n{\n\treturn this.cells.length == 0;\n};\n\n/**\n * Function: clear\n *\n * Clears the selection and fires a <change> event if the selection was not\n * empty.\n */\nmxGraphSelectionModel.prototype.clear = function()\n{\n\tthis.changeSelection(null, this.cells);\n};\n\n/**\n * Function: setCell\n *\n * Selects the specified <mxCell> using <setCells>.\n * \n * Parameters:\n * \n * cell - <mxCell> to be selected.\n */\nmxGraphSelectionModel.prototype.setCell = function(cell)\n{\n\tif (cell != null)\n\t{\n\t\tthis.setCells([cell]);\n\t}\n};\n\n/**\n * Function: setCells\n *\n * Selects the given array of <mxCells> and fires a <change> event.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be selected.\n */\nmxGraphSelectionModel.prototype.setCells = function(cells)\n{\n\tif (cells != null)\n\t{\n\t\tif (this.singleSelection)\n\t\t{\n\t\t\tcells = [this.getFirstSelectableCell(cells)];\n\t\t}\n\t\n\t\tvar tmp = [];\n\t\t\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (this.graph.isCellSelectable(cells[i]))\n\t\t\t{\n\t\t\t\ttmp.push(cells[i]);\n\t\t\t}\t\n\t\t}\n\n\t\tthis.changeSelection(tmp, this.cells);\n\t}\n};\n\n/**\n * Function: getFirstSelectableCell\n *\n * Returns the first selectable cell in the given array of cells.\n */\nmxGraphSelectionModel.prototype.getFirstSelectableCell = function(cells)\n{\n\tif (cells != null)\n\t{\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (this.graph.isCellSelectable(cells[i]))\n\t\t\t{\n\t\t\t\treturn cells[i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: addCell\n * \n * Adds the given <mxCell> to the selection and fires a <select> event.\n * \n * Parameters:\n * \n * cell - <mxCell> to add to the selection.\n */\nmxGraphSelectionModel.prototype.addCell = function(cell)\n{\n\tif (cell != null)\n\t{\n\t\tthis.addCells([cell]);\n\t}\n};\n\n/**\n * Function: addCells\n * \n * Adds the given array of <mxCells> to the selection and fires a <select>\n * event.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to add to the selection.\n */\nmxGraphSelectionModel.prototype.addCells = function(cells)\n{\n\tif (cells != null)\n\t{\n\t\tvar remove = null;\n\t\t\n\t\tif (this.singleSelection)\n\t\t{\n\t\t\tremove = this.cells;\n\t\t\tcells = [this.getFirstSelectableCell(cells)];\n\t\t}\n\n\t\tvar tmp = [];\n\t\t\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (!this.isSelected(cells[i]) &&\n\t\t\t\tthis.graph.isCellSelectable(cells[i]))\n\t\t\t{\n\t\t\t\ttmp.push(cells[i]);\n\t\t\t}\t\n\t\t}\n\n\t\tthis.changeSelection(tmp, remove);\n\t}\n};\n\n/**\n * Function: removeCell\n *\n * Removes the specified <mxCell> from the selection and fires a <select>\n * event for the remaining cells.\n * \n * Parameters:\n * \n * cell - <mxCell> to remove from the selection.\n */\nmxGraphSelectionModel.prototype.removeCell = function(cell)\n{\n\tif (cell != null)\n\t{\n\t\tthis.removeCells([cell]);\n\t}\n};\n\n/**\n * Function: removeCells\n */\nmxGraphSelectionModel.prototype.removeCells = function(cells)\n{\n\tif (cells != null)\n\t{\n\t\tvar tmp = [];\n\t\t\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (this.isSelected(cells[i]))\n\t\t\t{\n\t\t\t\ttmp.push(cells[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.changeSelection(null, tmp);\t\n\t}\n};\n\n/**\n * Function: changeSelection\n *\n * Adds/removes the specified arrays of <mxCell> to/from the selection.\n * \n * Parameters:\n * \n * added - Array of <mxCell> to add to the selection.\n * remove - Array of <mxCell> to remove from the selection.\n */\nmxGraphSelectionModel.prototype.changeSelection = function(added, removed)\n{\n\tif ((added != null &&\n\t\tadded.length > 0 &&\n\t\tadded[0] != null) ||\n\t\t(removed != null &&\n\t\tremoved.length > 0 &&\n\t\tremoved[0] != null))\n\t{\n\t\tvar change = new mxSelectionChange(this, added, removed);\n\t\tchange.execute();\n\t\tvar edit = new mxUndoableEdit(this, false);\n\t\tedit.add(change);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.UNDO, 'edit', edit));\n\t}\n};\n\n/**\n * Function: cellAdded\n *\n * Inner callback to add the specified <mxCell> to the selection. No event\n * is fired in this implementation.\n * \n * Paramters:\n * \n * cell - <mxCell> to add to the selection.\n */\nmxGraphSelectionModel.prototype.cellAdded = function(cell)\n{\n\tif (cell != null &&\n\t\t!this.isSelected(cell))\n\t{\n\t\tthis.cells.push(cell);\n\t}\n};\n\n/**\n * Function: cellRemoved\n *\n * Inner callback to remove the specified <mxCell> from the selection. No\n * event is fired in this implementation.\n * \n * Parameters:\n * \n * cell - <mxCell> to remove from the selection.\n */\nmxGraphSelectionModel.prototype.cellRemoved = function(cell)\n{\n\tif (cell != null)\n\t{\n\t\tvar index = mxUtils.indexOf(this.cells, cell);\n\t\t\n\t\tif (index >= 0)\n\t\t{\n\t\t\tthis.cells.splice(index, 1);\n\t\t}\n\t}\n};\n\n/**\n * Class: mxSelectionChange\n *\n * Action to change the current root in a view.\n *\n * Constructor: mxCurrentRootChange\n *\n * Constructs a change of the current root in the given view.\n */\nfunction mxSelectionChange(selectionModel, added, removed)\n{\n\tthis.selectionModel = selectionModel;\n\tthis.added = (added != null) ? added.slice() : null;\n\tthis.removed = (removed != null) ? removed.slice() : null;\n};\n\n/**\n * Function: execute\n *\n * Changes the current root of the view.\n */\nmxSelectionChange.prototype.execute = function()\n{\n\tvar t0 = mxLog.enter('mxSelectionChange.execute');\n\twindow.status = mxResources.get(\n\t\tthis.selectionModel.updatingSelectionResource) ||\n\t\tthis.selectionModel.updatingSelectionResource;\n\n\tif (this.removed != null)\n\t{\n\t\tfor (var i = 0; i < this.removed.length; i++)\n\t\t{\n\t\t\tthis.selectionModel.cellRemoved(this.removed[i]);\n\t\t}\n\t}\n\n\tif (this.added != null)\n\t{\n\t\tfor (var i = 0; i < this.added.length; i++)\n\t\t{\n\t\t\tthis.selectionModel.cellAdded(this.added[i]);\n\t\t}\n\t}\n\t\n\tvar tmp = this.added;\n\tthis.added = this.removed;\n\tthis.removed = tmp;\n\n\twindow.status = mxResources.get(this.selectionModel.doneResource) ||\n\t\tthis.selectionModel.doneResource;\n\tmxLog.leave('mxSelectionChange.execute', t0);\n\t\n\tthis.selectionModel.fireEvent(new mxEventObject(mxEvent.CHANGE,\n\t\t\t'added', this.added, 'removed', this.removed));\n};\n\n__mxOutput.mxGraphSelectionModel = typeof mxGraphSelectionModel !== 'undefined' ? mxGraphSelectionModel : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCellEditor\n *\n * In-place editor for the graph. To control this editor, use\n * <mxGraph.invokesStopCellEditing>, <mxGraph.enterStopsCellEditing> and\n * <mxGraph.escapeEnabled>. If <mxGraph.enterStopsCellEditing> is true then\n * ctrl-enter or shift-enter can be used to create a linefeed. The F2 and\n * escape keys can always be used to stop editing.\n * \n * To customize the location of the textbox in the graph, override\n * <getEditorBounds> as follows:\n * \n * (code)\n * graph.cellEditor.getEditorBounds = function(state)\n * {\n *   var result = mxCellEditor.prototype.getEditorBounds.apply(this, arguments);\n *   \n *   if (this.graph.getModel().isEdge(state.cell))\n *   {\n *     result.x = state.getCenterX() - result.width / 2;\n *     result.y = state.getCenterY() - result.height / 2;\n *   }\n *   \n *   return result;\n * };\n * (end)\n * \n * Note that this hook is only called if <autoSize> is false. If <autoSize> is true,\n * then <mxShape.getLabelBounds> is used to compute the current bounds of the textbox.\n * \n * The textarea uses the mxCellEditor CSS class. You can modify this class in\n * your custom CSS. Note: You should modify the CSS after loading the client\n * in the page.\n *\n * Example:\n * \n * To only allow numeric input in the in-place editor, use the following code.\n *\n * (code)\n * var text = graph.cellEditor.textarea;\n * \n * mxEvent.addListener(text, 'keydown', function (evt)\n * {\n *   if (!(evt.keyCode >= 48 && evt.keyCode <= 57) &&\n *       !(evt.keyCode >= 96 && evt.keyCode <= 105))\n *   {\n *     mxEvent.consume(evt);\n *   }\n * }); \n * (end)\n * \n * Placeholder:\n * \n * To implement a placeholder for cells without a label, use the\n * <emptyLabelText> variable.\n * \n * Resize in Chrome:\n * \n * Resize of the textarea is disabled by default. If you want to enable\n * this feature extend <init> and set this.textarea.style.resize = ''.\n * \n * To start editing on a key press event, the container of the graph\n * should have focus or a focusable parent should be used to add the\n * key press handler as follows.\n * \n * (code)\n * mxEvent.addListener(graph.container, 'keypress', mxUtils.bind(this, function(evt)\n * {\n *   if (!graph.isEditing() && !graph.isSelectionEmpty() && evt.which !== 0 &&\n *       !mxEvent.isAltDown(evt) && !mxEvent.isControlDown(evt) && !mxEvent.isMetaDown(evt))\n *   {\n *     graph.startEditing();\n *     \n *     if (mxClient.IS_FF)\n *     {\n *       graph.cellEditor.textarea.value = String.fromCharCode(evt.which);\n *     }\n *   }\n * }));\n * (end)\n * \n * To allow focus for a DIV, and hence to receive key press events, some browsers\n * require it to have a valid tabindex attribute. In this case the following\n * code may be used to keep the container focused.\n * \n * (code)\n * var graphFireMouseEvent = graph.fireMouseEvent;\n * graph.fireMouseEvent = function(evtName, me, sender)\n * {\n *   if (evtName == mxEvent.MOUSE_DOWN)\n *   {\n *     this.container.focus();\n *   }\n *   \n *   graphFireMouseEvent.apply(this, arguments);\n * };\n * (end)\n *\n * Constructor: mxCellEditor\n *\n * Constructs a new in-place editor for the specified graph.\n * \n * Parameters:\n * \n * graph - Reference to the enclosing <mxGraph>.\n */\nfunction mxCellEditor(graph)\n{\n\tthis.graph = graph;\n\t\n\t// Stops editing after zoom changes\n\tthis.zoomHandler = mxUtils.bind(this, function()\n\t{\n\t\tif (this.graph.isEditing())\n\t\t{\n\t\t\tthis.resize();\n\t\t}\n\t});\n\t\n\tthis.graph.view.addListener(mxEvent.SCALE, this.zoomHandler);\n\tthis.graph.view.addListener(mxEvent.SCALE_AND_TRANSLATE, this.zoomHandler);\n\t\n\t// Adds handling of deleted cells while editing\n\tthis.changeHandler = mxUtils.bind(this, function(sender)\n\t{\n\t\tif (this.editingCell != null && this.graph.getView().getState(this.editingCell) == null)\n\t\t{\n\t\t\tthis.stopEditing(true);\n\t\t}\n\t});\n\n\tthis.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);\n};\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxCellEditor.prototype.graph = null;\n\n/**\n * Variable: textarea\n *\n * Holds the DIV that is used for text editing. Note that this may be null before the first\n * edit. Instantiated in <init>.\n */\nmxCellEditor.prototype.textarea = null;\n\n/**\n * Variable: editingCell\n * \n * Reference to the <mxCell> that is currently being edited.\n */\nmxCellEditor.prototype.editingCell = null;\n\n/**\n * Variable: trigger\n * \n * Reference to the event that was used to start editing.\n */\nmxCellEditor.prototype.trigger = null;\n\n/**\n * Variable: modified\n * \n * Specifies if the label has been modified.\n */\nmxCellEditor.prototype.modified = false;\n\n/**\n * Variable: autoSize\n * \n * Specifies if the textarea should be resized while the text is being edited.\n * Default is true.\n */\nmxCellEditor.prototype.autoSize = true;\n\n/**\n * Variable: selectText\n * \n * Specifies if the text should be selected when editing starts. Default is\n * true.\n */\nmxCellEditor.prototype.selectText = true;\n\n/**\n * Variable: emptyLabelText\n * \n * Text to be displayed for empty labels. Default is '' or '<br>' in Firefox as\n * a workaround for the missing cursor bug for empty content editable. This can\n * be set to eg. \"[Type Here]\" to easier visualize editing of empty labels. The\n * value is only displayed before the first keystroke and is never used as the\n * actual editing value.\n */\nmxCellEditor.prototype.emptyLabelText = (mxClient.IS_FF) ? '<br>' : '';\n\n/**\n * Variable: escapeCancelsEditing\n * \n * If true, pressing the escape key will stop editing and not accept the new\n * value. Change this to false to accept the new value on escape, and cancel\n * editing on Shift+Escape instead. Default is true.\n */\nmxCellEditor.prototype.escapeCancelsEditing = true;\n\n/**\n * Variable: textNode\n * \n * Reference to the label DOM node that has been hidden.\n */\nmxCellEditor.prototype.textNode = '';\n\n/**\n * Variable: zIndex\n * \n * Specifies the zIndex for the textarea. Default is 5.\n */\nmxCellEditor.prototype.zIndex = 5;\n\n/**\n * Variable: minResize\n * \n * Defines the minimum width and height to be used in <resize>. Default is 0x20px.\n */\nmxCellEditor.prototype.minResize = new mxRectangle(0, 20);\n\n/**\n * Variable: wordWrapPadding\n * \n * Correction factor for word wrapping width. Default is 2 in quirks, 0 in IE\n * 11 and 1 in all other browsers and modes.\n */\nmxCellEditor.prototype.wordWrapPadding = (mxClient.IS_QUIRKS) ? 2 : (!mxClient.IS_IE11) ? 1 : 0;\n\n/**\n * Variable: blurEnabled\n *\n * If <focusLost> should be called if <textarea> loses the focus. Default is false.\n */\nmxCellEditor.prototype.blurEnabled = false;\n\n/**\n * Variable: initialValue\n * \n * Holds the initial editing value to check if the current value was modified.\n */\nmxCellEditor.prototype.initialValue = null;\n\n/**\n * Variable: align\n * \n * Holds the current temporary horizontal alignment for the cell style. If this\n * is modified then the current text alignment is changed and the cell style is\n * updated when the value is applied.\n */\nmxCellEditor.prototype.align = null;\n\n/**\n * Function: init\n *\n * Creates the <textarea> and installs the event listeners. The key handler\n * updates the <modified> state.\n */\nmxCellEditor.prototype.init = function ()\n{\n\tthis.textarea = document.createElement('div');\n\tthis.textarea.className = 'mxCellEditor mxPlainTextEditor';\n\tthis.textarea.contentEditable = true;\n\t\n\t// Workaround for selection outside of DIV if height is 0\n\tif (mxClient.IS_GC)\n\t{\n\t\tthis.textarea.style.minHeight = '1em';\n\t}\n\n\tthis.textarea.style.position = ((this.isLegacyEditor())) ? 'absolute' : 'relative';\n\tthis.installListeners(this.textarea);\n};\n\n/**\n * Function: applyValue\n * \n * Called in <stopEditing> if cancel is false to invoke <mxGraph.labelChanged>.\n */\nmxCellEditor.prototype.applyValue = function(state, value)\n{\n\tthis.graph.labelChanged(state.cell, value, this.trigger);\n};\n\n/**\n * Function: setAlign\n * \n * Sets the temporary horizontal alignment for the current editing session.\n */\nmxCellEditor.prototype.setAlign = function (align)\n{\n\tif (this.textarea != null)\n\t{\n\t\tthis.textarea.style.textAlign = align;\n\t}\n\t\n\tthis.align = align;\n\tthis.resize();\n};\n\n/**\n * Function: getInitialValue\n * \n * Gets the initial editing value for the given cell.\n */\nmxCellEditor.prototype.getInitialValue = function(state, trigger)\n{\n\tvar result = mxUtils.htmlEntities(this.graph.getEditingValue(state.cell, trigger), false);\n\t\n    // Workaround for trailing line breaks being ignored in the editor\n\tif (!mxClient.IS_QUIRKS && document.documentMode != 8 && document.documentMode != 9 &&\n\t\tdocument.documentMode != 10)\n\t{\n\t\tresult = mxUtils.replaceTrailingNewlines(result, '<div><br></div>');\n\t}\n    \n    return result.replace(/\\n/g, '<br>');\n};\n\n/**\n * Function: getCurrentValue\n * \n * Returns the current editing value.\n */\nmxCellEditor.prototype.getCurrentValue = function(state)\n{\n\treturn mxUtils.extractTextWithWhitespace(this.textarea.childNodes);\n};\n\n/**\n * Function: isCancelEditingKeyEvent\n * \n * Returns true if <escapeCancelsEditing> is true and shift, control and meta\n * are not pressed.\n */\nmxCellEditor.prototype.isCancelEditingKeyEvent = function(evt)\n{\n\treturn this.escapeCancelsEditing || mxEvent.isShiftDown(evt) || mxEvent.isControlDown(evt) || mxEvent.isMetaDown(evt);\n};\n\n/**\n * Function: installListeners\n * \n * Installs listeners for focus, change and standard key event handling.\n */\nmxCellEditor.prototype.installListeners = function(elt)\n{\n\t// Applies value if text is dragged\n\t// LATER: Gesture mouse events ignored for starting move\n\tmxEvent.addListener(elt, 'dragstart', mxUtils.bind(this, function(evt)\n\t{\n\t\tthis.graph.stopEditing(false);\n\t\tmxEvent.consume(evt);\n\t}));\n\n\t// Applies value if focus is lost\n\tmxEvent.addListener(elt, 'blur', mxUtils.bind(this, function(evt)\n\t{\n\t\tif (this.blurEnabled)\n\t\t{\n\t\t\tthis.focusLost(evt);\n\t\t}\n\t}));\n\n\t// Updates modified state and handles placeholder text\n\tmxEvent.addListener(elt, 'keydown', mxUtils.bind(this, function(evt)\n\t{\n\t\tif (!mxEvent.isConsumed(evt))\n\t\t{\n\t\t\tif (this.isStopEditingEvent(evt))\n\t\t\t{\n\t\t\t\tthis.graph.stopEditing(false);\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t}\n\t\t\telse if (evt.keyCode == 27 /* Escape */)\n\t\t\t{\n\t\t\t\tthis.graph.stopEditing(this.isCancelEditingKeyEvent(evt));\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t}\n\t\t}\n\t}));\n\n\t// Keypress only fires if printable key was pressed and handles removing the empty placeholder\n\tvar keypressHandler = mxUtils.bind(this, function(evt)\n\t{\n\t\tif (this.editingCell != null)\n\t\t{\n\t\t\t// Clears the initial empty label on the first keystroke\n\t\t\t// and workaround for FF which fires keypress for delete and backspace\n\t\t\tif (this.clearOnChange && elt.innerHTML == this.getEmptyLabelText() &&\n\t\t\t\t(!mxClient.IS_FF || (evt.keyCode != 8 /* Backspace */ && evt.keyCode != 46 /* Delete */)))\n\t\t\t{\n\t\t\t\tthis.clearOnChange = false;\n\t\t\t\telt.innerHTML = '';\n\t\t\t}\n\t\t}\n\t});\n\n\tmxEvent.addListener(elt, 'keypress', keypressHandler);\n\tmxEvent.addListener(elt, 'paste', keypressHandler);\n\t\n\t// Handler for updating the empty label text value after a change\n\tvar keyupHandler = mxUtils.bind(this, function(evt)\n\t{\n\t\tif (this.editingCell != null)\n\t\t{\n\t\t\t// Uses an optional text value for sempty labels which is cleared\n\t\t\t// when the first keystroke appears. This makes it easier to see\n\t\t\t// that a label is being edited even if the label is empty.\n\t\t\t// In Safari and FF, an empty text is represented by <BR> which isn't enough to force a valid size\n\t\t\tif (this.textarea.innerHTML.length == 0 || this.textarea.innerHTML == '<br>')\n\t\t\t{\n\t\t\t\tthis.textarea.innerHTML = this.getEmptyLabelText();\n\t\t\t\tthis.clearOnChange = this.textarea.innerHTML.length > 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.clearOnChange = false;\n\t\t\t}\n\t\t}\n\t});\n\n\tmxEvent.addListener(elt, (!mxClient.IS_IE11 && !mxClient.IS_IE) ? 'input' : 'keyup', keyupHandler);\n\tmxEvent.addListener(elt, 'cut', keyupHandler);\n\tmxEvent.addListener(elt, 'paste', keyupHandler);\n\n\t// Adds automatic resizing of the textbox while typing using input, keyup and/or DOM change events\n\tvar evtName = (!mxClient.IS_IE11 && !mxClient.IS_IE) ? 'input' : 'keydown';\n\t\n\tvar resizeHandler = mxUtils.bind(this, function(evt)\n\t{\n\t\tif (this.editingCell != null && this.autoSize && !mxEvent.isConsumed(evt))\n\t\t{\n\t\t\t// Asynchronous is needed for keydown and shows better results for input events overall\n\t\t\t// (ie non-blocking and cases where the offsetWidth/-Height was wrong at this time)\n\t\t\tif (this.resizeThread != null)\n\t\t\t{\n\t\t\t\twindow.clearTimeout(this.resizeThread);\n\t\t\t}\n\t\t\t\n\t\t\tthis.resizeThread = window.setTimeout(mxUtils.bind(this, function()\n\t\t\t{\n\t\t\t\tthis.resizeThread = null;\n\t\t\t\tthis.resize();\n\t\t\t}), 0);\n\t\t}\n\t});\n\t\n\tmxEvent.addListener(elt, evtName, resizeHandler);\n\tmxEvent.addListener(window, 'resize', resizeHandler);\n\n\tif (document.documentMode >= 9)\n\t{\n\t\tmxEvent.addListener(elt, 'DOMNodeRemoved', resizeHandler);\n\t\tmxEvent.addListener(elt, 'DOMNodeInserted', resizeHandler);\n\t}\n\telse\n\t{\n\t\tmxEvent.addListener(elt, 'cut', resizeHandler);\n\t\tmxEvent.addListener(elt, 'paste', resizeHandler);\n\t}\n};\n\n/**\n * Function: isStopEditingEvent\n * \n * Returns true if the given keydown event should stop cell editing. This\n * returns true if F2 is pressed of if <mxGraph.enterStopsCellEditing> is true\n * and enter is pressed without control or shift.\n */\nmxCellEditor.prototype.isStopEditingEvent = function(evt)\n{\n\treturn evt.keyCode == 113 /* F2 */ || (this.graph.isEnterStopsCellEditing() &&\n\t\tevt.keyCode == 13 /* Enter */ && !mxEvent.isControlDown(evt) &&\n\t\t!mxEvent.isShiftDown(evt));\n};\n\n/**\n * Function: isEventSource\n * \n * Returns true if this editor is the source for the given native event.\n */\nmxCellEditor.prototype.isEventSource = function(evt)\n{\n\treturn mxEvent.getSource(evt) == this.textarea;\n};\n\n/**\n * Function: resize\n * \n * Returns <modified>.\n */\nmxCellEditor.prototype.resize = function()\n{\n\tvar state = this.graph.getView().getState(this.editingCell);\n\t\n\tif (state == null)\n\t{\n\t\tthis.stopEditing(true);\n\t}\n\telse if (this.textarea != null)\n\t{\n\t\tvar isEdge = this.graph.getModel().isEdge(state.cell);\n \t\tvar scale = this.graph.getView().scale;\n \t\tvar m = null;\n\t\t\n\t\tif (!this.autoSize || (state.style[mxConstants.STYLE_OVERFLOW] == 'fill'))\n\t\t{\n\t\t\t// Specifies the bounds of the editor box\n\t\t\tthis.bounds = this.getEditorBounds(state);\n\t\t\tthis.textarea.style.width = Math.round(this.bounds.width / scale) + 'px';\n\t\t\tthis.textarea.style.height = Math.round(this.bounds.height / scale) + 'px';\n\t\t\t\n\t\t\t// FIXME: Offset when scaled\n\t\t\tif (document.documentMode == 8 || mxClient.IS_QUIRKS)\n\t\t\t{\n\t\t\t\tthis.textarea.style.left = Math.round(this.bounds.x) + 'px';\n\t\t\t\tthis.textarea.style.top = Math.round(this.bounds.y) + 'px';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.textarea.style.left = Math.max(0, Math.round(this.bounds.x + 1)) + 'px';\n\t\t\t\tthis.textarea.style.top = Math.max(0, Math.round(this.bounds.y + 1)) + 'px';\n\t\t\t}\n\t\t\t\n\t\t\t// Installs native word wrapping and avoids word wrap for empty label placeholder\n\t\t\tif (this.graph.isWrapping(state.cell) && (this.bounds.width >= 2 || this.bounds.height >= 2) &&\n\t\t\t\tthis.textarea.innerHTML != this.getEmptyLabelText())\n\t\t\t{\n\t\t\t\tthis.textarea.style.wordWrap = mxConstants.WORD_WRAP;\n\t\t\t\tthis.textarea.style.whiteSpace = 'normal';\n\t\t\t\t\n\t\t\t\tif (state.style[mxConstants.STYLE_OVERFLOW] != 'fill')\n\t\t\t\t{\n\t\t\t\t\tthis.textarea.style.width = Math.round(this.bounds.width / scale) + this.wordWrapPadding + 'px';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.textarea.style.whiteSpace = 'nowrap';\n\t\t\t\t\n\t\t\t\tif (state.style[mxConstants.STYLE_OVERFLOW] != 'fill')\n\t\t\t\t{\n\t\t\t\t\tthis.textarea.style.width = '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t \t{\n\t \t\tvar lw = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);\n\t\t\tm = (state.text != null && this.align == null) ? state.text.margin : null;\n\t\t\t\n\t\t\tif (m == null)\n\t\t\t{\n\t\t\t\tm = mxUtils.getAlignmentAsPoint(this.align || mxUtils.getValue(state.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_CENTER),\n\t\t\t\t\t\tmxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE));\n\t\t\t}\n\t\t\t\n\t \t\tif (isEdge)\n\t\t\t{\n\t\t\t\tthis.bounds = new mxRectangle(state.absoluteOffset.x, state.absoluteOffset.y, 0, 0);\n\t\t\t\t\n\t\t\t\tif (lw != null)\n\t\t\t \t{\n\t\t\t\t\tvar tmp = (parseFloat(lw) + 2) * scale;\n\t\t\t\t\tthis.bounds.width = tmp;\n\t\t\t\t\tthis.bounds.x += m.x * tmp;\n\t\t\t \t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar bds = mxRectangle.fromRectangle(state);\n\t\t\t\tvar hpos = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);\n\t\t\t\tvar vpos = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);\n\n\t\t\t\tbds = (state.shape != null && hpos == mxConstants.ALIGN_CENTER && vpos == mxConstants.ALIGN_MIDDLE) ? state.shape.getLabelBounds(bds) : bds;\n\t\t\t \t\n\t\t\t \tif (lw != null)\n\t\t\t \t{\n\t\t\t \t\tbds.width = parseFloat(lw) * scale;\n\t\t\t \t}\n\t\t\t \t\n\t\t\t \tif (!state.view.graph.cellRenderer.legacySpacing || state.style[mxConstants.STYLE_OVERFLOW] != 'width')\n\t\t\t \t{\n\t\t\t\t\tvar spacing = parseInt(state.style[mxConstants.STYLE_SPACING] || 2) * scale;\n\t\t\t\t\tvar spacingTop = (parseInt(state.style[mxConstants.STYLE_SPACING_TOP] || 0) + mxText.prototype.baseSpacingTop) * scale + spacing;\n\t\t\t\t\tvar spacingRight = (parseInt(state.style[mxConstants.STYLE_SPACING_RIGHT] || 0) + mxText.prototype.baseSpacingRight) * scale + spacing;\n\t\t\t\t\tvar spacingBottom = (parseInt(state.style[mxConstants.STYLE_SPACING_BOTTOM] || 0) + mxText.prototype.baseSpacingBottom) * scale + spacing;\n\t\t\t\t\tvar spacingLeft = (parseInt(state.style[mxConstants.STYLE_SPACING_LEFT] || 0) + mxText.prototype.baseSpacingLeft) * scale + spacing;\n\t\t\t\t\t\n\t\t\t\t\tvar hpos = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);\n\t\t\t\t\tvar vpos = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);\n\n\t\t\t\t\tbds = new mxRectangle(bds.x + spacingLeft, bds.y + spacingTop,\n\t\t\t\t\t\tbds.width - ((hpos == mxConstants.ALIGN_CENTER && lw == null) ? (spacingLeft + spacingRight) : 0),\n\t\t\t\t\t\tbds.height - ((vpos == mxConstants.ALIGN_MIDDLE) ? (spacingTop + spacingBottom) : 0));\n\t\t\t \t}\n\n\t\t\t\tthis.bounds = new mxRectangle(bds.x + state.absoluteOffset.x, bds.y + state.absoluteOffset.y, bds.width, bds.height);\n\t\t\t}\n\n\t\t\t// Needed for word wrap inside text blocks with oversize lines to match the final result where\n\t \t\t// the width of the longest line is used as the reference for text alignment in the cell\n\t \t\t// TODO: Fix word wrapping preview for edge labels in helloworld.html\n\t\t\tif (this.graph.isWrapping(state.cell) && (this.bounds.width >= 2 || this.bounds.height >= 2) &&\n\t\t\t\tthis.textarea.innerHTML != this.getEmptyLabelText())\n\t\t\t{\n\t\t\t\tthis.textarea.style.wordWrap = mxConstants.WORD_WRAP;\n\t\t\t\tthis.textarea.style.whiteSpace = 'normal';\n\t\t\t\t\n\t\t \t\t// Forces automatic reflow if text is removed from an oversize label and normal word wrap\n\t\t\t\tvar tmp = Math.round(this.bounds.width / ((document.documentMode == 8) ? scale : scale)) + this.wordWrapPadding;\n\n\t\t\t\tif (this.textarea.style.position != 'relative')\n\t\t\t\t{\n\t\t\t\t\tthis.textarea.style.width = tmp + 'px';\n\t\t\t\t\t\n\t\t\t\t\tif (this.textarea.scrollWidth > tmp)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.textarea.style.width = this.textarea.scrollWidth + 'px';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.textarea.style.maxWidth = tmp + 'px';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// KNOWN: Trailing cursor in IE9 quirks mode is not visible\n\t\t\t\tthis.textarea.style.whiteSpace = 'nowrap';\n\t\t\t\tthis.textarea.style.width = '';\n\t\t\t}\n\t\t\t\n\t\t\t// LATER: Keep in visible area, add fine tuning for pixel precision\n\t\t\t// Workaround for wrong measuring in IE8 standards\n\t\t\tif (document.documentMode == 8)\n\t\t\t{\n\t\t\t\tthis.textarea.style.zoom = '1';\n\t\t\t\tthis.textarea.style.height = 'auto';\n\t\t\t}\n\t\t\t\n\t\t\tvar ow = this.textarea.scrollWidth;\n\t\t\tvar oh = this.textarea.scrollHeight;\n\t\t\t\n\t\t\t// TODO: Update CSS width and height if smaller than minResize or remove minResize\n\t\t\t//if (this.minResize != null)\n\t\t\t//{\n\t\t\t//\tow = Math.max(ow, this.minResize.width);\n\t\t\t//\toh = Math.max(oh, this.minResize.height);\n\t\t\t//}\n\t\t\t\n\t\t\t// LATER: Keep in visible area, add fine tuning for pixel precision\n\t\t\tif (document.documentMode == 8)\n\t\t\t{\n\t\t\t\t// LATER: Scaled wrapping and position is wrong in IE8\n\t\t\t\tthis.textarea.style.left = Math.max(0, Math.ceil((this.bounds.x - m.x * (this.bounds.width - (ow + 1) * scale) + ow * (scale - 1) * 0 + (m.x + 0.5) * 2) / scale)) + 'px';\n\t\t\t\tthis.textarea.style.top = Math.max(0, Math.ceil((this.bounds.y - m.y * (this.bounds.height - (oh + 0.5) * scale) + oh * (scale - 1) * 0 + Math.abs(m.y + 0.5) * 1) / scale)) + 'px';\n\t\t\t\t// Workaround for wrong event handling width and height\n\t\t\t\tthis.textarea.style.width = Math.round(ow * scale) + 'px';\n\t\t\t\tthis.textarea.style.height = Math.round(oh * scale) + 'px';\n\t\t\t}\n\t\t\telse if (mxClient.IS_QUIRKS)\n\t\t\t{\t\t\t\n\t\t\t\tthis.textarea.style.left = Math.max(0, Math.ceil(this.bounds.x - m.x * (this.bounds.width - (ow + 1) * scale) + ow * (scale - 1) * 0 + (m.x + 0.5) * 2)) + 'px';\n\t\t\t\tthis.textarea.style.top = Math.max(0, Math.ceil(this.bounds.y - m.y * (this.bounds.height - (oh + 0.5) * scale) + oh * (scale - 1) * 0 + Math.abs(m.y + 0.5) * 1)) + 'px';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.textarea.style.left = Math.max(0, Math.round(this.bounds.x - m.x * (this.bounds.width - 2)) + 1) + 'px';\n\t\t\t\tthis.textarea.style.top = Math.max(0, Math.round(this.bounds.y - m.y * (this.bounds.height - 4) + ((m.y == -1) ? 3 : 0)) + 1) + 'px';\n\t\t\t}\n\t \t}\n\n\t\tif (mxClient.IS_VML)\n\t\t{\n\t\t\tthis.textarea.style.zoom = scale;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmxUtils.setPrefixedStyle(this.textarea.style, 'transformOrigin', '0px 0px');\n\t\t\tmxUtils.setPrefixedStyle(this.textarea.style, 'transform',\n\t\t\t\t'scale(' + scale + ',' + scale + ')' + ((m == null) ? '' :\n\t\t\t\t' translate(' + (m.x * 100) + '%,' + (m.y * 100) + '%)'));\n\t\t}\n\t}\n};\n\n/**\n * Function: focusLost\n *\n * Called if the textarea has lost focus.\n */\nmxCellEditor.prototype.focusLost = function()\n{\n\tthis.stopEditing(!this.graph.isInvokesStopCellEditing());\n};\n\n/**\n * Function: getBackgroundColor\n * \n * Returns the background color for the in-place editor. This implementation\n * always returns null.\n */\nmxCellEditor.prototype.getBackgroundColor = function(state)\n{\n\treturn null;\n};\n\n/**\n * Function: isLegacyEditor\n * \n * Returns true if max-width is not supported or if the SVG root element in\n * in the graph does not have CSS position absolute. In these cases the text\n * editor must use CSS position absolute to avoid an offset but it will have\n * a less accurate line wrapping width during the text editing preview. This\n * implementation returns true for IE8- and quirks mode or if the CSS position\n * of the SVG element is not absolute.\n */\nmxCellEditor.prototype.isLegacyEditor = function()\n{\n\tif (mxClient.IS_VML)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tvar absoluteRoot = false;\n\t\t\n\t\tif (mxClient.IS_SVG)\n\t\t{\n\t\t\tvar root = this.graph.view.getDrawPane().ownerSVGElement;\n\t\t\t\n\t\t\tif (root != null)\n\t\t\t{\n\t\t\t\tvar css = mxUtils.getCurrentStyle(root);\n\t\t\t\t\n\t\t\t\tif (css != null)\n\t\t\t\t{\t\t\t\t\n\t\t\t\t\tabsoluteRoot = css.position == 'absolute';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn !absoluteRoot;\n\t}\n};\n\n/**\n * Function: startEditing\n *\n * Starts the editor for the given cell.\n * \n * Parameters:\n * \n * cell - <mxCell> to start editing.\n * trigger - Optional mouse event that triggered the editor.\n */\nmxCellEditor.prototype.startEditing = function(cell, trigger)\n{\n\tthis.stopEditing(true);\n\tthis.align = null;\n\t\n\t// Creates new textarea instance\n\tif (this.textarea == null)\n\t{\n\t\tthis.init();\n\t}\n\t\n\tif (this.graph.tooltipHandler != null)\n\t{\n\t\tthis.graph.tooltipHandler.hideTooltip();\n\t}\n\t\n\tvar state = this.graph.getView().getState(cell);\n\t\n\tif (state != null)\n\t{\n\t\t// Configures the style of the in-place editor\n\t\tvar scale = this.graph.getView().scale;\n\t\tvar size = mxUtils.getValue(state.style, mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE);\n\t\tvar family = mxUtils.getValue(state.style, mxConstants.STYLE_FONTFAMILY, mxConstants.DEFAULT_FONTFAMILY);\n\t\tvar color = mxUtils.getValue(state.style, mxConstants.STYLE_FONTCOLOR, 'black');\n\t\tvar align = mxUtils.getValue(state.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_LEFT);\n\t\tvar bold = (mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) &\n\t\t\t\tmxConstants.FONT_BOLD) == mxConstants.FONT_BOLD;\n\t\tvar italic = (mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) &\n\t\t\t\tmxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC;\n\t\tvar txtDecor = [];\n\t\t\n\t\tif ((mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) &\n\t\t\t\tmxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE)\n\t\t{\n\t\t\ttxtDecor.push('underline');\n\t\t}\n\t\t\n\t\tif ((mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) &\n\t\t\t\tmxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH)\n\t\t{\n\t\t\ttxtDecor.push('line-through');\n\t\t}\n\t\t\n\t\tthis.textarea.style.lineHeight = (mxConstants.ABSOLUTE_LINE_HEIGHT) ? Math.round(size * mxConstants.LINE_HEIGHT) + 'px' : mxConstants.LINE_HEIGHT;\n\t\tthis.textarea.style.backgroundColor = this.getBackgroundColor(state);\n\t\tthis.textarea.style.textDecoration = txtDecor.join(' ');\n\t\tthis.textarea.style.fontWeight = (bold) ? 'bold' : 'normal';\n\t\tthis.textarea.style.fontStyle = (italic) ? 'italic' : '';\n\t\tthis.textarea.style.fontSize = Math.round(size) + 'px';\n\t\tthis.textarea.style.zIndex = this.zIndex;\n\t\tthis.textarea.style.fontFamily = family;\n\t\tthis.textarea.style.textAlign = align;\n\t\tthis.textarea.style.outline = 'none';\n\t\tthis.textarea.style.color = color;\n\t\t\n\t\tvar dir = this.textDirection = mxUtils.getValue(state.style, mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION);\n\t\t\n\t\tif (dir == mxConstants.TEXT_DIRECTION_AUTO)\n\t\t{\n\t\t\tif (state != null && state.text != null && state.text.dialect != mxConstants.DIALECT_STRICTHTML &&\n\t\t\t\t!mxUtils.isNode(state.text.value))\n\t\t\t{\n\t\t\t\tdir = state.text.getAutoDirection();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (dir == mxConstants.TEXT_DIRECTION_LTR || dir == mxConstants.TEXT_DIRECTION_RTL)\n\t\t{\n\t\t\tthis.textarea.setAttribute('dir', dir);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.textarea.removeAttribute('dir');\n\t\t}\n\n\t\t// Sets the initial editing value\n\t\tthis.textarea.innerHTML = this.getInitialValue(state, trigger) || '';\n\t\tthis.initialValue = this.textarea.innerHTML;\n\n\t\t// Uses an optional text value for empty labels which is cleared\n\t\t// when the first keystroke appears. This makes it easier to see\n\t\t// that a label is being edited even if the label is empty.\n\t\tif (this.textarea.innerHTML.length == 0 || this.textarea.innerHTML == '<br>')\n\t\t{\n\t\t\tthis.textarea.innerHTML = this.getEmptyLabelText();\n\t\t\tthis.clearOnChange = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.clearOnChange = this.textarea.innerHTML == this.getEmptyLabelText();\n\t\t}\n\n\t\tthis.graph.container.appendChild(this.textarea);\n\t\t\n\t\t// Update this after firing all potential events that could update the cleanOnChange flag\n\t\tthis.editingCell = cell;\n\t\tthis.trigger = trigger;\n\t\tthis.textNode = null;\n\n\t\tif (state.text != null && this.isHideLabel(state))\n\t\t{\n\t\t\tthis.textNode = state.text.node;\n\t\t\tthis.textNode.style.visibility = 'hidden';\n\t\t}\n\n\t\t// Workaround for initial offsetHeight not ready for heading in markup\n\t\tif (this.autoSize && (this.graph.model.isEdge(state.cell) || state.style[mxConstants.STYLE_OVERFLOW] != 'fill'))\n\t\t{\n\t\t\twindow.setTimeout(mxUtils.bind(this, function()\n\t\t\t{\n\t\t\t\tthis.resize();\n\t\t\t}), 0);\n\t\t}\n\t\t\n\t\tthis.resize();\n\t\t\n\t\t// Workaround for NS_ERROR_FAILURE in FF\n\t\ttry\n\t\t{\n\t\t\t// Prefers blinking cursor over no selected text if empty\n\t\t\tthis.textarea.focus();\n\t\t\t\n\t\t\tif (this.isSelectText() && this.textarea.innerHTML.length > 0 &&\n\t\t\t\t(this.textarea.innerHTML != this.getEmptyLabelText() || !this.clearOnChange))\n\t\t\t{\n\t\t\t\tdocument.execCommand('selectAll', false, null);\n\t\t\t}\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\t// ignore\n\t\t}\n\t}\n};\n\n/**\n * Function: isSelectText\n * \n * Returns <selectText>.\n */\nmxCellEditor.prototype.isSelectText = function()\n{\n\treturn this.selectText;\n};\n\n/**\n * Function: clearSelection\n * \n * Clears the selection.\n */\nmxCellEditor.prototype.clearSelection = function()\n{\n\tvar selection = null;\n\t\n\tif (window.getSelection)\n\t{\n\t\tselection = window.getSelection();\n\t}\n\telse if (document.selection)\n\t{\n\t\tselection = document.selection;\n\t}\n\t\n\tif (selection != null)\n\t{\n\t\tif (selection.empty)\n\t\t{\n\t\t\tselection.empty();\n\t\t}\n\t\telse if (selection.removeAllRanges)\n\t\t{\n\t\t\tselection.removeAllRanges();\n\t\t}\n\t}\n};\n\n/**\n * Function: stopEditing\n *\n * Stops the editor and applies the value if cancel is false.\n */\nmxCellEditor.prototype.stopEditing = function(cancel)\n{\n\tcancel = cancel || false;\n\t\n\tif (this.editingCell != null)\n\t{\n\t\tif (this.textNode != null)\n\t\t{\n\t\t\tthis.textNode.style.visibility = 'visible';\n\t\t\tthis.textNode = null;\n\t\t}\n\n\t\tvar state = (!cancel) ? this.graph.view.getState(this.editingCell) : null;\n\n\t\tvar initial = this.initialValue;\n\t\tthis.initialValue = null;\n\t\tthis.editingCell = null;\n\t\tthis.trigger = null;\n\t\tthis.bounds = null;\n\t\tthis.textarea.blur();\n\t\tthis.clearSelection();\n\t\t\n\t\tif (this.textarea.parentNode != null)\n\t\t{\n\t\t\tthis.textarea.parentNode.removeChild(this.textarea);\n\t\t}\n\t\t\n\t\tif (this.clearOnChange && this.textarea.innerHTML == this.getEmptyLabelText())\n\t\t{\n\t\t\tthis.textarea.innerHTML = '';\n\t\t\tthis.clearOnChange = false;\n\t\t}\n\n\t\tif (state != null && (this.textarea.innerHTML != initial || this.align != null))\n\t\t{\n\t\t\tthis.prepareTextarea();\n\t\t\tvar value = this.getCurrentValue(state);\n\t\t\t\n\t\t\tthis.graph.getModel().beginUpdate();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (value != null)\n\t\t\t\t{\n\t\t\t\t\tthis.applyValue(state, value);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (this.align != null)\n\t\t\t\t{\n\t\t\t\t\tthis.graph.setCellStyles(mxConstants.STYLE_ALIGN, this.align, [state.cell]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tthis.graph.getModel().endUpdate();\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Forces new instance on next edit for undo history reset\n\t\tmxEvent.release(this.textarea);\n\t\tthis.textarea = null;\n\t\tthis.align = null;\n\t}\n};\n\n/**\n * Function: prepareTextarea\n * \n * Prepares the textarea for getting its value in <stopEditing>.\n * This implementation removes the extra trailing linefeed in Firefox.\n */\nmxCellEditor.prototype.prepareTextarea = function()\n{\n\tif (this.textarea.lastChild != null &&\n\t\tthis.textarea.lastChild.nodeName == 'BR')\n\t{\n\t\tthis.textarea.removeChild(this.textarea.lastChild);\n\t}\n};\n\n/**\n * Function: isHideLabel\n * \n * Returns true if the label should be hidden while the cell is being\n * edited.\n */\nmxCellEditor.prototype.isHideLabel = function(state)\n{\n\treturn true;\n};\n\n/**\n * Function: getMinimumSize\n * \n * Returns the minimum width and height for editing the given state.\n */\nmxCellEditor.prototype.getMinimumSize = function(state)\n{\n\tvar scale = this.graph.getView().scale;\n\t\n\treturn new mxRectangle(0, 0, (state.text == null) ? 30 : state.text.size * scale + 20,\n\t\t\t(this.textarea.style.textAlign == 'left') ? 120 : 40);\n};\n\n/**\n * Function: getEditorBounds\n * \n * Returns the <mxRectangle> that defines the bounds of the editor.\n */\nmxCellEditor.prototype.getEditorBounds = function(state)\n{\n\tvar isEdge = this.graph.getModel().isEdge(state.cell);\n\tvar scale = this.graph.getView().scale;\n\tvar minSize = this.getMinimumSize(state);\n\tvar minWidth = minSize.width;\n \tvar minHeight = minSize.height;\n \tvar result = null;\n \t\n \tif (!isEdge && state.view.graph.cellRenderer.legacySpacing && state.style[mxConstants.STYLE_OVERFLOW] == 'fill')\n \t{\n \t\tresult = state.shape.getLabelBounds(mxRectangle.fromRectangle(state));\n \t}\n \telse\n \t{\n\t\tvar spacing = parseInt(state.style[mxConstants.STYLE_SPACING] || 0) * scale;\n\t\tvar spacingTop = (parseInt(state.style[mxConstants.STYLE_SPACING_TOP] || 0) + mxText.prototype.baseSpacingTop) * scale + spacing;\n\t\tvar spacingRight = (parseInt(state.style[mxConstants.STYLE_SPACING_RIGHT] || 0) + mxText.prototype.baseSpacingRight) * scale + spacing;\n\t\tvar spacingBottom = (parseInt(state.style[mxConstants.STYLE_SPACING_BOTTOM] || 0) + mxText.prototype.baseSpacingBottom) * scale + spacing;\n\t\tvar spacingLeft = (parseInt(state.style[mxConstants.STYLE_SPACING_LEFT] || 0) + mxText.prototype.baseSpacingLeft) * scale + spacing;\n\t\n\t \tresult = new mxRectangle(state.x, state.y,\n\t \t\t Math.max(minWidth, state.width - spacingLeft - spacingRight),\n\t \t\t Math.max(minHeight, state.height - spacingTop - spacingBottom));\n\t\tvar hpos = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);\n\t\tvar vpos = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);\n\t\t\n\t\tresult = (state.shape != null && hpos == mxConstants.ALIGN_CENTER && vpos == mxConstants.ALIGN_MIDDLE) ? state.shape.getLabelBounds(result) : result;\n\t\n\t\tif (isEdge)\n\t\t{\n\t\t\tresult.x = state.absoluteOffset.x;\n\t\t\tresult.y = state.absoluteOffset.y;\n\t\n\t\t\tif (state.text != null && state.text.boundingBox != null)\n\t\t\t{\n\t\t\t\t// Workaround for label containing just spaces in which case\n\t\t\t\t// the bounding box location contains negative numbers \n\t\t\t\tif (state.text.boundingBox.x > 0)\n\t\t\t\t{\n\t\t\t\t\tresult.x = state.text.boundingBox.x;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (state.text.boundingBox.y > 0)\n\t\t\t\t{\n\t\t\t\t\tresult.y = state.text.boundingBox.y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (state.text != null && state.text.boundingBox != null)\n\t\t{\n\t\t\tresult.x = Math.min(result.x, state.text.boundingBox.x);\n\t\t\tresult.y = Math.min(result.y, state.text.boundingBox.y);\n\t\t}\n\t\n\t\tresult.x += spacingLeft;\n\t\tresult.y += spacingTop;\n\t\n\t\tif (state.text != null && state.text.boundingBox != null)\n\t\t{\n\t\t\tif (!isEdge)\n\t\t\t{\n\t\t\t\tresult.width = Math.max(result.width, state.text.boundingBox.width);\n\t\t\t\tresult.height = Math.max(result.height, state.text.boundingBox.height);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.width = Math.max(minWidth, state.text.boundingBox.width);\n\t\t\t\tresult.height = Math.max(minHeight, state.text.boundingBox.height);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Applies the horizontal and vertical label positions\n\t\tif (this.graph.getModel().isVertex(state.cell))\n\t\t{\n\t\t\tvar horizontal = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);\n\t\n\t\t\tif (horizontal == mxConstants.ALIGN_LEFT)\n\t\t\t{\n\t\t\t\tresult.x -= state.width;\n\t\t\t}\n\t\t\telse if (horizontal == mxConstants.ALIGN_RIGHT)\n\t\t\t{\n\t\t\t\tresult.x += state.width;\n\t\t\t}\n\t\n\t\t\tvar vertical = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);\n\t\n\t\t\tif (vertical == mxConstants.ALIGN_TOP)\n\t\t\t{\n\t\t\t\tresult.y -= state.height;\n\t\t\t}\n\t\t\telse if (vertical == mxConstants.ALIGN_BOTTOM)\n\t\t\t{\n\t\t\t\tresult.y += state.height;\n\t\t\t}\n\t\t}\n \t}\n \t\n \treturn new mxRectangle(Math.round(result.x), Math.round(result.y), Math.round(result.width), Math.round(result.height));\n};\n\n/**\n * Function: getEmptyLabelText\n *\n * Returns the initial label value to be used of the label of the given\n * cell is empty. This label is displayed and cleared on the first keystroke.\n * This implementation returns <emptyLabelText>.\n * \n * Parameters:\n * \n * cell - <mxCell> for which a text for an empty editing box should be\n * returned.\n */\nmxCellEditor.prototype.getEmptyLabelText = function (cell)\n{\n\treturn this.emptyLabelText;\n};\n\n/**\n * Function: getEditingCell\n *\n * Returns the cell that is currently being edited or null if no cell is\n * being edited.\n */\nmxCellEditor.prototype.getEditingCell = function ()\n{\n\treturn this.editingCell;\n};\n\n/**\n * Function: destroy\n *\n * Destroys the editor and removes all associated resources.\n */\nmxCellEditor.prototype.destroy = function ()\n{\n\tif (this.textarea != null)\n\t{\n\t\tmxEvent.release(this.textarea);\n\t\t\n\t\tif (this.textarea.parentNode != null)\n\t\t{\n\t\t\tthis.textarea.parentNode.removeChild(this.textarea);\n\t\t}\n\t\t\n\t\tthis.textarea = null;\n\n\t}\n\t\t\t\n\tif (this.changeHandler != null)\n\t{\n\t\tthis.graph.getModel().removeListener(this.changeHandler);\n\t\tthis.changeHandler = null;\n\t}\n\n\tif (this.zoomHandler)\n\t{\n\t\tthis.graph.view.removeListener(this.zoomHandler);\n\t\tthis.zoomHandler = null;\n\t}\n};\n\n__mxOutput.mxCellEditor = typeof mxCellEditor !== 'undefined' ? mxCellEditor : undefined;\n\n/**\n * Copyright (c) 2006-2017, JGraph Ltd\n * Copyright (c) 2006-2017, Gaudenz Alder\n */\n/**\n * Class: mxCellRenderer\n * \n * Renders cells into a document object model. The <defaultShapes> is a global\n * map of shapename, constructor pairs that is used in all instances. You can\n * get a list of all available shape names using the following code.\n * \n * In general the cell renderer is in charge of creating, redrawing and\n * destroying the shape and label associated with a cell state, as well as\n * some other graphical objects, namely controls and overlays. The shape\n * hieararchy in the display (ie. the hierarchy in which the DOM nodes\n * appear in the document) does not reflect the cell hierarchy. The shapes\n * are a (flat) sequence of shapes and labels inside the draw pane of the\n * graph view, with some exceptions, namely the HTML labels being placed\n * directly inside the graph container for certain browsers.\n * \n * (code)\n * mxLog.show();\n * for (var i in mxCellRenderer.defaultShapes)\n * {\n *   mxLog.debug(i);\n * }\n * (end)\n *\n * Constructor: mxCellRenderer\n * \n * Constructs a new cell renderer with the following built-in shapes:\n * arrow, rectangle, ellipse, rhombus, image, line, label, cylinder,\n * swimlane, connector, actor and cloud.\n */\nfunction mxCellRenderer() { };\n\n/**\n * Variable: defaultShapes\n * \n * Static array that contains the globally registered shapes which are\n * known to all instances of this class. For adding new shapes you should\n * use the static <mxCellRenderer.registerShape> function.\n */\nmxCellRenderer.defaultShapes = new Object();\n\n/**\n * Variable: defaultEdgeShape\n * \n * Defines the default shape for edges. Default is <mxConnector>.\n */\nmxCellRenderer.prototype.defaultEdgeShape = mxConnector;\n\n/**\n * Variable: defaultVertexShape\n * \n * Defines the default shape for vertices. Default is <mxRectangleShape>.\n */\nmxCellRenderer.prototype.defaultVertexShape = mxRectangleShape;\n\n/**\n * Variable: defaultTextShape\n * \n * Defines the default shape for labels. Default is <mxText>.\n */\nmxCellRenderer.prototype.defaultTextShape = mxText;\n\n/**\n * Variable: legacyControlPosition\n * \n * Specifies if the folding icon should ignore the horizontal\n * orientation of a swimlane. Default is true.\n */\nmxCellRenderer.prototype.legacyControlPosition = true;\n\n/**\n * Variable: legacySpacing\n * \n * Specifies if spacing and label position should be ignored if overflow is\n * fill or width. Default is true for backwards compatiblity.\n */\nmxCellRenderer.prototype.legacySpacing = true;\n\n/**\n * Variable: antiAlias\n * \n * Anti-aliasing option for new shapes. Default is true.\n */\nmxCellRenderer.prototype.antiAlias = true;\n\n/**\n * Variable: minSvgStrokeWidth\n * \n * Minimum stroke width for SVG output.\n */\nmxCellRenderer.prototype.minSvgStrokeWidth = 1;\n\n/**\n * Variable: forceControlClickHandler\n * \n * Specifies if the enabled state of the graph should be ignored in the control\n * click handler (to allow folding in disabled graphs). Default is false.\n */\nmxCellRenderer.prototype.forceControlClickHandler = false;\n\n/**\n * Function: registerShape\n * \n * Registers the given constructor under the specified key in this instance\n * of the renderer.\n * \n * Example:\n * \n * (code)\n * mxCellRenderer.registerShape(mxConstants.SHAPE_RECTANGLE, mxRectangleShape);\n * (end)\n * \n * Parameters:\n * \n * key - String representing the shape name.\n * shape - Constructor of the <mxShape> subclass.\n */\nmxCellRenderer.registerShape = function(key, shape)\n{\n\tmxCellRenderer.defaultShapes[key] = shape;\n};\n\n// Adds default shapes into the default shapes array\nmxCellRenderer.registerShape(mxConstants.SHAPE_RECTANGLE, mxRectangleShape);\nmxCellRenderer.registerShape(mxConstants.SHAPE_ELLIPSE, mxEllipse);\nmxCellRenderer.registerShape(mxConstants.SHAPE_RHOMBUS, mxRhombus);\nmxCellRenderer.registerShape(mxConstants.SHAPE_CYLINDER, mxCylinder);\nmxCellRenderer.registerShape(mxConstants.SHAPE_CONNECTOR, mxConnector);\nmxCellRenderer.registerShape(mxConstants.SHAPE_ACTOR, mxActor);\nmxCellRenderer.registerShape(mxConstants.SHAPE_TRIANGLE, mxTriangle);\nmxCellRenderer.registerShape(mxConstants.SHAPE_HEXAGON, mxHexagon);\nmxCellRenderer.registerShape(mxConstants.SHAPE_CLOUD, mxCloud);\nmxCellRenderer.registerShape(mxConstants.SHAPE_LINE, mxLine);\nmxCellRenderer.registerShape(mxConstants.SHAPE_ARROW, mxArrow);\nmxCellRenderer.registerShape(mxConstants.SHAPE_ARROW_CONNECTOR, mxArrowConnector);\nmxCellRenderer.registerShape(mxConstants.SHAPE_DOUBLE_ELLIPSE, mxDoubleEllipse);\nmxCellRenderer.registerShape(mxConstants.SHAPE_SWIMLANE, mxSwimlane);\nmxCellRenderer.registerShape(mxConstants.SHAPE_IMAGE, mxImageShape);\nmxCellRenderer.registerShape(mxConstants.SHAPE_LABEL, mxLabel);\n\n/**\n * Function: initializeShape\n * \n * Initializes the shape in the given state by calling its init method with\n * the correct container after configuring it using <configureShape>.\n * \n * Parameters:\n * \n * state - <mxCellState> for which the shape should be initialized.\n */\nmxCellRenderer.prototype.initializeShape = function(state)\n{\n\tstate.shape.dialect = state.view.graph.dialect;\n\tthis.configureShape(state);\n\tstate.shape.init(state.view.getDrawPane());\n};\n\n/**\n * Function: createShape\n * \n * Creates and returns the shape for the given cell state.\n * \n * Parameters:\n * \n * state - <mxCellState> for which the shape should be created.\n */\nmxCellRenderer.prototype.createShape = function(state)\n{\n\tvar shape = null;\n\t\n\tif (state.style != null)\n\t{\n\t\t// Checks if there is a stencil for the name and creates\n\t\t// a shape instance for the stencil if one exists\n\t\tvar stencil = mxStencilRegistry.getStencil(state.style[mxConstants.STYLE_SHAPE]);\n\t\t\n\t\tif (stencil != null)\n\t\t{\n\t\t\tshape = new mxShape(stencil);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar ctor = this.getShapeConstructor(state);\n\t\t\tshape = new ctor();\n\t\t}\n\t}\n\t\n\treturn shape;\n};\n\n/**\n * Function: createIndicatorShape\n * \n * Creates the indicator shape for the given cell state.\n * \n * Parameters:\n * \n * state - <mxCellState> for which the indicator shape should be created.\n */\nmxCellRenderer.prototype.createIndicatorShape = function(state)\n{\n\tstate.shape.indicatorShape = this.getShape(state.view.graph.getIndicatorShape(state));\n};\n\n/**\n * Function: getShape\n * \n * Returns the shape for the given name from <defaultShapes>.\n */\nmxCellRenderer.prototype.getShape = function(name)\n{\n\treturn (name != null) ? mxCellRenderer.defaultShapes[name] : null;\n};\n\n/**\n * Function: getShapeConstructor\n * \n * Returns the constructor to be used for creating the shape.\n */\nmxCellRenderer.prototype.getShapeConstructor = function(state)\n{\n\tvar ctor = this.getShape(state.style[mxConstants.STYLE_SHAPE]);\n\t\n\tif (ctor == null)\n\t{\n\t\tctor = (state.view.graph.getModel().isEdge(state.cell)) ?\n\t\t\tthis.defaultEdgeShape : this.defaultVertexShape;\n\t}\n\t\n\treturn ctor;\n};\n\n/**\n * Function: configureShape\n * \n * Configures the shape for the given cell state.\n * \n * Parameters:\n * \n * state - <mxCellState> for which the shape should be configured.\n */\nmxCellRenderer.prototype.configureShape = function(state)\n{\n\tstate.shape.apply(state);\n\tstate.shape.image = state.view.graph.getImage(state);\n\tstate.shape.indicatorColor = state.view.graph.getIndicatorColor(state);\n\tstate.shape.indicatorStrokeColor = state.style[mxConstants.STYLE_INDICATOR_STROKECOLOR];\n\tstate.shape.indicatorGradientColor = state.view.graph.getIndicatorGradientColor(state);\n\tstate.shape.indicatorDirection = state.style[mxConstants.STYLE_INDICATOR_DIRECTION];\n\tstate.shape.indicatorImage = state.view.graph.getIndicatorImage(state);\n\n\tthis.postConfigureShape(state);\n};\n\n/**\n * Function: postConfigureShape\n * \n * Replaces any reserved words used for attributes, eg. inherit,\n * indicated or swimlane for colors in the shape for the given state.\n * This implementation resolves these keywords on the fill, stroke\n * and gradient color keys.\n */\nmxCellRenderer.prototype.postConfigureShape = function(state)\n{\n\tif (state.shape != null)\n\t{\n\t\tthis.resolveColor(state, 'indicatorGradientColor', mxConstants.STYLE_GRADIENTCOLOR);\n\t\tthis.resolveColor(state, 'indicatorColor', mxConstants.STYLE_FILLCOLOR);\n\t\tthis.resolveColor(state, 'gradient', mxConstants.STYLE_GRADIENTCOLOR);\n\t\tthis.resolveColor(state, 'stroke', mxConstants.STYLE_STROKECOLOR);\n\t\tthis.resolveColor(state, 'fill', mxConstants.STYLE_FILLCOLOR);\n\t}\n};\n\n/**\n * Function: checkPlaceholderStyles\n * \n * Checks if the style of the given <mxCellState> contains 'inherit',\n * 'indicated' or 'swimlane' for colors that support those keywords.\n */\nmxCellRenderer.prototype.checkPlaceholderStyles = function(state)\n{\n\t// LATER: Check if the color has actually changed\n\tif (state.style != null)\n\t{\n\t\tvar values = ['inherit', 'swimlane', 'indicated'];\n\t\tvar styles = [mxConstants.STYLE_FILLCOLOR, mxConstants.STYLE_STROKECOLOR,\n\t\t\tmxConstants.STYLE_GRADIENTCOLOR, mxConstants.STYLE_FONTCOLOR];\n\t\t\n\t\tfor (var i = 0; i < styles.length; i++)\n\t\t{\n\t\t\tif (mxUtils.indexOf(values, state.style[styles[i]]) >= 0)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: resolveColor\n * \n * Resolves special keywords 'inherit', 'indicated' and 'swimlane' and sets\n * the respective color on the shape.\n */\nmxCellRenderer.prototype.resolveColor = function(state, field, key)\n{\n\tvar shape = (key == mxConstants.STYLE_FONTCOLOR) ?\n\t\tstate.text : state.shape;\n\t\n\tif (shape != null)\n\t{\n\t\tvar graph = state.view.graph;\n\t\tvar value = shape[field];\n\t\tvar referenced = null;\n\t\t\n\t\tif (value == 'inherit')\n\t\t{\n\t\t\treferenced = graph.model.getParent(state.cell);\n\t\t}\n\t\telse if (value == 'swimlane')\n\t\t{\n\t\t\tshape[field] = (key == mxConstants.STYLE_STROKECOLOR ||\n\t\t\t\tkey == mxConstants.STYLE_FONTCOLOR) ?\n\t\t\t\t'#000000' : '#ffffff';\n\t\t\t\n\t\t\tif (graph.model.getTerminal(state.cell, false) != null)\n\t\t\t{\n\t\t\t\treferenced = graph.model.getTerminal(state.cell, false);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treferenced = state.cell;\n\t\t\t}\n\t\t\t\n\t\t\treferenced = graph.getSwimlane(referenced);\n\t\t\tkey = graph.swimlaneIndicatorColorAttribute;\n\t\t}\n\t\telse if (value == 'indicated' && state.shape != null)\n\t\t{\n\t\t\tshape[field] = state.shape.indicatorColor;\n\t\t}\n\t\telse if (key != mxConstants.STYLE_FILLCOLOR &&\n\t\t\tvalue == mxConstants.STYLE_FILLCOLOR &&\n\t\t\tstate.shape != null)\n\t\t{\n\t\t\tshape[field] = state.style[mxConstants.STYLE_FILLCOLOR];\n\t\t}\n\t\telse if (key != mxConstants.STYLE_STROKECOLOR &&\n\t\t\tvalue == mxConstants.STYLE_STROKECOLOR &&\n\t\t\tstate.shape != null)\n\t\t{\n\t\t\tshape[field] = state.style[mxConstants.STYLE_STROKECOLOR];\n\t\t}\n\t\n\t\tif (referenced != null)\n\t\t{\n\t\t\tvar rstate = graph.getView().getState(referenced);\n\t\t\tshape[field] = null;\n\t\t\t\n\t\t\tif (rstate != null)\n\t\t\t{\n\t\t\t\tvar rshape = (key == mxConstants.STYLE_FONTCOLOR) ? rstate.text : rstate.shape;\n\t\t\t\t\n\t\t\t\tif (rshape != null && field != 'indicatorColor')\n\t\t\t\t{\n\t\t\t\t\tshape[field] = rshape[field];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tshape[field] = rstate.style[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: getLabelValue\n * \n * Returns the value to be used for the label.\n * \n * Parameters:\n * \n * state - <mxCellState> for which the label should be created.\n */\nmxCellRenderer.prototype.getLabelValue = function(state)\n{\n\treturn state.view.graph.getLabel(state.cell);\n};\n\n/**\n * Function: createLabel\n * \n * Creates the label for the given cell state.\n * \n * Parameters:\n * \n * state - <mxCellState> for which the label should be created.\n */\nmxCellRenderer.prototype.createLabel = function(state, value)\n{\n\tvar graph = state.view.graph;\n\tvar isEdge = graph.getModel().isEdge(state.cell);\n\t\n\tif (state.style[mxConstants.STYLE_FONTSIZE] > 0 || state.style[mxConstants.STYLE_FONTSIZE] == null)\n\t{\n\t\t// Avoids using DOM node for empty labels\n\t\tvar isForceHtml = (graph.isHtmlLabel(state.cell) || (value != null && mxUtils.isNode(value)));\n\n\t\tstate.text = new this.defaultTextShape(value, new mxRectangle(),\n\t\t\t\t(state.style[mxConstants.STYLE_ALIGN] || mxConstants.ALIGN_CENTER),\n\t\t\t\tgraph.getVerticalAlign(state),\n\t\t\t\tstate.style[mxConstants.STYLE_FONTCOLOR],\n\t\t\t\tstate.style[mxConstants.STYLE_FONTFAMILY],\n\t\t\t\tstate.style[mxConstants.STYLE_FONTSIZE],\n\t\t\t\tstate.style[mxConstants.STYLE_FONTSTYLE],\n\t\t\t\tstate.style[mxConstants.STYLE_SPACING],\n\t\t\t\tstate.style[mxConstants.STYLE_SPACING_TOP],\n\t\t\t\tstate.style[mxConstants.STYLE_SPACING_RIGHT],\n\t\t\t\tstate.style[mxConstants.STYLE_SPACING_BOTTOM],\n\t\t\t\tstate.style[mxConstants.STYLE_SPACING_LEFT],\n\t\t\t\tstate.style[mxConstants.STYLE_HORIZONTAL],\n\t\t\t\tstate.style[mxConstants.STYLE_LABEL_BACKGROUNDCOLOR],\n\t\t\t\tstate.style[mxConstants.STYLE_LABEL_BORDERCOLOR],\n\t\t\t\tgraph.isWrapping(state.cell) && graph.isHtmlLabel(state.cell),\n\t\t\t\tgraph.isLabelClipped(state.cell),\n\t\t\t\tstate.style[mxConstants.STYLE_OVERFLOW],\n\t\t\t\tstate.style[mxConstants.STYLE_LABEL_PADDING],\n\t\t\t\tmxUtils.getValue(state.style, mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION));\n\t\tstate.text.opacity = mxUtils.getValue(state.style, mxConstants.STYLE_TEXT_OPACITY, 100);\n\t\tstate.text.dialect = (isForceHtml) ? mxConstants.DIALECT_STRICTHTML : state.view.graph.dialect;\n\t\tstate.text.style = state.style;\n\t\tstate.text.state = state;\n\t\tthis.initializeLabel(state, state.text);\n\t\t\n\t\t// Workaround for touch devices routing all events for a mouse gesture\n\t\t// (down, move, up) via the initial DOM node. IE additionally redirects\n\t\t// the event via the initial DOM node but the event source is the node\n\t\t// under the mouse, so we need to check if this is the case and force\n\t\t// getCellAt for the subsequent mouseMoves and the final mouseUp.\n\t\tvar forceGetCell = false;\n\t\t\n\t\tvar getState = function(evt)\n\t\t{\n\t\t\tvar result = state;\n\n\t\t\tif (mxClient.IS_TOUCH || forceGetCell)\n\t\t\t{\n\t\t\t\tvar x = mxEvent.getClientX(evt);\n\t\t\t\tvar y = mxEvent.getClientY(evt);\n\t\t\t\t\n\t\t\t\t// Dispatches the drop event to the graph which\n\t\t\t\t// consumes and executes the source function\n\t\t\t\tvar pt = mxUtils.convertPoint(graph.container, x, y);\n\t\t\t\tresult = graph.view.getState(graph.getCellAt(pt.x, pt.y));\n\t\t\t}\n\t\t\t\n\t\t\treturn result;\n\t\t};\n\t\t\n\t\t// TODO: Add handling for special touch device gestures\n\t\tmxEvent.addGestureListeners(state.text.node,\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tif (this.isLabelEvent(state, evt))\n\t\t\t\t{\n\t\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, state));\n\t\t\t\t\tforceGetCell = graph.dialect != mxConstants.DIALECT_SVG &&\n\t\t\t\t\t\tmxEvent.getSource(evt).nodeName == 'IMG';\n\t\t\t\t}\n\t\t\t}),\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tif (this.isLabelEvent(state, evt))\n\t\t\t\t{\n\t\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, getState(evt)));\n\t\t\t\t}\n\t\t\t}),\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tif (this.isLabelEvent(state, evt))\n\t\t\t\t{\n\t\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, getState(evt)));\n\t\t\t\t\tforceGetCell = false;\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\n\t\t// Uses double click timeout in mxGraph for quirks mode\n\t\tif (graph.nativeDblClickEnabled)\n\t\t{\n\t\t\tmxEvent.addListener(state.text.node, 'dblclick',\n\t\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t\t{\n\t\t\t\t\tif (this.isLabelEvent(state, evt))\n\t\t\t\t\t{\n\t\t\t\t\t\tgraph.dblClick(evt, state.cell);\n\t\t\t\t\t\tmxEvent.consume(evt);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t}\n};\n\n/**\n * Function: initializeLabel\n * \n * Initiailzes the label with a suitable container.\n * \n * Parameters:\n * \n * state - <mxCellState> whose label should be initialized.\n */\nmxCellRenderer.prototype.initializeLabel = function(state, shape)\n{\n\tif (mxClient.IS_SVG && mxClient.NO_FO && shape.dialect != mxConstants.DIALECT_SVG)\n\t{\n\t\tshape.init(state.view.graph.container);\n\t}\n\telse\n\t{\n\t\tshape.init(state.view.getDrawPane());\n\t}\n};\n\n/**\n * Function: createCellOverlays\n * \n * Creates the actual shape for showing the overlay for the given cell state.\n * \n * Parameters:\n * \n * state - <mxCellState> for which the overlay should be created.\n */\nmxCellRenderer.prototype.createCellOverlays = function(state)\n{\n\tvar graph = state.view.graph;\n\tvar overlays = graph.getCellOverlays(state.cell);\n\tvar dict = null;\n\t\n\tif (overlays != null)\n\t{\n\t\tdict = new mxDictionary();\n\t\t\n\t\tfor (var i = 0; i < overlays.length; i++)\n\t\t{\n\t\t\tvar shape = (state.overlays != null) ? state.overlays.remove(overlays[i]) : null;\n\t\t\t\n\t\t\tif (shape == null)\n\t\t\t{\n\t\t\t\tvar tmp = new mxImageShape(new mxRectangle(), overlays[i].image.src);\n\t\t\t\ttmp.dialect = state.view.graph.dialect;\n\t\t\t\ttmp.preserveImageAspect = false;\n\t\t\t\ttmp.overlay = overlays[i];\n\t\t\t\tthis.initializeOverlay(state, tmp);\n\t\t\t\tthis.installCellOverlayListeners(state, overlays[i], tmp);\n\t\n\t\t\t\tif (overlays[i].cursor != null)\n\t\t\t\t{\n\t\t\t\t\ttmp.node.style.cursor = overlays[i].cursor;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdict.put(overlays[i], tmp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdict.put(overlays[i], shape);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Removes unused\n\tif (state.overlays != null)\n\t{\n\t\tstate.overlays.visit(function(id, shape)\n\t\t{\n\t\t\tshape.destroy();\n\t\t});\n\t}\n\t\n\tstate.overlays = dict;\n};\n\n/**\n * Function: initializeOverlay\n * \n * Initializes the given overlay.\n * \n * Parameters:\n * \n * state - <mxCellState> for which the overlay should be created.\n * overlay - <mxImageShape> that represents the overlay.\n */\nmxCellRenderer.prototype.initializeOverlay = function(state, overlay)\n{\n\toverlay.init(state.view.getOverlayPane());\n};\n\n/**\n * Function: installOverlayListeners\n * \n * Installs the listeners for the given <mxCellState>, <mxCellOverlay> and\n * <mxShape> that represents the overlay.\n */\nmxCellRenderer.prototype.installCellOverlayListeners = function(state, overlay, shape)\n{\n\tvar graph  = state.view.graph;\n\t\n\tmxEvent.addListener(shape.node, 'click', function (evt)\n\t{\n\t\tif (graph.isEditing())\n\t\t{\n\t\t\tgraph.stopEditing(!graph.isInvokesStopCellEditing());\n\t\t}\n\t\t\n\t\toverlay.fireEvent(new mxEventObject(mxEvent.CLICK,\n\t\t\t\t'event', evt, 'cell', state.cell));\n\t});\n\t\n\tmxEvent.addGestureListeners(shape.node,\n\t\tfunction (evt)\n\t\t{\n\t\t\tmxEvent.consume(evt);\n\t\t},\n\t\tfunction (evt)\n\t\t{\n\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_MOVE,\n\t\t\t\tnew mxMouseEvent(evt, state));\n\t\t});\n\t\n\tif (mxClient.IS_TOUCH)\n\t{\n\t\tmxEvent.addListener(shape.node, 'touchend', function (evt)\n\t\t{\n\t\t\toverlay.fireEvent(new mxEventObject(mxEvent.CLICK,\n\t\t\t\t\t'event', evt, 'cell', state.cell));\n\t\t});\n\t}\n};\n\n/**\n * Function: createControl\n * \n * Creates the control for the given cell state.\n * \n * Parameters:\n * \n * state - <mxCellState> for which the control should be created.\n */\nmxCellRenderer.prototype.createControl = function(state)\n{\n\tvar graph = state.view.graph;\n\tvar image = graph.getFoldingImage(state);\n\t\n\tif (graph.foldingEnabled && image != null)\n\t{\n\t\tif (state.control == null)\n\t\t{\n\t\t\tvar b = new mxRectangle(0, 0, image.width, image.height);\n\t\t\tstate.control = new mxImageShape(b, image.src);\n\t\t\tstate.control.preserveImageAspect = false;\n\t\t\tstate.control.dialect = graph.dialect;\n\n\t\t\tthis.initControl(state, state.control, true, this.createControlClickHandler(state));\n\t\t}\n\t}\n\telse if (state.control != null)\n\t{\n\t\tstate.control.destroy();\n\t\tstate.control = null;\n\t}\n};\n\n/**\n * Function: createControlClickHandler\n * \n * Hook for creating the click handler for the folding icon.\n * \n * Parameters:\n * \n * state - <mxCellState> whose control click handler should be returned.\n */\nmxCellRenderer.prototype.createControlClickHandler = function(state)\n{\n\tvar graph = state.view.graph;\n\t\n\treturn mxUtils.bind(this, function (evt)\n\t{\n\t\tif (this.forceControlClickHandler || graph.isEnabled())\n\t\t{\n\t\t\tvar collapse = !graph.isCellCollapsed(state.cell);\n\t\t\tgraph.foldCells(collapse, false, [state.cell], null, evt);\n\t\t\tmxEvent.consume(evt);\n\t\t}\n\t});\n};\n\n/**\n * Function: initControl\n * \n * Initializes the given control and returns the corresponding DOM node.\n * \n * Parameters:\n * \n * state - <mxCellState> for which the control should be initialized.\n * control - <mxShape> to be initialized.\n * handleEvents - Boolean indicating if mousedown and mousemove should fire events via the graph.\n * clickHandler - Optional function to implement clicks on the control.\n */\nmxCellRenderer.prototype.initControl = function(state, control, handleEvents, clickHandler)\n{\n\tvar graph = state.view.graph;\n\t\n\t// In the special case where the label is in HTML and the display is SVG the image\n\t// should go into the graph container directly in order to be clickable. Otherwise\n\t// it is obscured by the HTML label that overlaps the cell.\n\tvar isForceHtml = graph.isHtmlLabel(state.cell) && mxClient.NO_FO &&\n\t\tgraph.dialect == mxConstants.DIALECT_SVG;\n\n\tif (isForceHtml)\n\t{\n\t\tcontrol.dialect = mxConstants.DIALECT_PREFERHTML;\n\t\tcontrol.init(graph.container);\n\t\tcontrol.node.style.zIndex = 1;\n\t}\n\telse\n\t{\n\t\tcontrol.init(state.view.getOverlayPane());\n\t}\n\n\tvar node = control.innerNode || control.node;\n\t\n\t// Workaround for missing click event on iOS is to check tolerance below\n\tif (clickHandler != null && !mxClient.IS_IOS)\n\t{\n\t\tif (graph.isEnabled())\n\t\t{\n\t\t\tnode.style.cursor = 'pointer';\n\t\t}\n\t\t\n\t\tmxEvent.addListener(node, 'click', clickHandler);\n\t}\n\t\n\tif (handleEvents)\n\t{\n\t\tvar first = null;\n\n\t\tmxEvent.addGestureListeners(node,\n\t\t\tfunction (evt)\n\t\t\t{\n\t\t\t\tfirst = new mxPoint(mxEvent.getClientX(evt), mxEvent.getClientY(evt));\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, state));\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t},\n\t\t\tfunction (evt)\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, state));\n\t\t\t},\n\t\t\tfunction (evt)\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, state));\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t});\n\t\t\n\t\t// Uses capture phase for event interception to stop bubble phase\n\t\tif (clickHandler != null && mxClient.IS_IOS)\n\t\t{\n\t\t\tnode.addEventListener('touchend', function(evt)\n\t\t\t{\n\t\t\t\tif (first != null)\n\t\t\t\t{\n\t\t\t\t\tvar tol = graph.tolerance;\n\t\t\t\t\t\n\t\t\t\t\tif (Math.abs(first.x - mxEvent.getClientX(evt)) < tol &&\n\t\t\t\t\t\tMath.abs(first.y - mxEvent.getClientY(evt)) < tol)\n\t\t\t\t\t{\n\t\t\t\t\t\tclickHandler.call(clickHandler, evt);\n\t\t\t\t\t\tmxEvent.consume(evt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, true);\n\t\t}\n\t}\n\t\n\treturn node;\n};\n\n/**\n * Function: isShapeEvent\n * \n * Returns true if the event is for the shape of the given state. This\n * implementation always returns true.\n * \n * Parameters:\n * \n * state - <mxCellState> whose shape fired the event.\n * evt - Mouse event which was fired.\n */\nmxCellRenderer.prototype.isShapeEvent = function(state, evt)\n{\n\treturn true;\n};\n\n/**\n * Function: isLabelEvent\n * \n * Returns true if the event is for the label of the given state. This\n * implementation always returns true.\n * \n * Parameters:\n * \n * state - <mxCellState> whose label fired the event.\n * evt - Mouse event which was fired.\n */\nmxCellRenderer.prototype.isLabelEvent = function(state, evt)\n{\n\treturn true;\n};\n\n/**\n * Function: installListeners\n * \n * Installs the event listeners for the given cell state.\n * \n * Parameters:\n * \n * state - <mxCellState> for which the event listeners should be isntalled.\n */\nmxCellRenderer.prototype.installListeners = function(state)\n{\n\tvar graph = state.view.graph;\n\n\t// Workaround for touch devices routing all events for a mouse\n\t// gesture (down, move, up) via the initial DOM node. Same for\n\t// HTML images in all IE versions (VML images are working).\n\tvar getState = function(evt)\n\t{\n\t\tvar result = state;\n\t\t\n\t\tif ((graph.dialect != mxConstants.DIALECT_SVG && mxEvent.getSource(evt).nodeName == 'IMG') || mxClient.IS_TOUCH)\n\t\t{\n\t\t\tvar x = mxEvent.getClientX(evt);\n\t\t\tvar y = mxEvent.getClientY(evt);\n\t\t\t\n\t\t\t// Dispatches the drop event to the graph which\n\t\t\t// consumes and executes the source function\n\t\t\tvar pt = mxUtils.convertPoint(graph.container, x, y);\n\t\t\tresult = graph.view.getState(graph.getCellAt(pt.x, pt.y));\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\tmxEvent.addGestureListeners(state.shape.node,\n\t\tmxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tif (this.isShapeEvent(state, evt))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, state));\n\t\t\t}\n\t\t}),\n\t\tmxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tif (this.isShapeEvent(state, evt))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, getState(evt)));\n\t\t\t}\n\t\t}),\n\t\tmxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tif (this.isShapeEvent(state, evt))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, getState(evt)));\n\t\t\t}\n\t\t})\n\t);\n\t\n\t// Uses double click timeout in mxGraph for quirks mode\n\tif (graph.nativeDblClickEnabled)\n\t{\n\t\tmxEvent.addListener(state.shape.node, 'dblclick',\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tif (this.isShapeEvent(state, evt))\n\t\t\t\t{\n\t\t\t\t\tgraph.dblClick(evt, state.cell);\n\t\t\t\t\tmxEvent.consume(evt);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n};\n\n/**\n * Function: redrawLabel\n * \n * Redraws the label for the given cell state.\n * \n * Parameters:\n * \n * state - <mxCellState> whose label should be redrawn.\n */\nmxCellRenderer.prototype.redrawLabel = function(state, forced)\n{\n\tvar graph = state.view.graph;\n\tvar value = this.getLabelValue(state);\n\tvar wrapping = graph.isWrapping(state.cell);\n\tvar clipping = graph.isLabelClipped(state.cell);\n\tvar isForceHtml = (state.view.graph.isHtmlLabel(state.cell) || (value != null && mxUtils.isNode(value)));\n\tvar dialect = (isForceHtml) ? mxConstants.DIALECT_STRICTHTML : state.view.graph.dialect;\n\tvar overflow = state.style[mxConstants.STYLE_OVERFLOW] || 'visible';\n\n\tif (state.text != null && (state.text.wrap != wrapping || state.text.clipped != clipping ||\n\t\tstate.text.overflow != overflow || state.text.dialect != dialect))\n\t{\n\t\tstate.text.destroy();\n\t\tstate.text = null;\n\t}\n\t\n\tif (state.text == null && value != null && (mxUtils.isNode(value) || value.length > 0))\n\t{\n\t\tthis.createLabel(state, value);\n\t}\n\telse if (state.text != null && (value == null || value.length == 0))\n\t{\n\t\tstate.text.destroy();\n\t\tstate.text = null;\n\t}\n\n\tif (state.text != null)\n\t{\n\t\t// Forced is true if the style has changed, so to get the updated\n\t\t// result in getLabelBounds we apply the new style to the shape\n\t\tif (forced)\n\t\t{\n\t\t\t// Checks if a full repaint is needed\n\t\t\tif (state.text.lastValue != null && this.isTextShapeInvalid(state, state.text))\n\t\t\t{\n\t\t\t\t// Forces a full repaint\n\t\t\t\tstate.text.lastValue = null;\n\t\t\t}\n\t\t\t\n\t\t\tstate.text.resetStyles();\n\t\t\tstate.text.apply(state);\n\t\t\t\n\t\t\t// Special case where value is obtained via hook in graph\n\t\t\tstate.text.valign = graph.getVerticalAlign(state);\n\t\t}\n\t\t\n\t\tvar bounds = this.getLabelBounds(state);\n\t\tvar nextScale = this.getTextScale(state);\n\t\tthis.resolveColor(state, 'color', mxConstants.STYLE_FONTCOLOR);\n\t\t\n\t\tif (forced || state.text.value != value || state.text.isWrapping != wrapping ||\n\t\t\tstate.text.overflow != overflow || state.text.isClipping != clipping ||\n\t\t\tstate.text.scale != nextScale || state.text.dialect != dialect ||\n\t\t\tstate.text.bounds == null || !state.text.bounds.equals(bounds))\n\t\t{\n\t\t\tstate.text.dialect = dialect;\n\t\t\tstate.text.value = value;\n\t\t\tstate.text.bounds = bounds;\n\t\t\tstate.text.scale = nextScale;\n\t\t\tstate.text.wrap = wrapping;\n\t\t\tstate.text.clipped = clipping;\n\t\t\tstate.text.overflow = overflow;\n\t\t\t\n\t\t\t// Preserves visible state\n\t\t\tvar vis = state.text.node.style.visibility;\n\t\t\tthis.redrawLabelShape(state.text);\n\t\t\tstate.text.node.style.visibility = vis;\n\t\t}\n\t}\n};\n\n/**\n * Function: isTextShapeInvalid\n * \n * Returns true if the style for the text shape has changed.\n * \n * Parameters:\n * \n * state - <mxCellState> whose label should be checked.\n * shape - <mxText> shape to be checked.\n */\nmxCellRenderer.prototype.isTextShapeInvalid = function(state, shape)\n{\n\tfunction check(property, stylename, defaultValue)\n\t{\n\t\tvar result = false;\n\t\t\n\t\t// Workaround for spacing added to directional spacing\n\t\tif (stylename == 'spacingTop' || stylename == 'spacingRight' ||\n\t\t\tstylename == 'spacingBottom' || stylename == 'spacingLeft')\n\t\t{\n\t\t\tresult = parseFloat(shape[property]) - parseFloat(shape.spacing) !=\n\t\t\t\t(state.style[stylename] || defaultValue);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = shape[property] != (state.style[stylename] || defaultValue);\n\t\t}\n\t\t\n\t\treturn result;\n\t};\n\n\treturn check('fontStyle', mxConstants.STYLE_FONTSTYLE, mxConstants.DEFAULT_FONTSTYLE) ||\n\t\tcheck('family', mxConstants.STYLE_FONTFAMILY, mxConstants.DEFAULT_FONTFAMILY) ||\n\t\tcheck('size', mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE) ||\n\t\tcheck('color', mxConstants.STYLE_FONTCOLOR, 'black') ||\n\t\tcheck('align', mxConstants.STYLE_ALIGN, '') ||\n\t\tcheck('valign', mxConstants.STYLE_VERTICAL_ALIGN, '') ||\n\t\tcheck('spacing', mxConstants.STYLE_SPACING, 2) ||\n\t\tcheck('spacingTop', mxConstants.STYLE_SPACING_TOP, 0) ||\n\t\tcheck('spacingRight', mxConstants.STYLE_SPACING_RIGHT, 0) ||\n\t\tcheck('spacingBottom', mxConstants.STYLE_SPACING_BOTTOM, 0) ||\n\t\tcheck('spacingLeft', mxConstants.STYLE_SPACING_LEFT, 0) ||\n\t\tcheck('horizontal', mxConstants.STYLE_HORIZONTAL, true) ||\n\t\tcheck('background', mxConstants.STYLE_LABEL_BACKGROUNDCOLOR) ||\n\t\tcheck('border', mxConstants.STYLE_LABEL_BORDERCOLOR) ||\n\t\tcheck('opacity', mxConstants.STYLE_TEXT_OPACITY, 100) ||\n\t\tcheck('textDirection', mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION);\n};\n\n/**\n * Function: redrawLabelShape\n * \n * Called to invoked redraw on the given text shape.\n * \n * Parameters:\n * \n * shape - <mxText> shape to be redrawn.\n */\nmxCellRenderer.prototype.redrawLabelShape = function(shape)\n{\n\tshape.redraw();\n};\n\n/**\n * Function: getTextScale\n * \n * Returns the scaling used for the label of the given state\n * \n * Parameters:\n * \n * state - <mxCellState> whose label scale should be returned.\n */\nmxCellRenderer.prototype.getTextScale = function(state)\n{\n\treturn state.view.scale;\n};\n\n/**\n * Function: getLabelBounds\n * \n * Returns the bounds to be used to draw the label of the given state.\n * \n * Parameters:\n * \n * state - <mxCellState> whose label bounds should be returned.\n */\nmxCellRenderer.prototype.getLabelBounds = function(state)\n{\n\tvar graph = state.view.graph;\n\tvar scale = state.view.scale;\n\tvar isEdge = graph.getModel().isEdge(state.cell);\n\tvar bounds = new mxRectangle(state.absoluteOffset.x, state.absoluteOffset.y);\n\n\tif (isEdge)\n\t{\n\t\tvar spacing = state.text.getSpacing();\n\t\tbounds.x += spacing.x * scale;\n\t\tbounds.y += spacing.y * scale;\n\t\t\n\t\tvar geo = graph.getCellGeometry(state.cell);\n\t\t\n\t\tif (geo != null)\n\t\t{\n\t\t\tbounds.width = Math.max(0, geo.width * scale);\n\t\t\tbounds.height = Math.max(0, geo.height * scale);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Inverts label position\n\t\tif (state.text.isPaintBoundsInverted())\n\t\t{\n\t\t\tvar tmp = bounds.x;\n\t\t\tbounds.x = bounds.y;\n\t\t\tbounds.y = tmp;\n\t\t}\n\t\t\n\t\tbounds.x += state.x;\n\t\tbounds.y += state.y;\n\t\t\n\t\t// Minimum of 1 fixes alignment bug in HTML labels\n\t\tbounds.width = Math.max(1, state.width);\n\t\tbounds.height = Math.max(1, state.height);\n\t}\n\n\tif (state.text.isPaintBoundsInverted())\n\t{\n\t\t// Rotates around center of state\n\t\tvar t = (state.width - state.height) / 2;\n\t\tbounds.x += t;\n\t\tbounds.y -= t;\n\t\tvar tmp = bounds.width;\n\t\tbounds.width = bounds.height;\n\t\tbounds.height = tmp;\n\t}\n\t\n\t// Shape can modify its label bounds\n\tif (state.shape != null)\n\t{\n\t\tvar hpos = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);\n\t\tvar vpos = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);\n\t\t\n\t\tif (hpos == mxConstants.ALIGN_CENTER && vpos == mxConstants.ALIGN_MIDDLE)\n\t\t{\n\t\t\tbounds = state.shape.getLabelBounds(bounds);\n\t\t}\n\t}\n\t\n\t// Label width style overrides actual label width\n\tvar lw = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);\n\t\n\tif (lw != null)\n\t{\n\t\tbounds.width = parseFloat(lw) * scale;\n\t}\n\t\n\tif (!isEdge)\n\t{\n\t\tthis.rotateLabelBounds(state, bounds);\n\t}\n\t\n\treturn bounds;\n};\n\n/**\n * Function: rotateLabelBounds\n * \n * Adds the shape rotation to the given label bounds and\n * applies the alignment and offsets.\n * \n * Parameters:\n * \n * state - <mxCellState> whose label bounds should be rotated.\n * bounds - <mxRectangle> the rectangle to be rotated.\n */\nmxCellRenderer.prototype.rotateLabelBounds = function(state, bounds)\n{\n\tbounds.y -= state.text.margin.y * bounds.height;\n\tbounds.x -= state.text.margin.x * bounds.width;\n\t\n\tif (!this.legacySpacing || (state.style[mxConstants.STYLE_OVERFLOW] != 'fill' && state.style[mxConstants.STYLE_OVERFLOW] != 'width'))\n\t{\n\t\tvar s = state.view.scale;\n\t\tvar spacing = state.text.getSpacing();\n\t\tbounds.x += spacing.x * s;\n\t\tbounds.y += spacing.y * s;\n\t\t\n\t\tvar hpos = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);\n\t\tvar vpos = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);\n\t\tvar lw = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);\n\t\t\n\t\tbounds.width = Math.max(0, bounds.width - ((hpos == mxConstants.ALIGN_CENTER && lw == null) ? (state.text.spacingLeft * s + state.text.spacingRight * s) : 0));\n\t\tbounds.height = Math.max(0, bounds.height - ((vpos == mxConstants.ALIGN_MIDDLE) ? (state.text.spacingTop * s + state.text.spacingBottom * s) : 0));\n\t}\n\n\tvar theta = state.text.getTextRotation();\n\n\t// Only needed if rotated around another center\n\tif (theta != 0 && state != null && state.view.graph.model.isVertex(state.cell))\n\t{\n\t\tvar cx = state.getCenterX();\n\t\tvar cy = state.getCenterY();\n\t\t\n\t\tif (bounds.x != cx || bounds.y != cy)\n\t\t{\n\t\t\tvar rad = theta * (Math.PI / 180);\n\t\t\tvar pt = mxUtils.getRotatedPoint(new mxPoint(bounds.x, bounds.y),\n\t\t\t\t\tMath.cos(rad), Math.sin(rad), new mxPoint(cx, cy));\n\t\t\t\n\t\t\tbounds.x = pt.x;\n\t\t\tbounds.y = pt.y;\n\t\t}\n\t}\n};\n\n/**\n * Function: redrawCellOverlays\n * \n * Redraws the overlays for the given cell state.\n * \n * Parameters:\n * \n * state - <mxCellState> whose overlays should be redrawn.\n */\nmxCellRenderer.prototype.redrawCellOverlays = function(state, forced)\n{\n\tthis.createCellOverlays(state);\n\n\tif (state.overlays != null)\n\t{\n\t\tvar rot = mxUtils.mod(mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION, 0), 90);\n        var rad = mxUtils.toRadians(rot);\n        var cos = Math.cos(rad);\n        var sin = Math.sin(rad);\n\t\t\n\t\tstate.overlays.visit(function(id, shape)\n\t\t{\n\t\t\tvar bounds = shape.overlay.getBounds(state);\n\t\t\n\t\t\tif (!state.view.graph.getModel().isEdge(state.cell))\n\t\t\t{\n\t\t\t\tif (state.shape != null && rot != 0)\n\t\t\t\t{\n\t\t\t\t\tvar cx = bounds.getCenterX();\n\t\t\t\t\tvar cy = bounds.getCenterY();\n\n\t\t\t\t\tvar point = mxUtils.getRotatedPoint(new mxPoint(cx, cy), cos, sin,\n\t\t\t        \t\tnew mxPoint(state.getCenterX(), state.getCenterY()));\n\n\t\t\t        cx = point.x;\n\t\t\t        cy = point.y;\n\t\t\t        bounds.x = Math.round(cx - bounds.width / 2);\n\t\t\t        bounds.y = Math.round(cy - bounds.height / 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (forced || shape.bounds == null || shape.scale != state.view.scale ||\n\t\t\t\t!shape.bounds.equals(bounds))\n\t\t\t{\n\t\t\t\tshape.bounds = bounds;\n\t\t\t\tshape.scale = state.view.scale;\n\t\t\t\tshape.redraw();\n\t\t\t}\n\t\t});\n\t}\n};\n\n/**\n * Function: redrawControl\n * \n * Redraws the control for the given cell state.\n * \n * Parameters:\n * \n * state - <mxCellState> whose control should be redrawn.\n */\nmxCellRenderer.prototype.redrawControl = function(state, forced)\n{\n\tvar image = state.view.graph.getFoldingImage(state);\n\t\n\tif (state.control != null && image != null)\n\t{\n\t\tvar bounds = this.getControlBounds(state, image.width, image.height);\n\t\tvar r = (this.legacyControlPosition) ?\n\t\t\t\tmxUtils.getValue(state.style, mxConstants.STYLE_ROTATION, 0) :\n\t\t\t\tstate.shape.getTextRotation();\n\t\tvar s = state.view.scale;\n\t\t\n\t\tif (forced || state.control.scale != s || !state.control.bounds.equals(bounds) ||\n\t\t\tstate.control.rotation != r)\n\t\t{\n\t\t\tstate.control.rotation = r;\n\t\t\tstate.control.bounds = bounds;\n\t\t\tstate.control.scale = s;\n\t\t\t\n\t\t\tstate.control.redraw();\n\t\t}\n\t}\n};\n\n/**\n * Function: getControlBounds\n * \n * Returns the bounds to be used to draw the control (folding icon) of the\n * given state.\n */\nmxCellRenderer.prototype.getControlBounds = function(state, w, h)\n{\n\tif (state.control != null)\n\t{\n\t\tvar s = state.view.scale;\n\t\tvar cx = state.getCenterX();\n\t\tvar cy = state.getCenterY();\n\t\n\t\tif (!state.view.graph.getModel().isEdge(state.cell))\n\t\t{\n\t\t\tcx = state.x + w * s;\n\t\t\tcy = state.y + h * s;\n\t\t\t\n\t\t\tif (state.shape != null)\n\t\t\t{\n\t\t\t\t// TODO: Factor out common code\n\t\t\t\tvar rot = state.shape.getShapeRotation();\n\t\t\t\t\n\t\t\t\tif (this.legacyControlPosition)\n\t\t\t\t{\n\t\t\t\t\trot = mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (state.shape.isPaintBoundsInverted())\n\t\t\t\t\t{\n\t\t\t\t\t\tvar t = (state.width - state.height) / 2;\n\t\t\t\t\t\tcx += t;\n\t\t\t\t\t\tcy -= t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (rot != 0)\n\t\t\t\t{\n\t\t\t        var rad = mxUtils.toRadians(rot);\n\t\t\t        var cos = Math.cos(rad);\n\t\t\t        var sin = Math.sin(rad);\n\t\t\t        \n\t\t\t        var point = mxUtils.getRotatedPoint(new mxPoint(cx, cy), cos, sin,\n\t\t\t        \t\tnew mxPoint(state.getCenterX(), state.getCenterY()));\n\t\t\t        cx = point.x;\n\t\t\t        cy = point.y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn (state.view.graph.getModel().isEdge(state.cell)) ? \n\t\t\tnew mxRectangle(Math.round(cx - w / 2 * s), Math.round(cy - h / 2 * s), Math.round(w * s), Math.round(h * s))\n\t\t\t: new mxRectangle(Math.round(cx - w / 2 * s), Math.round(cy - h / 2 * s), Math.round(w * s), Math.round(h * s));\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: insertStateAfter\n * \n * Inserts the given array of <mxShapes> after the given nodes in the DOM.\n * \n * Parameters:\n * \n * shapes - Array of <mxShapes> to be inserted.\n * node - Node in <drawPane> after which the shapes should be inserted.\n * htmlNode - Node in the graph container after which the shapes should be inserted that\n * will not go into the <drawPane> (eg. HTML labels without foreignObjects).\n */\nmxCellRenderer.prototype.insertStateAfter = function(state, node, htmlNode)\n{\n\tvar shapes = this.getShapesForState(state);\n\t\n\tfor (var i = 0; i < shapes.length; i++)\n\t{\n\t\tif (shapes[i] != null && shapes[i].node != null)\n\t\t{\n\t\t\tvar html = shapes[i].node.parentNode != state.view.getDrawPane() &&\n\t\t\t\tshapes[i].node.parentNode != state.view.getOverlayPane();\n\t\t\tvar temp = (html) ? htmlNode : node;\n\t\t\t\n\t\t\tif (temp != null && temp.nextSibling != shapes[i].node)\n\t\t\t{\n\t\t\t\tif (temp.nextSibling == null)\n\t\t\t\t{\n\t\t\t\t\ttemp.parentNode.appendChild(shapes[i].node);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttemp.parentNode.insertBefore(shapes[i].node, temp.nextSibling);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (temp == null)\n\t\t\t{\n\t\t\t\t// Special case: First HTML node should be first sibling after canvas\n\t\t\t\tif (shapes[i].node.parentNode == state.view.graph.container)\n\t\t\t\t{\n\t\t\t\t\tvar canvas = state.view.canvas;\n\t\t\t\t\t\n\t\t\t\t\twhile (canvas != null && canvas.parentNode != state.view.graph.container)\n\t\t\t\t\t{\n\t\t\t\t\t\tcanvas = canvas.parentNode;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (canvas != null && canvas.nextSibling != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (canvas.nextSibling != shapes[i].node)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tshapes[i].node.parentNode.insertBefore(shapes[i].node, canvas.nextSibling);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tshapes[i].node.parentNode.appendChild(shapes[i].node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (shapes[i].node.parentNode != null &&\n\t\t\t\t\tshapes[i].node.parentNode.firstChild != null &&\n\t\t\t\t\tshapes[i].node.parentNode.firstChild != shapes[i].node)\n\t\t\t\t{\n\t\t\t\t\t// Inserts the node as the first child of the parent to implement the order\n\t\t\t\t\tshapes[i].node.parentNode.insertBefore(shapes[i].node, shapes[i].node.parentNode.firstChild);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (html)\n\t\t\t{\n\t\t\t\thtmlNode = shapes[i].node;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode = shapes[i].node;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [node, htmlNode];\n};\n\n/**\n * Function: getShapesForState\n * \n * Returns the <mxShapes> for the given cell state in the order in which they should\n * appear in the DOM.\n * \n * Parameters:\n * \n * state - <mxCellState> whose shapes should be returned.\n */\nmxCellRenderer.prototype.getShapesForState = function(state)\n{\n\treturn [state.shape, state.text, state.control];\n};\n\n/**\n * Function: redraw\n * \n * Updates the bounds or points and scale of the shapes for the given cell\n * state. This is called in mxGraphView.validatePoints as the last step of\n * updating all cells.\n * \n * Parameters:\n * \n * state - <mxCellState> for which the shapes should be updated.\n * force - Optional boolean that specifies if the cell should be reconfiured\n * and redrawn without any additional checks.\n * rendering - Optional boolean that specifies if the cell should actually\n * be drawn into the DOM. If this is false then redraw and/or reconfigure\n * will not be called on the shape.\n */\nmxCellRenderer.prototype.redraw = function(state, force, rendering)\n{\n\tvar shapeChanged = this.redrawShape(state, force, rendering);\n\n\tif (state.shape != null && (rendering == null || rendering))\n\t{\n\t\tthis.redrawLabel(state, shapeChanged);\n\t\tthis.redrawCellOverlays(state, shapeChanged);\n\t\tthis.redrawControl(state, shapeChanged);\n\t}\n};\n\n/**\n * Function: redrawShape\n * \n * Redraws the shape for the given cell state.\n * \n * Parameters:\n * \n * state - <mxCellState> whose label should be redrawn.\n */\nmxCellRenderer.prototype.redrawShape = function(state, force, rendering)\n{\n\tvar model = state.view.graph.model;\n\tvar shapeChanged = false;\n\n\t// Forces creation of new shape if shape style has changed\n\tif (state.shape != null && state.shape.style != null && state.style != null &&\n\t\tstate.shape.style[mxConstants.STYLE_SHAPE] != state.style[mxConstants.STYLE_SHAPE])\n\t{\n\t\tstate.shape.destroy();\n\t\tstate.shape = null;\n\t}\n\t\n\tif (state.shape == null && state.view.graph.container != null &&\n\t\tstate.cell != state.view.currentRoot &&\n\t\t(model.isVertex(state.cell) || model.isEdge(state.cell)))\n\t{\n\t\tstate.shape = this.createShape(state);\n\t\t\n\t\tif (state.shape != null)\n\t\t{\n\t\t\tstate.shape.minSvgStrokeWidth = this.minSvgStrokeWidth;\n\t\t\tstate.shape.antiAlias = this.antiAlias;\n\t\n\t\t\tthis.createIndicatorShape(state);\n\t\t\tthis.initializeShape(state);\n\t\t\tthis.createCellOverlays(state);\n\t\t\tthis.installListeners(state);\n\t\t\t\n\t\t\t// Forces a refresh of the handler if one exists\n\t\t\tstate.view.graph.selectionCellsHandler.updateHandler(state);\n\t\t}\n\t}\n\telse if (!force && state.shape != null && (!mxUtils.equalEntries(state.shape.style,\n\t\tstate.style) || this.checkPlaceholderStyles(state)))\n\t{\n\t\tstate.shape.resetStyles();\n\t\tthis.configureShape(state);\n\t\t// LATER: Ignore update for realtime to fix reset of current gesture\n\t\tstate.view.graph.selectionCellsHandler.updateHandler(state);\n\t\tforce = true;\n\t}\n\t\n\t// Updates indicator shape\n\tif (state.shape != null && state.shape.indicatorShape !=\n\t\tthis.getShape(state.view.graph.getIndicatorShape(state)))\n\t{\n\t\tif (state.shape.indicator != null)\n\t\t{\n\t\t\tstate.shape.indicator.destroy();\n\t\t\tstate.shape.indicator = null;\n\t\t}\n\t\t\n\t\tthis.createIndicatorShape(state);\n\t\t\n\t\tif (state.shape.indicatorShape != null)\n\t\t{\n\t\t\tstate.shape.indicator = new state.shape.indicatorShape();\n\t\t\tstate.shape.indicator.dialect = state.shape.dialect;\n\t\t\tstate.shape.indicator.init(state.node);\n\t\t\tforce = true;\n\t\t}\n\t}\n\n\tif (state.shape != null)\n\t{\n\t\t// Handles changes of the collapse icon\n\t\tthis.createControl(state);\n\t\t\n\t\t// Redraws the cell if required, ignores changes to bounds if points are\n\t\t// defined as the bounds are updated for the given points inside the shape\n\t\tif (force || this.isShapeInvalid(state, state.shape))\n\t\t{\n\t\t\tif (state.absolutePoints != null)\n\t\t\t{\n\t\t\t\tstate.shape.points = state.absolutePoints.slice();\n\t\t\t\tstate.shape.bounds = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate.shape.points = null;\n\t\t\t\tstate.shape.bounds = new mxRectangle(state.x, state.y, state.width, state.height);\n\t\t\t}\n\n\t\t\tstate.shape.scale = state.view.scale;\n\t\t\t\n\t\t\tif (rendering == null || rendering)\n\t\t\t{\n\t\t\t\tthis.doRedrawShape(state);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate.shape.updateBoundingBox();\n\t\t\t}\n\t\t\t\n\t\t\tshapeChanged = true;\n\t\t}\n\t}\n\n\treturn shapeChanged;\n};\n\n/**\n * Function: doRedrawShape\n * \n * Invokes redraw on the shape of the given state.\n */\nmxCellRenderer.prototype.doRedrawShape = function(state)\n{\n\tstate.shape.redraw();\n};\n\n/**\n * Function: isShapeInvalid\n * \n * Returns true if the given shape must be repainted.\n */\nmxCellRenderer.prototype.isShapeInvalid = function(state, shape)\n{\n\treturn shape.bounds == null || shape.scale != state.view.scale ||\n\t\t(state.absolutePoints == null && !shape.bounds.equals(state)) ||\n\t\t(state.absolutePoints != null && !mxUtils.equalPoints(shape.points, state.absolutePoints))\n};\n\n/**\n * Function: destroy\n * \n * Destroys the shapes associated with the given cell state.\n * \n * Parameters:\n * \n * state - <mxCellState> for which the shapes should be destroyed.\n */\nmxCellRenderer.prototype.destroy = function(state)\n{\n\tif (state.shape != null)\n\t{\n\t\tif (state.text != null)\n\t\t{\t\t\n\t\t\tstate.text.destroy();\n\t\t\tstate.text = null;\n\t\t}\n\t\t\n\t\tif (state.overlays != null)\n\t\t{\n\t\t\tstate.overlays.visit(function(id, shape)\n\t\t\t{\n\t\t\t\tshape.destroy();\n\t\t\t});\n\t\t\t\n\t\t\tstate.overlays = null;\n\t\t}\n\n\t\tif (state.control != null)\n\t\t{\n\t\t\tstate.control.destroy();\n\t\t\tstate.control = null;\n\t\t}\n\t\t\n\t\tstate.shape.destroy();\n\t\tstate.shape = null;\n\t}\n};\n\n__mxOutput.mxCellRenderer = typeof mxCellRenderer !== 'undefined' ? mxCellRenderer : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxEdgeStyle =\n{\n\t/**\n\t * Class: mxEdgeStyle\n\t * \n\t * Provides various edge styles to be used as the values for\n\t * <mxConstants.STYLE_EDGE> in a cell style.\n\t *\n\t * Example:\n\t * \n\t * (code)\n\t * var style = stylesheet.getDefaultEdgeStyle();\n\t * style[mxConstants.STYLE_EDGE] = mxEdgeStyle.ElbowConnector;\n\t * (end)\n\t * \n\t * Sets the default edge style to <ElbowConnector>.\n\t * \n\t * Custom edge style:\n\t * \n\t * To write a custom edge style, a function must be added to the mxEdgeStyle\n\t * object as follows:\n\t * \n\t * (code)\n\t * mxEdgeStyle.MyStyle = function(state, source, target, points, result)\n\t * {\n\t *   if (source != null && target != null)\n\t *   {\n\t *     var pt = new mxPoint(target.getCenterX(), source.getCenterY());\n\t * \n\t *     if (mxUtils.contains(source, pt.x, pt.y))\n\t *     {\n\t *       pt.y = source.y + source.height;\n\t *     }\n\t * \n\t *     result.push(pt);\n\t *   }\n\t * };\n\t * (end)\n\t * \n\t * In the above example, a right angle is created using a point on the\n\t * horizontal center of the target vertex and the vertical center of the source\n\t * vertex. The code checks if that point intersects the source vertex and makes\n\t * the edge straight if it does. The point is then added into the result array,\n\t * which acts as the return value of the function.\n\t *\n\t * The new edge style should then be registered in the <mxStyleRegistry> as follows:\n\t * (code)\n\t * mxStyleRegistry.putValue('myEdgeStyle', mxEdgeStyle.MyStyle);\n\t * (end)\n\t * \n\t * The custom edge style above can now be used in a specific edge as follows:\n\t * \n\t * (code)\n\t * model.setStyle(edge, 'edgeStyle=myEdgeStyle');\n\t * (end)\n\t * \n\t * Note that the key of the <mxStyleRegistry> entry for the function should\n\t * be used in string values, unless <mxGraphView.allowEval> is true, in\n\t * which case you can also use mxEdgeStyle.MyStyle for the value in the\n\t * cell style above.\n\t * \n\t * Or it can be used for all edges in the graph as follows:\n\t * \n\t * (code)\n\t * var style = graph.getStylesheet().getDefaultEdgeStyle();\n\t * style[mxConstants.STYLE_EDGE] = mxEdgeStyle.MyStyle;\n\t * (end)\n\t * \n\t * Note that the object can be used directly when programmatically setting\n\t * the value, but the key in the <mxStyleRegistry> should be used when\n\t * setting the value via a key, value pair in a cell style.\n\t * \n\t * Function: EntityRelation\n\t * \n\t * Implements an entity relation style for edges (as used in database\n\t * schema diagrams). At the time the function is called, the result\n\t * array contains a placeholder (null) for the first absolute point,\n\t * that is, the point where the edge and source terminal are connected.\n\t * The implementation of the style then adds all intermediate waypoints\n\t * except for the last point, that is, the connection point between the\n\t * edge and the target terminal. The first ant the last point in the\n\t * result array are then replaced with mxPoints that take into account\n\t * the terminal's perimeter and next point on the edge.\n\t *\n\t * Parameters:\n\t * \n\t * state - <mxCellState> that represents the edge to be updated.\n\t * source - <mxCellState> that represents the source terminal.\n\t * target - <mxCellState> that represents the target terminal.\n\t * points - List of relative control points.\n\t * result - Array of <mxPoints> that represent the actual points of the\n\t * edge.\n\t */\n\t EntityRelation: function(state, source, target, points, result)\n\t {\n\t\tvar view = state.view;\n\t \tvar graph = view.graph;\n\t \tvar segment = mxUtils.getValue(state.style,\n\t \t\t\tmxConstants.STYLE_SEGMENT,\n\t \t\t\tmxConstants.ENTITY_SEGMENT) * view.scale;\n\t \t\n\t\tvar pts = state.absolutePoints;\n\t\tvar p0 = pts[0];\n\t\tvar pe = pts[pts.length-1];\n\n\t \tvar isSourceLeft = false;\n\t \t\n\t \tif (source != null)\n\t \t{\n \t\t\tvar sourceGeometry = graph.getCellGeometry(source.cell);\n\t\n\t\t \tif (sourceGeometry.relative)\n\t\t \t{\n\t\t \t\tisSourceLeft = sourceGeometry.x <= 0.5;\n\t\t \t}\n\t\t \telse if (target != null)\n\t\t \t{\n\t\t \t\tisSourceLeft = ((pe != null) ? pe.x : target.x + target.width) < ((p0 != null) ? p0.x : source.x);\n\t\t \t}\n\t \t}\n\n\t\tif (p0 != null)\n\t\t{\n\t\t\tsource = new mxCellState();\n\t\t\tsource.x = p0.x;\n\t\t\tsource.y = p0.y;\n\t\t}\n\t\telse if (source != null)\n\t\t{\n\t\t\tvar constraint = mxUtils.getPortConstraints(source, state, true, mxConstants.DIRECTION_MASK_NONE);\n\t\t\t\n\t\t\tif (constraint != mxConstants.DIRECTION_MASK_NONE && constraint != mxConstants.DIRECTION_MASK_WEST +\n\t\t\t\tmxConstants.DIRECTION_MASK_EAST)\n\t\t\t{\n\t\t\t\tisSourceLeft = constraint == mxConstants.DIRECTION_MASK_WEST;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn;\n\t\t}\n\t \t\n\t \tvar isTargetLeft = true;\n\t \t\n\t \tif (target != null)\n\t \t{\n\t\t \tvar targetGeometry = graph.getCellGeometry(target.cell);\n\t\n\t\t \tif (targetGeometry.relative)\n\t\t \t{\n\t\t \t\tisTargetLeft = targetGeometry.x <= 0.5;\n\t\t \t}\n\t\t \telse if (source != null)\n\t\t \t{\n\t\t \t\tisTargetLeft = ((p0 != null) ? p0.x : source.x + source.width) < ((pe != null) ? pe.x : target.x);\n\t\t \t}\n\t \t}\n\t\t\n\t\tif (pe != null)\n\t\t{\n\t\t\ttarget = new mxCellState();\n\t\t\ttarget.x = pe.x;\n\t\t\ttarget.y = pe.y;\n\t\t}\n\t\telse if (target != null)\n\t \t{\n\t\t\tvar constraint = mxUtils.getPortConstraints(target, state, false, mxConstants.DIRECTION_MASK_NONE);\n\n\t\t\tif (constraint != mxConstants.DIRECTION_MASK_NONE && constraint != mxConstants.DIRECTION_MASK_WEST +\n\t\t\t\tmxConstants.DIRECTION_MASK_EAST)\n\t\t\t{\n\t\t\t\tisTargetLeft = constraint == mxConstants.DIRECTION_MASK_WEST;\n\t\t\t}\n\t \t}\n\t\t\n\t\tif (source != null && target != null)\n\t\t{\n\t\t\tvar x0 = (isSourceLeft) ? source.x : source.x + source.width;\n\t\t\tvar y0 = view.getRoutingCenterY(source);\n\t\t\t\n\t\t\tvar xe = (isTargetLeft) ? target.x : target.x + target.width;\n\t\t\tvar ye = view.getRoutingCenterY(target);\n\t\n\t\t\tvar seg = segment;\n\t\n\t\t\tvar dx = (isSourceLeft) ? -seg : seg;\n\t\t\tvar dep = new mxPoint(x0 + dx, y0);\n\t\t\t\t\t\n\t\t\tdx = (isTargetLeft) ? -seg : seg;\n\t\t\tvar arr = new mxPoint(xe + dx, ye);\n\t\t\t\n\t\t\t// Adds intermediate points if both go out on same side\n\t\t\tif (isSourceLeft == isTargetLeft)\n\t\t\t{\n\t\t\t\tvar x = (isSourceLeft) ?\n\t\t\t\t\tMath.min(x0, xe)-segment :\n\t\t\t\t\tMath.max(x0, xe)+segment;\n\t\n\t\t\t\tresult.push(new mxPoint(x, y0));\n\t\t\t\tresult.push(new mxPoint(x, ye));\n\t\t\t}\n\t\t\telse if ((dep.x < arr.x) == isSourceLeft)\n\t\t\t{\n\t\t\t\tvar midY = y0 + (ye - y0) / 2;\n\t\n\t\t\t\tresult.push(dep);\n\t\t\t\tresult.push(new mxPoint(dep.x, midY));\n\t\t\t\tresult.push(new mxPoint(arr.x, midY));\n\t\t\t\tresult.push(arr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.push(dep);\n\t\t\t\tresult.push(arr);\n\t\t\t}\n\t\t}\n\t },\n\n\t /**\n\t * Function: Loop\n\t * \n\t * Implements a self-reference, aka. loop.\n\t */\n\tLoop: function(state, source, target, points, result)\n\t{\n\t\tvar pts = state.absolutePoints;\n\t\t\n\t\tvar p0 = pts[0];\n\t\tvar pe = pts[pts.length-1];\n\n\t\tif (p0 != null && pe != null)\n\t\t{\n\t\t\tif (points != null && points.length > 0)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < points.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar pt = points[i];\n\t\t\t\t\tpt = state.view.transformControlPoint(state, pt);\n\t\t\t\t\tresult.push(new mxPoint(pt.x, pt.y));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (source != null)\n\t\t{\n\t\t\tvar view = state.view;\n\t\t\tvar graph = view.graph;\n\t\t\tvar pt = (points != null && points.length > 0) ? points[0] : null;\n\n\t\t\tif (pt != null)\n\t\t\t{\n\t\t\t\tpt = view.transformControlPoint(state, pt);\n\t\t\t\t\t\n\t\t\t\tif (mxUtils.contains(source, pt.x, pt.y))\n\t\t\t\t{\n\t\t\t\t\tpt = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar x = 0;\n\t\t\tvar dx = 0;\n\t\t\tvar y = 0;\n\t\t\tvar dy = 0;\n\t\t\t\n\t\t \tvar seg = mxUtils.getValue(state.style, mxConstants.STYLE_SEGMENT,\n\t\t \t\tgraph.gridSize) * view.scale;\n\t\t\tvar dir = mxUtils.getValue(state.style, mxConstants.STYLE_DIRECTION,\n\t\t\t\tmxConstants.DIRECTION_WEST);\n\t\t\t\n\t\t\tif (dir == mxConstants.DIRECTION_NORTH ||\n\t\t\t\tdir == mxConstants.DIRECTION_SOUTH)\n\t\t\t{\n\t\t\t\tx = view.getRoutingCenterX(source);\n\t\t\t\tdx = seg;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ty = view.getRoutingCenterY(source);\n\t\t\t\tdy = seg;\n\t\t\t}\n\t\t\t\n\t\t\tif (pt == null ||\n\t\t\t\tpt.x < source.x ||\n\t\t\t\tpt.x > source.x + source.width)\n\t\t\t{\n\t\t\t\tif (pt != null)\n\t\t\t\t{\n\t\t\t\t\tx = pt.x;\n\t\t\t\t\tdy = Math.max(Math.abs(y - pt.y), dy);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (dir == mxConstants.DIRECTION_NORTH)\n\t\t\t\t\t{\n\t\t\t\t\t\ty = source.y - 2 * dx;\n\t\t\t\t\t}\n\t\t\t\t\telse if (dir == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t\t{\n\t\t\t\t\t\ty = source.y + source.height + 2 * dx;\n\t\t\t\t\t}\n\t\t\t\t\telse if (dir == mxConstants.DIRECTION_EAST)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = source.x - 2 * dy;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tx = source.x + source.width + 2 * dy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (pt != null)\n\t\t\t{\n\t\t\t\tx = view.getRoutingCenterX(source);\n\t\t\t\tdx = Math.max(Math.abs(x - pt.x), dy);\n\t\t\t\ty = pt.y;\n\t\t\t\tdy = 0;\n\t\t\t}\n\t\t\t\n\t\t\tresult.push(new mxPoint(x - dx, y - dy));\n\t\t\tresult.push(new mxPoint(x + dx, y + dy));\n\t\t}\n\t},\n\t\n\t/**\n\t * Function: ElbowConnector\n\t * \n\t * Uses either <SideToSide> or <TopToBottom> depending on the horizontal\n\t * flag in the cell style. <SideToSide> is used if horizontal is true or\n\t * unspecified. See <EntityRelation> for a description of the\n\t * parameters.\n\t */\n\tElbowConnector: function(state, source, target, points, result)\n\t{\n\t\tvar pt = (points != null && points.length > 0) ? points[0] : null;\n\n\t\tvar vertical = false;\n\t\tvar horizontal = false;\n\t\t\n\t\tif (source != null && target != null)\n\t\t{\n\t\t\tif (pt != null)\n\t\t\t{\n\t\t\t\tvar left = Math.min(source.x, target.x);\n\t\t\t\tvar right = Math.max(source.x + source.width,\n\t\t\t\t\ttarget.x + target.width);\n\t\n\t\t\t\tvar top = Math.min(source.y, target.y);\n\t\t\t\tvar bottom = Math.max(source.y + source.height,\n\t\t\t\t\ttarget.y + target.height);\n\n\t\t\t\tpt = state.view.transformControlPoint(state, pt);\n\t\t\t\t\t\n\t\t\t\tvertical = pt.y < top || pt.y > bottom;\n\t\t\t\thorizontal = pt.x < left || pt.x > right;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar left = Math.max(source.x, target.x);\n\t\t\t\tvar right = Math.min(source.x + source.width,\n\t\t\t\t\ttarget.x + target.width);\n\t\t\t\t\t\n\t\t\t\tvertical = left == right;\n\t\t\t\t\n\t\t\t\tif (!vertical)\n\t\t\t\t{\n\t\t\t\t\tvar top = Math.max(source.y, target.y);\n\t\t\t\t\tvar bottom = Math.min(source.y + source.height,\n\t\t\t\t\t\ttarget.y + target.height);\n\t\t\t\t\t\t\n\t\t\t\t\thorizontal = top == bottom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!horizontal && (vertical ||\n\t\t\tstate.style[mxConstants.STYLE_ELBOW] == mxConstants.ELBOW_VERTICAL))\n\t\t{\n\t\t\tmxEdgeStyle.TopToBottom(state, source, target, points, result);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmxEdgeStyle.SideToSide(state, source, target, points, result);\n\t\t}\n\t},\n\n\t/**\n\t * Function: SideToSide\n\t * \n\t * Implements a vertical elbow edge. See <EntityRelation> for a description\n\t * of the parameters.\n\t */\n\tSideToSide: function(state, source, target, points, result)\n\t{\n\t\tvar view = state.view;\n\t\tvar pt = (points != null && points.length > 0) ? points[0] : null;\n\t\tvar pts = state.absolutePoints;\n\t\tvar p0 = pts[0];\n\t\tvar pe = pts[pts.length-1];\n\t\t\n\t\tif (pt != null)\n\t\t{\n\t\t\tpt = view.transformControlPoint(state, pt);\n\t\t}\n\t\t\n\t\tif (p0 != null)\n\t\t{\n\t\t\tsource = new mxCellState();\n\t\t\tsource.x = p0.x;\n\t\t\tsource.y = p0.y;\n\t\t}\n\t\t\n\t\tif (pe != null)\n\t\t{\n\t\t\ttarget = new mxCellState();\n\t\t\ttarget.x = pe.x;\n\t\t\ttarget.y = pe.y;\n\t\t}\n\t\t\n\t\tif (source != null && target != null)\n\t\t{\n\t\t\tvar l = Math.max(source.x, target.x);\n\t\t\tvar r = Math.min(source.x + source.width,\n\t\t\t\t\t\t\t target.x + target.width);\n\t\n\t\t\tvar x = (pt != null) ? pt.x : Math.round(r + (l - r) / 2);\n\t\n\t\t\tvar y1 = view.getRoutingCenterY(source);\n\t\t\tvar y2 = view.getRoutingCenterY(target);\n\t\n\t\t\tif (pt != null)\n\t\t\t{\n\t\t\t\tif (pt.y >= source.y && pt.y <= source.y + source.height)\n\t\t\t\t{\n\t\t\t\t\ty1 = pt.y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (pt.y >= target.y && pt.y <= target.y + target.height)\n\t\t\t\t{\n\t\t\t\t\ty2 = pt.y;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!mxUtils.contains(target, x, y1) &&\n\t\t\t\t!mxUtils.contains(source, x, y1))\n\t\t\t{\n\t\t\t\tresult.push(new mxPoint(x,  y1));\n\t\t\t}\n\t\n\t\t\tif (!mxUtils.contains(target, x, y2) &&\n\t\t\t\t!mxUtils.contains(source, x, y2))\n\t\t\t{\n\t\t\t\tresult.push(new mxPoint(x, y2));\n\t\t\t}\n\t\n\t\t\tif (result.length == 1)\n\t\t\t{\n\t\t\t\tif (pt != null)\n\t\t\t\t{\n\t\t\t\t\tif (!mxUtils.contains(target, x, pt.y) &&\n\t\t\t\t\t\t!mxUtils.contains(source, x, pt.y))\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.push(new mxPoint(x, pt.y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\t\n\t\t\t\t\tvar t = Math.max(source.y, target.y);\n\t\t\t\t\tvar b = Math.min(source.y + source.height,\n\t\t\t\t\t\t\t target.y + target.height);\n\t\t\t\t\t\t \n\t\t\t\t\tresult.push(new mxPoint(x, t + (b - t) / 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Function: TopToBottom\n\t * \n\t * Implements a horizontal elbow edge. See <EntityRelation> for a\n\t * description of the parameters.\n\t */\n\tTopToBottom: function(state, source, target, points, result)\n\t{\n\t\tvar view = state.view;\n\t\tvar pt = (points != null && points.length > 0) ? points[0] : null;\n\t\tvar pts = state.absolutePoints;\n\t\tvar p0 = pts[0];\n\t\tvar pe = pts[pts.length-1];\n\t\t\n\t\tif (pt != null)\n\t\t{\n\t\t\tpt = view.transformControlPoint(state, pt);\n\t\t}\n\t\t\n\t\tif (p0 != null)\n\t\t{\n\t\t\tsource = new mxCellState();\n\t\t\tsource.x = p0.x;\n\t\t\tsource.y = p0.y;\n\t\t}\n\t\t\n\t\tif (pe != null)\n\t\t{\n\t\t\ttarget = new mxCellState();\n\t\t\ttarget.x = pe.x;\n\t\t\ttarget.y = pe.y;\n\t\t}\n\n\t\tif (source != null && target != null)\n\t\t{\n\t\t\tvar t = Math.max(source.y, target.y);\n\t\t\tvar b = Math.min(source.y + source.height,\n\t\t\t\t\t\t\t target.y + target.height);\n\t\n\t\t\tvar x = view.getRoutingCenterX(source);\n\t\t\t\n\t\t\tif (pt != null &&\n\t\t\t\tpt.x >= source.x &&\n\t\t\t\tpt.x <= source.x + source.width)\n\t\t\t{\n\t\t\t\tx = pt.x;\n\t\t\t}\n\t\t\t\n\t\t\tvar y = (pt != null) ? pt.y : Math.round(b + (t - b) / 2);\n\t\t\t\n\t\t\tif (!mxUtils.contains(target, x, y) &&\n\t\t\t\t!mxUtils.contains(source, x, y))\n\t\t\t{\n\t\t\t\tresult.push(new mxPoint(x, y));\t\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif (pt != null &&\n\t\t\t\tpt.x >= target.x &&\n\t\t\t\tpt.x <= target.x + target.width)\n\t\t\t{\n\t\t\t\tx = pt.x;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx = view.getRoutingCenterX(target);\n\t\t\t}\n\t\t\t\n\t\t\tif (!mxUtils.contains(target, x, y) &&\n\t\t\t\t!mxUtils.contains(source, x, y))\n\t\t\t{\n\t\t\t\tresult.push(new mxPoint(x, y));\t\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif (result.length == 1)\n\t\t\t{\n\t\t\t\tif (pt != null && result.length == 1)\n\t\t\t\t{\n\t\t\t\t\tif (!mxUtils.contains(target, pt.x, y) &&\n\t\t\t\t\t\t!mxUtils.contains(source, pt.x, y))\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.push(new mxPoint(pt.x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar l = Math.max(source.x, target.x);\n\t\t\t\t\tvar r = Math.min(source.x + source.width,\n\t\t\t\t\t\t\t target.x + target.width);\n\t\t\t\t\t\t \n\t\t\t\t\tresult.push(new mxPoint(l + (r - l) / 2, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Function: SegmentConnector\n\t * \n\t * Implements an orthogonal edge style. Use <mxEdgeSegmentHandler>\n\t * as an interactive handler for this style.\n\t * \n\t * state - <mxCellState> that represents the edge to be updated.\n\t * sourceScaled - <mxCellState> that represents the source terminal.\n\t * targetScaled - <mxCellState> that represents the target terminal.\n\t * controlHints - List of relative control points.\n\t * result - Array of <mxPoints> that represent the actual points of the\n\t * edge.\n\t *\n\t */\n\tSegmentConnector: function(state, sourceScaled, targetScaled, controlHints, result)\n\t{\n\t\t// Creates array of all way- and terminalpoints\n\t\tvar pts = mxEdgeStyle.scalePointArray(state.absolutePoints, state.view.scale);\n\t\tvar source = mxEdgeStyle.scaleCellState(sourceScaled, state.view.scale);\n\t\tvar target = mxEdgeStyle.scaleCellState(targetScaled, state.view.scale);\n\t\tvar tol = 1;\n\t\t\n\t\t// Whether the first segment outgoing from the source end is horizontal\n\t\tvar lastPushed = (result.length > 0) ? result[0] : null;\n\t\tvar horizontal = true;\n\t\tvar hint = null;\n\t\t\n\t\t// Adds waypoints only if outside of tolerance\n\t\tfunction pushPoint(pt)\n\t\t{\n\t\t\tpt.x = Math.round(pt.x * state.view.scale * 10) / 10;\n\t\t\tpt.y = Math.round(pt.y * state.view.scale * 10) / 10;\n\n\t\t\tif (lastPushed == null || Math.abs(lastPushed.x - pt.x) >= tol || Math.abs(lastPushed.y - pt.y) >= Math.max(1, state.view.scale))\n\t\t\t{\n\t\t\t\tresult.push(pt);\n\t\t\t\tlastPushed = pt;\n\t\t\t}\n\t\t\t\n\t\t\treturn lastPushed;\n\t\t};\n\n\t\t// Adds the first point\n\t\tvar pt = pts[0];\n\t\t\n\t\tif (pt == null && source != null)\n\t\t{\n\t\t\tpt = new mxPoint(state.view.getRoutingCenterX(source), state.view.getRoutingCenterY(source));\n\t\t}\n\t\telse if (pt != null)\n\t\t{\n\t\t\tpt = pt.clone();\n\t\t}\n\t\t\n\t\tvar lastInx = pts.length - 1;\n\n\t\t// Adds the waypoints\n\t\tif (controlHints != null && controlHints.length > 0)\n\t\t{\n\t\t\t// Converts all hints and removes nulls\n\t\t\tvar hints = [];\n\t\t\t\n\t\t\tfor (var i = 0; i < controlHints.length; i++)\n\t\t\t{\n\t\t\t\tvar tmp = state.view.transformControlPoint(state, controlHints[i], true);\n\t\t\t\t\n\t\t\t\tif (tmp != null)\n\t\t\t\t{\n\t\t\t\t\thints.push(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (hints.length == 0)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// Aligns source and target hint to fixed points\n\t\t\tif (pt != null && hints[0] != null)\n\t\t\t{\n\t\t\t\tif (Math.abs(hints[0].x - pt.x) < tol)\n\t\t\t\t{\n\t\t\t\t\thints[0].x = pt.x;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (Math.abs(hints[0].y - pt.y) < tol)\n\t\t\t\t{\n\t\t\t\t\thints[0].y = pt.y;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar pe = pts[lastInx];\n\t\t\t\n\t\t\tif (pe != null && hints[hints.length - 1] != null)\n\t\t\t{\n\t\t\t\tif (Math.abs(hints[hints.length - 1].x - pe.x) < tol)\n\t\t\t\t{\n\t\t\t\t\thints[hints.length - 1].x = pe.x;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (Math.abs(hints[hints.length - 1].y - pe.y) < tol)\n\t\t\t\t{\n\t\t\t\t\thints[hints.length - 1].y = pe.y;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\thint = hints[0];\n\n\t\t\tvar currentTerm = source;\n\t\t\tvar currentPt = pts[0];\n\t\t\tvar hozChan = false;\n\t\t\tvar vertChan = false;\n\t\t\tvar currentHint = hint;\n\t\t\t\n\t\t\tif (currentPt != null)\n\t\t\t{\n\t\t\t\tcurrentTerm = null;\n\t\t\t}\n\t\t\t\n\t\t\t// Check for alignment with fixed points and with channels\n\t\t\t// at source and target segments only\n\t\t\tfor (var i = 0; i < 2; i++)\n\t\t\t{\n\t\t\t\tvar fixedVertAlign = currentPt != null && currentPt.x == currentHint.x;\n\t\t\t\tvar fixedHozAlign = currentPt != null && currentPt.y == currentHint.y;\n\t\t\t\t\n\t\t\t\tvar inHozChan = currentTerm != null && (currentHint.y >= currentTerm.y &&\n\t\t\t\t\t\tcurrentHint.y <= currentTerm.y + currentTerm.height);\n\t\t\t\tvar inVertChan = currentTerm != null && (currentHint.x >= currentTerm.x &&\n\t\t\t\t\t\tcurrentHint.x <= currentTerm.x + currentTerm.width);\n\n\t\t\t\thozChan = fixedHozAlign || (currentPt == null && inHozChan);\n\t\t\t\tvertChan = fixedVertAlign || (currentPt == null && inVertChan);\n\t\t\t\t\n\t\t\t\t// If the current hint falls in both the hor and vert channels in the case\n\t\t\t\t// of a floating port, or if the hint is exactly co-incident with a \n\t\t\t\t// fixed point, ignore the source and try to work out the orientation\n\t\t\t\t// from the target end\n\t\t\t\tif (i==0 && ((hozChan && vertChan) || (fixedVertAlign && fixedHozAlign)))\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (currentPt != null && (!fixedHozAlign && !fixedVertAlign) && (inHozChan || inVertChan)) \n\t\t\t\t\t{\n\t\t\t\t\t\thorizontal = inHozChan ? false : true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t\tif (vertChan || hozChan)\n\t\t\t\t\t{\n\t\t\t\t\t\thorizontal = hozChan;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Work back from target end\n\t\t\t\t\t\t\thorizontal = hints.length % 2 == 0 ? hozChan : vertChan;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcurrentTerm = target;\n\t\t\t\tcurrentPt = pts[lastInx];\n\t\t\t\t\n\t\t\t\tif (currentPt != null)\n\t\t\t\t{\n\t\t\t\t\tcurrentTerm = null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcurrentHint = hints[hints.length - 1];\n\t\t\t\t\n\t\t\t\tif (fixedVertAlign && fixedHozAlign)\n\t\t\t\t{\n\t\t\t\t\thints = hints.slice(1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (horizontal && ((pts[0] != null && pts[0].y != hint.y) ||\n\t\t\t\t(pts[0] == null && source != null &&\n\t\t\t\t(hint.y < source.y || hint.y > source.y + source.height))))\n\t\t\t{\n\t\t\t\tpushPoint(new mxPoint(pt.x, hint.y));\n\t\t\t}\n\t\t\telse if (!horizontal && ((pts[0] != null && pts[0].x != hint.x) ||\n\t\t\t\t\t(pts[0] == null && source != null &&\n\t\t\t\t\t(hint.x < source.x || hint.x > source.x + source.width))))\n\t\t\t{\n\t\t\t\tpushPoint(new mxPoint(hint.x, pt.y));\n\t\t\t}\n\t\t\t\n\t\t\tif (horizontal)\n\t\t\t{\n\t\t\t\tpt.y = hint.y;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpt.x = hint.x;\n\t\t\t}\n\t\t\n\t\t\tfor (var i = 0; i < hints.length; i++)\n\t\t\t{\n\t\t\t\thorizontal = !horizontal;\n\t\t\t\thint = hints[i];\n\t\t\t\t\n//\t\t\t\tmxLog.show();\n//\t\t\t\tmxLog.debug('hint', i, hint.x, hint.y);\n\t\t\t\t\n\t\t\t\tif (horizontal)\n\t\t\t\t{\n\t\t\t\t\tpt.y = hint.y;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpt.x = hint.x;\n\t\t\t\t}\n\t\t\n\t\t\t\tpushPoint(pt.clone());\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\thint = pt;\n\t\t\t// FIXME: First click in connect preview toggles orientation\n\t\t\thorizontal = true;\n\t\t}\n\n\t\t// Adds the last point\n\t\tpt = pts[lastInx];\n\n\t\tif (pt == null && target != null)\n\t\t{\n\t\t\tpt = new mxPoint(state.view.getRoutingCenterX(target), state.view.getRoutingCenterY(target));\n\t\t}\n\t\t\n\t\tif (pt != null)\n\t\t{\n\t\t\tif (hint != null)\n\t\t\t{\n\t\t\t\tif (horizontal && ((pts[lastInx] != null && pts[lastInx].y != hint.y) ||\n\t\t\t\t\t(pts[lastInx] == null && target != null &&\n\t\t\t\t\t(hint.y < target.y || hint.y > target.y + target.height))))\n\t\t\t\t{\n\t\t\t\t\tpushPoint(new mxPoint(pt.x, hint.y));\n\t\t\t\t}\n\t\t\t\telse if (!horizontal && ((pts[lastInx] != null && pts[lastInx].x != hint.x) ||\n\t\t\t\t\t\t(pts[lastInx] == null && target != null &&\n\t\t\t\t\t\t(hint.x < target.x || hint.x > target.x + target.width))))\n\t\t\t\t{\n\t\t\t\t\tpushPoint(new mxPoint(hint.x, pt.y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Removes bends inside the source terminal for floating ports\n\t\tif (pts[0] == null && source != null)\n\t\t{\n\t\t\twhile (result.length > 1 && result[1] != null &&\n\t\t\t\tmxUtils.contains(source, result[1].x, result[1].y))\n\t\t\t{\n\t\t\t\tresult.splice(1, 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Removes bends inside the target terminal\n\t\tif (pts[lastInx] == null && target != null)\n\t\t{\n\t\t\twhile (result.length > 1 && result[result.length - 1] != null &&\n\t\t\t\tmxUtils.contains(target, result[result.length - 1].x, result[result.length - 1].y))\n\t\t\t{\n\t\t\t\tresult.splice(result.length - 1, 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Removes last point if inside tolerance with end point\n\t\tif (pe != null && result[result.length - 1] != null &&\n\t\t\tMath.abs(pe.x - result[result.length - 1].x) <= tol &&\n\t\t\tMath.abs(pe.y - result[result.length - 1].y) <= tol)\n\t\t{\n\t\t\tresult.splice(result.length - 1, 1);\n\t\t\t\n\t\t\t// Lines up second last point in result with end point\n\t\t\tif (result[result.length - 1] != null)\n\t\t\t{\n\t\t\t\tif (Math.abs(result[result.length - 1].x - pe.x) < tol)\n\t\t\t\t{\n\t\t\t\t\tresult[result.length - 1].x = pe.x;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (Math.abs(result[result.length - 1].y - pe.y) < tol)\n\t\t\t\t{\n\t\t\t\t\tresult[result.length - 1].y = pe.y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t\n\torthBuffer: 10,\n\t\n\torthPointsFallback: true,\n\n\tdirVectors: [ [ -1, 0 ],\n\t\t\t[ 0, -1 ], [ 1, 0 ], [ 0, 1 ], [ -1, 0 ], [ 0, -1 ], [ 1, 0 ] ],\n\n\twayPoints1: [ [ 0, 0], [ 0, 0],  [ 0, 0], [ 0, 0], [ 0, 0],  [ 0, 0],\n\t              [ 0, 0],  [ 0, 0], [ 0, 0],  [ 0, 0], [ 0, 0],  [ 0, 0] ],\n\n\troutePatterns: [\n\t\t[ [ 513, 2308, 2081, 2562 ], [ 513, 1090, 514, 2184, 2114, 2561 ],\n\t\t\t[ 513, 1090, 514, 2564, 2184, 2562 ],\n\t\t\t[ 513, 2308, 2561, 1090, 514, 2568, 2308 ] ],\n\t[ [ 514, 1057, 513, 2308, 2081, 2562 ], [ 514, 2184, 2114, 2561 ],\n\t\t\t[ 514, 2184, 2562, 1057, 513, 2564, 2184 ],\n\t\t\t[ 514, 1057, 513, 2568, 2308, 2561 ] ],\n\t[ [ 1090, 514, 1057, 513, 2308, 2081, 2562 ], [ 2114, 2561 ],\n\t\t\t[ 1090, 2562, 1057, 513, 2564, 2184 ],\n\t\t\t[ 1090, 514, 1057, 513, 2308, 2561, 2568 ] ],\n\t[ [ 2081, 2562 ], [ 1057, 513, 1090, 514, 2184, 2114, 2561 ],\n\t\t\t[ 1057, 513, 1090, 514, 2184, 2562, 2564 ],\n\t\t\t[ 1057, 2561, 1090, 514, 2568, 2308 ] ] ],\n\t\n\tinlineRoutePatterns: [\n\t\t\t[ null, [ 2114, 2568 ], null, null ],\n\t\t\t[ null, [ 514, 2081, 2114, 2568 ] , null, null ],\n\t\t\t[ null, [ 2114, 2561 ], null, null ],\n\t\t\t[ [ 2081, 2562 ], [ 1057, 2114, 2568 ],\n\t\t\t\t\t[ 2184, 2562 ],\n\t\t\t\t\tnull ] ],\n\tvertexSeperations: [],\n\n\tlimits: [\n\t       [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\n\t       [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ] ],\n\n\tLEFT_MASK: 32,\n\n\tTOP_MASK: 64,\n\n\tRIGHT_MASK: 128,\n\n\tBOTTOM_MASK: 256,\n\n\tLEFT: 1,\n\n\tTOP: 2,\n\n\tRIGHT: 4,\n\n\tBOTTOM: 8,\n\n\t// TODO remove magic numbers\n\tSIDE_MASK: 480,\n\t//mxEdgeStyle.LEFT_MASK | mxEdgeStyle.TOP_MASK | mxEdgeStyle.RIGHT_MASK\n\t//| mxEdgeStyle.BOTTOM_MASK,\n\n\tCENTER_MASK: 512,\n\n\tSOURCE_MASK: 1024,\n\n\tTARGET_MASK: 2048,\n\n\tVERTEX_MASK: 3072,\n\t// mxEdgeStyle.SOURCE_MASK | mxEdgeStyle.TARGET_MASK,\n\t\n\tgetJettySize: function(state, isSource)\n\t{\n\t\tvar value = mxUtils.getValue(state.style, (isSource) ? mxConstants.STYLE_SOURCE_JETTY_SIZE :\n\t\t\tmxConstants.STYLE_TARGET_JETTY_SIZE, mxUtils.getValue(state.style,\n\t\t\t\t\tmxConstants.STYLE_JETTY_SIZE, mxEdgeStyle.orthBuffer));\n\t\t\n\t\tif (value == 'auto')\n\t\t{\n\t\t\t// Computes the automatic jetty size\n\t\t\tvar type = mxUtils.getValue(state.style, (isSource) ? mxConstants.STYLE_STARTARROW : mxConstants.STYLE_ENDARROW, mxConstants.NONE);\n\t\t\t\n\t\t\tif (type != mxConstants.NONE)\n\t\t\t{\n\t\t\t\tvar size = mxUtils.getNumber(state.style, (isSource) ? mxConstants.STYLE_STARTSIZE : mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE);\n\t\t\t\tvalue = Math.max(2, Math.ceil((size + mxEdgeStyle.orthBuffer) / mxEdgeStyle.orthBuffer)) * mxEdgeStyle.orthBuffer;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvalue = 2 * mxEdgeStyle.orthBuffer;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn value;\n\t},\n\t\n\t/**\n\t * Function: scalePointArray\n\t * \n\t * Scales an array of <mxPoint>\n\t * \n\t * Parameters:\n\t * \n\t * points - array of <mxPoint> to scale\n\t * scale - the scaling to divide by\n\t * \n\t */\n\tscalePointArray: function(points, scale)\n\t{\n\t\tvar result = [];\n\n\t\tif (points != null)\n\t\t{\n\t\t\tfor (var i = 0; i < points.length; i++)\n\t\t\t{\n\t\t\t\tif (points[i] != null)\n\t\t\t\t{\n\t\t\t\t\tvar pt = new mxPoint(Math.round(points[i].x / scale * 10) / 10,\n\t\t\t\t\t\t\t\t\t\tMath.round(points[i].y / scale * 10) / 10);\n\t\t\t\t\tresult[i] = pt;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult[i] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = null;\n\t\t}\n\t\t\n\t\treturn result;\n\t},\n\t\n\t/**\n\t * Function: scaleCellState\n\t * \n\t * Scales an <mxCellState>\n\t * \n\t * Parameters:\n\t * \n\t * state - <mxCellState> to scale\n\t * scale - the scaling to divide by\n\t * \n\t */\n\tscaleCellState: function(state, scale)\n\t{\n\t\tvar result = null;\n\n\t\tif (state != null)\n\t\t{\n\t\t\tresult = state.clone();\n\t\t\tresult.setRect(Math.round(state.x / scale * 10) / 10,\n\t\t\t\t\t\t\tMath.round(state.y / scale * 10) / 10,\n\t\t\t\t\t\t\tMath.round(state.width / scale * 10) / 10,\n\t\t\t\t\t\t\tMath.round(state.height / scale * 10) / 10);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = null;\n\t\t}\n\t\t\n\t\treturn result;\n\t},\n\n\t/**\n\t * Function: OrthConnector\n\t * \n\t * Implements a local orthogonal router between the given\n\t * cells.\n\t * \n\t * Parameters:\n\t * \n\t * state - <mxCellState> that represents the edge to be updated.\n\t * sourceScaled - <mxCellState> that represents the source terminal.\n\t * targetScaled - <mxCellState> that represents the target terminal.\n\t * controlHints - List of relative control points.\n\t * result - Array of <mxPoints> that represent the actual points of the\n\t * edge.\n\t * \n\t */\n\tOrthConnector: function(state, sourceScaled, targetScaled, controlHints, result)\n\t{\n\t\tvar graph = state.view.graph;\n\t\tvar sourceEdge = source == null ? false : graph.getModel().isEdge(source.cell);\n\t\tvar targetEdge = target == null ? false : graph.getModel().isEdge(target.cell);\n\n\t\tvar pts = mxEdgeStyle.scalePointArray(state.absolutePoints, state.view.scale);\n\t\tvar source = mxEdgeStyle.scaleCellState(sourceScaled, state.view.scale);\n\t\tvar target = mxEdgeStyle.scaleCellState(targetScaled, state.view.scale);\n\n\t\tvar p0 = pts[0];\n\t\tvar pe = pts[pts.length-1];\n\t\t\n\t\tvar sourceX = source != null ? source.x : p0.x;\n\t\tvar sourceY = source != null ? source.y : p0.y;\n\t\tvar sourceWidth = source != null ? source.width : 0;\n\t\tvar sourceHeight = source != null ? source.height : 0;\n\t\t\n\t\tvar targetX = target != null ? target.x : pe.x;\n\t\tvar targetY = target != null ? target.y : pe.y;\n\t\tvar targetWidth = target != null ? target.width : 0;\n\t\tvar targetHeight = target != null ? target.height : 0;\n\n\t\tvar sourceBuffer = mxEdgeStyle.getJettySize(state, true);\n\t\tvar targetBuffer = mxEdgeStyle.getJettySize(state, false);\n\t\t\n\t\t//console.log('sourceBuffer', sourceBuffer);\n\t\t//console.log('targetBuffer', targetBuffer);\n\t\t// Workaround for loop routing within buffer zone\n\t\tif (source != null && target == source)\n\t\t{\n\t\t\ttargetBuffer = Math.max(sourceBuffer, targetBuffer);\n\t\t\tsourceBuffer = targetBuffer;\n\t\t}\n\t\t\n\t\tvar totalBuffer = targetBuffer + sourceBuffer;\n\t\t// console.log('totalBuffer', totalBuffer);\n\t\tvar tooShort = false;\n\t\t\n\t\t// Checks minimum distance for fixed points and falls back to segment connector\n\t\tif (p0 != null && pe != null)\n\t\t{\n\t\t\tvar dx = pe.x - p0.x;\n\t\t\tvar dy = pe.y - p0.y;\n\t\t\t\n\t\t\ttooShort = dx * dx + dy * dy < totalBuffer * totalBuffer;\n\t\t}\n\n\t\tif (tooShort || (mxEdgeStyle.orthPointsFallback && (controlHints != null &&\n\t\t\t\tcontrolHints.length > 0)) || sourceEdge || targetEdge)\n\t\t{\n\t\t\tmxEdgeStyle.SegmentConnector(state, sourceScaled, targetScaled, controlHints, result);\n\t\t\t\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine the side(s) of the source and target vertices\n\t\t// that the edge may connect to\n\t\t// portConstraint [source, target]\n\t\tvar portConstraint = [mxConstants.DIRECTION_MASK_ALL, mxConstants.DIRECTION_MASK_ALL];\n\t\tvar rotation = 0;\n\t\t\n\t\tif (source != null)\n\t\t{\n\t\t\tportConstraint[0] = mxUtils.getPortConstraints(source, state, true, \n\t\t\t\t\tmxConstants.DIRECTION_MASK_ALL);\n\t\t\trotation = mxUtils.getValue(source.style, mxConstants.STYLE_ROTATION, 0);\n\t\t\t\n\t\t\t//console.log('source rotation', rotation);\n\t\t\t\n\t\t\tif (rotation != 0)\n\t\t\t{\n\t\t\t\tvar newRect = mxUtils.getBoundingBox(new mxRectangle(sourceX, sourceY, sourceWidth, sourceHeight), rotation);\n\t\t\t\tsourceX = newRect.x; \n\t\t\t\tsourceY = newRect.y;\n\t\t\t\tsourceWidth = newRect.width;\n\t\t\t\tsourceHeight = newRect.height;\n\t\t\t}\n\t\t}\n\n\t\tif (target != null)\n\t\t{\n\t\t\tportConstraint[1] = mxUtils.getPortConstraints(target, state, false,\n\t\t\t\tmxConstants.DIRECTION_MASK_ALL);\n\t\t\trotation = mxUtils.getValue(target.style, mxConstants.STYLE_ROTATION, 0);\n\t\t\t\n\t\t\t//console.log('target rotation', rotation);\n\n\t\t\tif (rotation != 0)\n\t\t\t{\n\t\t\t\tvar newRect = mxUtils.getBoundingBox(new mxRectangle(targetX, targetY, targetWidth, targetHeight), rotation);\n\t\t\t\ttargetX = newRect.x;\n\t\t\t\ttargetY = newRect.y;\n\t\t\t\ttargetWidth = newRect.width;\n\t\t\t\ttargetHeight = newRect.height;\n\t\t\t}\n\t\t}\n\n\t\t//console.log('source' , sourceX, sourceY, sourceWidth, sourceHeight);\n\t\t//console.log('targetX' , targetX, targetY, targetWidth, targetHeight);\n\n\t\tvar dir = [0, 0];\n\n\t\t// Work out which faces of the vertices present against each other\n\t\t// in a way that would allow a 3-segment connection if port constraints\n\t\t// permitted.\n\t\t// geo -> [source, target] [x, y, width, height]\n\t\tvar geo = [ [sourceX, sourceY, sourceWidth, sourceHeight] ,\n\t\t            [targetX, targetY, targetWidth, targetHeight] ];\n\t\tvar buffer = [sourceBuffer, targetBuffer];\n\n\t\tfor (var i = 0; i < 2; i++)\n\t\t{\n\t\t\tmxEdgeStyle.limits[i][1] = geo[i][0] - buffer[i];\n\t\t\tmxEdgeStyle.limits[i][2] = geo[i][1] - buffer[i];\n\t\t\tmxEdgeStyle.limits[i][4] = geo[i][0] + geo[i][2] + buffer[i];\n\t\t\tmxEdgeStyle.limits[i][8] = geo[i][1] + geo[i][3] + buffer[i];\n\t\t}\n\t\t\n\t\t// Work out which quad the target is in\n\t\tvar sourceCenX = geo[0][0] + geo[0][2] / 2.0;\n\t\tvar sourceCenY = geo[0][1] + geo[0][3] / 2.0;\n\t\tvar targetCenX = geo[1][0] + geo[1][2] / 2.0;\n\t\tvar targetCenY = geo[1][1] + geo[1][3] / 2.0;\n\t\t\n\t\tvar dx = sourceCenX - targetCenX;\n\t\tvar dy = sourceCenY - targetCenY;\n\n\t\tvar quad = 0;\n\n\t\t// 0 | 1\n\t\t// -----\n\t\t// 3 | 2\n\t\t\n\t\tif (dx < 0)\n\t\t{\n\t\t\tif (dy < 0)\n\t\t\t{\n\t\t\t\tquad = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tquad = 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (dy <= 0)\n\t\t\t{\n\t\t\t\tquad = 3;\n\t\t\t\t\n\t\t\t\t// Special case on x = 0 and negative y\n\t\t\t\tif (dx == 0)\n\t\t\t\t{\n\t\t\t\t\tquad = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//console.log('quad', quad);\n\n\t\t// Check for connection constraints\n\t\tvar currentTerm = null;\n\t\t\n\t\tif (source != null)\n\t\t{\n\t\t\tcurrentTerm = p0;\n\t\t}\n\n\t\tvar constraint = [ [0.5, 0.5] , [0.5, 0.5] ];\n\n\t\tfor (var i = 0; i < 2; i++)\n\t\t{\n\t\t\tif (currentTerm != null)\n\t\t\t{\n\t\t\t\tconstraint[i][0] = (currentTerm.x - geo[i][0]) / geo[i][2];\n\t\t\t\t\n\t\t\t\tif (Math.abs(currentTerm.x - geo[i][0]) <= 1)\n\t\t\t\t{\n\t\t\t\t\tdir[i] = mxConstants.DIRECTION_MASK_WEST;\n\t\t\t\t}\n\t\t\t\telse if (Math.abs(currentTerm.x - geo[i][0] - geo[i][2]) <= 1)\n\t\t\t\t{\n\t\t\t\t\tdir[i] = mxConstants.DIRECTION_MASK_EAST;\n\t\t\t\t}\n\n\t\t\t\tconstraint[i][1] = (currentTerm.y - geo[i][1]) / geo[i][3];\n\n\t\t\t\tif (Math.abs(currentTerm.y - geo[i][1]) <= 1)\n\t\t\t\t{\n\t\t\t\t\tdir[i] = mxConstants.DIRECTION_MASK_NORTH;\n\t\t\t\t}\n\t\t\t\telse if (Math.abs(currentTerm.y - geo[i][1] - geo[i][3]) <= 1)\n\t\t\t\t{\n\t\t\t\t\tdir[i] = mxConstants.DIRECTION_MASK_SOUTH;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrentTerm = null;\n\t\t\t\n\t\t\tif (target != null)\n\t\t\t{\n\t\t\t\tcurrentTerm = pe;\n\t\t\t}\n\t\t}\n\n\t\tvar sourceTopDist = geo[0][1] - (geo[1][1] + geo[1][3]);\n\t\tvar sourceLeftDist = geo[0][0] - (geo[1][0] + geo[1][2]);\n\t\tvar sourceBottomDist = geo[1][1] - (geo[0][1] + geo[0][3]);\n\t\tvar sourceRightDist = geo[1][0] - (geo[0][0] + geo[0][2]);\n\n\t\tmxEdgeStyle.vertexSeperations[1] = Math.max(sourceLeftDist - totalBuffer, 0);\n\t\tmxEdgeStyle.vertexSeperations[2] = Math.max(sourceTopDist - totalBuffer, 0);\n\t\tmxEdgeStyle.vertexSeperations[4] = Math.max(sourceBottomDist - totalBuffer, 0);\n\t\tmxEdgeStyle.vertexSeperations[3] = Math.max(sourceRightDist - totalBuffer, 0);\n\t\t\t\t\n\t\t//==============================================================\n\t\t// Start of source and target direction determination\n\n\t\t// Work through the preferred orientations by relative positioning\n\t\t// of the vertices and list them in preferred and available order\n\t\t\n\t\tvar dirPref = [];\n\t\tvar horPref = [];\n\t\tvar vertPref = [];\n\n\t\thorPref[0] = (sourceLeftDist >= sourceRightDist) ? mxConstants.DIRECTION_MASK_WEST\n\t\t\t\t: mxConstants.DIRECTION_MASK_EAST;\n\t\tvertPref[0] = (sourceTopDist >= sourceBottomDist) ? mxConstants.DIRECTION_MASK_NORTH\n\t\t\t\t: mxConstants.DIRECTION_MASK_SOUTH;\n\n\t\thorPref[1] = mxUtils.reversePortConstraints(horPref[0]);\n\t\tvertPref[1] = mxUtils.reversePortConstraints(vertPref[0]);\n\t\t\n\t\tvar preferredHorizDist = sourceLeftDist >= sourceRightDist ? sourceLeftDist\n\t\t\t\t: sourceRightDist;\n\t\tvar preferredVertDist = sourceTopDist >= sourceBottomDist ? sourceTopDist\n\t\t\t\t: sourceBottomDist;\n\n\t\tvar prefOrdering = [ [0, 0] , [0, 0] ];\n\t\tvar preferredOrderSet = false;\n\n\t\t// If the preferred port isn't available, switch it\n\t\tfor (var i = 0; i < 2; i++)\n\t\t{\n\t\t\tif (dir[i] != 0x0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((horPref[i] & portConstraint[i]) == 0)\n\t\t\t{\n\t\t\t\thorPref[i] = mxUtils.reversePortConstraints(horPref[i]);\n\t\t\t}\n\n\t\t\tif ((vertPref[i] & portConstraint[i]) == 0)\n\t\t\t{\n\t\t\t\tvertPref[i] = mxUtils\n\t\t\t\t\t\t.reversePortConstraints(vertPref[i]);\n\t\t\t}\n\n\t\t\tprefOrdering[i][0] = vertPref[i];\n\t\t\tprefOrdering[i][1] = horPref[i];\n\t\t}\n\n\t\tif (preferredVertDist > 0\n\t\t\t\t&& preferredHorizDist > 0)\n\t\t{\n\t\t\t// Possibility of two segment edge connection\n\t\t\tif (((horPref[0] & portConstraint[0]) > 0)\n\t\t\t\t\t&& ((vertPref[1] & portConstraint[1]) > 0))\n\t\t\t{\n\t\t\t\tprefOrdering[0][0] = horPref[0];\n\t\t\t\tprefOrdering[0][1] = vertPref[0];\n\t\t\t\tprefOrdering[1][0] = vertPref[1];\n\t\t\t\tprefOrdering[1][1] = horPref[1];\n\t\t\t\tpreferredOrderSet = true;\n\t\t\t}\n\t\t\telse if (((vertPref[0] & portConstraint[0]) > 0)\n\t\t\t\t\t&& ((horPref[1] & portConstraint[1]) > 0))\n\t\t\t{\n\t\t\t\tprefOrdering[0][0] = vertPref[0];\n\t\t\t\tprefOrdering[0][1] = horPref[0];\n\t\t\t\tprefOrdering[1][0] = horPref[1];\n\t\t\t\tprefOrdering[1][1] = vertPref[1];\n\t\t\t\tpreferredOrderSet = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (preferredVertDist > 0 && !preferredOrderSet)\n\t\t{\n\t\t\tprefOrdering[0][0] = vertPref[0];\n\t\t\tprefOrdering[0][1] = horPref[0];\n\t\t\tprefOrdering[1][0] = vertPref[1];\n\t\t\tprefOrdering[1][1] = horPref[1];\n\t\t\tpreferredOrderSet = true;\n\n\t\t}\n\t\t\n\t\tif (preferredHorizDist > 0 && !preferredOrderSet)\n\t\t{\n\t\t\tprefOrdering[0][0] = horPref[0];\n\t\t\tprefOrdering[0][1] = vertPref[0];\n\t\t\tprefOrdering[1][0] = horPref[1];\n\t\t\tprefOrdering[1][1] = vertPref[1];\n\t\t\tpreferredOrderSet = true;\n\t\t}\n\n\t\t// The source and target prefs are now an ordered list of\n\t\t// the preferred port selections\n\t\t// If the list contains gaps, compact it\n\n\t\tfor (var i = 0; i < 2; i++)\n\t\t{\n\t\t\tif (dir[i] != 0x0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((prefOrdering[i][0] & portConstraint[i]) == 0)\n\t\t\t{\n\t\t\t\tprefOrdering[i][0] = prefOrdering[i][1];\n\t\t\t}\n\n\t\t\tdirPref[i] = prefOrdering[i][0] & portConstraint[i];\n\t\t\tdirPref[i] |= (prefOrdering[i][1] & portConstraint[i]) << 8;\n\t\t\tdirPref[i] |= (prefOrdering[1 - i][i] & portConstraint[i]) << 16;\n\t\t\tdirPref[i] |= (prefOrdering[1 - i][1 - i] & portConstraint[i]) << 24;\n\n\t\t\tif ((dirPref[i] & 0xF) == 0)\n\t\t\t{\n\t\t\t\tdirPref[i] = dirPref[i] << 8;\n\t\t\t}\n\t\t\t\n\t\t\tif ((dirPref[i] & 0xF00) == 0)\n\t\t\t{\n\t\t\t\tdirPref[i] = (dirPref[i] & 0xF) | dirPref[i] >> 8;\n\t\t\t}\n\t\t\t\n\t\t\tif ((dirPref[i] & 0xF0000) == 0)\n\t\t\t{\n\t\t\t\tdirPref[i] = (dirPref[i] & 0xFFFF)\n\t\t\t\t\t\t| ((dirPref[i] & 0xF000000) >> 8);\n\t\t\t}\n\n\t\t\tdir[i] = dirPref[i] & 0xF;\n\n\t\t\tif (portConstraint[i] == mxConstants.DIRECTION_MASK_WEST\n\t\t\t\t\t|| portConstraint[i] == mxConstants.DIRECTION_MASK_NORTH\n\t\t\t\t\t|| portConstraint[i] == mxConstants.DIRECTION_MASK_EAST\n\t\t\t\t\t|| portConstraint[i] == mxConstants.DIRECTION_MASK_SOUTH)\n\t\t\t{\n\t\t\t\tdir[i] = portConstraint[i];\n\t\t\t}\n\t\t}\n\n\t\t//==============================================================\n\t\t// End of source and target direction determination\n\n\t\tvar sourceIndex = dir[0] == mxConstants.DIRECTION_MASK_EAST ? 3\n\t\t\t\t: dir[0];\n\t\tvar targetIndex = dir[1] == mxConstants.DIRECTION_MASK_EAST ? 3\n\t\t\t\t: dir[1];\n\n\t\tsourceIndex -= quad;\n\t\ttargetIndex -= quad;\n\n\t\tif (sourceIndex < 1)\n\t\t{\n\t\t\tsourceIndex += 4;\n\t\t}\n\t\t\n\t\tif (targetIndex < 1)\n\t\t{\n\t\t\ttargetIndex += 4;\n\t\t}\n\n\t\tvar routePattern = mxEdgeStyle.routePatterns[sourceIndex - 1][targetIndex - 1];\n\t\t\n\t\t//console.log('routePattern', routePattern);\n\n\t\tmxEdgeStyle.wayPoints1[0][0] = geo[0][0];\n\t\tmxEdgeStyle.wayPoints1[0][1] = geo[0][1];\n\n\t\tswitch (dir[0])\n\t\t{\n\t\t\tcase mxConstants.DIRECTION_MASK_WEST:\n\t\t\t\tmxEdgeStyle.wayPoints1[0][0] -= sourceBuffer;\n\t\t\t\tmxEdgeStyle.wayPoints1[0][1] += constraint[0][1] * geo[0][3];\n\t\t\t\tbreak;\n\t\t\tcase mxConstants.DIRECTION_MASK_SOUTH:\n\t\t\t\tmxEdgeStyle.wayPoints1[0][0] += constraint[0][0] * geo[0][2];\n\t\t\t\tmxEdgeStyle.wayPoints1[0][1] += geo[0][3] + sourceBuffer;\n\t\t\t\tbreak;\n\t\t\tcase mxConstants.DIRECTION_MASK_EAST:\n\t\t\t\tmxEdgeStyle.wayPoints1[0][0] += geo[0][2] + sourceBuffer;\n\t\t\t\tmxEdgeStyle.wayPoints1[0][1] += constraint[0][1] * geo[0][3];\n\t\t\t\tbreak;\n\t\t\tcase mxConstants.DIRECTION_MASK_NORTH:\n\t\t\t\tmxEdgeStyle.wayPoints1[0][0] += constraint[0][0] * geo[0][2];\n\t\t\t\tmxEdgeStyle.wayPoints1[0][1] -= sourceBuffer;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tvar currentIndex = 0;\n\n\t\t// Orientation, 0 horizontal, 1 vertical\n\t\tvar lastOrientation = (dir[0] & (mxConstants.DIRECTION_MASK_EAST | mxConstants.DIRECTION_MASK_WEST)) > 0 ? 0\n\t\t\t\t: 1;\n\t\tvar initialOrientation = lastOrientation;\n\t\tvar currentOrientation = 0;\n\n\t\tfor (var i = 0; i < routePattern.length; i++)\n\t\t{\n\t\t\tvar nextDirection = routePattern[i] & 0xF;\n\n\t\t\t// Rotate the index of this direction by the quad\n\t\t\t// to get the real direction\n\t\t\tvar directionIndex = nextDirection == mxConstants.DIRECTION_MASK_EAST ? 3\n\t\t\t\t\t: nextDirection;\n\n\t\t\tdirectionIndex += quad;\n\n\t\t\tif (directionIndex > 4)\n\t\t\t{\n\t\t\t\tdirectionIndex -= 4;\n\t\t\t}\n\n\t\t\tvar direction = mxEdgeStyle.dirVectors[directionIndex - 1];\n\n\t\t\tcurrentOrientation = (directionIndex % 2 > 0) ? 0 : 1;\n\t\t\t// Only update the current index if the point moved\n\t\t\t// in the direction of the current segment move,\n\t\t\t// otherwise the same point is moved until there is \n\t\t\t// a segment direction change\n\t\t\tif (currentOrientation != lastOrientation)\n\t\t\t{\n\t\t\t\tcurrentIndex++;\n\t\t\t\t// Copy the previous way point into the new one\n\t\t\t\t// We can't base the new position on index - 1\n\t\t\t\t// because sometime elbows turn out not to exist,\n\t\t\t\t// then we'd have to rewind.\n\t\t\t\tmxEdgeStyle.wayPoints1[currentIndex][0] = mxEdgeStyle.wayPoints1[currentIndex - 1][0];\n\t\t\t\tmxEdgeStyle.wayPoints1[currentIndex][1] = mxEdgeStyle.wayPoints1[currentIndex - 1][1];\n\t\t\t}\n\n\t\t\tvar tar = (routePattern[i] & mxEdgeStyle.TARGET_MASK) > 0;\n\t\t\tvar sou = (routePattern[i] & mxEdgeStyle.SOURCE_MASK) > 0;\n\t\t\tvar side = (routePattern[i] & mxEdgeStyle.SIDE_MASK) >> 5;\n\t\t\tside = side << quad;\n\n\t\t\tif (side > 0xF)\n\t\t\t{\n\t\t\t\tside = side >> 4;\n\t\t\t}\n\n\t\t\tvar center = (routePattern[i] & mxEdgeStyle.CENTER_MASK) > 0;\n\n\t\t\tif ((sou || tar) && side < 9)\n\t\t\t{\n\t\t\t\tvar limit = 0;\n\t\t\t\tvar souTar = sou ? 0 : 1;\n\n\t\t\t\tif (center && currentOrientation == 0)\n\t\t\t\t{\n\t\t\t\t\tlimit = geo[souTar][0] + constraint[souTar][0] * geo[souTar][2];\n\t\t\t\t}\n\t\t\t\telse if (center)\n\t\t\t\t{\n\t\t\t\t\tlimit = geo[souTar][1] + constraint[souTar][1] * geo[souTar][3];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlimit = mxEdgeStyle.limits[souTar][side];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentOrientation == 0)\n\t\t\t\t{\n\t\t\t\t\tvar lastX = mxEdgeStyle.wayPoints1[currentIndex][0];\n\t\t\t\t\tvar deltaX = (limit - lastX) * direction[0];\n\n\t\t\t\t\tif (deltaX > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tmxEdgeStyle.wayPoints1[currentIndex][0] += direction[0]\n\t\t\t\t\t\t\t\t* deltaX;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar lastY = mxEdgeStyle.wayPoints1[currentIndex][1];\n\t\t\t\t\tvar deltaY = (limit - lastY) * direction[1];\n\n\t\t\t\t\tif (deltaY > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tmxEdgeStyle.wayPoints1[currentIndex][1] += direction[1]\n\t\t\t\t\t\t\t\t* deltaY;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (center)\n\t\t\t{\n\t\t\t\t// Which center we're travelling to depend on the current direction\n\t\t\t\tmxEdgeStyle.wayPoints1[currentIndex][0] += direction[0]\n\t\t\t\t\t\t* Math.abs(mxEdgeStyle.vertexSeperations[directionIndex] / 2);\n\t\t\t\tmxEdgeStyle.wayPoints1[currentIndex][1] += direction[1]\n\t\t\t\t\t\t* Math.abs(mxEdgeStyle.vertexSeperations[directionIndex] / 2);\n\t\t\t}\n\n\t\t\tif (currentIndex > 0\n\t\t\t\t\t&& mxEdgeStyle.wayPoints1[currentIndex][currentOrientation] == mxEdgeStyle.wayPoints1[currentIndex - 1][currentOrientation])\n\t\t\t{\n\t\t\t\tcurrentIndex--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlastOrientation = currentOrientation;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i <= currentIndex; i++)\n\t\t{\n\t\t\tif (i == currentIndex)\n\t\t\t{\n\t\t\t\t// Last point can cause last segment to be in\n\t\t\t\t// same direction as jetty/approach. If so,\n\t\t\t\t// check the number of points is consistent\n\t\t\t\t// with the relative orientation of source and target\n\t\t\t\t// jx. Same orientation requires an even\n\t\t\t\t// number of turns (points), different requires\n\t\t\t\t// odd.\n\t\t\t\tvar targetOrientation = (dir[1] & (mxConstants.DIRECTION_MASK_EAST | mxConstants.DIRECTION_MASK_WEST)) > 0 ? 0\n\t\t\t\t\t\t: 1;\n\t\t\t\tvar sameOrient = targetOrientation == initialOrientation ? 0 : 1;\n\n\t\t\t\t// (currentIndex + 1) % 2 is 0 for even number of points,\n\t\t\t\t// 1 for odd\n\t\t\t\tif (sameOrient != (currentIndex + 1) % 2)\n\t\t\t\t{\n\t\t\t\t\t// The last point isn't required\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tresult.push(new mxPoint(Math.round(mxEdgeStyle.wayPoints1[i][0] * state.view.scale * 10) / 10,\n\t\t\t\t\t\t\t\t\tMath.round(mxEdgeStyle.wayPoints1[i][1] * state.view.scale * 10) / 10));\n\t\t}\n\t\t\n\t\t//console.log(result);\n\n\t\t// Removes duplicates\n\t\tvar index = 1;\n\t\t\n\t\twhile (index < result.length)\n\t\t{\n\t\t\tif (result[index - 1] == null || result[index] == null ||\n\t\t\t\tresult[index - 1].x != result[index].x ||\n\t\t\t\tresult[index - 1].y != result[index].y)\n\t\t\t{\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.splice(index, 1);\n\t\t\t}\n\t\t}\n\t},\n\t\n\tgetRoutePattern: function(dir, quad, dx, dy)\n\t{\n\t\tvar sourceIndex = dir[0] == mxConstants.DIRECTION_MASK_EAST ? 3\n\t\t\t\t: dir[0];\n\t\tvar targetIndex = dir[1] == mxConstants.DIRECTION_MASK_EAST ? 3\n\t\t\t\t: dir[1];\n\n\t\tsourceIndex -= quad;\n\t\ttargetIndex -= quad;\n\n\t\tif (sourceIndex < 1)\n\t\t{\n\t\t\tsourceIndex += 4;\n\t\t}\n\t\tif (targetIndex < 1)\n\t\t{\n\t\t\ttargetIndex += 4;\n\t\t}\n\n\t\tvar result = routePatterns[sourceIndex - 1][targetIndex - 1];\n\n\t\tif (dx == 0 || dy == 0)\n\t\t{\n\t\t\tif (inlineRoutePatterns[sourceIndex - 1][targetIndex - 1] != null)\n\t\t\t{\n\t\t\t\tresult = inlineRoutePatterns[sourceIndex - 1][targetIndex - 1];\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n};\n__mxOutput.mxEdgeStyle = typeof mxEdgeStyle !== 'undefined' ? mxEdgeStyle : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxStyleRegistry =\n{\n\t/**\n\t * Class: mxStyleRegistry\n\t *\n\t * Singleton class that acts as a global converter from string to object values\n\t * in a style. This is currently only used to perimeters and edge styles.\n\t * \n\t * Variable: values\n\t *\n\t * Maps from strings to objects.\n\t */\n\tvalues: [],\n\n\t/**\n\t * Function: putValue\n\t *\n\t * Puts the given object into the registry under the given name.\n\t */\n\tputValue: function(name, obj)\n\t{\n\t\tmxStyleRegistry.values[name] = obj;\n\t},\n\n\t/**\n\t * Function: getValue\n\t *\n\t * Returns the value associated with the given name.\n\t */\n\tgetValue: function(name)\n\t{\n\t\treturn mxStyleRegistry.values[name];\n\t},\n\t\n\t/**\n\t * Function: getName\n\t * \n\t * Returns the name for the given value.\n\t */\n\tgetName: function(value)\n\t{\n\t\tfor (var key in mxStyleRegistry.values)\n\t\t{\n\t\t\tif (mxStyleRegistry.values[key] == value)\n\t\t\t{\n\t\t\t\treturn key;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\n};\n\nmxStyleRegistry.putValue(mxConstants.EDGESTYLE_ELBOW, mxEdgeStyle.ElbowConnector);\nmxStyleRegistry.putValue(mxConstants.EDGESTYLE_ENTITY_RELATION, mxEdgeStyle.EntityRelation);\nmxStyleRegistry.putValue(mxConstants.EDGESTYLE_LOOP, mxEdgeStyle.Loop);\nmxStyleRegistry.putValue(mxConstants.EDGESTYLE_SIDETOSIDE, mxEdgeStyle.SideToSide);\nmxStyleRegistry.putValue(mxConstants.EDGESTYLE_TOPTOBOTTOM, mxEdgeStyle.TopToBottom);\nmxStyleRegistry.putValue(mxConstants.EDGESTYLE_ORTHOGONAL, mxEdgeStyle.OrthConnector);\nmxStyleRegistry.putValue(mxConstants.EDGESTYLE_SEGMENT, mxEdgeStyle.SegmentConnector);\n\nmxStyleRegistry.putValue(mxConstants.PERIMETER_ELLIPSE, mxPerimeter.EllipsePerimeter);\nmxStyleRegistry.putValue(mxConstants.PERIMETER_RECTANGLE, mxPerimeter.RectanglePerimeter);\nmxStyleRegistry.putValue(mxConstants.PERIMETER_RHOMBUS, mxPerimeter.RhombusPerimeter);\nmxStyleRegistry.putValue(mxConstants.PERIMETER_TRIANGLE, mxPerimeter.TrianglePerimeter);\nmxStyleRegistry.putValue(mxConstants.PERIMETER_HEXAGON, mxPerimeter.HexagonPerimeter);\n\n__mxOutput.mxStyleRegistry = typeof mxStyleRegistry !== 'undefined' ? mxStyleRegistry : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraphView\n *\n * Extends <mxEventSource> to implement a view for a graph. This class is in\n * charge of computing the absolute coordinates for the relative child\n * geometries, the points for perimeters and edge styles and keeping them\n * cached in <mxCellStates> for faster retrieval. The states are updated\n * whenever the model or the view state (translate, scale) changes. The scale\n * and translate are honoured in the bounds.\n * \n * Event: mxEvent.UNDO\n * \n * Fires after the root was changed in <setCurrentRoot>. The <code>edit</code>\n * property contains the <mxUndoableEdit> which contains the\n * <mxCurrentRootChange>.\n * \n * Event: mxEvent.SCALE_AND_TRANSLATE\n * \n * Fires after the scale and translate have been changed in <scaleAndTranslate>.\n * The <code>scale</code>, <code>previousScale</code>, <code>translate</code>\n * and <code>previousTranslate</code> properties contain the new and previous\n * scale and translate, respectively.\n * \n * Event: mxEvent.SCALE\n * \n * Fires after the scale was changed in <setScale>. The <code>scale</code> and\n * <code>previousScale</code> properties contain the new and previous scale.\n * \n * Event: mxEvent.TRANSLATE\n * \n * Fires after the translate was changed in <setTranslate>. The\n * <code>translate</code> and <code>previousTranslate</code> properties contain\n * the new and previous value for translate.\n * \n * Event: mxEvent.DOWN and mxEvent.UP\n * \n * Fire if the current root is changed by executing an <mxCurrentRootChange>.\n * The event name depends on the location of the root in the cell hierarchy\n * with respect to the current root. The <code>root</code> and\n * <code>previous</code> properties contain the new and previous root,\n * respectively.\n * \n * Constructor: mxGraphView\n *\n * Constructs a new view for the given <mxGraph>.\n * \n * Parameters:\n * \n * graph - Reference to the enclosing <mxGraph>.\n */\nfunction mxGraphView(graph)\n{\n\tthis.graph = graph;\n\tthis.translate = new mxPoint();\n\tthis.graphBounds = new mxRectangle();\n\tthis.states = new mxDictionary();\n};\n\n/**\n * Extends mxEventSource.\n */\nmxGraphView.prototype = new mxEventSource();\nmxGraphView.prototype.constructor = mxGraphView;\n\n/**\n *\n */\nmxGraphView.prototype.EMPTY_POINT = new mxPoint();\n\n/**\n * Variable: doneResource\n * \n * Specifies the resource key for the status message after a long operation.\n * If the resource for this key does not exist then the value is used as\n * the status message. Default is 'done'.\n */\nmxGraphView.prototype.doneResource = (mxClient.language != 'none') ? 'done' : '';\n\n/**\n * Function: updatingDocumentResource\n *\n * Specifies the resource key for the status message while the document is\n * being updated. If the resource for this key does not exist then the\n * value is used as the status message. Default is 'updatingDocument'.\n */\nmxGraphView.prototype.updatingDocumentResource = (mxClient.language != 'none') ? 'updatingDocument' : '';\n\n/**\n * Variable: allowEval\n * \n * Specifies if string values in cell styles should be evaluated using\n * <mxUtils.eval>. This will only be used if the string values can't be mapped\n * to objects using <mxStyleRegistry>. Default is false. NOTE: Enabling this\n * switch carries a possible security risk.\n */\nmxGraphView.prototype.allowEval = false;\n\n/**\n * Variable: captureDocumentGesture\n * \n * Specifies if a gesture should be captured when it goes outside of the\n * graph container. Default is true.\n */\nmxGraphView.prototype.captureDocumentGesture = true;\n\n/**\n * Variable: optimizeVmlReflows\n * \n * Specifies if the <canvas> should be hidden while rendering in IE8 standards\n * mode and quirks mode. This will significantly improve rendering performance.\n * Default is true.\n */\nmxGraphView.prototype.optimizeVmlReflows = true;\n\n/**\n * Variable: rendering\n * \n * Specifies if shapes should be created, updated and destroyed using the\n * methods of <mxCellRenderer> in <graph>. Default is true.\n */\nmxGraphView.prototype.rendering = true;\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxGraphView.prototype.graph = null;\n\n/**\n * Variable: currentRoot\n *\n * <mxCell> that acts as the root of the displayed cell hierarchy.\n */\nmxGraphView.prototype.currentRoot = null;\n\n/**\n * Variable: graphBounds\n *\n * <mxRectangle> that caches the scales, translated bounds of the current view.\n */\nmxGraphView.prototype.graphBounds = null;\n\n/**\n * Variable: scale\n * \n * Specifies the scale. Default is 1 (100%).\n */\nmxGraphView.prototype.scale = 1;\n\t\n/**\n * Variable: translate\n *\n * <mxPoint> that specifies the current translation. Default is a new\n * empty <mxPoint>.\n */\nmxGraphView.prototype.translate = null;\n\n/**\n * Variable: states\n * \n * <mxDictionary> that maps from cell IDs to <mxCellStates>.\n */\nmxGraphView.prototype.states = null;\n\n/**\n * Variable: updateStyle\n * \n * Specifies if the style should be updated in each validation step. If this\n * is false then the style is only updated if the state is created or if the\n * style of the cell was changed. Default is false.\n */\nmxGraphView.prototype.updateStyle = false;\n\n/**\n * Variable: lastNode\n * \n * During validation, this contains the last DOM node that was processed.\n */\nmxGraphView.prototype.lastNode = null;\n\n/**\n * Variable: lastHtmlNode\n * \n * During validation, this contains the last HTML DOM node that was processed.\n */\nmxGraphView.prototype.lastHtmlNode = null;\n\n/**\n * Variable: lastForegroundNode\n * \n * During validation, this contains the last edge's DOM node that was processed.\n */\nmxGraphView.prototype.lastForegroundNode = null;\n\n/**\n * Variable: lastForegroundHtmlNode\n * \n * During validation, this contains the last edge HTML DOM node that was processed.\n */\nmxGraphView.prototype.lastForegroundHtmlNode = null;\n\n/**\n * Function: getGraphBounds\n *\n * Returns <graphBounds>.\n */\nmxGraphView.prototype.getGraphBounds = function()\n{\n\treturn this.graphBounds;\n};\n\n/**\n * Function: setGraphBounds\n *\n * Sets <graphBounds>.\n */\nmxGraphView.prototype.setGraphBounds = function(value)\n{\n\tthis.graphBounds = value;\n};\n\n/**\n * Function: getBounds\n * \n * Returns the union of all <mxCellStates> for the given array of <mxCells>.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> whose bounds should be returned.\n */\nmxGraphView.prototype.getBounds = function(cells)\n{\n\tvar result = null;\n\t\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tvar model = this.graph.getModel();\n\t\t\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (model.isVertex(cells[i]) || model.isEdge(cells[i]))\n\t\t\t{\n\t\t\t\tvar state = this.getState(cells[i]);\n\t\t\t\n\t\t\t\tif (state != null)\n\t\t\t\t{\n\t\t\t\t\tif (result == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = mxRectangle.fromRectangle(state);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.add(state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: setCurrentRoot\n *\n * Sets and returns the current root and fires an <undo> event before\n * calling <mxGraph.sizeDidChange>.\n *\n * Parameters:\n *\n * root - <mxCell> that specifies the root of the displayed cell hierarchy.\n */\nmxGraphView.prototype.setCurrentRoot = function(root)\n{\n\tif (this.currentRoot != root)\n\t{\n\t\tvar change = new mxCurrentRootChange(this, root);\n\t\tchange.execute();\n\t\tvar edit = new mxUndoableEdit(this, true);\n\t\tedit.add(change);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.UNDO, 'edit', edit));\n\t\tthis.graph.sizeDidChange();\n\t}\n\t\n\treturn root;\n};\n\n/**\n * Function: scaleAndTranslate\n *\n * Sets the scale and translation and fires a <scale> and <translate> event\n * before calling <revalidate> followed by <mxGraph.sizeDidChange>.\n *\n * Parameters:\n *\n * scale - Decimal value that specifies the new scale (1 is 100%).\n * dx - X-coordinate of the translation.\n * dy - Y-coordinate of the translation.\n */\nmxGraphView.prototype.scaleAndTranslate = function(scale, dx, dy)\n{\n\tvar previousScale = this.scale;\n\tvar previousTranslate = new mxPoint(this.translate.x, this.translate.y);\n\t\n\tif (this.scale != scale || this.translate.x != dx || this.translate.y != dy)\n\t{\n\t\tthis.scale = scale;\n\t\t\n\t\tthis.translate.x = dx;\n\t\tthis.translate.y = dy;\n\n\t\tif (this.isEventsEnabled())\n\t\t{\n\t\t\tthis.viewStateChanged();\n\t\t}\n\t}\n\t\n\tthis.fireEvent(new mxEventObject(mxEvent.SCALE_AND_TRANSLATE,\n\t\t'scale', scale, 'previousScale', previousScale,\n\t\t'translate', this.translate, 'previousTranslate', previousTranslate));\n};\n\n/**\n * Function: getScale\n * \n * Returns the <scale>.\n */\nmxGraphView.prototype.getScale = function()\n{\n\treturn this.scale;\n};\n\n/**\n * Function: setScale\n *\n * Sets the scale and fires a <scale> event before calling <revalidate> followed\n * by <mxGraph.sizeDidChange>.\n *\n * Parameters:\n *\n * value - Decimal value that specifies the new scale (1 is 100%).\n */\nmxGraphView.prototype.setScale = function(value)\n{\n\tvar previousScale = this.scale;\n\t\n\tif (this.scale != value)\n\t{\n\t\tthis.scale = value;\n\n\t\tif (this.isEventsEnabled())\n\t\t{\n\t\t\tthis.viewStateChanged();\n\t\t}\n\t}\n\t\n\tthis.fireEvent(new mxEventObject(mxEvent.SCALE,\n\t\t'scale', value, 'previousScale', previousScale));\n};\n\n/**\n * Function: getTranslate\n * \n * Returns the <translate>.\n */\nmxGraphView.prototype.getTranslate = function()\n{\n\treturn this.translate;\n};\n\n/**\n * Function: setTranslate\n *\n * Sets the translation and fires a <translate> event before calling\n * <revalidate> followed by <mxGraph.sizeDidChange>. The translation is the\n * negative of the origin.\n *\n * Parameters:\n *\n * dx - X-coordinate of the translation.\n * dy - Y-coordinate of the translation.\n */\nmxGraphView.prototype.setTranslate = function(dx, dy)\n{\n\tvar previousTranslate = new mxPoint(this.translate.x, this.translate.y);\n\t\n\tif (this.translate.x != dx || this.translate.y != dy)\n\t{\n\t\tthis.translate.x = dx;\n\t\tthis.translate.y = dy;\n\n\t\tif (this.isEventsEnabled())\n\t\t{\n\t\t\tthis.viewStateChanged();\n\t\t}\n\t}\n\t\n\tthis.fireEvent(new mxEventObject(mxEvent.TRANSLATE,\n\t\t'translate', this.translate, 'previousTranslate', previousTranslate));\n};\n\n/**\n * Function: viewStateChanged\n * \n * Invoked after <scale> and/or <translate> has changed.\n */\nmxGraphView.prototype.viewStateChanged = function()\n{\n\tthis.revalidate();\n\tthis.graph.sizeDidChange();\n};\n\n/**\n * Function: refresh\n *\n * Clears the view if <currentRoot> is not null and revalidates.\n */\nmxGraphView.prototype.refresh = function()\n{\n\tif (this.currentRoot != null)\n\t{\n\t\tthis.clear();\n\t}\n\t\n\tthis.revalidate();\n};\n\n/**\n * Function: revalidate\n *\n * Revalidates the complete view with all cell states.\n */\nmxGraphView.prototype.revalidate = function()\n{\n\tthis.invalidate();\n\tthis.validate();\n};\n\n/**\n * Function: clear\n *\n * Removes the state of the given cell and all descendants if the given\n * cell is not the current root.\n * \n * Parameters:\n * \n * cell - Optional <mxCell> for which the state should be removed. Default\n * is the root of the model.\n * force - Boolean indicating if the current root should be ignored for\n * recursion.\n */\nmxGraphView.prototype.clear = function(cell, force, recurse)\n{\n\tvar model = this.graph.getModel();\n\tcell = cell || model.getRoot();\n\tforce = (force != null) ? force : false;\n\trecurse = (recurse != null) ? recurse : true;\n\t\n\tthis.removeState(cell);\n\t\n\tif (recurse && (force || cell != this.currentRoot))\n\t{\n\t\tvar childCount = model.getChildCount(cell);\n\t\t\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tthis.clear(model.getChildAt(cell, i), force);\n\t\t}\n\t}\n\telse\n\t{\n\t\tthis.invalidate(cell);\n\t}\n};\n\n/**\n * Function: invalidate\n * \n * Invalidates the state of the given cell, all its descendants and\n * connected edges.\n * \n * Parameters:\n * \n * cell - Optional <mxCell> to be invalidated. Default is the root of the\n * model.\n */\nmxGraphView.prototype.invalidate = function(cell, recurse, includeEdges)\n{\n\tvar model = this.graph.getModel();\n\tcell = cell || model.getRoot();\n\trecurse = (recurse != null) ? recurse : true;\n\tincludeEdges = (includeEdges != null) ? includeEdges : true;\n\t\n\tvar state = this.getState(cell);\n\t\n\tif (state != null)\n\t{\n\t\tstate.invalid = true;\n\t}\n\t\n\t// Avoids infinite loops for invalid graphs\n\tif (!cell.invalidating)\n\t{\n\t\tcell.invalidating = true;\n\t\t\n\t\t// Recursively invalidates all descendants\n\t\tif (recurse)\n\t\t{\n\t\t\tvar childCount = model.getChildCount(cell);\n\t\t\t\n\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t{\n\t\t\t\tvar child = model.getChildAt(cell, i);\n\t\t\t\tthis.invalidate(child, recurse, includeEdges);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Propagates invalidation to all connected edges\n\t\tif (includeEdges)\n\t\t{\n\t\t\tvar edgeCount = model.getEdgeCount(cell);\n\t\t\t\n\t\t\tfor (var i = 0; i < edgeCount; i++)\n\t\t\t{\n\t\t\t\tthis.invalidate(model.getEdgeAt(cell, i), recurse, includeEdges);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdelete cell.invalidating;\n\t}\n};\n\n/**\n * Function: validate\n * \n * Calls <validateCell> and <validateCellState> and updates the <graphBounds>\n * using <getBoundingBox>. Finally the background is validated using\n * <validateBackground>.\n * \n * Parameters:\n * \n * cell - Optional <mxCell> to be used as the root of the validation.\n * Default is <currentRoot> or the root of the model.\n */\nmxGraphView.prototype.validate = function(cell)\n{\n\tvar t0 = mxLog.enter('mxGraphView.validate');\n\twindow.status = mxResources.get(this.updatingDocumentResource) ||\n\t\tthis.updatingDocumentResource;\n\t\n\tthis.resetValidationState();\n\t\n\t// Improves IE rendering speed by minimizing reflows\n\tvar prevDisplay = null;\n\t\n\tif (this.optimizeVmlReflows && this.canvas != null && this.textDiv == null &&\n\t\t((document.documentMode == 8 && !mxClient.IS_EM) || mxClient.IS_QUIRKS))\n\t{\n\t\t// Placeholder keeps scrollbar positions when canvas is hidden\n\t\tthis.placeholder = document.createElement('div');\n\t\tthis.placeholder.style.position = 'absolute';\n\t\tthis.placeholder.style.width = this.canvas.clientWidth + 'px';\n\t\tthis.placeholder.style.height = this.canvas.clientHeight + 'px';\n\t\tthis.canvas.parentNode.appendChild(this.placeholder);\n\n\t\tprevDisplay = this.drawPane.style.display;\n\t\tthis.canvas.style.display = 'none';\n\t\t\n\t\t// Creates temporary DIV used for text measuring in mxText.updateBoundingBox\n\t\tthis.textDiv = document.createElement('div');\n\t\tthis.textDiv.style.position = 'absolute';\n\t\tthis.textDiv.style.whiteSpace = 'nowrap';\n\t\tthis.textDiv.style.visibility = 'hidden';\n\t\tthis.textDiv.style.display = (mxClient.IS_QUIRKS) ? 'inline' : 'inline-block';\n\t\tthis.textDiv.style.zoom = '1';\n\t\t\n\t\tdocument.body.appendChild(this.textDiv);\n\t}\n\t\n\tvar graphBounds = this.getBoundingBox(this.validateCellState(\n\t\tthis.validateCell(cell || ((this.currentRoot != null) ?\n\t\t\tthis.currentRoot : this.graph.getModel().getRoot()))));\n\tthis.setGraphBounds((graphBounds != null) ? graphBounds : this.getEmptyBounds());\n\tthis.validateBackground();\n\t\n\tif (prevDisplay != null)\n\t{\n\t\tthis.canvas.style.display = prevDisplay;\n\t\tthis.textDiv.parentNode.removeChild(this.textDiv);\n\t\t\n\t\tif (this.placeholder != null)\n\t\t{\n\t\t\tthis.placeholder.parentNode.removeChild(this.placeholder);\n\t\t}\n\t\t\t\t\n\t\t// Textdiv cannot be reused\n\t\tthis.textDiv = null;\n\t}\n\t\n\tthis.resetValidationState();\n\t\n\twindow.status = mxResources.get(this.doneResource) ||\n\t\tthis.doneResource;\n\tmxLog.leave('mxGraphView.validate', t0);\n};\n\n/**\n * Function: getEmptyBounds\n * \n * Returns the bounds for an empty graph. This returns a rectangle at\n * <translate> with the size of 0 x 0.\n */\nmxGraphView.prototype.getEmptyBounds = function()\n{\n\treturn new mxRectangle(this.translate.x * this.scale, this.translate.y * this.scale);\n};\n\n/**\n * Function: getBoundingBox\n * \n * Returns the bounding box of the shape and the label for the given\n * <mxCellState> and its children if recurse is true.\n * \n * Parameters:\n * \n * state - <mxCellState> whose bounding box should be returned.\n * recurse - Optional boolean indicating if the children should be included.\n * Default is true.\n */\nmxGraphView.prototype.getBoundingBox = function(state, recurse)\n{\n\trecurse = (recurse != null) ? recurse : true;\n\tvar bbox = null;\n\t\n\tif (state != null)\n\t{\n\t\tif (state.shape != null && state.shape.boundingBox != null)\n\t\t{\n\t\t\tbbox = state.shape.boundingBox.clone();\n\t\t}\n\t\t\n\t\t// Adds label bounding box to graph bounds\n\t\tif (state.text != null && state.text.boundingBox != null)\n\t\t{\n\t\t\tif (bbox != null)\n\t\t\t{\n\t\t\t\tbbox.add(state.text.boundingBox);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbbox = state.text.boundingBox.clone();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (recurse)\n\t\t{\n\t\t\tvar model = this.graph.getModel();\n\t\t\tvar childCount = model.getChildCount(state.cell);\n\t\t\t\n\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t{\n\t\t\t\tvar bounds = this.getBoundingBox(this.getState(model.getChildAt(state.cell, i)));\n\t\t\t\t\n\t\t\t\tif (bounds != null)\n\t\t\t\t{\n\t\t\t\t\tif (bbox == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tbbox = bounds;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbbox.add(bounds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn bbox;\n};\n\n/**\n * Function: createBackgroundPageShape\n *\n * Creates and returns the shape used as the background page.\n * \n * Parameters:\n * \n * bounds - <mxRectangle> that represents the bounds of the shape.\n */\nmxGraphView.prototype.createBackgroundPageShape = function(bounds)\n{\n\treturn new mxRectangleShape(bounds, 'white', 'black');\n};\n\n/**\n * Function: validateBackground\n *\n * Calls <validateBackgroundImage> and <validateBackgroundPage>.\n */\nmxGraphView.prototype.validateBackground = function()\n{\n\tthis.validateBackgroundImage();\n\tthis.validateBackgroundPage();\n};\n\n/**\n * Function: validateBackgroundImage\n * \n * Validates the background image.\n */\nmxGraphView.prototype.validateBackgroundImage = function()\n{\n\tvar bg = this.graph.getBackgroundImage();\n\t\n\tif (bg != null)\n\t{\n\t\tif (this.backgroundImage == null || this.backgroundImage.image != bg.src)\n\t\t{\n\t\t\tif (this.backgroundImage != null)\n\t\t\t{\n\t\t\t\tthis.backgroundImage.destroy();\n\t\t\t}\n\t\t\t\n\t\t\tvar bounds = new mxRectangle(0, 0, 1, 1);\n\t\t\t\n\t\t\tthis.backgroundImage = new mxImageShape(bounds, bg.src);\n\t\t\tthis.backgroundImage.dialect = this.graph.dialect;\n\t\t\tthis.backgroundImage.init(this.backgroundPane);\n\t\t\tthis.backgroundImage.redraw();\n\n\t\t\t// Workaround for ignored event on background in IE8 standards mode\n\t\t\tif (document.documentMode == 8 && !mxClient.IS_EM)\n\t\t\t{\n\t\t\t\tmxEvent.addGestureListeners(this.backgroundImage.node,\n\t\t\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));\n\t\t\t\t\t}),\n\t\t\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));\n\t\t\t\t\t}),\n\t\t\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.redrawBackgroundImage(this.backgroundImage, bg);\n\t}\n\telse if (this.backgroundImage != null)\n\t{\n\t\tthis.backgroundImage.destroy();\n\t\tthis.backgroundImage = null;\n\t}\n};\n\n/**\n * Function: validateBackgroundPage\n * \n * Validates the background page.\n */\nmxGraphView.prototype.validateBackgroundPage = function()\n{\n\tif (this.graph.pageVisible)\n\t{\n\t\tvar bounds = this.getBackgroundPageBounds();\n\t\t\n\t\tif (this.backgroundPageShape == null)\n\t\t{\n\t\t\tthis.backgroundPageShape = this.createBackgroundPageShape(bounds);\n\t\t\tthis.backgroundPageShape.scale = this.scale;\n\t\t\tthis.backgroundPageShape.isShadow = true;\n\t\t\tthis.backgroundPageShape.dialect = this.graph.dialect;\n\t\t\tthis.backgroundPageShape.init(this.backgroundPane);\n\t\t\tthis.backgroundPageShape.redraw();\n\t\t\t\n\t\t\t// Adds listener for double click handling on background\n\t\t\tif (this.graph.nativeDblClickEnabled)\n\t\t\t{\n\t\t\t\tmxEvent.addListener(this.backgroundPageShape.node, 'dblclick', mxUtils.bind(this, function(evt)\n\t\t\t\t{\n\t\t\t\t\tthis.graph.dblClick(evt);\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\t// Adds basic listeners for graph event dispatching outside of the\n\t\t\t// container and finishing the handling of a single gesture\n\t\t\tmxEvent.addGestureListeners(this.backgroundPageShape.node,\n\t\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t\t{\n\t\t\t\t\tthis.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));\n\t\t\t\t}),\n\t\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t\t{\n\t\t\t\t\t// Hides the tooltip if mouse is outside container\n\t\t\t\t\tif (this.graph.tooltipHandler != null && this.graph.tooltipHandler.isHideOnHover())\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.graph.tooltipHandler.hide();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (this.graph.isMouseDown && !mxEvent.isConsumed(evt))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t\t{\n\t\t\t\t\tthis.graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.backgroundPageShape.scale = this.scale;\n\t\t\tthis.backgroundPageShape.bounds = bounds;\n\t\t\tthis.backgroundPageShape.redraw();\n\t\t}\n\t}\n\telse if (this.backgroundPageShape != null)\n\t{\n\t\tthis.backgroundPageShape.destroy();\n\t\tthis.backgroundPageShape = null;\n\t}\n};\n\n/**\n * Function: getBackgroundPageBounds\n * \n * Returns the bounds for the background page.\n */\nmxGraphView.prototype.getBackgroundPageBounds = function()\n{\n\tvar fmt = this.graph.pageFormat;\n\tvar ps = this.scale * this.graph.pageScale;\n\tvar bounds = new mxRectangle(this.scale * this.translate.x, this.scale * this.translate.y,\n\t\t\tfmt.width * ps, fmt.height * ps);\n\t\n\treturn bounds;\n};\n\n/**\n * Function: redrawBackgroundImage\n *\n * Updates the bounds and redraws the background image.\n * \n * Example:\n * \n * If the background image should not be scaled, this can be replaced with\n * the following.\n * \n * (code)\n * mxGraphView.prototype.redrawBackground = function(backgroundImage, bg)\n * {\n *   backgroundImage.bounds.x = this.translate.x;\n *   backgroundImage.bounds.y = this.translate.y;\n *   backgroundImage.bounds.width = bg.width;\n *   backgroundImage.bounds.height = bg.height;\n *\n *   backgroundImage.redraw();\n * };\n * (end)\n * \n * Parameters:\n * \n * backgroundImage - <mxImageShape> that represents the background image.\n * bg - <mxImage> that specifies the image and its dimensions.\n */\nmxGraphView.prototype.redrawBackgroundImage = function(backgroundImage, bg)\n{\n\tbackgroundImage.scale = this.scale;\n\tbackgroundImage.bounds.x = this.scale * this.translate.x;\n\tbackgroundImage.bounds.y = this.scale * this.translate.y;\n\tbackgroundImage.bounds.width = this.scale * bg.width;\n\tbackgroundImage.bounds.height = this.scale * bg.height;\n\n\tbackgroundImage.redraw();\n};\n\n/**\n * Function: validateCell\n * \n * Recursively creates the cell state for the given cell if visible is true and\n * the given cell is visible. If the cell is not visible but the state exists\n * then it is removed using <removeState>.\n * \n * Parameters:\n * \n * cell - <mxCell> whose <mxCellState> should be created.\n * visible - Optional boolean indicating if the cell should be visible. Default\n * is true.\n */\nmxGraphView.prototype.validateCell = function(cell, visible)\n{\n\tvisible = (visible != null) ? visible : true;\n\t\n\tif (cell != null)\n\t{\n\t\tvisible = visible && this.graph.isCellVisible(cell);\n\t\tvar state = this.getState(cell, visible);\n\t\t\n\t\tif (state != null && !visible)\n\t\t{\n\t\t\tthis.removeState(cell);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar model = this.graph.getModel();\n\t\t\tvar childCount = model.getChildCount(cell);\n\t\t\t\n\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t{\n\t\t\t\tthis.validateCell(model.getChildAt(cell, i), visible &&\n\t\t\t\t\t(!this.isCellCollapsed(cell) || cell == this.currentRoot));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn cell;\n};\n\n/**\n * Function: validateCellState\n * \n * Validates and repaints the <mxCellState> for the given <mxCell>.\n * \n * Parameters:\n * \n * cell - <mxCell> whose <mxCellState> should be validated.\n * recurse - Optional boolean indicating if the children of the cell should be\n * validated. Default is true.\n */\nmxGraphView.prototype.validateCellState = function(cell, recurse)\n{\n\trecurse = (recurse != null) ? recurse : true;\n\tvar state = null;\n\t\n\tif (cell != null)\n\t{\n\t\tstate = this.getState(cell);\n\t\t\n\t\tif (state != null)\n\t\t{\n\t\t\tvar model = this.graph.getModel();\n\t\t\t\n\t\t\tif (state.invalid)\n\t\t\t{\n\t\t\t\tstate.invalid = false;\n\t\t\t\t\n\t\t\t\tif (state.style == null || state.invalidStyle)\n\t\t\t\t{\n\t\t\t\t\tstate.style = this.graph.getCellStyle(state.cell);\n\t\t\t\t\tstate.invalidStyle = false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (cell != this.currentRoot)\n\t\t\t\t{\n\t\t\t\t\tthis.validateCellState(model.getParent(cell), false);\n\t\t\t\t}\n\n\t\t\t\tstate.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell, true), false), true);\n\t\t\t\tstate.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell, false), false), false);\n\t\t\t\t\n\t\t\t\tthis.updateCellState(state);\n\t\t\t\t\n\t\t\t\t// Repaint happens immediately after the cell is validated\n\t\t\t\tif (cell != this.currentRoot && !state.invalid)\n\t\t\t\t{\n\t\t\t\t\tthis.graph.cellRenderer.redraw(state, false, this.isRendering());\n\n\t\t\t\t\t// Handles changes to invertex paintbounds after update of rendering shape\n\t\t\t\t\tstate.updateCachedBounds();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (recurse && !state.invalid)\n\t\t\t{\n\t\t\t\t// Updates order in DOM if recursively traversing\n\t\t\t\tif (state.shape != null)\n\t\t\t\t{\n\t\t\t\t\tthis.stateValidated(state);\n\t\t\t\t}\n\t\t\t\n\t\t\t\tvar childCount = model.getChildCount(cell);\n\t\t\t\t\n\t\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t\t{\n\t\t\t\t\tthis.validateCellState(model.getChildAt(cell, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn state;\n};\n\n/**\n * Function: updateCellState\n * \n * Updates the given <mxCellState>.\n * \n * Parameters:\n * \n * state - <mxCellState> to be updated.\n */\nmxGraphView.prototype.updateCellState = function(state)\n{\n\tstate.absoluteOffset.x = 0;\n\tstate.absoluteOffset.y = 0;\n\tstate.origin.x = 0;\n\tstate.origin.y = 0;\n\tstate.length = 0;\n\t\n\tif (state.cell != this.currentRoot)\n\t{\n\t\tvar model = this.graph.getModel();\n\t\tvar pState = this.getState(model.getParent(state.cell)); \n\t\t\n\t\tif (pState != null && pState.cell != this.currentRoot)\n\t\t{\n\t\t\tstate.origin.x += pState.origin.x;\n\t\t\tstate.origin.y += pState.origin.y;\n\t\t}\n\t\t\n\t\tvar offset = this.graph.getChildOffsetForCell(state.cell);\n\t\t\n\t\tif (offset != null)\n\t\t{\n\t\t\tstate.origin.x += offset.x;\n\t\t\tstate.origin.y += offset.y;\n\t\t}\n\t\t\n\t\tvar geo = this.graph.getCellGeometry(state.cell);\t\t\t\t\n\t\n\t\tif (geo != null)\n\t\t{\n\t\t\tif (!model.isEdge(state.cell))\n\t\t\t{\n\t\t\t\toffset = (geo.offset != null) ? geo.offset : this.EMPTY_POINT;\n\t\n\t\t\t\tif (geo.relative && pState != null)\n\t\t\t\t{\n\t\t\t\t\tif (model.isEdge(pState.cell))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar origin = this.getPoint(pState, geo);\n\n\t\t\t\t\t\tif (origin != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstate.origin.x += (origin.x / this.scale) - pState.origin.x - this.translate.x;\n\t\t\t\t\t\t\tstate.origin.y += (origin.y / this.scale) - pState.origin.y - this.translate.y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tstate.origin.x += geo.x * pState.unscaledWidth + offset.x;\n\t\t\t\t\t\tstate.origin.y += geo.y * pState.unscaledHeight + offset.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate.absoluteOffset.x = this.scale * offset.x;\n\t\t\t\t\tstate.absoluteOffset.y = this.scale * offset.y;\n\t\t\t\t\tstate.origin.x += geo.x;\n\t\t\t\t\tstate.origin.y += geo.y;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tstate.x = this.scale * (this.translate.x + state.origin.x);\n\t\t\tstate.y = this.scale * (this.translate.y + state.origin.y);\n\t\t\tstate.width = this.scale * geo.width;\n\t\t\tstate.unscaledWidth = geo.width;\n\t\t\tstate.height = this.scale * geo.height;\n\t\t\tstate.unscaledHeight = geo.height;\n\t\t\t\n\t\t\tif (model.isVertex(state.cell))\n\t\t\t{\n\t\t\t\tthis.updateVertexState(state, geo);\n\t\t\t}\n\t\t\t\n\t\t\tif (model.isEdge(state.cell))\n\t\t\t{\n\t\t\t\tthis.updateEdgeState(state, geo);\n\t\t\t}\n\t\t}\n\t}\n\n\tstate.updateCachedBounds();\n};\n\n/**\n * Function: isCellCollapsed\n * \n * Returns true if the children of the given cell should not be visible in the\n * view. This implementation uses <mxGraph.isCellVisible> but it can be\n * overidden to use a separate condition.\n */\nmxGraphView.prototype.isCellCollapsed = function(cell)\n{\n\treturn this.graph.isCellCollapsed(cell);\n};\n\n/**\n * Function: updateVertexState\n * \n * Validates the given cell state.\n */\nmxGraphView.prototype.updateVertexState = function(state, geo)\n{\n\tvar model = this.graph.getModel();\n\tvar pState = this.getState(model.getParent(state.cell));\n\t\n\tif (geo.relative && pState != null && !model.isEdge(pState.cell))\n\t{\n\t\tvar alpha = mxUtils.toRadians(pState.style[mxConstants.STYLE_ROTATION] || '0');\n\t\t\n\t\tif (alpha != 0)\n\t\t{\n\t\t\tvar cos = Math.cos(alpha);\n\t\t\tvar sin = Math.sin(alpha);\n\n\t\t\tvar ct = new mxPoint(state.getCenterX(), state.getCenterY());\n\t\t\tvar cx = new mxPoint(pState.getCenterX(), pState.getCenterY());\n\t\t\tvar pt = mxUtils.getRotatedPoint(ct, cos, sin, cx);\n\t\t\tstate.x = pt.x - state.width / 2;\n\t\t\tstate.y = pt.y - state.height / 2;\n\t\t}\n\t}\n\t\n\tthis.updateVertexLabelOffset(state);\n};\n\n/**\n * Function: updateEdgeState\n * \n * Validates the given cell state.\n */\nmxGraphView.prototype.updateEdgeState = function(state, geo)\n{\n\tvar source = state.getVisibleTerminalState(true);\n\tvar target = state.getVisibleTerminalState(false);\n\t\n\t// This will remove edges with no terminals and no terminal points\n\t// as such edges are invalid and produce NPEs in the edge styles.\n\t// Also removes connected edges that have no visible terminals.\n\tif ((this.graph.model.getTerminal(state.cell, true) != null && source == null) ||\n\t\t(source == null && geo.getTerminalPoint(true) == null) ||\n\t\t(this.graph.model.getTerminal(state.cell, false) != null && target == null) ||\n\t\t(target == null && geo.getTerminalPoint(false) == null))\n\t{\n\t\tthis.clear(state.cell, true);\n\t}\n\telse\n\t{\n\t\tthis.updateFixedTerminalPoints(state, source, target);\n\t\tthis.updatePoints(state, geo.points, source, target);\n\t\tthis.updateFloatingTerminalPoints(state, source, target);\n\t\t\n\t\tvar pts = state.absolutePoints;\n\t\t\n\t\tif (state.cell != this.currentRoot && (pts == null || pts.length < 2 ||\n\t\t\tpts[0] == null || pts[pts.length - 1] == null))\n\t\t{\n\t\t\t// This will remove edges with invalid points from the list of states in the view.\n\t\t\t// Happens if the one of the terminals and the corresponding terminal point is null.\n\t\t\tthis.clear(state.cell, true);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.updateEdgeBounds(state);\n\t\t\tthis.updateEdgeLabelOffset(state);\n\t\t}\n\t}\n};\n\n/**\n * Function: updateVertexLabelOffset\n * \n * Updates the absoluteOffset of the given vertex cell state. This takes\n * into account the label position styles.\n * \n * Parameters:\n * \n * state - <mxCellState> whose absolute offset should be updated.\n */\nmxGraphView.prototype.updateVertexLabelOffset = function(state)\n{\n\tvar h = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);\n\n\tif (h == mxConstants.ALIGN_LEFT)\n\t{\n\t\tvar lw = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);\n\t\t\n\t\tif (lw != null)\n\t\t{\n\t\t\tlw *= this.scale;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlw = state.width;\n\t\t}\n\t\t\n\t\tstate.absoluteOffset.x -= lw;\n\t}\n\telse if (h == mxConstants.ALIGN_RIGHT)\n\t{\n\t\tstate.absoluteOffset.x += state.width;\n\t}\n\telse if (h == mxConstants.ALIGN_CENTER)\n\t{\n\t\tvar lw = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);\n\t\t\n\t\tif (lw != null)\n\t\t{\n\t\t\t// Aligns text block with given width inside the vertex width\n\t\t\tvar align = mxUtils.getValue(state.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_CENTER);\n\t\t\tvar dx = 0;\n\t\t\t\n\t\t\tif (align == mxConstants.ALIGN_CENTER)\n\t\t\t{\n\t\t\t\tdx = 0.5;\n\t\t\t}\n\t\t\telse if (align == mxConstants.ALIGN_RIGHT)\n\t\t\t{\n\t\t\t\tdx = 1;\n\t\t\t}\n\t\t\t\n\t\t\tif (dx != 0)\n\t\t\t{\n\t\t\t\tstate.absoluteOffset.x -= (lw * this.scale - state.width) * dx;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvar v = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);\n\t\n\tif (v == mxConstants.ALIGN_TOP)\n\t{\n\t\tstate.absoluteOffset.y -= state.height;\n\t}\n\telse if (v == mxConstants.ALIGN_BOTTOM)\n\t{\n\t\tstate.absoluteOffset.y += state.height;\n\t}\n};\n\n/**\n * Function: resetValidationState\n *\n * Resets the current validation state.\n */\nmxGraphView.prototype.resetValidationState = function()\n{\n\tthis.lastNode = null;\n\tthis.lastHtmlNode = null;\n\tthis.lastForegroundNode = null;\n\tthis.lastForegroundHtmlNode = null;\n};\n\n/**\n * Function: stateValidated\n * \n * Invoked when a state has been processed in <validatePoints>. This is used\n * to update the order of the DOM nodes of the shape.\n * \n * Parameters:\n * \n * state - <mxCellState> that represents the cell state.\n */\nmxGraphView.prototype.stateValidated = function(state)\n{\n\tvar fg = (this.graph.getModel().isEdge(state.cell) && this.graph.keepEdgesInForeground) ||\n\t\t(this.graph.getModel().isVertex(state.cell) && this.graph.keepEdgesInBackground);\n\tvar htmlNode = (fg) ? this.lastForegroundHtmlNode || this.lastHtmlNode : this.lastHtmlNode;\n\tvar node = (fg) ? this.lastForegroundNode || this.lastNode : this.lastNode;\n\tvar result = this.graph.cellRenderer.insertStateAfter(state, node, htmlNode);\n\n\tif (fg)\n\t{\n\t\tthis.lastForegroundHtmlNode = result[1];\n\t\tthis.lastForegroundNode = result[0];\n\t}\n\telse\n\t{\n\t\tthis.lastHtmlNode = result[1];\n\t\tthis.lastNode = result[0];\n\t}\n};\n\n/**\n * Function: updateFixedTerminalPoints\n *\n * Sets the initial absolute terminal points in the given state before the edge\n * style is computed.\n * \n * Parameters:\n * \n * edge - <mxCellState> whose initial terminal points should be updated.\n * source - <mxCellState> which represents the source terminal.\n * target - <mxCellState> which represents the target terminal.\n */\nmxGraphView.prototype.updateFixedTerminalPoints = function(edge, source, target)\n{\n\tthis.updateFixedTerminalPoint(edge, source, true,\n\t\tthis.graph.getConnectionConstraint(edge, source, true));\n\tthis.updateFixedTerminalPoint(edge, target, false,\n\t\tthis.graph.getConnectionConstraint(edge, target, false));\n};\n\n/**\n * Function: updateFixedTerminalPoint\n *\n * Sets the fixed source or target terminal point on the given edge.\n * \n * Parameters:\n * \n * edge - <mxCellState> whose terminal point should be updated.\n * terminal - <mxCellState> which represents the actual terminal.\n * source - Boolean that specifies if the terminal is the source.\n * constraint - <mxConnectionConstraint> that specifies the connection.\n */\nmxGraphView.prototype.updateFixedTerminalPoint = function(edge, terminal, source, constraint)\n{\n\tedge.setAbsoluteTerminalPoint(this.getFixedTerminalPoint(edge, terminal, source, constraint), source);\n};\n\n/**\n * Function: getFixedTerminalPoint\n *\n * Returns the fixed source or target terminal point for the given edge.\n * \n * Parameters:\n * \n * edge - <mxCellState> whose terminal point should be returned.\n * terminal - <mxCellState> which represents the actual terminal.\n * source - Boolean that specifies if the terminal is the source.\n * constraint - <mxConnectionConstraint> that specifies the connection.\n */\nmxGraphView.prototype.getFixedTerminalPoint = function(edge, terminal, source, constraint)\n{\n\tvar pt = null;\n\t\n\tif (constraint != null)\n\t{\n\t\tpt = this.graph.getConnectionPoint(terminal, constraint, false); // FIXME Rounding introduced bugs when calculating label positions -> , this.graph.isOrthogonal(edge));\n\t}\n\t\n\tif (pt == null && terminal == null)\n\t{\n\t\tvar s = this.scale;\n\t\tvar tr = this.translate;\n\t\tvar orig = edge.origin;\n\t\tvar geo = this.graph.getCellGeometry(edge.cell);\n\t\tpt = geo.getTerminalPoint(source);\n\t\t\n\t\tif (pt != null)\n\t\t{\n\t\t\tpt = new mxPoint(s * (tr.x + pt.x + orig.x),\n\t\t\t\t\t\t\t s * (tr.y + pt.y + orig.y));\n\t\t}\n\t}\n\t\n\treturn pt;\n};\n\n/**\n * Function: updateBoundsFromStencil\n * \n * Updates the bounds of the given cell state to reflect the bounds of the stencil\n * if it has a fixed aspect and returns the previous bounds as an <mxRectangle> if\n * the bounds have been modified or null otherwise.\n * \n * Parameters:\n * \n * edge - <mxCellState> whose bounds should be updated.\n */\nmxGraphView.prototype.updateBoundsFromStencil = function(state)\n{\n\tvar previous = null;\n\t\n\tif (state != null && state.shape != null && state.shape.stencil != null && state.shape.stencil.aspect == 'fixed')\n\t{\n\t\tprevious = mxRectangle.fromRectangle(state);\n\t\tvar asp = state.shape.stencil.computeAspect(state.style, state.x, state.y, state.width, state.height);\n\t\tstate.setRect(asp.x, asp.y, state.shape.stencil.w0 * asp.width, state.shape.stencil.h0 * asp.height);\n\t}\n\t\n\treturn previous;\n};\n\n/**\n * Function: updatePoints\n *\n * Updates the absolute points in the given state using the specified array\n * of <mxPoints> as the relative points.\n * \n * Parameters:\n * \n * edge - <mxCellState> whose absolute points should be updated.\n * points - Array of <mxPoints> that constitute the relative points.\n * source - <mxCellState> that represents the source terminal.\n * target - <mxCellState> that represents the target terminal.\n */\nmxGraphView.prototype.updatePoints = function(edge, points, source, target)\n{\n\tif (edge != null)\n\t{\n\t\tvar pts = [];\n\t\tpts.push(edge.absolutePoints[0]);\n\t\tvar edgeStyle = this.getEdgeStyle(edge, points, source, target);\n\t\t\n\t\tif (edgeStyle != null)\n\t\t{\n\t\t\tvar src = this.getTerminalPort(edge, source, true);\n\t\t\tvar trg = this.getTerminalPort(edge, target, false);\n\t\t\t\n\t\t\t// Uses the stencil bounds for routing and restores after routing\n\t\t\tvar srcBounds = this.updateBoundsFromStencil(src);\n\t\t\tvar trgBounds = this.updateBoundsFromStencil(trg);\n\n\t\t\tedgeStyle(edge, src, trg, points, pts);\n\t\t\t\n\t\t\t// Restores previous bounds\n\t\t\tif (srcBounds != null)\n\t\t\t{\n\t\t\t\tsrc.setRect(srcBounds.x, srcBounds.y, srcBounds.width, srcBounds.height);\n\t\t\t}\n\t\t\t\n\t\t\tif (trgBounds != null)\n\t\t\t{\n\t\t\t\ttrg.setRect(trgBounds.x, trgBounds.y, trgBounds.width, trgBounds.height);\n\t\t\t}\n\t\t}\n\t\telse if (points != null)\n\t\t{\n\t\t\tfor (var i = 0; i < points.length; i++)\n\t\t\t{\n\t\t\t\tif (points[i] != null)\n\t\t\t\t{\n\t\t\t\t\tvar pt = mxUtils.clone(points[i]);\n\t\t\t\t\tpts.push(this.transformControlPoint(edge, pt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar tmp = edge.absolutePoints;\n\t\tpts.push(tmp[tmp.length-1]);\n\n\t\tedge.absolutePoints = pts;\n\t}\n};\n\n/**\n * Function: transformControlPoint\n *\n * Transforms the given control point to an absolute point.\n */\nmxGraphView.prototype.transformControlPoint = function(state, pt, ignoreScale)\n{\n\tif (state != null && pt != null)\n\t{\n\t\tvar orig = state.origin;\n\t\tvar scale = ignoreScale ? 1 : this.scale\n\t\t\n\t    return new mxPoint(scale * (pt.x + this.translate.x + orig.x),\n\t    \t\tscale * (pt.y + this.translate.y + orig.y));\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: isLoopStyleEnabled\n * \n * Returns true if the given edge should be routed with <mxGraph.defaultLoopStyle>\n * or the <mxConstants.STYLE_LOOP> defined for the given edge. This implementation\n * returns true if the given edge is a loop and does not have connections constraints\n * associated.\n */\nmxGraphView.prototype.isLoopStyleEnabled = function(edge, points, source, target)\n{\n\tvar sc = this.graph.getConnectionConstraint(edge, source, true);\n\tvar tc = this.graph.getConnectionConstraint(edge, target, false);\n\t\n\tif ((points == null || points.length < 2) &&\n\t\t(!mxUtils.getValue(edge.style, mxConstants.STYLE_ORTHOGONAL_LOOP, false) ||\n\t\t((sc == null || sc.point == null) && (tc == null || tc.point == null))))\n\t{\n\t\treturn source != null && source == target;\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: getEdgeStyle\n * \n * Returns the edge style function to be used to render the given edge state.\n */\nmxGraphView.prototype.getEdgeStyle = function(edge, points, source, target)\n{\n\tvar edgeStyle = this.isLoopStyleEnabled(edge, points, source, target) ?\n\t\tmxUtils.getValue(edge.style, mxConstants.STYLE_LOOP, this.graph.defaultLoopStyle) :\n\t\t(!mxUtils.getValue(edge.style, mxConstants.STYLE_NOEDGESTYLE, false) ?\n\t\tedge.style[mxConstants.STYLE_EDGE] : null);\n\n\t// Converts string values to objects\n\tif (typeof(edgeStyle) == \"string\")\n\t{\n\t\tvar tmp = mxStyleRegistry.getValue(edgeStyle);\n\t\t\n\t\tif (tmp == null && this.isAllowEval())\n\t\t{\n \t\t\ttmp = mxUtils.eval(edgeStyle);\n\t\t}\n\t\t\n\t\tedgeStyle = tmp;\n\t}\n\t\n\tif (typeof(edgeStyle) == \"function\")\n\t{\n\t\treturn edgeStyle;\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: updateFloatingTerminalPoints\n *\n * Updates the terminal points in the given state after the edge style was\n * computed for the edge.\n * \n * Parameters:\n * \n * state - <mxCellState> whose terminal points should be updated.\n * source - <mxCellState> that represents the source terminal.\n * target - <mxCellState> that represents the target terminal.\n */\nmxGraphView.prototype.updateFloatingTerminalPoints = function(state, source, target)\n{\n\tvar pts = state.absolutePoints;\n\tvar p0 = pts[0];\n\tvar pe = pts[pts.length - 1];\n\n\tif (pe == null && target != null)\n\t{\n\t\tthis.updateFloatingTerminalPoint(state, target, source, false);\n\t}\n\t\n\tif (p0 == null && source != null)\n\t{\n\t\tthis.updateFloatingTerminalPoint(state, source, target, true);\n\t}\n};\n\n/**\n * Function: updateFloatingTerminalPoint\n *\n * Updates the absolute terminal point in the given state for the given\n * start and end state, where start is the source if source is true.\n * \n * Parameters:\n * \n * edge - <mxCellState> whose terminal point should be updated.\n * start - <mxCellState> for the terminal on \"this\" side of the edge.\n * end - <mxCellState> for the terminal on the other side of the edge.\n * source - Boolean indicating if start is the source terminal state.\n */\nmxGraphView.prototype.updateFloatingTerminalPoint = function(edge, start, end, source)\n{\n\tedge.setAbsoluteTerminalPoint(this.getFloatingTerminalPoint(edge, start, end, source), source);\n};\n\n/**\n * Function: getFloatingTerminalPoint\n * \n * Returns the floating terminal point for the given edge, start and end\n * state, where start is the source if source is true.\n * \n * Parameters:\n * \n * edge - <mxCellState> whose terminal point should be returned.\n * start - <mxCellState> for the terminal on \"this\" side of the edge.\n * end - <mxCellState> for the terminal on the other side of the edge.\n * source - Boolean indicating if start is the source terminal state.\n */\nmxGraphView.prototype.getFloatingTerminalPoint = function(edge, start, end, source)\n{\n\tstart = this.getTerminalPort(edge, start, source);\n\tvar next = this.getNextPoint(edge, end, source);\n\t\n\tvar orth = this.graph.isOrthogonal(edge);\n\tvar alpha = mxUtils.toRadians(Number(start.style[mxConstants.STYLE_ROTATION] || '0'));\n\tvar center = new mxPoint(start.getCenterX(), start.getCenterY());\n\t\n\tif (alpha != 0)\n\t{\n\t\tvar cos = Math.cos(-alpha);\n\t\tvar sin = Math.sin(-alpha);\n\t\tnext = mxUtils.getRotatedPoint(next, cos, sin, center);\n\t}\n\t\n\tvar border = parseFloat(edge.style[mxConstants.STYLE_PERIMETER_SPACING] || 0);\n\tborder += parseFloat(edge.style[(source) ?\n\t\tmxConstants.STYLE_SOURCE_PERIMETER_SPACING :\n\t\tmxConstants.STYLE_TARGET_PERIMETER_SPACING] || 0);\n\tvar pt = this.getPerimeterPoint(start, next, alpha == 0 && orth, border);\n\n\tif (alpha != 0)\n\t{\n\t\tvar cos = Math.cos(alpha);\n\t\tvar sin = Math.sin(alpha);\n\t\tpt = mxUtils.getRotatedPoint(pt, cos, sin, center);\n\t}\n\n\treturn pt;\n};\n\n/**\n * Function: getTerminalPort\n * \n * Returns an <mxCellState> that represents the source or target terminal or\n * port for the given edge.\n * \n * Parameters:\n * \n * state - <mxCellState> that represents the state of the edge.\n * terminal - <mxCellState> that represents the terminal.\n * source - Boolean indicating if the given terminal is the source terminal.\n */\nmxGraphView.prototype.getTerminalPort = function(state, terminal, source)\n{\n\tvar key = (source) ? mxConstants.STYLE_SOURCE_PORT :\n\t\tmxConstants.STYLE_TARGET_PORT;\n\tvar id = mxUtils.getValue(state.style, key);\n\t\n\tif (id != null)\n\t{\n\t\tvar tmp = this.getState(this.graph.getModel().getCell(id));\n\t\t\n\t\t// Only uses ports where a cell state exists\n\t\tif (tmp != null)\n\t\t{\n\t\t\tterminal = tmp;\n\t\t}\n\t}\n\t\n\treturn terminal;\n};\n\n/**\n * Function: getPerimeterPoint\n *\n * Returns an <mxPoint> that defines the location of the intersection point between\n * the perimeter and the line between the center of the shape and the given point.\n * \n * Parameters:\n * \n * terminal - <mxCellState> for the source or target terminal.\n * next - <mxPoint> that lies outside of the given terminal.\n * orthogonal - Boolean that specifies if the orthogonal projection onto\n * the perimeter should be returned. If this is false then the intersection\n * of the perimeter and the line between the next and the center point is\n * returned.\n * border - Optional border between the perimeter and the shape.\n */\nmxGraphView.prototype.getPerimeterPoint = function(terminal, next, orthogonal, border)\n{\n\tvar point = null;\n\t\n\tif (terminal != null)\n\t{\n\t\tvar perimeter = this.getPerimeterFunction(terminal);\n\t\t\n\t\tif (perimeter != null && next != null)\n\t\t{\n\t\t\tvar bounds = this.getPerimeterBounds(terminal, border);\n\n\t\t\tif (bounds.width > 0 || bounds.height > 0)\n\t\t\t{\n\t\t\t\tpoint = new mxPoint(next.x, next.y);\n\t\t\t\tvar flipH = false;\n\t\t\t\tvar flipV = false;\t\n\t\t\t\t\n\t\t\t\tif (this.graph.model.isVertex(terminal.cell))\n\t\t\t\t{\n\t\t\t\t\tflipH = mxUtils.getValue(terminal.style, mxConstants.STYLE_FLIPH, 0) == 1;\n\t\t\t\t\tflipV = mxUtils.getValue(terminal.style, mxConstants.STYLE_FLIPV, 0) == 1;\t\n\t\n\t\t\t\t\t// Legacy support for stencilFlipH/V\n\t\t\t\t\tif (terminal.shape != null && terminal.shape.stencil != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tflipH = (mxUtils.getValue(terminal.style, 'stencilFlipH', 0) == 1) || flipH;\n\t\t\t\t\t\tflipV = (mxUtils.getValue(terminal.style, 'stencilFlipV', 0) == 1) || flipV;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (flipH)\n\t\t\t\t\t{\n\t\t\t\t\t\tpoint.x = 2 * bounds.getCenterX() - point.x;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (flipV)\n\t\t\t\t\t{\n\t\t\t\t\t\tpoint.y = 2 * bounds.getCenterY() - point.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpoint = perimeter(bounds, terminal, point, orthogonal);\n\n\t\t\t\tif (point != null)\n\t\t\t\t{\n\t\t\t\t\tif (flipH)\n\t\t\t\t\t{\n\t\t\t\t\t\tpoint.x = 2 * bounds.getCenterX() - point.x;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (flipV)\n\t\t\t\t\t{\n\t\t\t\t\t\tpoint.y = 2 * bounds.getCenterY() - point.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (point == null)\n\t\t{\n\t\t\tpoint = this.getPoint(terminal);\n\t\t}\n\t}\n\t\n\treturn point;\n};\n\n/**\n * Function: getRoutingCenterX\n * \n * Returns the x-coordinate of the center point for automatic routing.\n */\nmxGraphView.prototype.getRoutingCenterX = function (state)\n{\n\tvar f = (state.style != null) ? parseFloat(state.style\n\t\t[mxConstants.STYLE_ROUTING_CENTER_X]) || 0 : 0;\n\n\treturn state.getCenterX() + f * state.width;\n};\n\n/**\n * Function: getRoutingCenterY\n * \n * Returns the y-coordinate of the center point for automatic routing.\n */\nmxGraphView.prototype.getRoutingCenterY = function (state)\n{\n\tvar f = (state.style != null) ? parseFloat(state.style\n\t\t[mxConstants.STYLE_ROUTING_CENTER_Y]) || 0 : 0;\n\n\treturn state.getCenterY() + f * state.height;\n};\n\n/**\n * Function: getPerimeterBounds\n *\n * Returns the perimeter bounds for the given terminal, edge pair as an\n * <mxRectangle>.\n * \n * If you have a model where each terminal has a relative child that should\n * act as the graphical endpoint for a connection from/to the terminal, then\n * this method can be replaced as follows:\n * \n * (code)\n * var oldGetPerimeterBounds = mxGraphView.prototype.getPerimeterBounds;\n * mxGraphView.prototype.getPerimeterBounds = function(terminal, edge, isSource)\n * {\n *   var model = this.graph.getModel();\n *   var childCount = model.getChildCount(terminal.cell);\n * \n *   if (childCount > 0)\n *   {\n *     var child = model.getChildAt(terminal.cell, 0);\n *     var geo = model.getGeometry(child);\n *\n *     if (geo != null &&\n *         geo.relative)\n *     {\n *       var state = this.getState(child);\n *       \n *       if (state != null)\n *       {\n *         terminal = state;\n *       }\n *     }\n *   }\n *   \n *   return oldGetPerimeterBounds.apply(this, arguments);\n * };\n * (end)\n * \n * Parameters:\n * \n * terminal - <mxCellState> that represents the terminal.\n * border - Number that adds a border between the shape and the perimeter.\n */\nmxGraphView.prototype.getPerimeterBounds = function(terminal, border)\n{\n\tborder = (border != null) ? border : 0;\n\n\tif (terminal != null)\n\t{\n\t\tborder += parseFloat(terminal.style[mxConstants.STYLE_PERIMETER_SPACING] || 0);\n\t}\n\n\treturn terminal.getPerimeterBounds(border * this.scale);\n};\n\n/**\n * Function: getPerimeterFunction\n *\n * Returns the perimeter function for the given state.\n */\nmxGraphView.prototype.getPerimeterFunction = function(state)\n{\n\tvar perimeter = state.style[mxConstants.STYLE_PERIMETER];\n\n\t// Converts string values to objects\n\tif (typeof(perimeter) == \"string\")\n\t{\n\t\tvar tmp = mxStyleRegistry.getValue(perimeter);\n\t\t\n\t\tif (tmp == null && this.isAllowEval())\n\t\t{\n \t\t\ttmp = mxUtils.eval(perimeter);\n\t\t}\n\n\t\tperimeter = tmp;\n\t}\n\t\n\tif (typeof(perimeter) == \"function\")\n\t{\n\t\treturn perimeter;\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: getNextPoint\n *\n * Returns the nearest point in the list of absolute points or the center\n * of the opposite terminal.\n * \n * Parameters:\n * \n * edge - <mxCellState> that represents the edge.\n * opposite - <mxCellState> that represents the opposite terminal.\n * source - Boolean indicating if the next point for the source or target\n * should be returned.\n */\nmxGraphView.prototype.getNextPoint = function(edge, opposite, source)\n{\n\tvar pts = edge.absolutePoints;\n\tvar point = null;\n\t\n\tif (pts != null && pts.length >= 2)\n\t{\n\t\tvar count = pts.length;\n\t\tpoint = pts[(source) ? Math.min(1, count - 1) : Math.max(0, count - 2)];\n\t}\n\t\n\tif (point == null && opposite != null)\n\t{\n\t\tpoint = new mxPoint(opposite.getCenterX(), opposite.getCenterY());\n\t}\n\t\n\treturn point;\n};\n\n/**\n * Function: getVisibleTerminal\n *\n * Returns the nearest ancestor terminal that is visible. The edge appears\n * to be connected to this terminal on the display. The result of this method\n * is cached in <mxCellState.getVisibleTerminalState>.\n * \n * Parameters:\n * \n * edge - <mxCell> whose visible terminal should be returned.\n * source - Boolean that specifies if the source or target terminal\n * should be returned.\n */\nmxGraphView.prototype.getVisibleTerminal = function(edge, source)\n{\n\tvar model = this.graph.getModel();\n\tvar result = model.getTerminal(edge, source);\n\tvar best = result;\n\t\n\twhile (result != null && result != this.currentRoot)\n\t{\n\t\tif (!this.graph.isCellVisible(best) || this.isCellCollapsed(result))\n\t\t{\n\t\t\tbest = result;\n\t\t}\n\t\t\n\t\tresult = model.getParent(result);\n\t}\n\n\t// Checks if the result is valid for the current view state\n\tif (best != null && (!model.contains(best) ||\n\t\tmodel.getParent(best) == model.getRoot() ||\n\t\tbest == this.currentRoot))\n\t{\n\t\tbest = null;\n\t}\n\t\n\treturn best;\n};\n\n/**\n * Function: updateEdgeBounds\n *\n * Updates the given state using the bounding box of t\n * he absolute points.\n * Also updates <mxCellState.terminalDistance>, <mxCellState.length> and\n * <mxCellState.segments>.\n * \n * Parameters:\n * \n * state - <mxCellState> whose bounds should be updated.\n */\nmxGraphView.prototype.updateEdgeBounds = function(state)\n{\n\tvar points = state.absolutePoints;\n\tvar p0 = points[0];\n\tvar pe = points[points.length - 1];\n\t\n\tif (p0.x != pe.x || p0.y != pe.y)\n\t{\n\t\tvar dx = pe.x - p0.x;\n\t\tvar dy = pe.y - p0.y;\n\t\tstate.terminalDistance = Math.sqrt(dx * dx + dy * dy);\n\t}\n\telse\n\t{\n\t\tstate.terminalDistance = 0;\n\t}\n\t\n\tvar length = 0;\n\tvar segments = [];\n\tvar pt = p0;\n\t\n\tif (pt != null)\n\t{\n\t\tvar minX = pt.x;\n\t\tvar minY = pt.y;\n\t\tvar maxX = minX;\n\t\tvar maxY = minY;\n\t\t\n\t\tfor (var i = 1; i < points.length; i++)\n\t\t{\n\t\t\tvar tmp = points[i];\n\t\t\t\n\t\t\tif (tmp != null)\n\t\t\t{\n\t\t\t\tvar dx = pt.x - tmp.x;\n\t\t\t\tvar dy = pt.y - tmp.y;\n\t\t\t\t\n\t\t\t\tvar segment = Math.sqrt(dx * dx + dy * dy);\n\t\t\t\tsegments.push(segment);\n\t\t\t\tlength += segment;\n\t\t\t\t\n\t\t\t\tpt = tmp;\n\t\t\t\t\n\t\t\t\tminX = Math.min(pt.x, minX);\n\t\t\t\tminY = Math.min(pt.y, minY);\n\t\t\t\tmaxX = Math.max(pt.x, maxX);\n\t\t\t\tmaxY = Math.max(pt.y, maxY);\n\t\t\t}\n\t\t}\n\t\t\n\t\tstate.length = length;\n\t\tstate.segments = segments;\n\t\t\n\t\tvar markerSize = 1; // TODO: include marker size\n\t\t\n\t\tstate.x = minX;\n\t\tstate.y = minY;\n\t\tstate.width = Math.max(markerSize, maxX - minX);\n\t\tstate.height = Math.max(markerSize, maxY - minY);\n\t}\n};\n\n/**\n * Function: getPoint\n *\n * Returns the absolute point on the edge for the given relative\n * <mxGeometry> as an <mxPoint>. The edge is represented by the given\n * <mxCellState>.\n * \n * Parameters:\n * \n * state - <mxCellState> that represents the state of the parent edge.\n * geometry - <mxGeometry> that represents the relative location.\n */\nmxGraphView.prototype.getPoint = function(state, geometry)\n{\n\tvar x = state.getCenterX();\n\tvar y = state.getCenterY();\n\t\n\tif (state.segments != null && (geometry == null || geometry.relative))\n\t{\n\t\tvar gx = (geometry != null) ? geometry.x / 2 : 0;\n\t\tvar pointCount = state.absolutePoints.length;\n\t\tvar dist = Math.round((gx + 0.5) * state.length);\n\t\tvar segment = state.segments[0];\n\t\tvar length = 0;\t\t\t\t\n\t\tvar index = 1;\n\n\t\twhile (dist >= Math.round(length + segment) && index < pointCount - 1)\n\t\t{\n\t\t\tlength += segment;\n\t\t\tsegment = state.segments[index++];\n\t\t}\n\n\t\tvar factor = (segment == 0) ? 0 : (dist - length) / segment;\n\t\tvar p0 = state.absolutePoints[index-1];\n\t\tvar pe = state.absolutePoints[index];\n\n\t\tif (p0 != null && pe != null)\n\t\t{\n\t\t\tvar gy = 0;\n\t\t\tvar offsetX = 0;\n\t\t\tvar offsetY = 0;\n\n\t\t\tif (geometry != null)\n\t\t\t{\n\t\t\t\tgy = geometry.y;\n\t\t\t\tvar offset = geometry.offset;\n\t\t\t\t\n\t\t\t\tif (offset != null)\n\t\t\t\t{\n\t\t\t\t\toffsetX = offset.x;\n\t\t\t\t\toffsetY = offset.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar dx = pe.x - p0.x;\n\t\t\tvar dy = pe.y - p0.y;\n\t\t\tvar nx = (segment == 0) ? 0 : dy / segment;\n\t\t\tvar ny = (segment == 0) ? 0 : dx / segment;\n\t\t\t\n\t\t\tx = p0.x + dx * factor + (nx * gy + offsetX) * this.scale;\n\t\t\ty = p0.y + dy * factor - (ny * gy - offsetY) * this.scale;\n\t\t}\n\t}\n\telse if (geometry != null)\n\t{\n\t\tvar offset = geometry.offset;\n\t\t\n\t\tif (offset != null)\n\t\t{\n\t\t\tx += offset.x;\n\t\t\ty += offset.y;\n\t\t}\n\t}\n\t\n\treturn new mxPoint(x, y);\t\t\n};\n\n/**\n * Function: getRelativePoint\n *\n * Gets the relative point that describes the given, absolute label\n * position for the given edge state.\n * \n * Parameters:\n * \n * state - <mxCellState> that represents the state of the parent edge.\n * x - Specifies the x-coordinate of the absolute label location.\n * y - Specifies the y-coordinate of the absolute label location.\n */\nmxGraphView.prototype.getRelativePoint = function(edgeState, x, y)\n{\n\tvar model = this.graph.getModel();\n\tvar geometry = model.getGeometry(edgeState.cell);\n\t\n\tif (geometry != null)\n\t{\n\t\tvar pointCount = edgeState.absolutePoints.length;\n\t\t\n\t\tif (geometry.relative && pointCount > 1)\n\t\t{\n\t\t\tvar totalLength = edgeState.length;\n\t\t\tvar segments = edgeState.segments;\n\n\t\t\t// Works which line segment the point of the label is closest to\n\t\t\tvar p0 = edgeState.absolutePoints[0];\n\t\t\tvar pe = edgeState.absolutePoints[1];\n\t\t\tvar minDist = mxUtils.ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);\n\n\t\t\tvar index = 0;\n\t\t\tvar tmp = 0;\n\t\t\tvar length = 0;\n\t\t\t\n\t\t\tfor (var i = 2; i < pointCount; i++)\n\t\t\t{\n\t\t\t\ttmp += segments[i - 2];\n\t\t\t\tpe = edgeState.absolutePoints[i];\n\t\t\t\tvar dist = mxUtils.ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);\n\n\t\t\t\tif (dist <= minDist)\n\t\t\t\t{\n\t\t\t\t\tminDist = dist;\n\t\t\t\t\tindex = i - 1;\n\t\t\t\t\tlength = tmp;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tp0 = pe;\n\t\t\t}\n\t\t\t\n\t\t\tvar seg = segments[index];\n\t\t\tp0 = edgeState.absolutePoints[index];\n\t\t\tpe = edgeState.absolutePoints[index + 1];\n\t\t\t\n\t\t\tvar x2 = p0.x;\n\t\t\tvar y2 = p0.y;\n\t\t\t\n\t\t\tvar x1 = pe.x;\n\t\t\tvar y1 = pe.y;\n\t\t\t\n\t\t\tvar px = x;\n\t\t\tvar py = y;\n\t\t\t\n\t\t\tvar xSegment = x2 - x1;\n\t\t\tvar ySegment = y2 - y1;\n\t\t\t\n\t\t\tpx -= x1;\n\t\t\tpy -= y1;\n\t\t\tvar projlenSq = 0;\n\t\t\t\n\t\t\tpx = xSegment - px;\n\t\t\tpy = ySegment - py;\n\t\t\tvar dotprod = px * xSegment + py * ySegment;\n\n\t\t\tif (dotprod <= 0.0)\n\t\t\t{\n\t\t\t\tprojlenSq = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprojlenSq = dotprod * dotprod\n\t\t\t\t\t\t/ (xSegment * xSegment + ySegment * ySegment);\n\t\t\t}\n\n\t\t\tvar projlen = Math.sqrt(projlenSq);\n\n\t\t\tif (projlen > seg)\n\t\t\t{\n\t\t\t\tprojlen = seg;\n\t\t\t}\n\n\t\t\tvar yDistance = Math.sqrt(mxUtils.ptSegDistSq(p0.x, p0.y, pe\n\t\t\t\t\t.x, pe.y, x, y));\n\t\t\tvar direction = mxUtils.relativeCcw(p0.x, p0.y, pe.x, pe.y, x, y);\n\n\t\t\tif (direction == -1)\n\t\t\t{\n\t\t\t\tyDistance = -yDistance;\n\t\t\t}\n\n\t\t\t// Constructs the relative point for the label\n\t\t\treturn new mxPoint(((totalLength / 2 - length - projlen) / totalLength) * -2,\n\t\t\t\t\t\tyDistance / this.scale);\n\t\t}\n\t}\n\t\n\treturn new mxPoint();\n};\n\n/**\n * Function: updateEdgeLabelOffset\n *\n * Updates <mxCellState.absoluteOffset> for the given state. The absolute\n * offset is normally used for the position of the edge label. Is is\n * calculated from the geometry as an absolute offset from the center\n * between the two endpoints if the geometry is absolute, or as the\n * relative distance between the center along the line and the absolute\n * orthogonal distance if the geometry is relative.\n * \n * Parameters:\n * \n * state - <mxCellState> whose absolute offset should be updated.\n */\nmxGraphView.prototype.updateEdgeLabelOffset = function(state)\n{\n\tvar points = state.absolutePoints;\n\t\n\tstate.absoluteOffset.x = state.getCenterX();\n\tstate.absoluteOffset.y = state.getCenterY();\n\n\tif (points != null && points.length > 0 && state.segments != null)\n\t{\n\t\tvar geometry = this.graph.getCellGeometry(state.cell);\n\t\t\n\t\tif (geometry.relative)\n\t\t{\n\t\t\tvar offset = this.getPoint(state, geometry);\n\t\t\t\n\t\t\tif (offset != null)\n\t\t\t{\n\t\t\t\tstate.absoluteOffset = offset;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar p0 = points[0];\n\t\t\tvar pe = points[points.length - 1];\n\t\t\t\n\t\t\tif (p0 != null && pe != null)\n\t\t\t{\n\t\t\t\tvar dx = pe.x - p0.x;\n\t\t\t\tvar dy = pe.y - p0.y;\n\t\t\t\tvar x0 = 0;\n\t\t\t\tvar y0 = 0;\n\n\t\t\t\tvar off = geometry.offset;\n\t\t\t\t\n\t\t\t\tif (off != null)\n\t\t\t\t{\n\t\t\t\t\tx0 = off.x;\n\t\t\t\t\ty0 = off.y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar x = p0.x + dx / 2 + x0 * this.scale;\n\t\t\t\tvar y = p0.y + dy / 2 + y0 * this.scale;\n\t\t\t\t\n\t\t\t\tstate.absoluteOffset.x = x;\n\t\t\t\tstate.absoluteOffset.y = y;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: getState\n *\n * Returns the <mxCellState> for the given cell. If create is true, then\n * the state is created if it does not yet exist.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the <mxCellState> should be returned.\n * create - Optional boolean indicating if a new state should be created\n * if it does not yet exist. Default is false.\n */\nmxGraphView.prototype.getState = function(cell, create)\n{\n\tcreate = create || false;\n\tvar state = null;\n\t\n\tif (cell != null)\n\t{\n\t\tstate = this.states.get(cell);\n\t\t\n\t\tif (create && (state == null || this.updateStyle) && this.graph.isCellVisible(cell))\n\t\t{\n\t\t\tif (state == null)\n\t\t\t{\n\t\t\t\tstate = this.createState(cell);\n\t\t\t\tthis.states.put(cell, state);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate.style = this.graph.getCellStyle(cell);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn state;\n};\n\n/**\n * Function: isRendering\n *\n * Returns <rendering>.\n */\nmxGraphView.prototype.isRendering = function()\n{\n\treturn this.rendering;\n};\n\n/**\n * Function: setRendering\n *\n * Sets <rendering>.\n */\nmxGraphView.prototype.setRendering = function(value)\n{\n\tthis.rendering = value;\n};\n\n/**\n * Function: isAllowEval\n *\n * Returns <allowEval>.\n */\nmxGraphView.prototype.isAllowEval = function()\n{\n\treturn this.allowEval;\n};\n\n/**\n * Function: setAllowEval\n *\n * Sets <allowEval>.\n */\nmxGraphView.prototype.setAllowEval = function(value)\n{\n\tthis.allowEval = value;\n};\n\n/**\n * Function: getStates\n *\n * Returns <states>.\n */\nmxGraphView.prototype.getStates = function()\n{\n\treturn this.states;\n};\n\n/**\n * Function: setStates\n *\n * Sets <states>.\n */\nmxGraphView.prototype.setStates = function(value)\n{\n\tthis.states = value;\n};\n\n/**\n * Function: getCellStates\n *\n * Returns the <mxCellStates> for the given array of <mxCells>. The array\n * contains all states that are not null, that is, the returned array may\n * have less elements than the given array. If no argument is given, then\n * this returns <states>.\n */\nmxGraphView.prototype.getCellStates = function(cells)\n{\n\tif (cells == null)\n\t{\n\t\treturn this.states;\n\t}\n\telse\n\t{\n\t\tvar result = [];\n\t\t\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tvar state = this.getState(cells[i]);\n\t\t\t\n\t\t\tif (state != null)\n\t\t\t{\n\t\t\t\tresult.push(state);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n};\n\n/**\n * Function: removeState\n *\n * Removes and returns the <mxCellState> for the given cell.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the <mxCellState> should be removed.\n */\nmxGraphView.prototype.removeState = function(cell)\n{\n\tvar state = null;\n\t\n\tif (cell != null)\n\t{\n\t\tstate = this.states.remove(cell);\n\t\t\n\t\tif (state != null)\n\t\t{\n\t\t\tthis.graph.cellRenderer.destroy(state);\n\t\t\tstate.invalid = true;\n\t\t\tstate.destroy();\n\t\t}\n\t}\n\t\n\treturn state;\n};\n\n/**\n * Function: createState\n *\n * Creates and returns an <mxCellState> for the given cell and initializes\n * it using <mxCellRenderer.initialize>.\n * \n * Parameters:\n * \n * cell - <mxCell> for which a new <mxCellState> should be created.\n */\nmxGraphView.prototype.createState = function(cell)\n{\n\treturn new mxCellState(this, cell, this.graph.getCellStyle(cell));\n};\n\n/**\n * Function: getCanvas\n *\n * Returns the DOM node that contains the background-, draw- and\n * overlay- and decoratorpanes.\n */\nmxGraphView.prototype.getCanvas = function()\n{\n\treturn this.canvas;\n};\n\n/**\n * Function: getBackgroundPane\n *\n * Returns the DOM node that represents the background layer.\n */\nmxGraphView.prototype.getBackgroundPane = function()\n{\n\treturn this.backgroundPane;\n};\n\n/**\n * Function: getDrawPane\n *\n * Returns the DOM node that represents the main drawing layer.\n */\nmxGraphView.prototype.getDrawPane = function()\n{\n\treturn this.drawPane;\n};\n\n/**\n * Function: getOverlayPane\n *\n * Returns the DOM node that represents the layer above the drawing layer.\n */\nmxGraphView.prototype.getOverlayPane = function()\n{\n\treturn this.overlayPane;\n};\n\n/**\n * Function: getDecoratorPane\n *\n * Returns the DOM node that represents the topmost drawing layer.\n */\nmxGraphView.prototype.getDecoratorPane = function()\n{\n\treturn this.decoratorPane;\n};\n\n/**\n * Function: isContainerEvent\n * \n * Returns true if the event origin is one of the drawing panes or\n * containers of the view.\n */\nmxGraphView.prototype.isContainerEvent = function(evt)\n{\n\tvar source = mxEvent.getSource(evt);\n\n\treturn (source == this.graph.container ||\n\t\tsource.parentNode == this.backgroundPane ||\n\t\t(source.parentNode != null &&\n\t\tsource.parentNode.parentNode == this.backgroundPane) ||\n\t\tsource == this.canvas.parentNode ||\n\t\tsource == this.canvas ||\n\t\tsource == this.backgroundPane ||\n\t\tsource == this.drawPane ||\n\t\tsource == this.overlayPane ||\n\t\tsource == this.decoratorPane);\n};\n\n/**\n * Function: isScrollEvent\n * \n * Returns true if the event origin is one of the scrollbars of the\n * container in IE. Such events are ignored.\n */\n mxGraphView.prototype.isScrollEvent = function(evt)\n{\n\tvar offset = mxUtils.getOffset(this.graph.container);\n\tvar pt = new mxPoint(evt.clientX - offset.x, evt.clientY - offset.y);\n\n\tvar outWidth = this.graph.container.offsetWidth;\n\tvar inWidth = this.graph.container.clientWidth;\n\n\tif (outWidth > inWidth && pt.x > inWidth + 2 && pt.x <= outWidth)\n\t{\n\t\treturn true;\n\t}\n\n\tvar outHeight = this.graph.container.offsetHeight;\n\tvar inHeight = this.graph.container.clientHeight;\n\t\n\tif (outHeight > inHeight && pt.y > inHeight + 2 && pt.y <= outHeight)\n\t{\n\t\treturn true;\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: init\n *\n * Initializes the graph event dispatch loop for the specified container\n * and invokes <create> to create the required DOM nodes for the display.\n */\nmxGraphView.prototype.init = function()\n{\n\tthis.installListeners();\n\t\n\t// Creates the DOM nodes for the respective display dialect\n\tvar graph = this.graph;\n\t\n\tif (graph.dialect == mxConstants.DIALECT_SVG)\n\t{\n\t\tthis.createSvg();\n\t}\n\telse if (graph.dialect == mxConstants.DIALECT_VML)\n\t{\n\t\tthis.createVml();\n\t}\n\telse\n\t{\n\t\tthis.createHtml();\n\t}\n};\n\n/**\n * Function: installListeners\n *\n * Installs the required listeners in the container.\n */\nmxGraphView.prototype.installListeners = function()\n{\n\tvar graph = this.graph;\n\tvar container = graph.container;\n\t\n\tif (container != null)\n\t{\n\t\t// Support for touch device gestures (eg. pinch to zoom)\n\t\t// Double-tap handling is implemented in mxGraph.fireMouseEvent\n\t\tif (mxClient.IS_TOUCH)\n\t\t{\n\t\t\tmxEvent.addListener(container, 'gesturestart', mxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tgraph.fireGestureEvent(evt);\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t}));\n\t\t\t\n\t\t\tmxEvent.addListener(container, 'gesturechange', mxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tgraph.fireGestureEvent(evt);\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t}));\n\n\t\t\tmxEvent.addListener(container, 'gestureend', mxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tgraph.fireGestureEvent(evt);\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t}));\n\t\t}\n\t\t\n\t\t// Fires event only for one pointer per gesture\n\t\tvar pointerId = null;\n\t\t\n\t\t// Adds basic listeners for graph event dispatching\n\t\tmxEvent.addGestureListeners(container, mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\t// Condition to avoid scrollbar events starting a rubberband selection\n\t\t\tif (this.isContainerEvent(evt) && ((!mxClient.IS_IE && !mxClient.IS_IE11 && !mxClient.IS_GC &&\n\t\t\t\t!mxClient.IS_OP && !mxClient.IS_SF) || !this.isScrollEvent(evt)))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));\n\t\t\t\tpointerId = evt.pointerId;\n\t\t\t}\n\t\t}),\n\t\tmxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tif (this.isContainerEvent(evt) && (pointerId == null || evt.pointerId == pointerId))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));\n\t\t\t}\n\t\t}),\n\t\tmxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tif (this.isContainerEvent(evt))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));\n\t\t\t}\n\t\t\t\n\t\t\tpointerId = null;\n\t\t}));\n\t\t\n\t\t// Adds listener for double click handling on background, this does always\n\t\t// use native event handler, we assume that the DOM of the background\n\t\t// does not change during the double click\n\t\tmxEvent.addListener(container, 'dblclick', mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tif (this.isContainerEvent(evt))\n\t\t\t{\n\t\t\t\tgraph.dblClick(evt);\n\t\t\t}\n\t\t}));\n\n\t\t// Workaround for touch events which started on some DOM node\n\t\t// on top of the container, in which case the cells under the\n\t\t// mouse for the move and up events are not detected.\n\t\tvar getState = function(evt)\n\t\t{\n\t\t\tvar state = null;\n\t\t\t\n\t\t\t// Workaround for touch events which started on some DOM node\n\t\t\t// on top of the container, in which case the cells under the\n\t\t\t// mouse for the move and up events are not detected.\n\t\t\tif (mxClient.IS_TOUCH)\n\t\t\t{\n\t\t\t\tvar x = mxEvent.getClientX(evt);\n\t\t\t\tvar y = mxEvent.getClientY(evt);\n\t\t\t\t\n\t\t\t\t// Dispatches the drop event to the graph which\n\t\t\t\t// consumes and executes the source function\n\t\t\t\tvar pt = mxUtils.convertPoint(container, x, y);\n\t\t\t\tstate = graph.view.getState(graph.getCellAt(pt.x, pt.y));\n\t\t\t}\n\t\t\t\n\t\t\treturn state;\n\t\t};\n\t\t\n\t\t// Adds basic listeners for graph event dispatching outside of the\n\t\t// container and finishing the handling of a single gesture\n\t\t// Implemented via graph event dispatch loop to avoid duplicate events\n\t\t// in Firefox and Chrome\n\t\tgraph.addMouseListener(\n\t\t{\n\t\t\tmouseDown: function(sender, me)\n\t\t\t{\n\t\t\t\tgraph.popupMenuHandler.hideMenu();\n\t\t\t},\n\t\t\tmouseMove: function() { },\n\t\t\tmouseUp: function() { }\n\t\t});\n\t\t\n\t\tthis.moveHandler = mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\t// Hides the tooltip if mouse is outside container\n\t\t\tif (graph.tooltipHandler != null && graph.tooltipHandler.isHideOnHover())\n\t\t\t{\n\t\t\t\tgraph.tooltipHandler.hide();\n\t\t\t}\n\n\t\t\tif (this.captureDocumentGesture && graph.isMouseDown && graph.container != null &&\n\t\t\t\t!this.isContainerEvent(evt) && graph.container.style.display != 'none' &&\n\t\t\t\tgraph.container.style.visibility != 'hidden' && !mxEvent.isConsumed(evt))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, getState(evt)));\n\t\t\t}\n\t\t});\n\t\t\n\t\tthis.endHandler = mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tif (this.captureDocumentGesture && graph.isMouseDown && graph.container != null &&\n\t\t\t\t!this.isContainerEvent(evt) && graph.container.style.display != 'none' &&\n\t\t\t\tgraph.container.style.visibility != 'hidden')\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));\n\t\t\t}\n\t\t});\n\t\t\n\t\tmxEvent.addGestureListeners(document, null, this.moveHandler, this.endHandler);\n\t}\n};\n\n/**\n * Function: createHtml\n *\n * Creates the DOM nodes for the HTML display.\n */\nmxGraphView.prototype.createHtml = function()\n{\n\tvar container = this.graph.container;\n\t\n\tif (container != null)\n\t{\n\t\tthis.canvas = this.createHtmlPane('100%', '100%');\n\t\tthis.canvas.style.overflow = 'hidden';\n\t\n\t\t// Uses minimal size for inner DIVs on Canvas. This is required\n\t\t// for correct event processing in IE. If we have an overlapping\n\t\t// DIV then the events on the cells are only fired for labels.\n\t\tthis.backgroundPane = this.createHtmlPane('1px', '1px');\n\t\tthis.drawPane = this.createHtmlPane('1px', '1px');\n\t\tthis.overlayPane = this.createHtmlPane('1px', '1px');\n\t\tthis.decoratorPane = this.createHtmlPane('1px', '1px');\n\t\t\n\t\tthis.canvas.appendChild(this.backgroundPane);\n\t\tthis.canvas.appendChild(this.drawPane);\n\t\tthis.canvas.appendChild(this.overlayPane);\n\t\tthis.canvas.appendChild(this.decoratorPane);\n\n\t\tcontainer.appendChild(this.canvas);\n\t\tthis.updateContainerStyle(container);\n\t\t\n\t\t// Implements minWidth/minHeight in quirks mode\n\t\tif (mxClient.IS_QUIRKS)\n\t\t{\n\t\t\tvar onResize = mxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tvar bounds = this.getGraphBounds();\n\t\t\t\tvar width = bounds.x + bounds.width + this.graph.border;\n\t\t\t\tvar height = bounds.y + bounds.height + this.graph.border;\n\t\t\t\t\n\t\t\t\tthis.updateHtmlCanvasSize(width, height);\n\t\t\t});\n\t\t\t\n\t\t\tmxEvent.addListener(window, 'resize', onResize);\n\t\t}\n\t}\n};\n\n/**\n * Function: updateHtmlCanvasSize\n * \n * Updates the size of the HTML canvas.\n */\nmxGraphView.prototype.updateHtmlCanvasSize = function(width, height)\n{\n\tif (this.graph.container != null)\n\t{\n\t\tvar ow = this.graph.container.offsetWidth;\n\t\tvar oh = this.graph.container.offsetHeight;\n\n\t\tif (ow < width)\n\t\t{\n\t\t\tthis.canvas.style.width = width + 'px';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.canvas.style.width = '100%';\n\t\t}\n\n\t\tif (oh < height)\n\t\t{\n\t\t\tthis.canvas.style.height = height + 'px';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.canvas.style.height = '100%';\n\t\t}\n\t}\n};\n\n/**\n * Function: createHtmlPane\n * \n * Creates and returns a drawing pane in HTML (DIV).\n */\nmxGraphView.prototype.createHtmlPane = function(width, height)\n{\n\tvar pane = document.createElement('DIV');\n\t\n\tif (width != null && height != null)\n\t{\n\t\tpane.style.position = 'absolute';\n\t\tpane.style.left = '0px';\n\t\tpane.style.top = '0px';\n\n\t\tpane.style.width = width;\n\t\tpane.style.height = height;\n\t}\n\telse\n\t{\n\t\tpane.style.position = 'relative';\n\t}\n\t\n\treturn pane;\n};\n\n/**\n * Function: createVml\n *\n * Creates the DOM nodes for the VML display.\n */\nmxGraphView.prototype.createVml = function()\n{\n\tvar container = this.graph.container;\n\n\tif (container != null)\n\t{\n\t\tvar width = container.offsetWidth;\n\t\tvar height = container.offsetHeight;\n\t\tthis.canvas = this.createVmlPane(width, height);\n\t\tthis.canvas.style.overflow = 'hidden';\n\t\t\n\t\tthis.backgroundPane = this.createVmlPane(width, height);\n\t\tthis.drawPane = this.createVmlPane(width, height);\n\t\tthis.overlayPane = this.createVmlPane(width, height);\n\t\tthis.decoratorPane = this.createVmlPane(width, height);\n\t\t\n\t\tthis.canvas.appendChild(this.backgroundPane);\n\t\tthis.canvas.appendChild(this.drawPane);\n\t\tthis.canvas.appendChild(this.overlayPane);\n\t\tthis.canvas.appendChild(this.decoratorPane);\n\t\t\n\t\tcontainer.appendChild(this.canvas);\n\t}\n};\n\n/**\n * Function: createVmlPane\n * \n * Creates a drawing pane in VML (group).\n */\nmxGraphView.prototype.createVmlPane = function(width, height)\n{\n\tvar pane = document.createElement(mxClient.VML_PREFIX + ':group');\n\t\n\t// At this point the width and height are potentially\n\t// uninitialized. That's OK.\n\tpane.style.position = 'absolute';\n\tpane.style.left = '0px';\n\tpane.style.top = '0px';\n\n\tpane.style.width = width + 'px';\n\tpane.style.height = height + 'px';\n\n\tpane.setAttribute('coordsize', width + ',' + height);\n\tpane.setAttribute('coordorigin', '0,0');\n\t\n\treturn pane;\n};\n\n/**\n * Function: createSvg\n *\n * Creates and returns the DOM nodes for the SVG display.\n */\nmxGraphView.prototype.createSvg = function()\n{\n\tvar container = this.graph.container;\n\tthis.canvas = document.createElementNS(mxConstants.NS_SVG, 'g');\n\t\n\t// For background image\n\tthis.backgroundPane = document.createElementNS(mxConstants.NS_SVG, 'g');\n\tthis.canvas.appendChild(this.backgroundPane);\n\n\t// Adds two layers (background is early feature)\n\tthis.drawPane = document.createElementNS(mxConstants.NS_SVG, 'g');\n\tthis.canvas.appendChild(this.drawPane);\n\n\tthis.overlayPane = document.createElementNS(mxConstants.NS_SVG, 'g');\n\tthis.canvas.appendChild(this.overlayPane);\n\t\n\tthis.decoratorPane = document.createElementNS(mxConstants.NS_SVG, 'g');\n\tthis.canvas.appendChild(this.decoratorPane);\n\t\n\tvar root = document.createElementNS(mxConstants.NS_SVG, 'svg');\n\troot.style.left = '0px';\n\troot.style.top = '0px';\n\troot.style.width = '100%';\n\troot.style.height = '100%';\n\t\n\t// NOTE: In standards mode, the SVG must have block layout\n\t// in order for the container DIV to not show scrollbars.\n\troot.style.display = 'block';\n\troot.appendChild(this.canvas);\n\t\n\t// Workaround for scrollbars in IE11 and below\n\tif (mxClient.IS_IE || mxClient.IS_IE11)\n\t{\n\t\troot.style.overflow = 'hidden';\n\t}\n\n\tif (container != null)\n\t{\n\t\tcontainer.appendChild(root);\n\t\tthis.updateContainerStyle(container);\n\t}\n};\n\n/**\n * Function: updateContainerStyle\n * \n * Updates the style of the container after installing the SVG DOM elements.\n */\nmxGraphView.prototype.updateContainerStyle = function(container)\n{\n\t// Workaround for offset of container\n\tvar style = mxUtils.getCurrentStyle(container);\n\t\n\tif (style != null && style.position == 'static')\n\t{\n\t\tcontainer.style.position = 'relative';\n\t}\n\t\n\t// Disables built-in pan and zoom in IE10 and later\n\tif (mxClient.IS_POINTER)\n\t{\n\t\tcontainer.style.touchAction = 'none';\n\t}\n};\n\n/**\n * Function: destroy\n * \n * Destroys the view and all its resources.\n */\nmxGraphView.prototype.destroy = function()\n{\n\tvar root = (this.canvas != null) ? this.canvas.ownerSVGElement : null;\n\t\n\tif (root == null)\n\t{\n\t\troot = this.canvas;\n\t}\n\t\n\tif (root != null && root.parentNode != null)\n\t{\n\t\tthis.clear(this.currentRoot, true);\n\t\tmxEvent.removeGestureListeners(document, null, this.moveHandler, this.endHandler);\n\t\tmxEvent.release(this.graph.container);\n\t\troot.parentNode.removeChild(root);\n\t\t\n\t\tthis.moveHandler = null;\n\t\tthis.endHandler = null;\n\t\tthis.canvas = null;\n\t\tthis.backgroundPane = null;\n\t\tthis.drawPane = null;\n\t\tthis.overlayPane = null;\n\t\tthis.decoratorPane = null;\n\t}\n};\n\n/**\n * Class: mxCurrentRootChange\n *\n * Action to change the current root in a view.\n *\n * Constructor: mxCurrentRootChange\n *\n * Constructs a change of the current root in the given view.\n */\nfunction mxCurrentRootChange(view, root)\n{\n\tthis.view = view;\n\tthis.root = root;\n\tthis.previous = root;\n\tthis.isUp = root == null;\n\t\n\tif (!this.isUp)\n\t{\n\t\tvar tmp = this.view.currentRoot;\n\t\tvar model = this.view.graph.getModel();\n\t\t\n\t\twhile (tmp != null)\n\t\t{\n\t\t\tif (tmp == root)\n\t\t\t{\n\t\t\t\tthis.isUp = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ttmp = model.getParent(tmp);\n\t\t}\n\t}\n};\n\n/**\n * Function: execute\n *\n * Changes the current root of the view.\n */\nmxCurrentRootChange.prototype.execute = function()\n{\n\tvar tmp = this.view.currentRoot;\n\tthis.view.currentRoot = this.previous;\n\tthis.previous = tmp;\n\n\tvar translate = this.view.graph.getTranslateForRoot(this.view.currentRoot);\n\t\n\tif (translate != null)\n\t{\n\t\tthis.view.translate = new mxPoint(-translate.x, -translate.y);\n\t}\n\n\tif (this.isUp)\n\t{\n\t\tthis.view.clear(this.view.currentRoot, true);\n\t\tthis.view.validate();\n\t}\n\telse\n\t{\n\t\tthis.view.refresh();\n\t}\n\t\n\tvar name = (this.isUp) ? mxEvent.UP : mxEvent.DOWN;\n\tthis.view.fireEvent(new mxEventObject(name,\n\t\t'root', this.view.currentRoot, 'previous', this.previous));\n\tthis.isUp = !this.isUp;\n};\n\n__mxOutput.mxGraphView = typeof mxGraphView !== 'undefined' ? mxGraphView : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraph\n *\n * Extends <mxEventSource> to implement a graph component for\n * the browser. This is the main class of the package. To activate\n * panning and connections use <setPanning> and <setConnectable>.\n * For rubberband selection you must create a new instance of\n * <mxRubberband>. The following listeners are added to\n * <mouseListeners> by default:\n * \n * - <tooltipHandler>: <mxTooltipHandler> that displays tooltips\n * - <panningHandler>: <mxPanningHandler> for panning and popup menus\n * - <connectionHandler>: <mxConnectionHandler> for creating connections\n * - <graphHandler>: <mxGraphHandler> for moving and cloning cells\n * \n * These listeners will be called in the above order if they are enabled.\n *\n * Background Images:\n * \n * To display a background image, set the image, image width and\n * image height using <setBackgroundImage>. If one of the\n * above values has changed then the <view>'s <mxGraphView.validate>\n * should be invoked.\n * \n * Cell Images:\n * \n * To use images in cells, a shape must be specified in the default\n * vertex style (or any named style). Possible shapes are\n * <mxConstants.SHAPE_IMAGE> and <mxConstants.SHAPE_LABEL>.\n * The code to change the shape used in the default vertex style,\n * the following code is used:\n * \n * (code)\n * var style = graph.getStylesheet().getDefaultVertexStyle();\n * style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_IMAGE;\n * (end)\n * \n * For the default vertex style, the image to be displayed can be\n * specified in a cell's style using the <mxConstants.STYLE_IMAGE>\n * key and the image URL as a value, for example:\n * \n * (code)\n * image=http://www.example.com/image.gif\n * (end)\n * \n * For a named style, the the stylename must be the first element\n * of the cell style:\n * \n * (code)\n * stylename;image=http://www.example.com/image.gif\n * (end)\n * \n * A cell style can have any number of key=value pairs added, divided\n * by a semicolon as follows:\n * \n * (code)\n * [stylename;|key=value;]\n * (end)\n *\n * Labels:\n * \n * The cell labels are defined by <getLabel> which uses <convertValueToString>\n * if <labelsVisible> is true. If a label must be rendered as HTML markup, then\n * <isHtmlLabel> should return true for the respective cell. If all labels\n * contain HTML markup, <htmlLabels> can be set to true. NOTE: Enabling HTML\n * labels carries a possible security risk (see the section on security in\n * the manual).\n * \n * If wrapping is needed for a label, then <isHtmlLabel> and <isWrapping> must\n * return true for the cell whose label should be wrapped. See <isWrapping> for\n * an example.\n * \n * If clipping is needed to keep the rendering of a HTML label inside the\n * bounds of its vertex, then <isClipping> should return true for the\n * respective cell.\n * \n * By default, edge labels are movable and vertex labels are fixed. This can be\n * changed by setting <edgeLabelsMovable> and <vertexLabelsMovable>, or by\n * overriding <isLabelMovable>.\n *\n * In-place Editing:\n * \n * In-place editing is started with a doubleclick or by typing F2.\n * Programmatically, <edit> is used to check if the cell is editable\n * (<isCellEditable>) and call <startEditingAtCell>, which invokes\n * <mxCellEditor.startEditing>. The editor uses the value returned\n * by <getEditingValue> as the editing value.\n * \n * After in-place editing, <labelChanged> is called, which invokes\n * <mxGraphModel.setValue>, which in turn calls\n * <mxGraphModel.valueForCellChanged> via <mxValueChange>.\n * \n * The event that triggers in-place editing is passed through to the\n * <cellEditor>, which may take special actions depending on the type of the\n * event or mouse location, and is also passed to <getEditingValue>. The event\n * is then passed back to the event processing functions which can perform\n * specific actions based on the trigger event.\n * \n * Tooltips:\n * \n * Tooltips are implemented by <getTooltip>, which calls <getTooltipForCell>\n * if a cell is under the mousepointer. The default implementation checks if\n * the cell has a getTooltip function and calls it if it exists. Hence, in order\n * to provide custom tooltips, the cell must provide a getTooltip function, or \n * one of the two above functions must be overridden.\n * \n * Typically, for custom cell tooltips, the latter function is overridden as\n * follows:\n * \n * (code)\n * graph.getTooltipForCell = function(cell)\n * {\n *   var label = this.convertValueToString(cell);\n *   return 'Tooltip for '+label;\n * }\n * (end)\n * \n * When using a config file, the function is overridden in the mxGraph section\n * using the following entry:\n * \n * (code)\n * <add as=\"getTooltipForCell\"><![CDATA[\n *   function(cell)\n *   {\n *     var label = this.convertValueToString(cell);\n *     return 'Tooltip for '+label;\n *   }\n * ]]></add>\n * (end)\n * \n * \"this\" refers to the graph in the implementation, so for example to check if \n * a cell is an edge, you use this.getModel().isEdge(cell)\n *\n * For replacing the default implementation of <getTooltipForCell> (rather than \n * replacing the function on a specific instance), the following code should be \n * used after loading the JavaScript files, but before creating a new mxGraph \n * instance using <mxGraph>:\n * \n * (code)\n * mxGraph.prototype.getTooltipForCell = function(cell)\n * {\n *   var label = this.convertValueToString(cell);\n *   return 'Tooltip for '+label;\n * }\n * (end)\n * \n * Shapes & Styles:\n * \n * The implementation of new shapes is demonstrated in the examples. We'll assume\n * that we have implemented a custom shape with the name BoxShape which we want\n * to use for drawing vertices. To use this shape, it must first be registered in\n * the cell renderer as follows:\n * \n * (code)\n * mxCellRenderer.registerShape('box', BoxShape);\n * (end)\n * \n * The code registers the BoxShape constructor under the name box in the cell\n * renderer of the graph. The shape can now be referenced using the shape-key in\n * a style definition. (The cell renderer contains a set of additional shapes,\n * namely one for each constant with a SHAPE-prefix in <mxConstants>.)\n *\n * Styles are a collection of key, value pairs and a stylesheet is a collection\n * of named styles. The names are referenced by the cellstyle, which is stored\n * in <mxCell.style> with the following format: [stylename;|key=value;]. The\n * string is resolved to a collection of key, value pairs, where the keys are\n * overridden with the values in the string.\n *\n * When introducing a new shape, the name under which the shape is registered\n * must be used in the stylesheet. There are three ways of doing this:\n * \n *   - By changing the default style, so that all vertices will use the new\n * \t\tshape\n *   - By defining a new style, so that only vertices with the respective\n * \t\tcellstyle will use the new shape\n *   - By using shape=box in the cellstyle's optional list of key, value pairs\n * \t\tto be overridden\n *\n * In the first case, the code to fetch and modify the default style for\n * vertices is as follows:\n * \n * (code)\n * var style = graph.getStylesheet().getDefaultVertexStyle();\n * style[mxConstants.STYLE_SHAPE] = 'box';\n * (end)\n * \n * The code takes the default vertex style, which is used for all vertices that\n * do not have a specific cellstyle, and modifies the value for the shape-key\n * in-place to use the new BoxShape for drawing vertices. This is done by\n * assigning the box value in the second line, which refers to the name of the\n * BoxShape in the cell renderer.\n * \n * In the second case, a collection of key, value pairs is created and then\n * added to the stylesheet under a new name. In order to distinguish the\n * shapename and the stylename we'll use boxstyle for the stylename:\n * \n * (code)\n * var style = new Object();\n * style[mxConstants.STYLE_SHAPE] = 'box';\n * style[mxConstants.STYLE_STROKECOLOR] = '#000000';\n * style[mxConstants.STYLE_FONTCOLOR] = '#000000';\n * graph.getStylesheet().putCellStyle('boxstyle', style);\n * (end)\n * \n * The code adds a new style with the name boxstyle to the stylesheet. To use\n * this style with a cell, it must be referenced from the cellstyle as follows:\n * \n * (code)\n * var vertex = graph.insertVertex(parent, null, 'Hello, World!', 20, 20, 80, 20,\n * \t\t\t\t'boxstyle');\n * (end)\n * \n * To summarize, each new shape must be registered in the <mxCellRenderer> with\n * a unique name. That name is then used as the value of the shape-key in a\n * default or custom style. If there are multiple custom shapes, then there\n * should be a separate style for each shape.\n * \n * Inheriting Styles:\n * \n * For fill-, stroke-, gradient-, font- and indicatorColors special keywords\n * can be used. The inherit keyword for one of these colors will inherit the\n * color for the same key from the parent cell. The swimlane keyword does the\n * same, but inherits from the nearest swimlane in the ancestor hierarchy.\n * Finally, the indicated keyword will use the color of the indicator as the\n * color for the given key.\n * \n * Scrollbars:\n * \n * The <containers> overflow CSS property defines if scrollbars are used to\n * display the graph. For values of 'auto' or 'scroll', the scrollbars will\n * be shown. Note that the <resizeContainer> flag is normally not used\n * together with scrollbars, as it will resize the container to match the\n * size of the graph after each change.\n * \n * Multiplicities and Validation:\n * \n * To control the possible connections in mxGraph, <getEdgeValidationError> is\n * used. The default implementation of the function uses <multiplicities>,\n * which is an array of <mxMultiplicity>. Using this class allows to establish\n * simple multiplicities, which are enforced by the graph.\n * \n * The <mxMultiplicity> uses <mxCell.is> to determine for which terminals it\n * applies. The default implementation of <mxCell.is> works with DOM nodes (XML\n * nodes) and checks if the given type parameter matches the nodeName of the\n * node (case insensitive). Optionally, an attributename and value can be\n * specified which are also checked.\n * \n * <getEdgeValidationError> is called whenever the connectivity of an edge\n * changes. It returns an empty string or an error message if the edge is\n * invalid or null if the edge is valid. If the returned string is not empty\n * then it is displayed as an error message.\n * \n * <mxMultiplicity> allows to specify the multiplicity between a terminal and\n * its possible neighbors. For example, if any rectangle may only be connected\n * to, say, a maximum of two circles you can add the following rule to\n * <multiplicities>:\n * \n * (code)\n * graph.multiplicities.push(new mxMultiplicity(\n *   true, 'rectangle', null, null, 0, 2, ['circle'],\n *   'Only 2 targets allowed',\n *   'Only shape targets allowed'));\n * (end)\n * \n * This will display the first error message whenever a rectangle is connected\n * to more than two circles and the second error message if a rectangle is\n * connected to anything but a circle.\n * \n * For certain multiplicities, such as a minimum of 1 connection, which cannot\n * be enforced at cell creation time (unless the cell is created together with\n * the connection), mxGraph offers <validate> which checks all multiplicities\n * for all cells and displays the respective error messages in an overlay icon\n * on the cells.\n * \n * If a cell is collapsed and contains validation errors, a respective warning\n * icon is attached to the collapsed cell.\n * \n * Auto-Layout:\n * \n * For automatic layout, the <getLayout> hook is provided in <mxLayoutManager>.\n * It can be overridden to return a layout algorithm for the children of a\n * given cell.\n * \n * Unconnected edges:\n * \n * The default values for all switches are designed to meet the requirements of\n * general diagram drawing applications. A very typical set of settings to\n * avoid edges that are not connected is the following:\n * \n * (code)\n * graph.setAllowDanglingEdges(false);\n * graph.setDisconnectOnMove(false);\n * (end)\n * \n * Setting the <cloneInvalidEdges> switch to true is optional. This switch\n * controls if edges are inserted after a copy, paste or clone-drag if they are\n * invalid. For example, edges are invalid if copied or control-dragged without \n * having selected the corresponding terminals and allowDanglingEdges is\n * false, in which case the edges will not be cloned if the switch is false.\n * \n * Output:\n * \n * To produce an XML representation for a diagram, the following code can be\n * used.\n * \n * (code)\n * var enc = new mxCodec(mxUtils.createXmlDocument());\n * var node = enc.encode(graph.getModel());\n * (end)\n * \n * This will produce an XML node than can be handled using the DOM API or\n * turned into a string representation using the following code:\n * \n * (code)\n * var xml = mxUtils.getXml(node);\n * (end)\n * \n * To obtain a formatted string, mxUtils.getPrettyXml can be used instead.\n * \n * This string can now be stored in a local persistent storage (for example\n * using Google Gears) or it can be passed to a backend using mxUtils.post as\n * follows. The url variable is the URL of the Java servlet, PHP page or HTTP\n * handler, depending on the server.\n * \n * (code)\n * var xmlString = encodeURIComponent(mxUtils.getXml(node));\n * mxUtils.post(url, 'xml='+xmlString, function(req)\n * {\n *   // Process server response using req of type mxXmlRequest\n * });\n * (end)\n * \n * Input:\n * \n * To load an XML representation of a diagram into an existing graph object\n * mxUtils.load can be used as follows. The url variable is the URL of the Java\n * servlet, PHP page or HTTP handler that produces the XML string.\n * \n * (code)\n * var xmlDoc = mxUtils.load(url).getXml();\n * var node = xmlDoc.documentElement;\n * var dec = new mxCodec(node.ownerDocument);\n * dec.decode(node, graph.getModel());\n * (end)\n * \n * For creating a page that loads the client and a diagram using a single\n * request please refer to the deployment examples in the backends.\n * \n * Functional dependencies:\n * \n * (see images/callgraph.png)\n * \n * Resources:\n *\n * resources/graph - Language resources for mxGraph\n *\n * Group: Events\n * \n * Event: mxEvent.ROOT\n * \n * Fires if the root in the model has changed. This event has no properties.\n * \n * Event: mxEvent.ALIGN_CELLS\n * \n * Fires between begin- and endUpdate in <alignCells>. The <code>cells</code>\n * and <code>align</code> properties contain the respective arguments that were\n * passed to <alignCells>.\n *\n * Event: mxEvent.FLIP_EDGE\n *\n * Fires between begin- and endUpdate in <flipEdge>. The <code>edge</code>\n * property contains the edge passed to <flipEdge>.\n * \n * Event: mxEvent.ORDER_CELLS\n * \n * Fires between begin- and endUpdate in <orderCells>. The <code>cells</code>\n * and <code>back</code> properties contain the respective arguments that were\n * passed to <orderCells>.\n *\n * Event: mxEvent.CELLS_ORDERED\n *\n * Fires between begin- and endUpdate in <cellsOrdered>. The <code>cells</code>\n * and <code>back</code> arguments contain the respective arguments that were\n * passed to <cellsOrdered>.\n * \n * Event: mxEvent.GROUP_CELLS\n * \n * Fires between begin- and endUpdate in <groupCells>. The <code>group</code>,\n * <code>cells</code> and <code>border</code> arguments contain the respective\n * arguments that were passed to <groupCells>.\n * \n * Event: mxEvent.UNGROUP_CELLS\n * \n * Fires between begin- and endUpdate in <ungroupCells>. The <code>cells</code>\n * property contains the array of cells that was passed to <ungroupCells>.\n * \n * Event: mxEvent.REMOVE_CELLS_FROM_PARENT\n * \n * Fires between begin- and endUpdate in <removeCellsFromParent>. The\n * <code>cells</code> property contains the array of cells that was passed to\n * <removeCellsFromParent>.\n * \n * Event: mxEvent.ADD_CELLS\n * \n * Fires between begin- and endUpdate in <addCells>. The <code>cells</code>,\n * <code>parent</code>, <code>index</code>, <code>source</code> and\n * <code>target</code> properties contain the respective arguments that were\n * passed to <addCells>.\n * \n * Event: mxEvent.CELLS_ADDED\n * \n * Fires between begin- and endUpdate in <cellsAdded>. The <code>cells</code>,\n * <code>parent</code>, <code>index</code>, <code>source</code>,\n * <code>target</code> and <code>absolute</code> properties contain the\n * respective arguments that were passed to <cellsAdded>.\n * \n * Event: mxEvent.REMOVE_CELLS\n * \n * Fires between begin- and endUpdate in <removeCells>. The <code>cells</code>\n * and <code>includeEdges</code> arguments contain the respective arguments\n * that were passed to <removeCells>.\n * \n * Event: mxEvent.CELLS_REMOVED\n * \n * Fires between begin- and endUpdate in <cellsRemoved>. The <code>cells</code>\n * argument contains the array of cells that was removed.\n * \n * Event: mxEvent.SPLIT_EDGE\n * \n * Fires between begin- and endUpdate in <splitEdge>. The <code>edge</code>\n * property contains the edge to be splitted, the <code>cells</code>,\n * <code>newEdge</code>, <code>dx</code> and <code>dy</code> properties contain\n * the respective arguments that were passed to <splitEdge>.\n * \n * Event: mxEvent.TOGGLE_CELLS\n * \n * Fires between begin- and endUpdate in <toggleCells>. The <code>show</code>,\n * <code>cells</code> and <code>includeEdges</code> properties contain the\n * respective arguments that were passed to <toggleCells>.\n * \n * Event: mxEvent.FOLD_CELLS\n * \n * Fires between begin- and endUpdate in <foldCells>. The\n * <code>collapse</code>, <code>cells</code> and <code>recurse</code>\n * properties contain the respective arguments that were passed to <foldCells>.\n * \n * Event: mxEvent.CELLS_FOLDED\n * \n * Fires between begin- and endUpdate in cellsFolded. The\n * <code>collapse</code>, <code>cells</code> and <code>recurse</code>\n * properties contain the respective arguments that were passed to\n * <cellsFolded>.\n * \n * Event: mxEvent.UPDATE_CELL_SIZE\n * \n * Fires between begin- and endUpdate in <updateCellSize>. The\n * <code>cell</code> and <code>ignoreChildren</code> properties contain the\n * respective arguments that were passed to <updateCellSize>.\n * \n * Event: mxEvent.RESIZE_CELLS\n * \n * Fires between begin- and endUpdate in <resizeCells>. The <code>cells</code>\n * and <code>bounds</code> properties contain the respective arguments that\n * were passed to <resizeCells>.\n * \n * Event: mxEvent.CELLS_RESIZED\n * \n * Fires between begin- and endUpdate in <cellsResized>. The <code>cells</code>\n * and <code>bounds</code> properties contain the respective arguments that\n * were passed to <cellsResized>.\n * \n * Event: mxEvent.MOVE_CELLS\n * \n * Fires between begin- and endUpdate in <moveCells>. The <code>cells</code>,\n * <code>dx</code>, <code>dy</code>, <code>clone</code>, <code>target</code>\n * and <code>event</code> properties contain the respective arguments that\n * were passed to <moveCells>.\n * \n * Event: mxEvent.CELLS_MOVED\n * \n * Fires between begin- and endUpdate in <cellsMoved>. The <code>cells</code>,\n * <code>dx</code>, <code>dy</code> and <code>disconnect</code> properties\n * contain the respective arguments that were passed to <cellsMoved>.\n * \n * Event: mxEvent.CONNECT_CELL\n * \n * Fires between begin- and endUpdate in <connectCell>. The <code>edge</code>,\n * <code>terminal</code> and <code>source</code> properties contain the\n * respective arguments that were passed to <connectCell>.\n * \n * Event: mxEvent.CELL_CONNECTED\n * \n * Fires between begin- and endUpdate in <cellConnected>. The\n * <code>edge</code>, <code>terminal</code> and <code>source</code> properties\n * contain the respective arguments that were passed to <cellConnected>.\n * \n * Event: mxEvent.REFRESH\n * \n * Fires after <refresh> was executed. This event has no properties.\n *\n * Event: mxEvent.CLICK\n * \n * Fires in <click> after a click event. The <code>event</code> property\n * contains the original mouse event and <code>cell</code> property contains\n * the cell under the mouse or null if the background was clicked.\n * \n * Event: mxEvent.DOUBLE_CLICK\n *\n * Fires in <dblClick> after a double click. The <code>event</code> property\n * contains the original mouse event and the <code>cell</code> property\n * contains the cell under the mouse or null if the background was clicked.\n * \n * Event: mxEvent.GESTURE\n *\n * Fires in <fireGestureEvent> after a touch gesture. The <code>event</code>\n * property contains the original gesture end event and the <code>cell</code>\n * property contains the optional cell associated with the gesture.\n *\n * Event: mxEvent.TAP_AND_HOLD\n *\n * Fires in <tapAndHold> if a tap and hold event was detected. The <code>event</code>\n * property contains the initial touch event and the <code>cell</code> property\n * contains the cell under the mouse or null if the background was clicked.\n *\n * Event: mxEvent.FIRE_MOUSE_EVENT\n *\n * Fires in <fireMouseEvent> before the mouse listeners are invoked. The\n * <code>eventName</code> property contains the event name and the\n * <code>event</code> property contains the <mxMouseEvent>.\n *\n * Event: mxEvent.SIZE\n *\n * Fires after <sizeDidChange> was executed. The <code>bounds</code> property\n * contains the new graph bounds.\n *\n * Event: mxEvent.START_EDITING\n *\n * Fires before the in-place editor starts in <startEditingAtCell>. The\n * <code>cell</code> property contains the cell that is being edited and the\n * <code>event</code> property contains the optional event argument that was\n * passed to <startEditingAtCell>.\n * \n * Event: mxEvent.EDITING_STARTED\n *\n * Fires after the in-place editor starts in <startEditingAtCell>. The\n * <code>cell</code> property contains the cell that is being edited and the\n * <code>event</code> property contains the optional event argument that was\n * passed to <startEditingAtCell>.\n * \n * Event: mxEvent.EDITING_STOPPED\n *\n * Fires after the in-place editor stops in <stopEditing>.\n *\n * Event: mxEvent.LABEL_CHANGED\n *\n * Fires between begin- and endUpdate in <cellLabelChanged>. The\n * <code>cell</code> property contains the cell, the <code>value</code>\n * property contains the new value for the cell, the <code>old</code> property\n * contains the old value and the optional <code>event</code> property contains\n * the mouse event that started the edit.\n * \n * Event: mxEvent.ADD_OVERLAY\n *\n * Fires after an overlay is added in <addCellOverlay>. The <code>cell</code>\n * property contains the cell and the <code>overlay</code> property contains\n * the <mxCellOverlay> that was added.\n *\n * Event: mxEvent.REMOVE_OVERLAY\n *\n * Fires after an overlay is removed in <removeCellOverlay> and\n * <removeCellOverlays>. The <code>cell</code> property contains the cell and\n * the <code>overlay</code> property contains the <mxCellOverlay> that was\n * removed.\n * \n * Constructor: mxGraph\n * \n * Constructs a new mxGraph in the specified container. Model is an optional\n * mxGraphModel. If no model is provided, a new mxGraphModel instance is \n * used as the model. The container must have a valid owner document prior \n * to calling this function in Internet Explorer. RenderHint is a string to\n * affect the display performance and rendering in IE, but not in SVG-based \n * browsers. The parameter is mapped to <dialect>, which may \n * be one of <mxConstants.DIALECT_SVG> for SVG-based browsers, \n * <mxConstants.DIALECT_STRICTHTML> for fastest display mode,\n * <mxConstants.DIALECT_PREFERHTML> for faster display mode,\n * <mxConstants.DIALECT_MIXEDHTML> for fast and <mxConstants.DIALECT_VML> \n * for exact display mode (slowest). The dialects are defined in mxConstants.\n * The default values are DIALECT_SVG for SVG-based browsers and\n * DIALECT_MIXED for IE.\n *\n * The possible values for the renderingHint parameter are explained below:\n * \n * fast - The parameter is based on the fact that the display performance is \n * highly improved in IE if the VML is not contained within a VML group \n * element. The lack of a group element only slightly affects the display while \n * panning, but improves the performance by almost a factor of 2, while keeping \n * the display sufficiently accurate. This also allows to render certain shapes as HTML \n * if the display accuracy is not affected, which is implemented by \n * <mxShape.isMixedModeHtml>. This is the default setting and is mapped to\n * DIALECT_MIXEDHTML.\n * faster - Same as fast, but more expensive shapes are avoided. This is \n * controlled by <mxShape.preferModeHtml>. The default implementation will \n * avoid gradients and rounded rectangles, but more significant shapes, such \n * as rhombus, ellipse, actor and cylinder will be rendered accurately. This \n * setting is mapped to DIALECT_PREFERHTML.\n * fastest - Almost anything will be rendered in Html. This allows for \n * rectangles, labels and images. This setting is mapped to\n * DIALECT_STRICTHTML.\n * exact - If accurate panning is required and if the diagram is small (up\n * to 100 cells), then this value should be used. In this mode, a group is \n * created that contains the VML. This allows for accurate panning and is \n * mapped to DIALECT_VML.\n *\n * Example:\n * \n * To create a graph inside a DOM node with an id of graph:\n * (code)\n * var container = document.getElementById('graph');\n * var graph = new mxGraph(container);\n * (end)\n * \n * Parameters:\n * \n * container - Optional DOM node that acts as a container for the graph.\n * If this is null then the container can be initialized later using\n * <init>.\n * model - Optional <mxGraphModel> that constitutes the graph data.\n * renderHint - Optional string that specifies the display accuracy and\n * performance. Default is mxConstants.DIALECT_MIXEDHTML (for IE).\n * stylesheet - Optional <mxStylesheet> to be used in the graph.\n */\nfunction mxGraph(container, model, renderHint, stylesheet)\n{\n\t// Initializes the variable in case the prototype has been\n\t// modified to hold some listeners (which is possible because\n\t// the createHandlers call is executed regardless of the\n\t// arguments passed into the ctor).\n\tthis.mouseListeners = null;\n\t\n\t// Converts the renderHint into a dialect\n\tthis.renderHint = renderHint;\n\n\tif (mxClient.IS_SVG)\n\t{\n\t\tthis.dialect = mxConstants.DIALECT_SVG;\n\t}\n\telse if (renderHint == mxConstants.RENDERING_HINT_EXACT && mxClient.IS_VML)\n\t{\n\t\tthis.dialect = mxConstants.DIALECT_VML;\n\t}\n\telse if (renderHint == mxConstants.RENDERING_HINT_FASTEST)\n\t{\n\t\tthis.dialect = mxConstants.DIALECT_STRICTHTML;\n\t}\n\telse if (renderHint == mxConstants.RENDERING_HINT_FASTER)\n\t{\n\t\tthis.dialect = mxConstants.DIALECT_PREFERHTML;\n\t}\n\telse // default for VML\n\t{\n\t\tthis.dialect = mxConstants.DIALECT_MIXEDHTML;\n\t}\n\t\n\t// Initializes the main members that do not require a container\n\tthis.model = (model != null) ? model : new mxGraphModel();\n\tthis.multiplicities = [];\n\tthis.imageBundles = [];\n\tthis.cellRenderer = this.createCellRenderer();\n\tthis.setSelectionModel(this.createSelectionModel());\n\tthis.setStylesheet((stylesheet != null) ? stylesheet : this.createStylesheet());\n\tthis.view = this.createGraphView();\n\t\n\t// Adds a graph model listener to update the view\n\tthis.graphModelChangeListener = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tthis.graphModelChanged(evt.getProperty('edit').changes);\n\t});\n\t\n\tthis.model.addListener(mxEvent.CHANGE, this.graphModelChangeListener);\n\n\t// Installs basic event handlers with disabled default settings.\n\tthis.createHandlers();\n\t\n\t// Initializes the display if a container was specified\n\tif (container != null)\n\t{\n\t\tthis.init(container);\n\t}\n\t\n\tthis.view.revalidate();\n};\n\n/**\n * Installs the required language resources at class\n * loading time.\n */\nif (mxLoadResources)\n{\n\tmxResources.add(mxClient.basePath + '/resources/graph');\n}\nelse\n{\n\tmxClient.defaultBundles.push(mxClient.basePath + '/resources/graph');\n}\n\n/**\n * Extends mxEventSource.\n */\nmxGraph.prototype = new mxEventSource();\nmxGraph.prototype.constructor = mxGraph;\n\n/**\n * Group: Variables\n */\n\n/**\n * Variable: mouseListeners\n * \n * Holds the mouse event listeners. See <fireMouseEvent>.\n */\nmxGraph.prototype.mouseListeners = null;\n\n/**\n * Variable: isMouseDown\n * \n * Holds the state of the mouse button.\n */\nmxGraph.prototype.isMouseDown = false;\n\n/**\n * Variable: model\n * \n * Holds the <mxGraphModel> that contains the cells to be displayed.\n */\nmxGraph.prototype.model = null;\n\n/**\n * Variable: view\n * \n * Holds the <mxGraphView> that caches the <mxCellStates> for the cells.\n */\nmxGraph.prototype.view = null;\n\n/**\n * Variable: stylesheet\n * \n * Holds the <mxStylesheet> that defines the appearance of the cells.\n * \n * \n * Example:\n * \n * Use the following code to read a stylesheet into an existing graph.\n * \n * (code)\n * var req = mxUtils.load('stylesheet.xml');\n * var root = req.getDocumentElement();\n * var dec = new mxCodec(root.ownerDocument);\n * dec.decode(root, graph.stylesheet);\n * (end)\n */\nmxGraph.prototype.stylesheet = null;\n\t\n/**\n * Variable: selectionModel\n * \n * Holds the <mxGraphSelectionModel> that models the current selection.\n */\nmxGraph.prototype.selectionModel = null;\n\n/**\n * Variable: cellEditor\n * \n * Holds the <mxCellEditor> that is used as the in-place editing.\n */\nmxGraph.prototype.cellEditor = null;\n\n/**\n * Variable: cellRenderer\n * \n * Holds the <mxCellRenderer> for rendering the cells in the graph.\n */\nmxGraph.prototype.cellRenderer = null;\n\n/**\n * Variable: multiplicities\n * \n * An array of <mxMultiplicities> describing the allowed\n * connections in a graph.\n */\nmxGraph.prototype.multiplicities = null;\n\n/**\n * Variable: renderHint\n * \n * RenderHint as it was passed to the constructor.\n */\nmxGraph.prototype.renderHint = null;\n\n/**\n * Variable: dialect\n * \n * Dialect to be used for drawing the graph. Possible values are all\n * constants in <mxConstants> with a DIALECT-prefix.\n */\nmxGraph.prototype.dialect = null;\n\n/**\n * Variable: gridSize\n * \n * Specifies the grid size. Default is 10.\n */\nmxGraph.prototype.gridSize = 10;\n\t\n/**\n * Variable: gridEnabled\n * \n * Specifies if the grid is enabled. This is used in <snap>. Default is\n * true.\n */\nmxGraph.prototype.gridEnabled = true;\n\n/**\n * Variable: portsEnabled\n * \n * Specifies if ports are enabled. This is used in <cellConnected> to update\n * the respective style. Default is true.\n */\nmxGraph.prototype.portsEnabled = true;\n\n/**\n * Variable: nativeDoubleClickEnabled\n * \n * Specifies if native double click events should be detected. Default is true.\n */\nmxGraph.prototype.nativeDblClickEnabled = true;\n\n/**\n * Variable: doubleTapEnabled\n * \n * Specifies if double taps on touch-based devices should be handled as a\n * double click. Default is true.\n */\nmxGraph.prototype.doubleTapEnabled = true;\n\n/**\n * Variable: doubleTapTimeout\n * \n * Specifies the timeout for double taps and non-native double clicks. Default\n * is 500 ms.\n */\nmxGraph.prototype.doubleTapTimeout = 500;\n\n/**\n * Variable: doubleTapTolerance\n * \n * Specifies the tolerance for double taps and double clicks in quirks mode.\n * Default is 25 pixels.\n */\nmxGraph.prototype.doubleTapTolerance = 25;\n\n/**\n * Variable: lastTouchX\n * \n * Holds the x-coordinate of the last touch event for double tap detection.\n */\nmxGraph.prototype.lastTouchY = 0;\n\n/**\n * Variable: lastTouchX\n * \n * Holds the y-coordinate of the last touch event for double tap detection.\n */\nmxGraph.prototype.lastTouchY = 0;\n\n/**\n * Variable: lastTouchTime\n * \n * Holds the time of the last touch event for double click detection.\n */\nmxGraph.prototype.lastTouchTime = 0;\n\n/**\n * Variable: tapAndHoldEnabled\n * \n * Specifies if tap and hold should be used for starting connections on touch-based\n * devices. Default is true.\n */\nmxGraph.prototype.tapAndHoldEnabled = true;\n\n/**\n * Variable: tapAndHoldDelay\n * \n * Specifies the time for a tap and hold. Default is 500 ms.\n */\nmxGraph.prototype.tapAndHoldDelay = 500;\n\n/**\n * Variable: tapAndHoldInProgress\n * \n * True if the timer for tap and hold events is running.\n */\nmxGraph.prototype.tapAndHoldInProgress = false;\n\n/**\n * Variable: tapAndHoldValid\n * \n * True as long as the timer is running and the touch events\n * stay within the given <tapAndHoldTolerance>.\n */\nmxGraph.prototype.tapAndHoldValid = false;\n\n/**\n * Variable: initialTouchX\n * \n * Holds the x-coordinate of the intial touch event for tap and hold.\n */\nmxGraph.prototype.initialTouchX = 0;\n\n/**\n * Variable: initialTouchY\n * \n * Holds the y-coordinate of the intial touch event for tap and hold.\n */\nmxGraph.prototype.initialTouchY = 0;\n\n/**\n * Variable: tolerance\n * \n * Tolerance for a move to be handled as a single click.\n * Default is 4 pixels.\n */\nmxGraph.prototype.tolerance = 4;\n\n/**\n * Variable: defaultOverlap\n * \n * Value returned by <getOverlap> if <isAllowOverlapParent> returns\n * true for the given cell. <getOverlap> is used in <constrainChild> if\n * <isConstrainChild> returns true. The value specifies the\n * portion of the child which is allowed to overlap the parent.\n */\nmxGraph.prototype.defaultOverlap = 0.5;\n\n/**\n * Variable: defaultParent\n * \n * Specifies the default parent to be used to insert new cells.\n * This is used in <getDefaultParent>. Default is null.\n */\nmxGraph.prototype.defaultParent = null;\n\n/**\n * Variable: alternateEdgeStyle\n * \n * Specifies the alternate edge style to be used if the main control point\n * on an edge is being doubleclicked. Default is null.\n */\nmxGraph.prototype.alternateEdgeStyle = null;\n\n/**\n * Variable: backgroundImage\n *\n * Specifies the <mxImage> to be returned by <getBackgroundImage>. Default\n * is null.\n * \n * Example:\n *\n * (code)\n * var img = new mxImage('http://www.example.com/maps/examplemap.jpg', 1024, 768);\n * graph.setBackgroundImage(img);\n * graph.view.validate();\n * (end)\n */\nmxGraph.prototype.backgroundImage = null;\n\n/**\n * Variable: pageVisible\n *\n * Specifies if the background page should be visible. Default is false.\n * Not yet implemented.\n */\nmxGraph.prototype.pageVisible = false;\n\n/**\n * Variable: pageBreaksVisible\n * \n * Specifies if a dashed line should be drawn between multiple pages. Default\n * is false. If you change this value while a graph is being displayed then you\n * should call <sizeDidChange> to force an update of the display.\n */\nmxGraph.prototype.pageBreaksVisible = false;\n\n/**\n * Variable: pageBreakColor\n * \n * Specifies the color for page breaks. Default is 'gray'.\n */\nmxGraph.prototype.pageBreakColor = 'gray';\n\n/**\n * Variable: pageBreakDashed\n * \n * Specifies the page breaks should be dashed. Default is true.\n */\nmxGraph.prototype.pageBreakDashed = true;\n\n/**\n * Variable: minPageBreakDist\n * \n * Specifies the minimum distance for page breaks to be visible. Default is\n * 20 (in pixels).\n */\nmxGraph.prototype.minPageBreakDist = 20;\n\n/**\n * Variable: preferPageSize\n * \n * Specifies if the graph size should be rounded to the next page number in\n * <sizeDidChange>. This is only used if the graph container has scrollbars.\n * Default is false.\n */\nmxGraph.prototype.preferPageSize = false;\n\n/**\n * Variable: pageFormat\n *\n * Specifies the page format for the background page. Default is\n * <mxConstants.PAGE_FORMAT_A4_PORTRAIT>. This is used as the default in\n * <mxPrintPreview> and for painting the background page if <pageVisible> is\n * true and the pagebreaks if <pageBreaksVisible> is true.\n */\nmxGraph.prototype.pageFormat = mxConstants.PAGE_FORMAT_A4_PORTRAIT;\n\n/**\n * Variable: pageScale\n *\n * Specifies the scale of the background page. Default is 1.5.\n * Not yet implemented.\n */\nmxGraph.prototype.pageScale = 1.5;\n\n/**\n * Variable: enabled\n * \n * Specifies the return value for <isEnabled>. Default is true.\n */\nmxGraph.prototype.enabled = true;\n\n/**\n * Variable: escapeEnabled\n * \n * Specifies if <mxKeyHandler> should invoke <escape> when the escape key\n * is pressed. Default is true.\n */\nmxGraph.prototype.escapeEnabled = true;\n\n/**\n * Variable: invokesStopCellEditing\n * \n * If true, when editing is to be stopped by way of selection changing,\n * data in diagram changing or other means stopCellEditing is invoked, and\n * changes are saved. This is implemented in a focus handler in\n * <mxCellEditor>. Default is true.\n */\nmxGraph.prototype.invokesStopCellEditing = true;\n\n/**\n * Variable: enterStopsCellEditing\n * \n * If true, pressing the enter key without pressing control or shift will stop\n * editing and accept the new value. This is used in <mxCellEditor> to stop\n * cell editing. Note: You can always use F2 and escape to stop editing.\n * Default is false.\n */\nmxGraph.prototype.enterStopsCellEditing = false;\n\n/**\n * Variable: useScrollbarsForPanning\n * \n * Specifies if scrollbars should be used for panning in <panGraph> if\n * any scrollbars are available. If scrollbars are enabled in CSS, but no\n * scrollbars appear because the graph is smaller than the container size,\n * then no panning occurs if this is true. Default is true.\n */\nmxGraph.prototype.useScrollbarsForPanning = true;\n\n/**\n * Variable: exportEnabled\n * \n * Specifies the return value for <canExportCell>. Default is true.\n */\nmxGraph.prototype.exportEnabled = true;\n\n/**\n * Variable: importEnabled\n * \n * Specifies the return value for <canImportCell>. Default is true.\n */\nmxGraph.prototype.importEnabled = true;\n\n/**\n * Variable: cellsLocked\n * \n * Specifies the return value for <isCellLocked>. Default is false.\n */\nmxGraph.prototype.cellsLocked = false;\n\n/**\n * Variable: cellsCloneable\n * \n * Specifies the return value for <isCellCloneable>. Default is true.\n */\nmxGraph.prototype.cellsCloneable = true;\n\n/**\n * Variable: foldingEnabled\n * \n * Specifies if folding (collapse and expand via an image icon in the graph\n * should be enabled). Default is true.\n */\nmxGraph.prototype.foldingEnabled = true;\n\n/**\n * Variable: cellsEditable\n * \n * Specifies the return value for <isCellEditable>. Default is true.\n */\nmxGraph.prototype.cellsEditable = true;\n\t\t\n/**\n * Variable: cellsDeletable\n * \n * Specifies the return value for <isCellDeletable>. Default is true.\n */\nmxGraph.prototype.cellsDeletable = true;\n\n/**\n * Variable: cellsMovable\n * \n * Specifies the return value for <isCellMovable>. Default is true.\n */\nmxGraph.prototype.cellsMovable = true;\n\t\n/**\n * Variable: edgeLabelsMovable\n * \n * Specifies the return value for edges in <isLabelMovable>. Default is true.\n */\nmxGraph.prototype.edgeLabelsMovable = true;\n\t\n/**\n * Variable: vertexLabelsMovable\n * \n * Specifies the return value for vertices in <isLabelMovable>. Default is false.\n */\nmxGraph.prototype.vertexLabelsMovable = false;\n\n/**\n * Variable: dropEnabled\n * \n * Specifies the return value for <isDropEnabled>. Default is false.\n */\nmxGraph.prototype.dropEnabled = false;\n\n/**\n * Variable: splitEnabled\n * \n * Specifies if dropping onto edges should be enabled. This is ignored if\n * <dropEnabled> is false. If enabled, it will call <splitEdge> to carry\n * out the drop operation. Default is true.\n */\nmxGraph.prototype.splitEnabled = true;\n\n/**\n * Variable: cellsResizable\n * \n * Specifies the return value for <isCellResizable>. Default is true.\n */\nmxGraph.prototype.cellsResizable = true;\n\n/**\n * Variable: cellsBendable\n * \n * Specifies the return value for <isCellsBendable>. Default is true.\n */\nmxGraph.prototype.cellsBendable = true;\n\n/**\n * Variable: cellsSelectable\n * \n * Specifies the return value for <isCellSelectable>. Default is true.\n */\nmxGraph.prototype.cellsSelectable = true;\n\n/**\n * Variable: cellsDisconnectable\n * \n * Specifies the return value for <isCellDisconntable>. Default is true.\n */\nmxGraph.prototype.cellsDisconnectable = true;\n\n/**\n * Variable: autoSizeCells\n * \n * Specifies if the graph should automatically update the cell size after an\n * edit. This is used in <isAutoSizeCell>. Default is false.\n */\nmxGraph.prototype.autoSizeCells = false;\n\n/**\n * Variable: autoSizeCellsOnAdd\n * \n * Specifies if autoSize style should be applied when cells are added. Default is false.\n */\nmxGraph.prototype.autoSizeCellsOnAdd = false;\n\n/**\n * Variable: autoScroll\n * \n * Specifies if the graph should automatically scroll if the mouse goes near\n * the container edge while dragging. This is only taken into account if the\n * container has scrollbars. Default is true.\n * \n * If you need this to work without scrollbars then set <ignoreScrollbars> to\n * true. Please consult the <ignoreScrollbars> for details. In general, with\n * no scrollbars, the use of <allowAutoPanning> is recommended.\n */\nmxGraph.prototype.autoScroll = true;\n\n/**\n * Variable: ignoreScrollbars\n * \n * Specifies if the graph should automatically scroll regardless of the\n * scrollbars. This will scroll the container using positive values for\n * scroll positions (ie usually only rightwards and downwards). To avoid\n * possible conflicts with panning, set <translateToScrollPosition> to true.\n */\nmxGraph.prototype.ignoreScrollbars = false;\n\n/**\n * Variable: translateToScrollPosition\n * \n * Specifies if the graph should automatically convert the current scroll\n * position to a translate in the graph view when a mouseUp event is received.\n * This can be used to avoid conflicts when using <autoScroll> and\n * <ignoreScrollbars> with no scrollbars in the container.\n */\nmxGraph.prototype.translateToScrollPosition = false;\n\n/**\n * Variable: timerAutoScroll\n * \n * Specifies if autoscrolling should be carried out via mxPanningManager even\n * if the container has scrollbars. This disables <scrollPointToVisible> and\n * uses <mxPanningManager> instead. If this is true then <autoExtend> is\n * disabled. It should only be used with a scroll buffer or when scollbars\n * are visible and scrollable in all directions. Default is false.\n */\nmxGraph.prototype.timerAutoScroll = false;\n\n/**\n * Variable: allowAutoPanning\n * \n * Specifies if panning via <panGraph> should be allowed to implement autoscroll\n * if no scrollbars are available in <scrollPointToVisible>. To enable panning\n * inside the container, near the edge, set <mxPanningManager.border> to a\n * positive value. Default is false.\n */\nmxGraph.prototype.allowAutoPanning = false;\n\n/**\n * Variable: autoExtend\n * \n * Specifies if the size of the graph should be automatically extended if the\n * mouse goes near the container edge while dragging. This is only taken into\n * account if the container has scrollbars. Default is true. See <autoScroll>.\n */\nmxGraph.prototype.autoExtend = true;\n\n/**\n * Variable: maximumGraphBounds\n * \n * <mxRectangle> that specifies the area in which all cells in the diagram\n * should be placed. Uses in <getMaximumGraphBounds>. Use a width or height of\n * 0 if you only want to give a upper, left corner.\n */\nmxGraph.prototype.maximumGraphBounds = null;\n\n/**\n * Variable: minimumGraphSize\n * \n * <mxRectangle> that specifies the minimum size of the graph. This is ignored\n * if the graph container has no scrollbars. Default is null.\n */\nmxGraph.prototype.minimumGraphSize = null;\n\n/**\n * Variable: minimumContainerSize\n * \n * <mxRectangle> that specifies the minimum size of the <container> if\n * <resizeContainer> is true.\n */\nmxGraph.prototype.minimumContainerSize = null;\n\t\t\n/**\n * Variable: maximumContainerSize\n * \n * <mxRectangle> that specifies the maximum size of the container if\n * <resizeContainer> is true.\n */\nmxGraph.prototype.maximumContainerSize = null;\n\n/**\n * Variable: resizeContainer\n * \n * Specifies if the container should be resized to the graph size when\n * the graph size has changed. Default is false.\n */\nmxGraph.prototype.resizeContainer = false;\n\n/**\n * Variable: border\n * \n * Border to be added to the bottom and right side when the container is\n * being resized after the graph has been changed. Default is 0.\n */\nmxGraph.prototype.border = 0;\n\t\t\n/**\n * Variable: keepEdgesInForeground\n * \n * Specifies if edges should appear in the foreground regardless of their order\n * in the model. If <keepEdgesInForeground> and <keepEdgesInBackground> are\n * both true then the normal order is applied. Default is false.\n */\nmxGraph.prototype.keepEdgesInForeground = false;\n\n/**\n * Variable: keepEdgesInBackground\n * \n * Specifies if edges should appear in the background regardless of their order\n * in the model. If <keepEdgesInForeground> and <keepEdgesInBackground> are\n * both true then the normal order is applied. Default is false.\n */\nmxGraph.prototype.keepEdgesInBackground = false;\n\n/**\n * Variable: allowNegativeCoordinates\n * \n * Specifies if negative coordinates for vertices are allowed. Default is true.\n */\nmxGraph.prototype.allowNegativeCoordinates = true;\n\n/**\n * Variable: constrainChildren\n * \n * Specifies if a child should be constrained inside the parent bounds after a\n * move or resize of the child. Default is true.\n */\nmxGraph.prototype.constrainChildren = true;\n\n/**\n * Variable: constrainRelativeChildren\n * \n * Specifies if child cells with relative geometries should be constrained\n * inside the parent bounds, if <constrainChildren> is true, and/or the\n * <maximumGraphBounds>. Default is false.\n */\nmxGraph.prototype.constrainRelativeChildren = false;\n\n/**\n * Variable: extendParents\n * \n * Specifies if a parent should contain the child bounds after a resize of\n * the child. Default is true. This has precedence over <constrainChildren>.\n */\nmxGraph.prototype.extendParents = true;\n\n/**\n * Variable: extendParentsOnAdd\n * \n * Specifies if parents should be extended according to the <extendParents>\n * switch if cells are added. Default is true.\n */\nmxGraph.prototype.extendParentsOnAdd = true;\n\n/**\n * Variable: extendParentsOnAdd\n * \n * Specifies if parents should be extended according to the <extendParents>\n * switch if cells are added. Default is false for backwards compatiblity.\n */\nmxGraph.prototype.extendParentsOnMove = false;\n\n/**\n * Variable: recursiveResize\n * \n * Specifies the return value for <isRecursiveResize>. Default is\n * false for backwards compatiblity.\n */\nmxGraph.prototype.recursiveResize = false;\n\n/**\n * Variable: collapseToPreferredSize\n * \n * Specifies if the cell size should be changed to the preferred size when\n * a cell is first collapsed. Default is true.\n */\nmxGraph.prototype.collapseToPreferredSize = true;\n\n/**\n * Variable: zoomFactor\n * \n * Specifies the factor used for <zoomIn> and <zoomOut>. Default is 1.2\n * (120%).\n */\nmxGraph.prototype.zoomFactor = 1.2;\n\n/**\n * Variable: keepSelectionVisibleOnZoom\n * \n * Specifies if the viewport should automatically contain the selection cells\n * after a zoom operation. Default is false.\n */\nmxGraph.prototype.keepSelectionVisibleOnZoom = false;\n\n/**\n * Variable: centerZoom\n * \n * Specifies if the zoom operations should go into the center of the actual\n * diagram rather than going from top, left. Default is true.\n */\nmxGraph.prototype.centerZoom = true;\n\n/**\n * Variable: resetViewOnRootChange\n * \n * Specifies if the scale and translate should be reset if the root changes in\n * the model. Default is true.\n */\nmxGraph.prototype.resetViewOnRootChange = true;\n\n/**\n * Variable: resetEdgesOnResize\n * \n * Specifies if edge control points should be reset after the resize of a\n * connected cell. Default is false.\n */\nmxGraph.prototype.resetEdgesOnResize = false;\n\n/**\n * Variable: resetEdgesOnMove\n * \n * Specifies if edge control points should be reset after the move of a\n * connected cell. Default is false.\n */\nmxGraph.prototype.resetEdgesOnMove = false;\n\n/**\n * Variable: resetEdgesOnConnect\n * \n * Specifies if edge control points should be reset after the the edge has been\n * reconnected. Default is true.\n */\nmxGraph.prototype.resetEdgesOnConnect = true;\n\n/**\n * Variable: allowLoops\n * \n * Specifies if loops (aka self-references) are allowed. Default is false.\n */\nmxGraph.prototype.allowLoops = false;\n\t\n/**\n * Variable: defaultLoopStyle\n * \n * <mxEdgeStyle> to be used for loops. This is a fallback for loops if the\n * <mxConstants.STYLE_LOOP> is undefined. Default is <mxEdgeStyle.Loop>.\n */\nmxGraph.prototype.defaultLoopStyle = mxEdgeStyle.Loop;\n\n/**\n * Variable: multigraph\n * \n * Specifies if multiple edges in the same direction between the same pair of\n * vertices are allowed. Default is true.\n */\nmxGraph.prototype.multigraph = true;\n\n/**\n * Variable: connectableEdges\n * \n * Specifies if edges are connectable. Default is false. This overrides the\n * connectable field in edges.\n */\nmxGraph.prototype.connectableEdges = false;\n\n/**\n * Variable: allowDanglingEdges\n * \n * Specifies if edges with disconnected terminals are allowed in the graph.\n * Default is true.\n */\nmxGraph.prototype.allowDanglingEdges = true;\n\n/**\n * Variable: cloneInvalidEdges\n * \n * Specifies if edges that are cloned should be validated and only inserted\n * if they are valid. Default is true.\n */\nmxGraph.prototype.cloneInvalidEdges = false;\n\n/**\n * Variable: disconnectOnMove\n * \n * Specifies if edges should be disconnected from their terminals when they\n * are moved. Default is true.\n */\nmxGraph.prototype.disconnectOnMove = true;\n\n/**\n * Variable: labelsVisible\n * \n * Specifies if labels should be visible. This is used in <getLabel>. Default\n * is true.\n */\nmxGraph.prototype.labelsVisible = true;\n\t\n/**\n * Variable: htmlLabels\n * \n * Specifies the return value for <isHtmlLabel>. Default is false.\n */\nmxGraph.prototype.htmlLabels = false;\n\n/**\n * Variable: swimlaneSelectionEnabled\n * \n * Specifies if swimlanes should be selectable via the content if the\n * mouse is released. Default is true.\n */\nmxGraph.prototype.swimlaneSelectionEnabled = true;\n\n/**\n * Variable: swimlaneNesting\n * \n * Specifies if nesting of swimlanes is allowed. Default is true.\n */\nmxGraph.prototype.swimlaneNesting = true;\n\t\n/**\n * Variable: swimlaneIndicatorColorAttribute\n * \n * The attribute used to find the color for the indicator if the indicator\n * color is set to 'swimlane'. Default is <mxConstants.STYLE_FILLCOLOR>.\n */\nmxGraph.prototype.swimlaneIndicatorColorAttribute = mxConstants.STYLE_FILLCOLOR;\n\n/**\n * Variable: imageBundles\n * \n * Holds the list of image bundles.\n */\nmxGraph.prototype.imageBundles = null;\n\n/**\n * Variable: minFitScale\n * \n * Specifies the minimum scale to be applied in <fit>. Default is 0.1. Set this\n * to null to allow any value.\n */\nmxGraph.prototype.minFitScale = 0.1;\n\n/**\n * Variable: maxFitScale\n * \n * Specifies the maximum scale to be applied in <fit>. Default is 8. Set this\n * to null to allow any value.\n */\nmxGraph.prototype.maxFitScale = 8;\n\n/**\n * Variable: panDx\n * \n * Current horizontal panning value. Default is 0.\n */\nmxGraph.prototype.panDx = 0;\n\n/**\n * Variable: panDy\n * \n * Current vertical panning value. Default is 0.\n */\nmxGraph.prototype.panDy = 0;\n\n/**\n * Variable: collapsedImage\n * \n * Specifies the <mxImage> to indicate a collapsed state.\n * Default value is mxClient.imageBasePath + '/collapsed.gif'\n */\nmxGraph.prototype.collapsedImage = new mxImage(mxClient.imageBasePath + '/collapsed.gif', 9, 9);\n\n/**\n * Variable: expandedImage\n * \n * Specifies the <mxImage> to indicate a expanded state.\n * Default value is mxClient.imageBasePath + '/expanded.gif'\n */\nmxGraph.prototype.expandedImage = new mxImage(mxClient.imageBasePath + '/expanded.gif', 9, 9);\n\n/**\n * Variable: warningImage\n * \n * Specifies the <mxImage> for the image to be used to display a warning\n * overlay. See <setCellWarning>. Default value is mxClient.imageBasePath +\n * '/warning'.  The extension for the image depends on the platform. It is\n * '.png' on the Mac and '.gif' on all other platforms.\n */\nmxGraph.prototype.warningImage = new mxImage(mxClient.imageBasePath + '/warning'+\n\t((mxClient.IS_MAC) ? '.png' : '.gif'), 16, 16);\n\n/**\n * Variable: alreadyConnectedResource\n * \n * Specifies the resource key for the error message to be displayed in\n * non-multigraphs when two vertices are already connected. If the resource\n * for this key does not exist then the value is used as the error message.\n * Default is 'alreadyConnected'.\n */\nmxGraph.prototype.alreadyConnectedResource = (mxClient.language != 'none') ? 'alreadyConnected' : '';\n\n/**\n * Variable: containsValidationErrorsResource\n * \n * Specifies the resource key for the warning message to be displayed when\n * a collapsed cell contains validation errors. If the resource for this\n * key does not exist then the value is used as the warning message.\n * Default is 'containsValidationErrors'.\n */\nmxGraph.prototype.containsValidationErrorsResource = (mxClient.language != 'none') ? 'containsValidationErrors' : '';\n\n/**\n * Variable: collapseExpandResource\n * \n * Specifies the resource key for the tooltip on the collapse/expand icon.\n * If the resource for this key does not exist then the value is used as\n * the tooltip. Default is 'collapse-expand'.\n */\nmxGraph.prototype.collapseExpandResource = (mxClient.language != 'none') ? 'collapse-expand' : '';\n\n/**\n * Function: init\n * \n * Initializes the <container> and creates the respective datastructures.\n * \n * Parameters:\n * \n * container - DOM node that will contain the graph display.\n */\nmxGraph.prototype.init = function(container)\n{\n\tthis.container = container;\n\t\n\t// Initializes the in-place editor\n\tthis.cellEditor = this.createCellEditor();\t\n\n\t// Initializes the container using the view\n\tthis.view.init();\n\t\n\t// Updates the size of the container for the current graph\n\tthis.sizeDidChange();\n\t\n\t// Hides tooltips and resets tooltip timer if mouse leaves container\n\tmxEvent.addListener(container, 'mouseleave', mxUtils.bind(this, function(evt)\n\t{\n\t\tif (this.tooltipHandler != null && this.tooltipHandler.div != null &&\n\t\t\tthis.tooltipHandler.div != evt.relatedTarget)\n\t\t{\n\t\t\tthis.tooltipHandler.hide();\n\t\t}\n\t}));\n\n\t// Automatic deallocation of memory\n\tif (mxClient.IS_IE)\n\t{\n\t\tmxEvent.addListener(window, 'unload', mxUtils.bind(this, function()\n\t\t{\n\t\t\tthis.destroy();\n\t\t}));\n\t\t\n\t\t// Disable shift-click for text\n\t\tmxEvent.addListener(container, 'selectstart',\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\treturn this.isEditing() || (!this.isMouseDown && !mxEvent.isShiftDown(evt));\n\t\t\t})\n\t\t);\n\t}\n\t\n\t// Workaround for missing last shape and connect preview in IE8 standards\n\t// mode if no initial graph displayed or no label for shape defined\n\tif (document.documentMode == 8)\n\t{\n\t\tcontainer.insertAdjacentHTML('beforeend', '<' + mxClient.VML_PREFIX + ':group' +\n\t\t\t' style=\"DISPLAY: none;\"></' + mxClient.VML_PREFIX + ':group>');\n\t}\n};\n\n/**\n * Function: createHandlers\n * \n * Creates the tooltip-, panning-, connection- and graph-handler (in this\n * order). This is called in the constructor before <init> is called.\n */\nmxGraph.prototype.createHandlers = function()\n{\n\tthis.tooltipHandler = this.createTooltipHandler();\n\tthis.tooltipHandler.setEnabled(false);\n\tthis.selectionCellsHandler = this.createSelectionCellsHandler();\n\tthis.connectionHandler = this.createConnectionHandler();\n\tthis.connectionHandler.setEnabled(false);\n\tthis.graphHandler = this.createGraphHandler();\n\tthis.panningHandler = this.createPanningHandler();\n\tthis.panningHandler.panningEnabled = false;\n\tthis.popupMenuHandler = this.createPopupMenuHandler();\n};\n\n/**\n * Function: createTooltipHandler\n * \n * Creates and returns a new <mxTooltipHandler> to be used in this graph.\n */\nmxGraph.prototype.createTooltipHandler = function()\n{\n\treturn new mxTooltipHandler(this);\n};\n\n/**\n * Function: createSelectionCellsHandler\n * \n * Creates and returns a new <mxTooltipHandler> to be used in this graph.\n */\nmxGraph.prototype.createSelectionCellsHandler = function()\n{\n\treturn new mxSelectionCellsHandler(this);\n};\n\n/**\n * Function: createConnectionHandler\n * \n * Creates and returns a new <mxConnectionHandler> to be used in this graph.\n */\nmxGraph.prototype.createConnectionHandler = function()\n{\n\treturn new mxConnectionHandler(this);\n};\n\n/**\n * Function: createGraphHandler\n * \n * Creates and returns a new <mxGraphHandler> to be used in this graph.\n */\nmxGraph.prototype.createGraphHandler = function()\n{\n\treturn new mxGraphHandler(this);\n};\n\n/**\n * Function: createPanningHandler\n * \n * Creates and returns a new <mxPanningHandler> to be used in this graph.\n */\nmxGraph.prototype.createPanningHandler = function()\n{\n\treturn new mxPanningHandler(this);\n};\n\n/**\n * Function: createPopupMenuHandler\n * \n * Creates and returns a new <mxPopupMenuHandler> to be used in this graph.\n */\nmxGraph.prototype.createPopupMenuHandler = function()\n{\n\treturn new mxPopupMenuHandler(this);\n};\n\n/**\n * Function: createSelectionModel\n * \n * Creates a new <mxGraphSelectionModel> to be used in this graph.\n */\nmxGraph.prototype.createSelectionModel = function()\n{\n\treturn new mxGraphSelectionModel(this);\n};\n\n/**\n * Function: createStylesheet\n * \n * Creates a new <mxGraphSelectionModel> to be used in this graph.\n */\nmxGraph.prototype.createStylesheet = function()\n{\n\treturn new mxStylesheet();\n};\n\n/**\n * Function: createGraphView\n * \n * Creates a new <mxGraphView> to be used in this graph.\n */\nmxGraph.prototype.createGraphView = function()\n{\n\treturn new mxGraphView(this);\n};\n \n/**\n * Function: createCellRenderer\n * \n * Creates a new <mxCellRenderer> to be used in this graph.\n */\nmxGraph.prototype.createCellRenderer = function()\n{\n\treturn new mxCellRenderer();\n};\n\n/**\n * Function: createCellEditor\n * \n * Creates a new <mxCellEditor> to be used in this graph.\n */\nmxGraph.prototype.createCellEditor = function()\n{\n\treturn new mxCellEditor(this);\n};\n\n/**\n * Function: getModel\n * \n * Returns the <mxGraphModel> that contains the cells.\n */\nmxGraph.prototype.getModel = function()\n{\n\treturn this.model;\n};\n\n/**\n * Function: getView\n * \n * Returns the <mxGraphView> that contains the <mxCellStates>.\n */\nmxGraph.prototype.getView = function()\n{\n\treturn this.view;\n};\n\n/**\n * Function: getStylesheet\n * \n * Returns the <mxStylesheet> that defines the style.\n */\nmxGraph.prototype.getStylesheet = function()\n{\n\treturn this.stylesheet;\n};\n\n/**\n * Function: setStylesheet\n * \n * Sets the <mxStylesheet> that defines the style.\n */\nmxGraph.prototype.setStylesheet = function(stylesheet)\n{\n\tthis.stylesheet = stylesheet;\n};\n\n/**\n * Function: getSelectionModel\n * \n * Returns the <mxGraphSelectionModel> that contains the selection.\n */\nmxGraph.prototype.getSelectionModel = function()\n{\n\treturn this.selectionModel;\n};\n\n/**\n * Function: setSelectionModel\n * \n * Sets the <mxSelectionModel> that contains the selection.\n */\nmxGraph.prototype.setSelectionModel = function(selectionModel)\n{\n\tthis.selectionModel = selectionModel;\n};\n\n/**\n * Function: getSelectionCellsForChanges\n * \n * Returns the cells to be selected for the given array of changes.\n * \n * Parameters:\n * \n * ignoreFn - Optional function that takes a change and returns true if the\n * change should be ignored.\n * \n */\nmxGraph.prototype.getSelectionCellsForChanges = function(changes, ignoreFn)\n{\n\tvar dict = new mxDictionary();\n\tvar cells = [];\n\t\n\tvar addCell = mxUtils.bind(this, function(cell)\n\t{\n\t\tif (!dict.get(cell) && this.model.contains(cell))\n\t\t{\n\t\t\tif (this.model.isEdge(cell) || this.model.isVertex(cell))\n\t\t\t{\n\t\t\t\tdict.put(cell, true);\n\t\t\t\tcells.push(cell);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar childCount = this.model.getChildCount(cell);\n\t\t\t\t\n\t\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t\t{\n\t\t\t\t\taddCell(this.model.getChildAt(cell, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tfor (var i = 0; i < changes.length; i++)\n\t{\n\t\tvar change = changes[i];\n\t\t\n\t\tif (change.constructor != mxRootChange &&\n\t\t\t(ignoreFn == null || !ignoreFn(change)))\n\t\t{\n\t\t\tvar cell = null;\n\n\t\t\tif (change instanceof mxChildChange)\n\t\t\t{\n\t\t\t\tcell = change.child;\n\t\t\t}\n\t\t\telse if (change.cell != null &&\n\t\t\t\tchange.cell instanceof mxCell)\n\t\t\t{\n\t\t\t\tcell = change.cell;\n\t\t\t}\n\t\t\t\n\t\t\tif (cell != null)\n\t\t\t{\n\t\t\t\taddCell(cell);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn cells;\n};\n\n/**\n * Function: graphModelChanged\n * \n * Called when the graph model changes. Invokes <processChange> on each\n * item of the given array to update the view accordingly.\n * \n * Parameters:\n * \n * changes - Array that contains the individual changes.\n */\nmxGraph.prototype.graphModelChanged = function(changes)\n{\n\tfor (var i = 0; i < changes.length; i++)\n\t{\n\t\tthis.processChange(changes[i]);\n\t}\n\n\tthis.updateSelection();\n\tthis.view.validate();\n\tthis.sizeDidChange();\n};\n\n/**\n * Function: updateSelection\n * \n * Removes selection cells that are not in the model from the selection.\n */\nmxGraph.prototype.updateSelection = function()\n{\n\tvar cells = this.getSelectionCells();\n\tvar removed = [];\n\t\n\tfor (var i = 0; i < cells.length; i++)\n\t{\n\t\tif (!this.model.contains(cells[i]) || !this.isCellVisible(cells[i]))\n\t\t{\n\t\t\tremoved.push(cells[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar par = this.model.getParent(cells[i]);\n\t\t\t\n\t\t\twhile (par != null && par != this.view.currentRoot)\n\t\t\t{\n\t\t\t\tif (this.isCellCollapsed(par) || !this.isCellVisible(par))\n\t\t\t\t{\n\t\t\t\t\tremoved.push(cells[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpar = this.model.getParent(par);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis.removeSelectionCells(removed);\n};\n\n/**\n * Function: processChange\n * \n * Processes the given change and invalidates the respective cached data\n * in <view>. This fires a <root> event if the root has changed in the\n * model.\n * \n * Parameters:\n * \n * change - Object that represents the change on the model.\n */\nmxGraph.prototype.processChange = function(change)\n{\n\t// Resets the view settings, removes all cells and clears\n\t// the selection if the root changes.\n\tif (change instanceof mxRootChange)\n\t{\n\t\tthis.clearSelection();\n\t\tthis.setDefaultParent(null);\n\t\tthis.removeStateForCell(change.previous);\n\t\t\n\t\tif (this.resetViewOnRootChange)\n\t\t{\n\t\t\tthis.view.scale = 1;\n\t\t\tthis.view.translate.x = 0;\n\t\t\tthis.view.translate.y = 0;\n\t\t}\n\n\t\tthis.fireEvent(new mxEventObject(mxEvent.ROOT));\n\t}\n\t\n\t// Adds or removes a child to the view by online invaliding\n\t// the minimal required portions of the cache, namely, the\n\t// old and new parent and the child.\n\telse if (change instanceof mxChildChange)\n\t{\n\t\tvar newParent = this.model.getParent(change.child);\n\t\tthis.view.invalidate(change.child, true, true);\n\t\t\n\t\tif (!this.model.contains(newParent) || this.isCellCollapsed(newParent))\n\t\t{\n\t\t\tthis.view.invalidate(change.child, true, true);\n\t\t\tthis.removeStateForCell(change.child);\n\t\t\t\n\t\t\t// Handles special case of current root of view being removed\n\t\t\tif (this.view.currentRoot == change.child)\n\t\t\t{\n\t\t\t\tthis.home();\n\t\t\t}\n\t\t}\n \n\t\tif (newParent != change.previous)\n\t\t{\n\t\t\t// Refreshes the collapse/expand icons on the parents\n\t\t\tif (newParent != null)\n\t\t\t{\n\t\t\t\tthis.view.invalidate(newParent, false, false);\n\t\t\t}\n\t\t\t\n\t\t\tif (change.previous != null)\n\t\t\t{\n\t\t\t\tthis.view.invalidate(change.previous, false, false);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Handles two special cases where the shape does not need to be\n\t// recreated from scratch, it only needs to be invalidated.\n\telse if (change instanceof mxTerminalChange || change instanceof mxGeometryChange)\n\t{\n\t\t// Checks if the geometry has changed to avoid unnessecary revalidation\n\t\tif (change instanceof mxTerminalChange || ((change.previous == null && change.geometry != null) ||\n\t\t\t(change.previous != null && !change.previous.equals(change.geometry))))\n\t\t{\n\t\t\tthis.view.invalidate(change.cell);\n\t\t}\n\t}\n\n\t// Handles two special cases where only the shape, but no\n\t// descendants need to be recreated\n\telse if (change instanceof mxValueChange)\n\t{\n\t\tthis.view.invalidate(change.cell, false, false);\n\t}\n\t\n\t// Requires a new mxShape in JavaScript\n\telse if (change instanceof mxStyleChange)\n\t{\n\t\tthis.view.invalidate(change.cell, true, true);\n\t\tvar state = this.view.getState(change.cell);\n\t\t\n\t\tif (state != null)\n\t\t{\n\t\t\tstate.invalidStyle = true;\n\t\t}\n\t}\n\t\n\t// Removes the state from the cache by default\n\telse if (change.cell != null && change.cell instanceof mxCell)\n\t{\n\t\tthis.removeStateForCell(change.cell);\n\t}\n};\n\n/**\n * Function: removeStateForCell\n * \n * Removes all cached information for the given cell and its descendants.\n * This is called when a cell was removed from the model.\n * \n * Paramters:\n * \n * cell - <mxCell> that was removed from the model.\n */\nmxGraph.prototype.removeStateForCell = function(cell)\n{\n\tvar childCount = this.model.getChildCount(cell);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tthis.removeStateForCell(this.model.getChildAt(cell, i));\n\t}\n\n\tthis.view.invalidate(cell, false, true);\n\tthis.view.removeState(cell);\n};\n\n/**\n * Group: Overlays\n */\n\n/**\n * Function: addCellOverlay\n * \n * Adds an <mxCellOverlay> for the specified cell. This method fires an\n * <addoverlay> event and returns the new <mxCellOverlay>.\n * \n * Parameters:\n * \n * cell - <mxCell> to add the overlay for.\n * overlay - <mxCellOverlay> to be added for the cell.\n */\nmxGraph.prototype.addCellOverlay = function(cell, overlay)\n{\n\tif (cell.overlays == null)\n\t{\n\t\tcell.overlays = [];\n\t}\n\t\n\tcell.overlays.push(overlay);\n\n\tvar state = this.view.getState(cell);\n\n\t// Immediately updates the cell display if the state exists\n\tif (state != null)\n\t{\n\t\tthis.cellRenderer.redraw(state);\n\t}\n\t\n\tthis.fireEvent(new mxEventObject(mxEvent.ADD_OVERLAY,\n\t\t\t'cell', cell, 'overlay', overlay));\n\t\n\treturn overlay;\n};\n\n/**\n * Function: getCellOverlays\n * \n * Returns the array of <mxCellOverlays> for the given cell or null, if\n * no overlays are defined.\n * \n * Parameters:\n * \n * cell - <mxCell> whose overlays should be returned.\n */\nmxGraph.prototype.getCellOverlays = function(cell)\n{\n\treturn cell.overlays;\n};\n\n/**\n * Function: removeCellOverlay\n * \n * Removes and returns the given <mxCellOverlay> from the given cell. This\n * method fires a <removeoverlay> event. If no overlay is given, then all\n * overlays are removed using <removeOverlays>.\n * \n * Parameters:\n * \n * cell - <mxCell> whose overlay should be removed.\n * overlay - Optional <mxCellOverlay> to be removed.\n */\nmxGraph.prototype.removeCellOverlay = function(cell, overlay)\n{\n\tif (overlay == null)\n\t{\n\t\tthis.removeCellOverlays(cell);\n\t}\n\telse\n\t{\n\t\tvar index = mxUtils.indexOf(cell.overlays, overlay);\n\t\t\n\t\tif (index >= 0)\n\t\t{\n\t\t\tcell.overlays.splice(index, 1);\n\t\t\t\n\t\t\tif (cell.overlays.length == 0)\n\t\t\t{\n\t\t\t\tcell.overlays = null;\n\t\t\t}\n\t\t\t\n\t\t\t// Immediately updates the cell display if the state exists\n\t\t\tvar state = this.view.getState(cell);\n\t\t\t\n\t\t\tif (state != null)\n\t\t\t{\n\t\t\t\tthis.cellRenderer.redraw(state);\n\t\t\t}\n\t\t\t\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.REMOVE_OVERLAY,\n\t\t\t\t\t'cell', cell, 'overlay', overlay));\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\toverlay = null;\n\t\t}\n\t}\n\t\n\treturn overlay;\n};\n\n/**\n * Function: removeCellOverlays\n * \n * Removes all <mxCellOverlays> from the given cell. This method\n * fires a <removeoverlay> event for each <mxCellOverlay> and returns\n * the array of <mxCellOverlays> that was removed from the cell.\n * \n * Parameters:\n * \n * cell - <mxCell> whose overlays should be removed\n */\nmxGraph.prototype.removeCellOverlays = function(cell)\n{\n\tvar overlays = cell.overlays;\n\t\n\tif (overlays != null)\n\t{\n\t\tcell.overlays = null;\n\t\t\n\t\t// Immediately updates the cell display if the state exists\n\t\tvar state = this.view.getState(cell);\n\t\t\n\t\tif (state != null)\n\t\t{\n\t\t\tthis.cellRenderer.redraw(state);\n\t\t}\n\t\t\n\t\tfor (var i = 0; i < overlays.length; i++)\n\t\t{\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.REMOVE_OVERLAY,\n\t\t\t\t\t'cell', cell, 'overlay', overlays[i]));\n\t\t}\n\t}\n\t\n\treturn overlays;\n};\n\n/**\n * Function: clearCellOverlays\n * \n * Removes all <mxCellOverlays> in the graph for the given cell and all its\n * descendants. If no cell is specified then all overlays are removed from\n * the graph. This implementation uses <removeCellOverlays> to remove the\n * overlays from the individual cells.\n * \n * Parameters:\n * \n * cell - Optional <mxCell> that represents the root of the subtree to\n * remove the overlays from. Default is the root in the model.\n */\nmxGraph.prototype.clearCellOverlays = function(cell)\n{\n\tcell = (cell != null) ? cell : this.model.getRoot();\n\tthis.removeCellOverlays(cell);\n\t\n\t// Recursively removes all overlays from the children\n\tvar childCount = this.model.getChildCount(cell);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = this.model.getChildAt(cell, i);\n\t\tthis.clearCellOverlays(child); // recurse\n\t}\n};\n\n/**\n * Function: setCellWarning\n * \n * Creates an overlay for the given cell using the warning and image or\n * <warningImage> and returns the new <mxCellOverlay>. The warning is\n * displayed as a tooltip in a red font and may contain HTML markup. If\n * the warning is null or a zero length string, then all overlays are\n * removed from the cell.\n * \n * Example:\n * \n * (code)\n * graph.setCellWarning(cell, '<b>Warning:</b>: Hello, World!');\n * (end)\n * \n * Parameters:\n * \n * cell - <mxCell> whose warning should be set.\n * warning - String that represents the warning to be displayed.\n * img - Optional <mxImage> to be used for the overlay. Default is\n * <warningImage>.\n * isSelect - Optional boolean indicating if a click on the overlay\n * should select the corresponding cell. Default is false.\n */\nmxGraph.prototype.setCellWarning = function(cell, warning, img, isSelect)\n{\n\tif (warning != null && warning.length > 0)\n\t{\n\t\timg = (img != null) ? img : this.warningImage;\n\t\t\n\t\t// Creates the overlay with the image and warning\n\t\tvar overlay = new mxCellOverlay(img,\n\t\t\t'<font color=red>'+warning+'</font>');\n\t\t\n\t\t// Adds a handler for single mouseclicks to select the cell\n\t\tif (isSelect)\n\t\t{\n\t\t\toverlay.addListener(mxEvent.CLICK,\n\t\t\t\tmxUtils.bind(this, function(sender, evt)\n\t\t\t\t{\n\t\t\t\t\tif (this.isEnabled())\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.setSelectionCell(cell);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\t\n\t\t// Sets and returns the overlay in the graph\n\t\treturn this.addCellOverlay(cell, overlay);\n\t}\n\telse\n\t{\n\t\tthis.removeCellOverlays(cell);\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Group: In-place editing\n */\n\n/**\n * Function: startEditing\n * \n * Calls <startEditingAtCell> using the given cell or the first selection\n * cell.\n * \n * Parameters:\n * \n * evt - Optional mouse event that triggered the editing.\n */\nmxGraph.prototype.startEditing = function(evt)\n{\n\tthis.startEditingAtCell(null, evt);\n};\n\n/**\n * Function: startEditingAtCell\n * \n * Fires a <startEditing> event and invokes <mxCellEditor.startEditing>\n * on <editor>. After editing was started, a <editingStarted> event is\n * fired.\n * \n * Parameters:\n * \n * cell - <mxCell> to start the in-place editor for.\n * evt - Optional mouse event that triggered the editing.\n */\nmxGraph.prototype.startEditingAtCell = function(cell, evt)\n{\n\tif (evt == null || !mxEvent.isMultiTouchEvent(evt))\n\t{\n\t\tif (cell == null)\n\t\t{\n\t\t\tcell = this.getSelectionCell();\n\t\t\t\n\t\t\tif (cell != null && !this.isCellEditable(cell))\n\t\t\t{\n\t\t\t\tcell = null;\n\t\t\t}\n\t\t}\n\t\n\t\tif (cell != null)\n\t\t{\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.START_EDITING,\n\t\t\t\t\t'cell', cell, 'event', evt));\n\t\t\tthis.cellEditor.startEditing(cell, evt);\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.EDITING_STARTED,\n\t\t\t\t\t'cell', cell, 'event', evt));\n\t\t}\n\t}\n};\n\n/**\n * Function: getEditingValue\n * \n * Returns the initial value for in-place editing. This implementation\n * returns <convertValueToString> for the given cell. If this function is\n * overridden, then <mxGraphModel.valueForCellChanged> should take care\n * of correctly storing the actual new value inside the user object.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the initial editing value should be returned.\n * evt - Optional mouse event that triggered the editor.\n */\nmxGraph.prototype.getEditingValue = function(cell, evt)\n{\n\treturn this.convertValueToString(cell);\n};\n\n/**\n * Function: stopEditing\n * \n * Stops the current editing  and fires a <editingStopped> event.\n * \n * Parameters:\n * \n * cancel - Boolean that specifies if the current editing value\n * should be stored.\n */\nmxGraph.prototype.stopEditing = function(cancel)\n{\n\tthis.cellEditor.stopEditing(cancel);\n\tthis.fireEvent(new mxEventObject(mxEvent.EDITING_STOPPED, 'cancel', cancel));\n};\n\n/**\n * Function: labelChanged\n * \n * Sets the label of the specified cell to the given value using\n * <cellLabelChanged> and fires <mxEvent.LABEL_CHANGED> while the\n * transaction is in progress. Returns the cell whose label was changed.\n * \n * Parameters:\n * \n * cell - <mxCell> whose label should be changed.\n * value - New label to be assigned.\n * evt - Optional event that triggered the change.\n */\nmxGraph.prototype.labelChanged = function(cell, value, evt)\n{\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tvar old = cell.value;\n\t\tthis.cellLabelChanged(cell, value, this.isAutoSizeCell(cell));\n\t\tthis.fireEvent(new mxEventObject(mxEvent.LABEL_CHANGED,\n\t\t\t'cell', cell, 'value', value, 'old', old, 'event', evt));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\t\n\treturn cell;\n};\n\n/**\n * Function: cellLabelChanged\n * \n * Sets the new label for a cell. If autoSize is true then\n * <cellSizeUpdated> will be called.\n * \n * In the following example, the function is extended to map changes to\n * attributes in an XML node, as shown in <convertValueToString>.\n * Alternatively, the handling of this can be implemented as shown in\n * <mxGraphModel.valueForCellChanged> without the need to clone the\n * user object.\n * \n * (code)\n * var graphCellLabelChanged = graph.cellLabelChanged;\n * graph.cellLabelChanged = function(cell, newValue, autoSize)\n * {\n * \t// Cloned for correct undo/redo\n * \tvar elt = cell.value.cloneNode(true);\n *  elt.setAttribute('label', newValue);\n *  \n *  newValue = elt;\n *  graphCellLabelChanged.apply(this, arguments);\n * };\n * (end) \n * \n * Parameters:\n * \n * cell - <mxCell> whose label should be changed.\n * value - New label to be assigned.\n * autoSize - Boolean that specifies if <cellSizeUpdated> should be called.\n */\nmxGraph.prototype.cellLabelChanged = function(cell, value, autoSize)\n{\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.model.setValue(cell, value);\n\t\t\n\t\tif (autoSize)\n\t\t{\n\t\t\tthis.cellSizeUpdated(cell, false);\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n};\n\n/**\n * Group: Event processing\n */\n\n/**\n * Function: escape\n * \n * Processes an escape keystroke.\n * \n * Parameters:\n * \n * evt - Mouseevent that represents the keystroke.\n */\nmxGraph.prototype.escape = function(evt)\n{\n\tthis.fireEvent(new mxEventObject(mxEvent.ESCAPE, 'event', evt));\n};\n\n/**\n * Function: click\n * \n * Processes a singleclick on an optional cell and fires a <click> event.\n * The click event is fired initially. If the graph is enabled and the\n * event has not been consumed, then the cell is selected using\n * <selectCellForEvent> or the selection is cleared using\n * <clearSelection>. The events consumed state is set to true if the\n * corresponding <mxMouseEvent> has been consumed.\n *\n * To handle a click event, use the following code.\n * \n * (code)\n * graph.addListener(mxEvent.CLICK, function(sender, evt)\n * {\n *   var e = evt.getProperty('event'); // mouse event\n *   var cell = evt.getProperty('cell'); // cell may be null\n *   \n *   if (cell != null)\n *   {\n *     // Do something useful with cell and consume the event\n *     evt.consume();\n *   }\n * });\n * (end)\n * \n * Parameters:\n * \n * me - <mxMouseEvent> that represents the single click.\n */\nmxGraph.prototype.click = function(me)\n{\n\tvar evt = me.getEvent();\n\tvar cell = me.getCell();\n\tvar mxe = new mxEventObject(mxEvent.CLICK, 'event', evt, 'cell', cell);\n\t\n\tif (me.isConsumed())\n\t{\n\t\tmxe.consume();\n\t}\n\t\n\tthis.fireEvent(mxe);\n\t\n\tif (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed())\n\t{\n\t\tif (cell != null)\n\t\t{\n\t\t\tif (this.isTransparentClickEvent(evt))\n\t\t\t{\n\t\t\t\tvar active = false;\n\t\t\t\t\n\t\t\t\tvar tmp = this.getCellAt(me.graphX, me.graphY, null, null, null,\n\t\t\t\t\tmxUtils.bind(this, function(state)\n\t\t\t\t{\n\t\t\t\t\tvar selected = this.isCellSelected(state.cell);\n\t\t\t\t\tactive = active || selected;\n\t\t\t\t\t\n\t\t\t\t\treturn !active || selected || (state.cell != cell &&\n\t\t\t\t\t\tthis.model.isAncestor(state.cell, cell));\n\t\t\t\t}));\n\t\t\t\t\n\t\t\t\tif (tmp != null)\n\t\t\t\t{\n\t\t\t\t\tcell = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (this.isSwimlaneSelectionEnabled())\n\t\t{\n\t\t\tcell = this.getSwimlaneAt(me.getGraphX(), me.getGraphY());\n\t\t\t\t\n\t\t\tif (cell != null && (!this.isToggleEvent(evt) ||\n\t\t\t\t!mxEvent.isAltDown(evt)))\n\t\t\t{\n\t\t\t\tvar temp = cell;\n\t\t\t\tvar swimlanes = [];\n\t\t\t\t\n\t\t\t\twhile (temp != null)\n\t\t\t\t{\n\t\t\t\t\ttemp = this.model.getParent(temp);\n\t\t\t\t\tvar state = this.view.getState(temp);\n\t\t\t\t\t\n\t\t\t\t\tif (this.isSwimlane(temp) && state != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tswimlanes.push(temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Selects ancestors for selected swimlanes\n\t\t\t\tif (swimlanes.length > 0)\n\t\t\t\t{\n\t\t\t\t\tswimlanes = swimlanes.reverse();\n\t\t\t\t\tswimlanes.splice(0, 0, cell);\n\t\t\t\t\tswimlanes.push(cell);\n\t\t\t\t\t\n\t\t\t\t\tfor (var i = 0; i < swimlanes.length - 1; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.isCellSelected(swimlanes[i]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcell = swimlanes[(this.isToggleEvent(evt)) ?\n\t\t\t\t\t\t\t\ti : i + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tif (cell != null)\n\t\t{\n\t\t\tthis.selectCellForEvent(cell, evt);\n\t\t}\n\t\telse if (!this.isToggleEvent(evt))\n\t\t{\n\t\t\tthis.clearSelection();\n\t\t}\n\t}\n};\n\n/**\n * Function: isSiblingSelected\n * \n * Returns true if any sibling of the given cell is selected.\n */\nmxGraph.prototype.isSiblingSelected = function(cell)\n{\n\tvar model = this.model;\n\tvar parent = model.getParent(cell);\n\tvar childCount = model.getChildCount(parent);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = model.getChildAt(parent, i);\n\t\t\n\t\tif (cell != child && this.isCellSelected(child))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n};\n\n\n/**\n * Function: dblClick\n * \n * Processes a doubleclick on an optional cell and fires a <dblclick>\n * event. The event is fired initially. If the graph is enabled and the\n * event has not been consumed, then <edit> is called with the given\n * cell. The event is ignored if no cell was specified.\n *\n * Example for overriding this method.\n *\n * (code)\n * graph.dblClick = function(evt, cell)\n * {\n *   var mxe = new mxEventObject(mxEvent.DOUBLE_CLICK, 'event', evt, 'cell', cell);\n *   this.fireEvent(mxe);\n *   \n *   if (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed())\n *   {\n * \t   mxUtils.alert('Hello, World!');\n *     mxe.consume();\n *   }\n * }\n * (end)\n * \n * Example listener for this event.\n * \n * (code)\n * graph.addListener(mxEvent.DOUBLE_CLICK, function(sender, evt)\n * {\n *   var cell = evt.getProperty('cell');\n *   // do something with the cell and consume the\n *   // event to prevent in-place editing from start\n * });\n * (end) \n * \n * Parameters:\n * \n * evt - Mouseevent that represents the doubleclick.\n * cell - Optional <mxCell> under the mousepointer.\n */\nmxGraph.prototype.dblClick = function(evt, cell)\n{\n\tvar mxe = new mxEventObject(mxEvent.DOUBLE_CLICK, 'event', evt, 'cell', cell);\n\tthis.fireEvent(mxe);\n\t\n\t// Handles the event if it has not been consumed\n\tif (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed() &&\n\t\tcell != null && this.isCellEditable(cell) && !this.isEditing(cell))\n\t{\n\t\tthis.startEditingAtCell(cell, evt);\n\t\tmxEvent.consume(evt);\n\t}\n};\n\n/**\n * Function: tapAndHold\n * \n * Handles the <mxMouseEvent> by highlighting the <mxCellState>.\n * \n * Parameters:\n * \n * me - <mxMouseEvent> that represents the touch event.\n * state - Optional <mxCellState> that is associated with the event.\n */\nmxGraph.prototype.tapAndHold = function(me)\n{\n\tvar evt = me.getEvent();\n\tvar mxe = new mxEventObject(mxEvent.TAP_AND_HOLD, 'event', evt, 'cell', me.getCell());\n\n\t// LATER: Check if event should be consumed if me is consumed\n\tthis.fireEvent(mxe);\n\n\tif (mxe.isConsumed())\n\t{\n\t\t// Resets the state of the panning handler\n\t\tthis.panningHandler.panningTrigger = false;\n\t}\n\t\n\t// Handles the event if it has not been consumed\n\tif (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed() && this.connectionHandler.isEnabled())\n\t{\n\t\tvar state = this.view.getState(this.connectionHandler.marker.getCell(me));\n\n\t\tif (state != null)\n\t\t{\n\t\t\tthis.connectionHandler.marker.currentColor = this.connectionHandler.marker.validColor;\n\t\t\tthis.connectionHandler.marker.markedState = state;\n\t\t\tthis.connectionHandler.marker.mark();\n\t\t\t\n\t\t\tthis.connectionHandler.first = new mxPoint(me.getGraphX(), me.getGraphY());\n\t\t\tthis.connectionHandler.edgeState = this.connectionHandler.createEdgeState(me);\n\t\t\tthis.connectionHandler.previous = state;\n\t\t\tthis.connectionHandler.fireEvent(new mxEventObject(mxEvent.START, 'state', this.connectionHandler.previous));\n\t\t}\n\t}\n};\n\n/**\n * Function: scrollPointToVisible\n * \n * Scrolls the graph to the given point, extending the graph container if\n * specified.\n */\nmxGraph.prototype.scrollPointToVisible = function(x, y, extend, border)\n{\n\tif (!this.timerAutoScroll && (this.ignoreScrollbars || mxUtils.hasScrollbars(this.container)))\n\t{\n\t\tvar c = this.container;\n\t\tborder = (border != null) ? border : 20;\n\t\t\n\t\tif (x >= c.scrollLeft && y >= c.scrollTop && x <= c.scrollLeft + c.clientWidth &&\n\t\t\ty <= c.scrollTop + c.clientHeight)\n\t\t{\n\t\t\tvar dx = c.scrollLeft + c.clientWidth - x;\n\t\t\t\n\t\t\tif (dx < border)\n\t\t\t{\n\t\t\t\tvar old = c.scrollLeft;\n\t\t\t\tc.scrollLeft += border - dx;\n\n\t\t\t\t// Automatically extends the canvas size to the bottom, right\n\t\t\t\t// if the event is outside of the canvas and the edge of the\n\t\t\t\t// canvas has been reached. Notes: Needs fix for IE.\n\t\t\t\tif (extend && old == c.scrollLeft)\n\t\t\t\t{\n\t\t\t\t\tif (this.dialect == mxConstants.DIALECT_SVG)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar root = this.view.getDrawPane().ownerSVGElement;\n\t\t\t\t\t\tvar width = this.container.scrollWidth + border - dx;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Updates the clipping region. This is an expensive\n\t\t\t\t\t\t// operation that should not be executed too often.\n\t\t\t\t\t\troot.style.width = width + 'px';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar width = Math.max(c.clientWidth, c.scrollWidth) + border - dx;\n\t\t\t\t\t\tvar canvas = this.view.getCanvas();\n\t\t\t\t\t\tcanvas.style.width = width + 'px';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tc.scrollLeft += border - dx;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdx = x - c.scrollLeft;\n\t\t\t\t\n\t\t\t\tif (dx < border)\n\t\t\t\t{\n\t\t\t\t\tc.scrollLeft -= border - dx;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar dy = c.scrollTop + c.clientHeight - y;\n\t\t\t\n\t\t\tif (dy < border)\n\t\t\t{\n\t\t\t\tvar old = c.scrollTop;\n\t\t\t\tc.scrollTop += border - dy;\n\n\t\t\t\tif (old == c.scrollTop && extend)\n\t\t\t\t{\n\t\t\t\t\tif (this.dialect == mxConstants.DIALECT_SVG)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar root = this.view.getDrawPane().ownerSVGElement;\n\t\t\t\t\t\tvar height = this.container.scrollHeight + border - dy;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Updates the clipping region. This is an expensive\n\t\t\t\t\t\t// operation that should not be executed too often.\n\t\t\t\t\t\troot.style.height = height + 'px';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar height = Math.max(c.clientHeight, c.scrollHeight) + border - dy;\n\t\t\t\t\t\tvar canvas = this.view.getCanvas();\n\t\t\t\t\t\tcanvas.style.height = height + 'px';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tc.scrollTop += border - dy;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdy = y - c.scrollTop;\n\t\t\t\t\n\t\t\t\tif (dy < border)\n\t\t\t\t{\n\t\t\t\t\tc.scrollTop -= border - dy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if (this.allowAutoPanning && !this.panningHandler.isActive())\n\t{\n\t\tif (this.panningManager == null)\n\t\t{\n\t\t\tthis.panningManager = this.createPanningManager();\n\t\t}\n\n\t\tthis.panningManager.panTo(x + this.panDx, y + this.panDy);\n\t}\n};\n\n\n/**\n * Function: createPanningManager\n * \n * Creates and returns an <mxPanningManager>.\n */\nmxGraph.prototype.createPanningManager = function()\n{\n\treturn new mxPanningManager(this);\n};\n\n/**\n * Function: getBorderSizes\n * \n * Returns the size of the border and padding on all four sides of the\n * container. The left, top, right and bottom borders are stored in the x, y,\n * width and height of the returned <mxRectangle>, respectively.\n */\nmxGraph.prototype.getBorderSizes = function()\n{\n\tvar css = mxUtils.getCurrentStyle(this.container);\n\t\n\treturn new mxRectangle(mxUtils.parseCssNumber(css.paddingLeft) +\n\t\t\t((css.borderLeftStyle != 'none') ? mxUtils.parseCssNumber(css.borderLeftWidth) : 0),\n\t\tmxUtils.parseCssNumber(css.paddingTop) +\n\t\t\t((css.borderTopStyle != 'none') ? mxUtils.parseCssNumber(css.borderTopWidth) : 0),\n\t\tmxUtils.parseCssNumber(css.paddingRight) +\n\t\t\t((css.borderRightStyle != 'none') ? mxUtils.parseCssNumber(css.borderRightWidth) : 0),\n\t\tmxUtils.parseCssNumber(css.paddingBottom) +\n\t\t\t((css.borderBottomStyle != 'none') ? mxUtils.parseCssNumber(css.borderBottomWidth) : 0));\n};\n\n/**\n * Function: getPreferredPageSize\n * \n * Returns the preferred size of the background page if <preferPageSize> is true.\n */\nmxGraph.prototype.getPreferredPageSize = function(bounds, width, height)\n{\n\tvar scale = this.view.scale;\n\tvar tr = this.view.translate;\n\tvar fmt = this.pageFormat;\n\tvar ps = this.pageScale;\n\tvar page = new mxRectangle(0, 0, Math.ceil(fmt.width * ps), Math.ceil(fmt.height * ps));\n\t\n\tvar hCount = (this.pageBreaksVisible) ? Math.ceil(width / page.width) : 1;\n\tvar vCount = (this.pageBreaksVisible) ? Math.ceil(height / page.height) : 1;\n\t\n\treturn new mxRectangle(0, 0, hCount * page.width + 2 + tr.x, vCount * page.height + 2 + tr.y);\n};\n\n/**\n * Function: fit\n *\n * Scales the graph such that the complete diagram fits into <container> and\n * returns the current scale in the view. To fit an initial graph prior to\n * rendering, set <mxGraphView.rendering> to false prior to changing the model\n * and execute the following after changing the model.\n * \n * (code)\n * graph.fit();\n * graph.view.rendering = true;\n * graph.refresh();\n * (end)\n * \n * To fit and center the graph, the following code can be used.\n * \n * (code)\n * var margin = 2;\n * var max = 3;\n * \n * var bounds = graph.getGraphBounds();\n * var cw = graph.container.clientWidth - margin;\n * var ch = graph.container.clientHeight - margin;\n * var w = bounds.width / graph.view.scale;\n * var h = bounds.height / graph.view.scale;\n * var s = Math.min(max, Math.min(cw / w, ch / h));\n * \n * graph.view.scaleAndTranslate(s,\n *   (margin + cw - w * s) / (2 * s) - bounds.x / graph.view.scale,\n *   (margin + ch - h * s) / (2 * s) - bounds.y / graph.view.scale);\n * (end)\n * \n * Parameters:\n * \n * border - Optional number that specifies the border. Default is <border>.\n * keepOrigin - Optional boolean that specifies if the translate should be\n * changed. Default is false.\n * margin - Optional margin in pixels. Default is 0.\n * enabled - Optional boolean that specifies if the scale should be set or\n * just returned. Default is true.\n * ignoreWidth - Optional boolean that specifies if the width should be\n * ignored. Default is false.\n * ignoreHeight - Optional boolean that specifies if the height should be\n * ignored. Default is false.\n * maxHeight - Optional maximum height.\n */\nmxGraph.prototype.fit = function(border, keepOrigin, margin, enabled, ignoreWidth, ignoreHeight, maxHeight)\n{\n\tif (this.container != null)\n\t{\n\t\tborder = (border != null) ? border : this.getBorder();\n\t\tkeepOrigin = (keepOrigin != null) ? keepOrigin : false;\n\t\tmargin = (margin != null) ? margin : 0;\n\t\tenabled = (enabled != null) ? enabled : true;\n\t\tignoreWidth = (ignoreWidth != null) ? ignoreWidth : false;\n\t\tignoreHeight = (ignoreHeight != null) ? ignoreHeight : false;\n\t\t\n\t\t// Adds spacing and border from css\n\t\tvar cssBorder = this.getBorderSizes();\n\t\tvar w1 = this.container.offsetWidth - cssBorder.x - cssBorder.width - 1;\n\t\tvar h1 = (maxHeight != null) ? maxHeight : this.container.offsetHeight - cssBorder.y - cssBorder.height - 1;\n\t\tvar bounds = this.view.getGraphBounds();\n\t\t\n\t\tif (bounds.width > 0 && bounds.height > 0)\n\t\t{\n\t\t\tif (keepOrigin && bounds.x != null && bounds.y != null)\n\t\t\t{\n\t\t\t\tbounds = bounds.clone();\n\t\t\t\tbounds.width += bounds.x;\n\t\t\t\tbounds.height += bounds.y;\n\t\t\t\tbounds.x = 0;\n\t\t\t\tbounds.y = 0;\n\t\t\t}\n\t\t\t\n\t\t\t// LATER: Use unscaled bounding boxes to fix rounding errors\n\t\t\tvar s = this.view.scale;\n\t\t\tvar w2 = bounds.width / s;\n\t\t\tvar h2 = bounds.height / s;\n\t\t\t\n\t\t\t// Fits to the size of the background image if required\n\t\t\tif (this.backgroundImage != null)\n\t\t\t{\n\t\t\t\tw2 = Math.max(w2, this.backgroundImage.width - bounds.x / s);\n\t\t\t\th2 = Math.max(h2, this.backgroundImage.height - bounds.y / s);\n\t\t\t}\n\t\t\t\n\t\t\tvar b = ((keepOrigin) ? border : 2 * border) + margin + 1;\n\n\t\t\tw1 -= b;\n\t\t\th1 -= b;\n\t\t\t\n\t\t\tvar s2 = (((ignoreWidth) ? h1 / h2 : (ignoreHeight) ? w1 / w2 :\n\t\t\t\tMath.min(w1 / w2, h1 / h2)));\n\t\t\t\n\t\t\tif (this.minFitScale != null)\n\t\t\t{\n\t\t\t\ts2 = Math.max(s2, this.minFitScale);\n\t\t\t}\n\t\t\t\n\t\t\tif (this.maxFitScale != null)\n\t\t\t{\n\t\t\t\ts2 = Math.min(s2, this.maxFitScale);\n\t\t\t}\n\t\n\t\t\tif (enabled)\n\t\t\t{\n\t\t\t\tif (!keepOrigin)\n\t\t\t\t{\n\t\t\t\t\tif (!mxUtils.hasScrollbars(this.container))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar x0 = (bounds.x != null) ? Math.floor(this.view.translate.x - bounds.x / s + border / s2 + margin / 2) : border;\n\t\t\t\t\t\tvar y0 = (bounds.y != null) ? Math.floor(this.view.translate.y - bounds.y / s + border / s2 + margin / 2) : border;\n\n\t\t\t\t\t\tthis.view.scaleAndTranslate(s2, x0, y0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.view.setScale(s2);\n\t\t\t\t\t\tvar b2 = this.getGraphBounds();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (b2.x != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.container.scrollLeft = b2.x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (b2.y != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.container.scrollTop = b2.y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (this.view.scale != s2)\n\t\t\t\t{\n\t\t\t\t\tthis.view.setScale(s2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn s2;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this.view.scale;\n};\n\n/**\n * Function: sizeDidChange\n * \n * Called when the size of the graph has changed. This implementation fires\n * a <size> event after updating the clipping region of the SVG element in\n * SVG-bases browsers.\n */\nmxGraph.prototype.sizeDidChange = function()\n{\n\tvar bounds = this.getGraphBounds();\n\t\n\tif (this.container != null)\n\t{\n\t\tvar border = this.getBorder();\n\t\t\n\t\tvar width = Math.max(0, bounds.x) + bounds.width + 2 * border;\n\t\tvar height = Math.max(0, bounds.y) + bounds.height + 2 * border;\n\t\t\n\t\tif (this.minimumContainerSize != null)\n\t\t{\n\t\t\twidth = Math.max(width, this.minimumContainerSize.width);\n\t\t\theight = Math.max(height, this.minimumContainerSize.height);\n\t\t}\n\n\t\tif (this.resizeContainer)\n\t\t{\n\t\t\tthis.doResizeContainer(width, height);\n\t\t}\n\n\t\tif (this.preferPageSize || (!mxClient.IS_IE && this.pageVisible))\n\t\t{\n\t\t\tvar size = this.getPreferredPageSize(bounds, Math.max(1, width), Math.max(1, height));\n\t\t\t\n\t\t\tif (size != null)\n\t\t\t{\n\t\t\t\twidth = size.width * this.view.scale;\n\t\t\t\theight = size.height * this.view.scale;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (this.minimumGraphSize != null)\n\t\t{\n\t\t\twidth = Math.max(width, this.minimumGraphSize.width * this.view.scale);\n\t\t\theight = Math.max(height, this.minimumGraphSize.height * this.view.scale);\n\t\t}\n\n\t\twidth = Math.ceil(width);\n\t\theight = Math.ceil(height);\n\n\t\tif (this.dialect == mxConstants.DIALECT_SVG)\n\t\t{\n\t\t\tvar root = this.view.getDrawPane().ownerSVGElement;\n\t\t\t\n\t\t\tif (root != null)\n\t\t\t{\n\t\t\t\troot.style.minWidth = Math.max(1, width) + 'px';\n\t\t\t\troot.style.minHeight = Math.max(1, height) + 'px';\n\t\t\t\troot.style.width = '100%';\n\t\t\t\troot.style.height = '100%';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (mxClient.IS_QUIRKS)\n\t\t\t{\n\t\t\t\t// Quirks mode does not support minWidth/-Height\n\t\t\t\tthis.view.updateHtmlCanvasSize(Math.max(1, width), Math.max(1, height));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.view.canvas.style.minWidth = Math.max(1, width) + 'px';\n\t\t\t\tthis.view.canvas.style.minHeight = Math.max(1, height) + 'px';\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.updatePageBreaks(this.pageBreaksVisible, width, height);\n\t}\n\n\tthis.fireEvent(new mxEventObject(mxEvent.SIZE, 'bounds', bounds));\n};\n\n/**\n * Function: doResizeContainer\n * \n * Resizes the container for the given graph width and height.\n */\nmxGraph.prototype.doResizeContainer = function(width, height)\n{\n\tif (this.maximumContainerSize != null)\n\t{\n\t\twidth = Math.min(this.maximumContainerSize.width, width);\n\t\theight = Math.min(this.maximumContainerSize.height, height);\n\t}\n\n\tthis.container.style.width = Math.ceil(width) + 'px';\n\tthis.container.style.height = Math.ceil(height) + 'px';\n};\n\n/**\n * Function: updatePageBreaks\n * \n * Invokes from <sizeDidChange> to redraw the page breaks.\n * \n * Parameters:\n * \n * visible - Boolean that specifies if page breaks should be shown.\n * width - Specifies the width of the container in pixels.\n * height - Specifies the height of the container in pixels.\n */\nmxGraph.prototype.updatePageBreaks = function(visible, width, height)\n{\n\tvar scale = this.view.scale;\n\tvar tr = this.view.translate;\n\tvar fmt = this.pageFormat;\n\tvar ps = scale * this.pageScale;\n\tvar bounds = new mxRectangle(0, 0, fmt.width * ps, fmt.height * ps);\n\n\tvar gb = mxRectangle.fromRectangle(this.getGraphBounds());\n\tgb.width = Math.max(1, gb.width);\n\tgb.height = Math.max(1, gb.height);\n\t\n\tbounds.x = Math.floor((gb.x - tr.x * scale) / bounds.width) * bounds.width + tr.x * scale;\n\tbounds.y = Math.floor((gb.y - tr.y * scale) / bounds.height) * bounds.height + tr.y * scale;\n\t\n\tgb.width = Math.ceil((gb.width + (gb.x - bounds.x)) / bounds.width) * bounds.width;\n\tgb.height = Math.ceil((gb.height + (gb.y - bounds.y)) / bounds.height) * bounds.height;\n\t\n\t// Does not show page breaks if the scale is too small\n\tvisible = visible && Math.min(bounds.width, bounds.height) > this.minPageBreakDist;\n\n\tvar horizontalCount = (visible) ? Math.ceil(gb.height / bounds.height) + 1 : 0;\n\tvar verticalCount = (visible) ? Math.ceil(gb.width / bounds.width) + 1 : 0;\n\tvar right = (verticalCount - 1) * bounds.width;\n\tvar bottom = (horizontalCount - 1) * bounds.height;\n\t\n\tif (this.horizontalPageBreaks == null && horizontalCount > 0)\n\t{\n\t\tthis.horizontalPageBreaks = [];\n\t}\n\n\tif (this.verticalPageBreaks == null && verticalCount > 0)\n\t{\n\t\tthis.verticalPageBreaks = [];\n\t}\n\t\n\tvar drawPageBreaks = mxUtils.bind(this, function(breaks)\n\t{\n\t\tif (breaks != null)\n\t\t{\n\t\t\tvar count = (breaks == this.horizontalPageBreaks) ? horizontalCount : verticalCount; \n\t\t\t\n\t\t\tfor (var i = 0; i <= count; i++)\n\t\t\t{\n\t\t\t\tvar pts = (breaks == this.horizontalPageBreaks) ?\n\t\t\t\t\t[new mxPoint(Math.round(bounds.x), Math.round(bounds.y + i * bounds.height)),\n\t\t\t         new mxPoint(Math.round(bounds.x + right), Math.round(bounds.y + i * bounds.height))] :\n\t\t\t        [new mxPoint(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y)),\n\t\t\t         new mxPoint(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y + bottom))];\n\n\t\t\t\tif (breaks[i] != null)\n\t\t\t\t{\n\t\t\t\t\tbreaks[i].points = pts;\n\t\t\t\t\tbreaks[i].redraw();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar pageBreak = new mxPolyline(pts, this.pageBreakColor);\n\t\t\t\t\tpageBreak.dialect = this.dialect;\n\t\t\t\t\tpageBreak.pointerEvents = false;\n\t\t\t\t\tpageBreak.isDashed = this.pageBreakDashed;\n\t\t\t\t\tpageBreak.init(this.view.backgroundPane);\n\t\t\t\t\tpageBreak.redraw();\n\t\t\t\t\t\n\t\t\t\t\tbreaks[i] = pageBreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (var i = count; i < breaks.length; i++)\n\t\t\t{\n\t\t\t\tbreaks[i].destroy();\n\t\t\t}\n\t\t\t\n\t\t\tbreaks.splice(count, breaks.length - count);\n\t\t}\n\t});\n\t\n\tdrawPageBreaks(this.horizontalPageBreaks);\n\tdrawPageBreaks(this.verticalPageBreaks);\n};\n\n/**\n * Group: Cell styles\n */\n\n/**\n * Function: getCurrentCellStyle\n * \n * Returns the style for the given cell from the cell state, if one exists,\n * or using <getCellStyle>.\n * \n * Parameters:\n * \n * cell - <mxCell> whose style should be returned as an array.\n * ignoreState - Optional boolean that specifies if the cell state should be ignored.\n */\nmxGraph.prototype.getCurrentCellStyle = function(cell, ignoreState)\n{\n\tvar state = (ignoreState) ? null : this.view.getState(cell);\n\t\n\treturn (state != null) ? state.style : this.getCellStyle(cell);\n};\n\n/**\n * Function: getCellStyle\n * \n * Returns an array of key, value pairs representing the cell style for the\n * given cell. If no string is defined in the model that specifies the\n * style, then the default style for the cell is returned or an empty object,\n * if no style can be found. Note: You should try and get the cell state\n * for the given cell and use the cached style in the state before using\n * this method.\n * \n * Parameters:\n * \n * cell - <mxCell> whose style should be returned as an array.\n */\nmxGraph.prototype.getCellStyle = function(cell)\n{\n\tvar stylename = this.model.getStyle(cell);\n\tvar style = null;\n\t\n\t// Gets the default style for the cell\n\tif (this.model.isEdge(cell))\n\t{\n\t\tstyle = this.stylesheet.getDefaultEdgeStyle();\n\t}\n\telse\n\t{\n\t\tstyle = this.stylesheet.getDefaultVertexStyle();\n\t}\n\t\n\t// Resolves the stylename using the above as the default\n\tif (stylename != null)\n\t{\n\t\tstyle = this.postProcessCellStyle(this.stylesheet.getCellStyle(stylename, style));\n\t}\n\t\n\t// Returns a non-null value if no style can be found\n\tif (style == null)\n\t{\n\t\tstyle = new Object();\n\t}\n\t\n\treturn style;\n};\n\n/**\n * Function: postProcessCellStyle\n * \n * Tries to resolve the value for the image style in the image bundles and\n * turns short data URIs as defined in mxImageBundle to data URIs as\n * defined in RFC 2397 of the IETF.\n */\nmxGraph.prototype.postProcessCellStyle = function(style)\n{\n\tif (style != null)\n\t{\n\t\tvar key = style[mxConstants.STYLE_IMAGE];\n\t\tvar image = this.getImageFromBundles(key);\n\n\t\tif (image != null)\n\t\t{\n\t\t\tstyle[mxConstants.STYLE_IMAGE] = image;\n\t\t}\n\t\telse\n\t\t{\n\t\t\timage = key;\n\t\t}\n\t\t\n\t\t// Converts short data uris to normal data uris\n\t\tif (image != null && image.substring(0, 11) == 'data:image/')\n\t\t{\n\t\t\tif (image.substring(0, 20) == 'data:image/svg+xml,<')\n\t\t\t{\n\t\t\t\t// Required for FF and IE11\n\t\t\t\timage = image.substring(0, 19) + encodeURIComponent(image.substring(19));\n\t\t\t}\n\t\t\telse if (image.substring(0, 22) != 'data:image/svg+xml,%3C')\n\t\t\t{\n\t\t\t\tvar comma = image.indexOf(',');\n\t\t\t\t\n\t\t\t\t// Adds base64 encoding prefix if needed\n\t\t\t\tif (comma > 0 && image.substring(comma - 7, comma + 1) != ';base64,')\n\t\t\t\t{\n\t\t\t\t\timage = image.substring(0, comma) + ';base64,'\n\t\t\t\t\t\t+ image.substring(comma + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tstyle[mxConstants.STYLE_IMAGE] = image;\n\t\t}\n\t}\n\n\treturn style;\n};\n\n/**\n * Function: setCellStyle\n * \n * Sets the style of the specified cells. If no cells are given, then the\n * selection cells are changed.\n * \n * Parameters:\n * \n * style - String representing the new style of the cells.\n * cells - Optional array of <mxCells> to set the style for. Default is the\n * selection cells.\n */\nmxGraph.prototype.setCellStyle = function(style, cells)\n{\n\tcells = cells || this.getSelectionCells();\n\t\n\tif (cells != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tthis.model.setStyle(cells[i], style);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: toggleCellStyle\n * \n * Toggles the boolean value for the given key in the style of the given cell\n * and returns the new value as 0 or 1. If no cell is specified then the\n * selection cell is used.\n * \n * Parameter:\n * \n * key - String representing the key for the boolean value to be toggled.\n * defaultValue - Optional boolean default value if no value is defined.\n * Default is false.\n * cell - Optional <mxCell> whose style should be modified. Default is\n * the selection cell.\n */\nmxGraph.prototype.toggleCellStyle = function(key, defaultValue, cell)\n{\n\tcell = cell || this.getSelectionCell();\n\t\n\treturn this.toggleCellStyles(key, defaultValue, [cell]);\n};\n\n/**\n * Function: toggleCellStyles\n * \n * Toggles the boolean value for the given key in the style of the given cells\n * and returns the new value as 0 or 1. If no cells are specified, then the\n * selection cells are used. For example, this can be used to toggle\n * <mxConstants.STYLE_ROUNDED> or any other style with a boolean value.\n * \n * Parameter:\n * \n * key - String representing the key for the boolean value to be toggled.\n * defaultValue - Optional boolean default value if no value is defined.\n * Default is false.\n * cells - Optional array of <mxCells> whose styles should be modified.\n * Default is the selection cells.\n */\nmxGraph.prototype.toggleCellStyles = function(key, defaultValue, cells)\n{\n\tdefaultValue = (defaultValue != null) ? defaultValue : false;\n\tcells = cells || this.getSelectionCells();\n\tvar value = null;\n\t\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tvar style = this.getCurrentCellStyle(cells[0]);\n\t\tvalue = (mxUtils.getValue(style, key, defaultValue)) ? 0 : 1;\n\t\tthis.setCellStyles(key, value, cells);\n\t}\n\t\n\treturn value;\n};\n\n/**\n * Function: setCellStyles\n * \n * Sets the key to value in the styles of the given cells. This will modify\n * the existing cell styles in-place and override any existing assignment\n * for the given key. If no cells are specified, then the selection cells\n * are changed. If no value is specified, then the respective key is\n * removed from the styles.\n * \n * Parameters:\n * \n * key - String representing the key to be assigned.\n * value - String representing the new value for the key.\n * cells - Optional array of <mxCells> to change the style for. Default is\n * the selection cells.\n */\nmxGraph.prototype.setCellStyles = function(key, value, cells)\n{\n\tcells = cells || this.getSelectionCells();\n\tmxUtils.setCellStyles(this.model, cells, key, value);\n};\n\n/**\n * Function: toggleCellStyleFlags\n * \n * Toggles the given bit for the given key in the styles of the specified\n * cells.\n * \n * Parameters:\n * \n * key - String representing the key to toggle the flag in.\n * flag - Integer that represents the bit to be toggled.\n * cells - Optional array of <mxCells> to change the style for. Default is\n * the selection cells.\n */\nmxGraph.prototype.toggleCellStyleFlags = function(key, flag, cells)\n{\n\tthis.setCellStyleFlags(key, flag, null, cells);\n};\n\n/**\n * Function: setCellStyleFlags\n * \n * Sets or toggles the given bit for the given key in the styles of the\n * specified cells.\n * \n * Parameters:\n * \n * key - String representing the key to toggle the flag in.\n * flag - Integer that represents the bit to be toggled.\n * value - Boolean value to be used or null if the value should be toggled.\n * cells - Optional array of <mxCells> to change the style for. Default is\n * the selection cells.\n */\nmxGraph.prototype.setCellStyleFlags = function(key, flag, value, cells)\n{\n\tcells = cells || this.getSelectionCells();\n\t\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tif (value == null)\n\t\t{\n\t\t\tvar style = this.getCurrentCellStyle(cells[0]);\n\t\t\tvar current = parseInt(style[key] || 0);\n\t\t\tvalue = !((current & flag) == flag);\n\t\t}\n\n\t\tmxUtils.setCellStyleFlags(this.model, cells, key, flag, value);\n\t}\n};\n\n/**\n * Group: Cell alignment and orientation\n */\n\n/**\n * Function: alignCells\n * \n * Aligns the given cells vertically or horizontally according to the given\n * alignment using the optional parameter as the coordinate.\n * \n * Parameters:\n * \n * align - Specifies the alignment. Possible values are all constants in\n * mxConstants with an ALIGN prefix.\n * cells - Array of <mxCells> to be aligned.\n * param - Optional coordinate for the alignment.\n */\nmxGraph.prototype.alignCells = function(align, cells, param)\n{\n\tif (cells == null)\n\t{\n\t\tcells = this.getSelectionCells();\n\t}\n\t\n\tif (cells != null && cells.length > 1)\n\t{\n\t\t// Finds the required coordinate for the alignment\n\t\tif (param == null)\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tvar state = this.view.getState(cells[i]);\n\t\t\t\t\n\t\t\t\tif (state != null && !this.model.isEdge(cells[i]))\n\t\t\t\t{\n\t\t\t\t\tif (param == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (align == mxConstants.ALIGN_CENTER)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = state.x + state.width / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (align == mxConstants.ALIGN_RIGHT)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = state.x + state.width;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (align == mxConstants.ALIGN_TOP)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = state.y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (align == mxConstants.ALIGN_MIDDLE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = state.y + state.height / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (align == mxConstants.ALIGN_BOTTOM)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = state.y + state.height;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = state.x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (align == mxConstants.ALIGN_RIGHT)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = Math.max(param, state.x + state.width);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (align == mxConstants.ALIGN_TOP)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = Math.min(param, state.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (align == mxConstants.ALIGN_BOTTOM)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = Math.max(param, state.y + state.height);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = Math.min(param, state.x);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Aligns the cells to the coordinate\n\t\tif (param != null)\n\t\t{\n\t\t\tvar s = this.view.scale;\n\n\t\t\tthis.model.beginUpdate();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar state = this.view.getState(cells[i]);\n\t\t\t\t\t\n\t\t\t\t\tif (state != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar geo = this.getCellGeometry(cells[i]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (geo != null && !this.model.isEdge(cells[i]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (align == mxConstants.ALIGN_CENTER)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.x += (param - state.x - state.width / 2) / s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (align == mxConstants.ALIGN_RIGHT)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.x += (param - state.x - state.width) / s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (align == mxConstants.ALIGN_TOP)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.y += (param - state.y) / s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (align == mxConstants.ALIGN_MIDDLE)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.y += (param - state.y - state.height / 2) / s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (align == mxConstants.ALIGN_BOTTOM)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.y += (param - state.y - state.height) / s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.x += (param - state.x) / s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tthis.resizeCell(cells[i], geo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.ALIGN_CELLS,\n\t\t\t\t\t\t'align', align, 'cells', cells));\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tthis.model.endUpdate();\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn cells;\n};\n\n/**\n * Function: flipEdge\n * \n * Toggles the style of the given edge between null (or empty) and\n * <alternateEdgeStyle>. This method fires <mxEvent.FLIP_EDGE> while the\n * transaction is in progress. Returns the edge that was flipped.\n * \n * Here is an example that overrides this implementation to invert the\n * value of <mxConstants.STYLE_ELBOW> without removing any existing styles.\n * \n * (code)\n * graph.flipEdge = function(edge)\n * {\n *   if (edge != null)\n *   {\n *     var style = this.getCurrentCellStyle(edge);\n *     var elbow = mxUtils.getValue(style, mxConstants.STYLE_ELBOW,\n *         mxConstants.ELBOW_HORIZONTAL);\n *     var value = (elbow == mxConstants.ELBOW_HORIZONTAL) ?\n *         mxConstants.ELBOW_VERTICAL : mxConstants.ELBOW_HORIZONTAL;\n *     this.setCellStyles(mxConstants.STYLE_ELBOW, value, [edge]);\n *   }\n * };\n * (end)\n * \n * Parameters:\n * \n * edge - <mxCell> whose style should be changed.\n */\nmxGraph.prototype.flipEdge = function(edge)\n{\n\tif (edge != null &&\n\t\tthis.alternateEdgeStyle != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tvar style = this.model.getStyle(edge);\n\n\t\t\tif (style == null || style.length == 0)\n\t\t\t{\n\t\t\t\tthis.model.setStyle(edge, this.alternateEdgeStyle);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.model.setStyle(edge, null);\n\t\t\t}\n\n\t\t\t// Removes all existing control points\n\t\t\tthis.resetEdge(edge);\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.FLIP_EDGE, 'edge', edge));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n\n\treturn edge;\n};\n\n/**\n * Function: addImageBundle\n *\n * Adds the specified <mxImageBundle>.\n */\nmxGraph.prototype.addImageBundle = function(bundle)\n{\n\tthis.imageBundles.push(bundle);\n};\n\n/**\n * Function: removeImageBundle\n * \n * Removes the specified <mxImageBundle>.\n */\nmxGraph.prototype.removeImageBundle = function(bundle)\n{\n\tvar tmp = [];\n\t\n\tfor (var i = 0; i < this.imageBundles.length; i++)\n\t{\n\t\tif (this.imageBundles[i] != bundle)\n\t\t{\n\t\t\ttmp.push(this.imageBundles[i]);\n\t\t}\n\t}\n\t\n\tthis.imageBundles = tmp;\n};\n\n/**\n * Function: getImageFromBundles\n *\n * Searches all <imageBundles> for the specified key and returns the value\n * for the first match or null if the key is not found.\n */\nmxGraph.prototype.getImageFromBundles = function(key)\n{\n\tif (key != null)\n\t{\n\t\tfor (var i = 0; i < this.imageBundles.length; i++)\n\t\t{\n\t\t\tvar image = this.imageBundles[i].getImage(key);\n\t\t\t\n\t\t\tif (image != null)\n\t\t\t{\n\t\t\t\treturn image;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Group: Order\n */\n\n/**\n * Function: orderCells\n * \n * Moves the given cells to the front or back. The change is carried out\n * using <cellsOrdered>. This method fires <mxEvent.ORDER_CELLS> while the\n * transaction is in progress.\n * \n * Parameters:\n * \n * back - Boolean that specifies if the cells should be moved to back.\n * cells - Array of <mxCells> to move to the background. If null is\n * specified then the selection cells are used.\n */\nmxGraph.prototype.orderCells = function(back, cells)\n{\n\tif (cells == null)\n\t{\n\t\tcells = mxUtils.sortCells(this.getSelectionCells(), true);\n\t}\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.cellsOrdered(cells, back);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.ORDER_CELLS,\n\t\t\t\t'back', back, 'cells', cells));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: cellsOrdered\n * \n * Moves the given cells to the front or back. This method fires\n * <mxEvent.CELLS_ORDERED> while the transaction is in progress.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> whose order should be changed.\n * back - Boolean that specifies if the cells should be moved to back.\n */\nmxGraph.prototype.cellsOrdered = function(cells, back)\n{\n\tif (cells != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tvar parent = this.model.getParent(cells[i]);\n\n\t\t\t\tif (back)\n\t\t\t\t{\n\t\t\t\t\tthis.model.add(parent, cells[i], i);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.model.add(parent, cells[i],\n\t\t\t\t\t\t\tthis.model.getChildCount(parent) - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELLS_ORDERED,\n\t\t\t\t\t'back', back, 'cells', cells));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Group: Grouping\n */\n\n/**\n * Function: groupCells\n * \n * Adds the cells into the given group. The change is carried out using\n * <cellsAdded>, <cellsMoved> and <cellsResized>. This method fires\n * <mxEvent.GROUP_CELLS> while the transaction is in progress. Returns the\n * new group. A group is only created if there is at least one entry in the\n * given array of cells.\n * \n * Parameters:\n * \n * group - <mxCell> that represents the target group. If null is specified\n * then a new group is created using <createGroupCell>.\n * border - Optional integer that specifies the border between the child\n * area and the group bounds. Default is 0.\n * cells - Optional array of <mxCells> to be grouped. If null is specified\n * then the selection cells are used.\n */\nmxGraph.prototype.groupCells = function(group, border, cells)\n{\n\tif (cells == null)\n\t{\n\t\tcells = mxUtils.sortCells(this.getSelectionCells(), true);\n\t}\n\n\tcells = this.getCellsForGroup(cells);\n\n\tif (group == null)\n\t{\n\t\tgroup = this.createGroupCell(cells);\n\t}\n\n\tvar bounds = this.getBoundsForGroup(group, cells, border);\n\n\tif (cells.length > 1 && bounds != null)\n\t{\n\t\t// Uses parent of group or previous parent of first child\n\t\tvar parent = this.model.getParent(group);\n\t\t\n\t\tif (parent == null)\n\t\t{\n\t\t\tparent = this.model.getParent(cells[0]);\n\t\t}\n\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\t// Checks if the group has a geometry and\n\t\t\t// creates one if one does not exist\n\t\t\tif (this.getCellGeometry(group) == null)\n\t\t\t{\n\t\t\t\tthis.model.setGeometry(group, new mxGeometry());\n\t\t\t}\n\n\t\t\t// Adds the group into the parent\n\t\t\tvar index = this.model.getChildCount(parent);\n\t\t\tthis.cellsAdded([group], parent, index, null, null, false, false, false);\n\n\t\t\t// Adds the children into the group and moves\n\t\t\tindex = this.model.getChildCount(group);\n\t\t\tthis.cellsAdded(cells, group, index, null, null, false, false, false);\n\t\t\tthis.cellsMoved(cells, -bounds.x, -bounds.y, false, false, false);\n\n\t\t\t// Resizes the group\n\t\t\tthis.cellsResized([group], [bounds], false);\n\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.GROUP_CELLS,\n\t\t\t\t\t'group', group, 'border', border, 'cells', cells));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n\n\treturn group;\n};\n\n/**\n * Function: getCellsForGroup\n * \n * Returns the cells with the same parent as the first cell\n * in the given array.\n */\nmxGraph.prototype.getCellsForGroup = function(cells)\n{\n\tvar result = [];\n\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tvar parent = this.model.getParent(cells[0]);\n\t\tresult.push(cells[0]);\n\n\t\t// Filters selection cells with the same parent\n\t\tfor (var i = 1; i < cells.length; i++)\n\t\t{\n\t\t\tif (this.model.getParent(cells[i]) == parent)\n\t\t\t{\n\t\t\t\tresult.push(cells[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getBoundsForGroup\n * \n * Returns the bounds to be used for the given group and children.\n */\nmxGraph.prototype.getBoundsForGroup = function(group, children, border)\n{\n\tvar result = this.getBoundingBoxFromGeometry(children, true);\n\t\n\tif (result != null)\n\t{\n\t\tif (this.isSwimlane(group))\n\t\t{\n\t\t\tvar size = this.getStartSize(group);\n\t\t\t\n\t\t\tresult.x -= size.width;\n\t\t\tresult.y -= size.height;\n\t\t\tresult.width += size.width;\n\t\t\tresult.height += size.height;\n\t\t}\n\t\t\n\t\t// Adds the border\n\t\tif (border != null)\n\t\t{\n\t\t\tresult.x -= border;\n\t\t\tresult.y -= border;\n\t\t\tresult.width += 2 * border;\n\t\t\tresult.height += 2 * border;\n\t\t}\n\t}\t\t\t\n\t\n\treturn result;\n};\n\n/**\n * Function: createGroupCell\n * \n * Hook for creating the group cell to hold the given array of <mxCells> if\n * no group cell was given to the <group> function.\n * \n * The following code can be used to set the style of new group cells.\n * \n * (code)\n * var graphCreateGroupCell = graph.createGroupCell;\n * graph.createGroupCell = function(cells)\n * {\n *   var group = graphCreateGroupCell.apply(this, arguments);\n *   group.setStyle('group');\n *   \n *   return group;\n * };\n */\nmxGraph.prototype.createGroupCell = function(cells)\n{\n\tvar group = new mxCell('');\n\tgroup.setVertex(true);\n\tgroup.setConnectable(false);\n\t\n\treturn group;\n};\n\n/**\n * Function: ungroupCells\n * \n * Ungroups the given cells by moving the children the children to their\n * parents parent and removing the empty groups. Returns the children that\n * have been removed from the groups.\n * \n * Parameters:\n * \n * cells - Array of cells to be ungrouped. If null is specified then the\n * selection cells are used.\n */\nmxGraph.prototype.ungroupCells = function(cells)\n{\n\tvar result = [];\n\t\n\tif (cells == null)\n\t{\n\t\tcells = this.getCellsForUngroup();\n\t}\n\t\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tvar children = this.model.getChildren(cells[i]);\n\t\t\t\t\n\t\t\t\tif (children != null && children.length > 0)\n\t\t\t\t{\n\t\t\t\t\tchildren = children.slice();\n\t\t\t\t\tvar parent = this.model.getParent(cells[i]);\n\t\t\t\t\tvar index = this.model.getChildCount(parent);\n\n\t\t\t\t\tthis.cellsAdded(children, parent, index, null, null, true);\n\t\t\t\t\tresult = result.concat(children);\n\t\t\t\t\t\n\t\t\t\t\t// Fix relative child cells\n\t\t\t\t\tfor (var j = 0; j < children.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar state = this.view.getState(children[j]);\n\t\t\t\t\t\tvar geo = this.getCellGeometry(children[j]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (state != null && geo != null && geo.relative)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\t\tgeo.x = state.origin.x;\n\t\t\t\t\t\t\tgeo.y = state.origin.y;\n\t\t\t\t\t\t\tgeo.relative = false;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tthis.model.setGeometry(children[j], geo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.removeCellsAfterUngroup(cells);\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.UNGROUP_CELLS, 'cells', cells));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getCellsForUngroup\n * \n * Returns the selection cells that can be ungrouped.\n */\nmxGraph.prototype.getCellsForUngroup = function()\n{\n\tvar cells = this.getSelectionCells();\n\n\t// Finds the cells with children\n\tvar tmp = [];\n\t\n\tfor (var i = 0; i < cells.length; i++)\n\t{\n\t\tif (this.model.isVertex(cells[i]) &&\n\t\t\tthis.model.getChildCount(cells[i]) > 0)\n\t\t{\n\t\t\ttmp.push(cells[i]);\n\t\t}\n\t}\n\n\treturn tmp;\n};\n\n/**\n * Function: removeCellsAfterUngroup\n * \n * Hook to remove the groups after <ungroupCells>.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> that were ungrouped.\n */\nmxGraph.prototype.removeCellsAfterUngroup = function(cells)\n{\n\tthis.cellsRemoved(this.addAllEdges(cells));\n};\n\n/**\n * Function: removeCellsFromParent\n * \n * Removes the specified cells from their parents and adds them to the\n * default parent. Returns the cells that were removed from their parents.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be removed from their parents.\n */\nmxGraph.prototype.removeCellsFromParent = function(cells)\n{\n\tif (cells == null)\n\t{\n\t\tcells = this.getSelectionCells();\n\t}\n\t\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tvar parent = this.getDefaultParent();\n\t\tvar index = this.model.getChildCount(parent);\n\n\t\tthis.cellsAdded(cells, parent, index, null, null, true);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.REMOVE_CELLS_FROM_PARENT, 'cells', cells));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: updateGroupBounds\n * \n * Updates the bounds of the given groups to include all children and returns\n * the passed-in cells. Call this with the groups in parent to child order,\n * top-most group first, the cells are processed in reverse order and cells\n * with no children are ignored.\n * \n * Parameters:\n * \n * cells - The groups whose bounds should be updated. If this is null, then\n * the selection cells are used.\n * border - Optional border to be added in the group. Default is 0.\n * moveGroup - Optional boolean that allows the group to be moved. Default\n * is false.\n * topBorder - Optional top border to be added in the group. Default is 0.\n * rightBorder - Optional top border to be added in the group. Default is 0.\n * bottomBorder - Optional top border to be added in the group. Default is 0.\n * leftBorder - Optional top border to be added in the group. Default is 0.\n */\nmxGraph.prototype.updateGroupBounds = function(cells, border, moveGroup, topBorder, rightBorder, bottomBorder, leftBorder)\n{\n\tif (cells == null)\n\t{\n\t\tcells = this.getSelectionCells();\n\t}\n\t\n\tborder = (border != null) ? border : 0;\n\tmoveGroup = (moveGroup != null) ? moveGroup : false;\n\ttopBorder = (topBorder != null) ? topBorder : 0;\n\trightBorder = (rightBorder != null) ? rightBorder : 0;\n\tbottomBorder = (bottomBorder != null) ? bottomBorder : 0;\n\tleftBorder = (leftBorder != null) ? leftBorder : 0;\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tfor (var i = cells.length - 1; i >= 0; i--)\n\t\t{\n\t\t\tvar geo = this.getCellGeometry(cells[i]);\n\t\t\t\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tvar children = this.getChildCells(cells[i]);\n\t\t\t\t\n\t\t\t\tif (children != null && children.length > 0)\n\t\t\t\t{\n\t\t\t\t\tvar bounds = this.getBoundingBoxFromGeometry(children, true);\n\t\t\t\t\t\n\t\t\t\t\tif (bounds != null && bounds.width > 0 && bounds.height > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Adds the size of the title area for swimlanes\n\t\t\t\t\t\tvar size = (this.isSwimlane(cells[i])) ?\n\t\t\t\t\t\t\tthis.getActualStartSize(cells[i], true) : new mxRectangle();\n\t\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (moveGroup)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.x = Math.round(geo.x + bounds.x - border - size.x - leftBorder);\n\t\t\t\t\t\t\tgeo.y = Math.round(geo.y + bounds.y - border - size.y - topBorder);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tgeo.width = Math.round(bounds.width + 2 * border + size.x + leftBorder + rightBorder + size.width);\n\t\t\t\t\t\tgeo.height = Math.round(bounds.height + 2 * border + size.y + topBorder + bottomBorder + size.height);\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.model.setGeometry(cells[i], geo);\n\t\t\t\t\t\tthis.moveCells(children, border + size.x - bounds.x + leftBorder,\n\t\t\t\t\t\t\t\tborder + size.y - bounds.y + topBorder);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: getBoundingBox\n * \n * Returns the bounding box for the given array of <mxCells>. The bounding box for\n * each cell and its descendants is computed using <mxGraphView.getBoundingBox>.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> whose bounding box should be returned.\n */\nmxGraph.prototype.getBoundingBox = function(cells)\n{\n\tvar result = null;\n\t\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (this.model.isVertex(cells[i]) || this.model.isEdge(cells[i]))\n\t\t\t{\n\t\t\t\tvar bbox = this.view.getBoundingBox(this.view.getState(cells[i]), true);\n\t\t\t\n\t\t\t\tif (bbox != null)\n\t\t\t\t{\n\t\t\t\t\tif (result == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = mxRectangle.fromRectangle(bbox);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.add(bbox);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Group: Cell cloning, insertion and removal\n */\n\n/**\n * Function: cloneCell\n * \n * Returns the clone for the given cell. Uses <cloneCells>.\n * \n * Parameters:\n * \n * cell - <mxCell> to be cloned.\n * allowInvalidEdges - Optional boolean that specifies if invalid edges\n * should be cloned. Default is true.\n * mapping - Optional mapping for existing clones.\n * keepPosition - Optional boolean indicating if the position of the cells should\n * be updated to reflect the lost parent cell. Default is false.\n */\nmxGraph.prototype.cloneCell = function(cell, allowInvalidEdges, mapping, keepPosition)\n{\n\treturn this.cloneCells([cell], allowInvalidEdges, mapping, keepPosition)[0];\n};\n\n/**\n * Function: cloneCells\n * \n * Returns the clones for the given cells. The clones are created recursively\n * using <mxGraphModel.cloneCells>. If the terminal of an edge is not in the\n * given array, then the respective end is assigned a terminal point and the\n * terminal is removed.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be cloned.\n * allowInvalidEdges - Optional boolean that specifies if invalid edges\n * should be cloned. Default is true.\n * mapping - Optional mapping for existing clones.\n * keepPosition - Optional boolean indicating if the position of the cells should\n * be updated to reflect the lost parent cell. Default is false.\n */\nmxGraph.prototype.cloneCells = function(cells, allowInvalidEdges, mapping, keepPosition)\n{\n\tallowInvalidEdges = (allowInvalidEdges != null) ? allowInvalidEdges : true;\n\tvar clones = null;\n\t\n\tif (cells != null)\n\t{\n\t\t// Creates a dictionary for fast lookups\n\t\tvar dict = new mxDictionary();\n\t\tvar tmp = [];\n\t\t\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tdict.put(cells[i], true);\n\t\t\ttmp.push(cells[i]);\n\t\t}\n\t\t\n\t\tif (tmp.length > 0)\n\t\t{\n\t\t\tvar scale = this.view.scale;\n\t\t\tvar trans = this.view.translate;\n\t\t\tclones = this.model.cloneCells(cells, true, mapping);\n\t\t\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tif (!allowInvalidEdges && this.model.isEdge(clones[i]) &&\n\t\t\t\t\tthis.getEdgeValidationError(clones[i],\n\t\t\t\t\t\tthis.model.getTerminal(clones[i], true),\n\t\t\t\t\t\tthis.model.getTerminal(clones[i], false)) != null)\n\t\t\t\t{\n\t\t\t\t\tclones[i] = null;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar g = this.model.getGeometry(clones[i]);\n\t\t\t\t\t\n\t\t\t\t\tif (g != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar state = this.view.getState(cells[i]);\n\t\t\t\t\t\tvar pstate = this.view.getState(this.model.getParent(cells[i]));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (state != null && pstate != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar dx = (keepPosition) ? 0 : pstate.origin.x;\n\t\t\t\t\t\t\tvar dy = (keepPosition) ? 0 : pstate.origin.y;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (this.model.isEdge(clones[i]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar pts = state.absolutePoints;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (pts != null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Checks if the source is cloned or sets the terminal point\n\t\t\t\t\t\t\t\t\tvar src = this.model.getTerminal(cells[i], true);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\twhile (src != null && !dict.get(src))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tsrc = this.model.getParent(src);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif (src == null && pts[0] != null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tg.setTerminalPoint(\n\t\t\t\t\t\t\t\t\t\t\tnew mxPoint(pts[0].x / scale - trans.x,\n\t\t\t\t\t\t\t\t\t\t\t\tpts[0].y / scale - trans.y), true);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// Checks if the target is cloned or sets the terminal point\n\t\t\t\t\t\t\t\t\tvar trg = this.model.getTerminal(cells[i], false);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\twhile (trg != null && !dict.get(trg))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttrg = this.model.getParent(trg);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar n = pts.length - 1;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif (trg == null && pts[n] != null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tg.setTerminalPoint(\n\t\t\t\t\t\t\t\t\t\t\tnew mxPoint(pts[n].x / scale - trans.x,\n\t\t\t\t\t\t\t\t\t\t\t\tpts[n].y / scale - trans.y), false);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// Translates the control points\n\t\t\t\t\t\t\t\t\tvar points = g.points;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif (points != null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tfor (var j = 0; j < points.length; j++)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tpoints[j].x += dx;\n\t\t\t\t\t\t\t\t\t\t\tpoints[j].y += dy;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tg.translate(dx, dy);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tclones = [];\n\t\t}\n\t}\n\t\n\treturn clones;\n};\n\n/**\n * Function: insertVertex\n * \n * Adds a new vertex into the given parent <mxCell> using value as the user\n * object and the given coordinates as the <mxGeometry> of the new vertex.\n * The id and style are used for the respective properties of the new\n * <mxCell>, which is returned.\n *\n * When adding new vertices from a mouse event, one should take into\n * account the offset of the graph container and the scale and translation\n * of the view in order to find the correct unscaled, untranslated\n * coordinates using <mxGraph.getPointForEvent> as follows:\n * \n * (code)\n * var pt = graph.getPointForEvent(evt);\n * var parent = graph.getDefaultParent();\n * graph.insertVertex(parent, null,\n * \t\t\t'Hello, World!', x, y, 220, 30);\n * (end)\n * \n * For adding image cells, the style parameter can be assigned as\n * \n * (code)\n * stylename;image=imageUrl\n * (end)\n * \n * See <mxGraph> for more information on using images.\n *\n * Parameters:\n * \n * parent - <mxCell> that specifies the parent of the new vertex.\n * id - Optional string that defines the Id of the new vertex.\n * value - Object to be used as the user object.\n * x - Integer that defines the x coordinate of the vertex.\n * y - Integer that defines the y coordinate of the vertex.\n * width - Integer that defines the width of the vertex.\n * height - Integer that defines the height of the vertex.\n * style - Optional string that defines the cell style.\n * relative - Optional boolean that specifies if the geometry is relative.\n * Default is false.\n */\nmxGraph.prototype.insertVertex = function(parent, id, value,\n\tx, y, width, height, style, relative)\n{\n\tvar vertex = this.createVertex(parent, id, value, x, y, width, height, style, relative);\n\n\treturn this.addCell(vertex, parent);\n};\n\n/**\n * Function: createVertex\n * \n * Hook method that creates the new vertex for <insertVertex>.\n */\nmxGraph.prototype.createVertex = function(parent, id, value,\n\t\tx, y, width, height, style, relative)\n{\n\t// Creates the geometry for the vertex\n\tvar geometry = new mxGeometry(x, y, width, height);\n\tgeometry.relative = (relative != null) ? relative : false;\n\t\n\t// Creates the vertex\n\tvar vertex = new mxCell(value, geometry, style);\n\tvertex.setId(id);\n\tvertex.setVertex(true);\n\tvertex.setConnectable(true);\n\t\n\treturn vertex;\n};\n\t\n/**\n * Function: insertEdge\n * \n * Adds a new edge into the given parent <mxCell> using value as the user\n * object and the given source and target as the terminals of the new edge.\n * The id and style are used for the respective properties of the new\n * <mxCell>, which is returned.\n *\n * Parameters:\n * \n * parent - <mxCell> that specifies the parent of the new edge.\n * id - Optional string that defines the Id of the new edge.\n * value - JavaScript object to be used as the user object.\n * source - <mxCell> that defines the source of the edge.\n * target - <mxCell> that defines the target of the edge.\n * style - Optional string that defines the cell style.\n */\nmxGraph.prototype.insertEdge = function(parent, id, value, source, target, style)\n{\n\tvar edge = this.createEdge(parent, id, value, source, target, style);\n\t\n\treturn this.addEdge(edge, parent, source, target);\n};\n\n/**\n * Function: createEdge\n * \n * Hook method that creates the new edge for <insertEdge>. This\n * implementation does not set the source and target of the edge, these\n * are set when the edge is added to the model.\n * \n */\nmxGraph.prototype.createEdge = function(parent, id, value, source, target, style)\n{\n\t// Creates the edge\n\tvar edge = new mxCell(value, new mxGeometry(), style);\n\tedge.setId(id);\n\tedge.setEdge(true);\n\tedge.geometry.relative = true;\n\t\n\treturn edge;\n};\n\n/**\n * Function: addEdge\n * \n * Adds the edge to the parent and connects it to the given source and\n * target terminals. This is a shortcut method. Returns the edge that was\n * added.\n * \n * Parameters:\n * \n * edge - <mxCell> to be inserted into the given parent.\n * parent - <mxCell> that represents the new parent. If no parent is\n * given then the default parent is used.\n * source - Optional <mxCell> that represents the source terminal.\n * target - Optional <mxCell> that represents the target terminal.\n * index - Optional index to insert the cells at. Default is to append.\n */\nmxGraph.prototype.addEdge = function(edge, parent, source, target, index)\n{\n\treturn this.addCell(edge, parent, index, source, target);\n};\n\n/**\n * Function: addCell\n * \n * Adds the cell to the parent and connects it to the given source and\n * target terminals. This is a shortcut method. Returns the cell that was\n * added.\n * \n * Parameters:\n * \n * cell - <mxCell> to be inserted into the given parent.\n * parent - <mxCell> that represents the new parent. If no parent is\n * given then the default parent is used.\n * index - Optional index to insert the cells at. Default is to append.\n * source - Optional <mxCell> that represents the source terminal.\n * target - Optional <mxCell> that represents the target terminal.\n */\nmxGraph.prototype.addCell = function(cell, parent, index, source, target)\n{\n\treturn this.addCells([cell], parent, index, source, target)[0];\n};\n\n/**\n * Function: addCells\n * \n * Adds the cells to the parent at the given index, connecting each cell to\n * the optional source and target terminal. The change is carried out using\n * <cellsAdded>. This method fires <mxEvent.ADD_CELLS> while the\n * transaction is in progress. Returns the cells that were added.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be inserted.\n * parent - <mxCell> that represents the new parent. If no parent is\n * given then the default parent is used.\n * index - Optional index to insert the cells at. Default is to append.\n * source - Optional source <mxCell> for all inserted cells.\n * target - Optional target <mxCell> for all inserted cells.\n * absolute - Optional boolean indicating of cells should be kept at\n * their absolute position. Default is false.\n */\nmxGraph.prototype.addCells = function(cells, parent, index, source, target, absolute)\n{\n\tif (parent == null)\n\t{\n\t\tparent = this.getDefaultParent();\n\t}\n\t\n\tif (index == null)\n\t{\n\t\tindex = this.model.getChildCount(parent);\n\t}\n\t\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.cellsAdded(cells, parent, index, source, target, (absolute != null) ? absolute : false, true);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.ADD_CELLS, 'cells', cells,\n\t\t\t\t'parent', parent, 'index', index, 'source', source, 'target', target));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: cellsAdded\n * \n * Adds the specified cells to the given parent. This method fires\n * <mxEvent.CELLS_ADDED> while the transaction is in progress.\n */\nmxGraph.prototype.cellsAdded = function(cells, parent, index, source, target, absolute, constrain, extend)\n{\n\tif (cells != null && parent != null && index != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tvar parentState = (absolute) ? this.view.getState(parent) : null;\n\t\t\tvar o1 = (parentState != null) ? parentState.origin : null;\n\t\t\tvar zero = new mxPoint(0, 0);\n\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tif (cells[i] == null)\n\t\t\t\t{\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar previous = this.model.getParent(cells[i]);\n\t\n\t\t\t\t\t// Keeps the cell at its absolute location\n\t\t\t\t\tif (o1 != null && cells[i] != parent && parent != previous)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar oldState = this.view.getState(previous);\n\t\t\t\t\t\tvar o2 = (oldState != null) ? oldState.origin : zero;\n\t\t\t\t\t\tvar geo = this.model.getGeometry(cells[i]);\n\t\n\t\t\t\t\t\tif (geo != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar dx = o2.x - o1.x;\n\t\t\t\t\t\t\tvar dy = o2.y - o1.y;\n\t\n\t\t\t\t\t\t\t// FIXME: Cells should always be inserted first before any other edit\n\t\t\t\t\t\t\t// to avoid forward references in sessions.\n\t\t\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\t\tgeo.translate(dx, dy);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (!geo.relative && this.model.isVertex(cells[i]) &&\n\t\t\t\t\t\t\t\t!this.isAllowNegativeCoordinates())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.x = Math.max(0, geo.x);\n\t\t\t\t\t\t\t\tgeo.y = Math.max(0, geo.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tthis.model.setGeometry(cells[i], geo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Decrements all following indices\n\t\t\t\t\t// if cell is already in parent\n\t\t\t\t\tif (parent == previous && index + i > this.model.getChildCount(parent))\n\t\t\t\t\t{\n\t\t\t\t\t\tindex--;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.model.add(parent, cells[i], index + i);\n\t\t\t\t\t\n\t\t\t\t\tif (this.autoSizeCellsOnAdd)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.autoSizeCell(cells[i], true);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Extends the parent or constrains the child\n\t\t\t\t\tif ((extend == null || extend) &&\n\t\t\t\t\t\tthis.isExtendParentsOnAdd(cells[i]) && this.isExtendParent(cells[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.extendParent(cells[i]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Additionally constrains the child after extending the parent\n\t\t\t\t\tif (constrain == null || constrain)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.constrainChild(cells[i]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Sets the source terminal\n\t\t\t\t\tif (source != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.cellConnected(cells[i], source, true);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Sets the target terminal\n\t\t\t\t\tif (target != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.cellConnected(cells[i], target, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELLS_ADDED, 'cells', cells,\n\t\t\t\t'parent', parent, 'index', index, 'source', source, 'target', target,\n\t\t\t\t'absolute', absolute));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: autoSizeCell\n * \n * Resizes the specified cell to just fit around the its label and/or children\n * \n * Parameters:\n * \n * cell - <mxCells> to be resized.\n * recurse - Optional boolean which specifies if all descendants should be\n * autosized. Default is true.\n */\nmxGraph.prototype.autoSizeCell = function(cell, recurse)\n{\n\trecurse = (recurse != null) ? recurse : true;\n\t\n\tif (recurse)\n\t{\n\t\tvar childCount = this.model.getChildCount(cell);\n\t\t\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tthis.autoSizeCell(this.model.getChildAt(cell, i));\n\t\t}\n\t}\n\n\tif (this.getModel().isVertex(cell) && this.isAutoSizeCell(cell))\n\t{\n\t\tthis.updateCellSize(cell);\n\t}\n};\n\n/**\n * Function: removeCells\n * \n * Removes the given cells from the graph including all connected edges if\n * includeEdges is true. The change is carried out using <cellsRemoved>.\n * This method fires <mxEvent.REMOVE_CELLS> while the transaction is in\n * progress. The removed cells are returned as an array.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to remove. If null is specified then the\n * selection cells which are deletable are used.\n * includeEdges - Optional boolean which specifies if all connected edges\n * should be removed as well. Default is true.\n */\nmxGraph.prototype.removeCells = function(cells, includeEdges)\n{\n\tincludeEdges = (includeEdges != null) ? includeEdges : true;\n\t\n\tif (cells == null)\n\t{\n\t\tcells = this.getDeletableCells(this.getSelectionCells());\n\t}\n\n\t// Adds all edges to the cells\n\tif (includeEdges)\n\t{\n\t\t// FIXME: Remove duplicate cells in result or do not add if\n\t\t// in cells or descendant of cells\n\t\tcells = this.getDeletableCells(this.addAllEdges(cells));\n\t}\n\telse\n\t{\n\t\tcells = cells.slice();\n\t\t\n\t\t// Removes edges that are currently not\n\t\t// visible as those cannot be updated\n\t\tvar edges = this.getDeletableCells(this.getAllEdges(cells));\n\t\tvar dict = new mxDictionary();\n\t\t\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tdict.put(cells[i], true);\n\t\t}\n\t\t\n\t\tfor (var i = 0; i < edges.length; i++)\n\t\t{\n\t\t\tif (this.view.getState(edges[i]) == null &&\n\t\t\t\t!dict.get(edges[i]))\n\t\t\t{\n\t\t\t\tdict.put(edges[i], true);\n\t\t\t\tcells.push(edges[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.cellsRemoved(cells);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.REMOVE_CELLS, \n\t\t\t\t'cells', cells, 'includeEdges', includeEdges));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\t\n\treturn cells;\n};\n\n/**\n * Function: cellsRemoved\n * \n * Removes the given cells from the model. This method fires\n * <mxEvent.CELLS_REMOVED> while the transaction is in progress.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to remove.\n */\nmxGraph.prototype.cellsRemoved = function(cells)\n{\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tvar scale = this.view.scale;\n\t\tvar tr = this.view.translate;\n\t\t\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\t// Creates hashtable for faster lookup\n\t\t\tvar dict = new mxDictionary();\n\t\t\t\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tdict.put(cells[i], true);\n\t\t\t}\n\t\t\t\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\t// Disconnects edges which are not being removed\n\t\t\t\tvar edges = this.getAllEdges([cells[i]]);\n\t\t\t\t\n\t\t\t\tvar disconnectTerminal = mxUtils.bind(this, function(edge, source)\n\t\t\t\t{\n\t\t\t\t\tvar geo = this.model.getGeometry(edge);\n\n\t\t\t\t\tif (geo != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Checks if terminal is being removed\n\t\t\t\t\t\tvar terminal = this.model.getTerminal(edge, source);\n\t\t\t\t\t\tvar connected = false;\n\t\t\t\t\t\tvar tmp = terminal;\n\t\t\t\t\t\t\n\t\t\t\t\t\twhile (tmp != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (cells[i] == tmp)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tconnected = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttmp = this.model.getParent(tmp);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (connected)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\t\tvar state = this.view.getState(edge);\n\n\t\t\t\t\t\t\tif (state != null && state.absolutePoints != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar pts = state.absolutePoints;\n\t\t\t\t\t\t\t\tvar n = (source) ? 0 : pts.length - 1;\n\n\t\t\t\t\t\t\t\tgeo.setTerminalPoint(new mxPoint(\n\t\t\t\t\t\t\t\t\tpts[n].x / scale - tr.x - state.origin.x,\n\t\t\t\t\t\t\t\t\tpts[n].y / scale - tr.y - state.origin.y), source);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Fallback to center of terminal if routing\n\t\t\t\t\t\t\t\t// points are not available to add new point\n\t\t\t\t\t\t\t\t// KNOWN: Should recurse to find parent offset\n\t\t\t\t\t\t\t\t// of edge for nested groups but invisible edges\n\t\t\t\t\t\t\t\t// should be removed in removeCells step\n\t\t\t\t\t\t\t\tvar tstate = this.view.getState(terminal);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (tstate != null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tgeo.setTerminalPoint(new mxPoint(\n\t\t\t\t\t\t\t\t\t\ttstate.getCenterX() / scale - tr.x,\n\t\t\t\t\t\t\t\t\t\ttstate.getCenterY() / scale - tr.y), source);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.model.setGeometry(edge, geo);\n\t\t\t\t\t\t\tthis.model.setTerminal(edge, null, source);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tfor (var j = 0; j < edges.length; j++)\n\t\t\t\t{\n\t\t\t\t\tif (!dict.get(edges[j]))\n\t\t\t\t\t{\n\t\t\t\t\t\tdict.put(edges[j], true);\n\t\t\t\t\t\tdisconnectTerminal(edges[j], true);\n\t\t\t\t\t\tdisconnectTerminal(edges[j], false);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.model.remove(cells[i]);\n\t\t\t}\n\t\t\t\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELLS_REMOVED, 'cells', cells));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: splitEdge\n * \n * Splits the given edge by adding the newEdge between the previous source\n * and the given cell and reconnecting the source of the given edge to the\n * given cell. This method fires <mxEvent.SPLIT_EDGE> while the transaction\n * is in progress. Returns the new edge that was inserted.\n * \n * Parameters:\n * \n * edge - <mxCell> that represents the edge to be splitted.\n * cells - <mxCells> that represents the cells to insert into the edge.\n * newEdge - <mxCell> that represents the edge to be inserted.\n * dx - Optional integer that specifies the vector to move the cells.\n * dy - Optional integer that specifies the vector to move the cells.\n * x - Integer that specifies the x-coordinate of the drop location.\n * y - Integer that specifies the y-coordinate of the drop location.\n * parent - Optional parent to insert the cell. If null the parent of\n * the edge is used.\n */\nmxGraph.prototype.splitEdge = function(edge, cells, newEdge, dx, dy, x, y, parent)\n{\n\tdx = dx || 0;\n\tdy = dy || 0;\n\n\tparent = (parent != null) ? parent : this.model.getParent(edge);\n\tvar source = this.model.getTerminal(edge, true);\n\t\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tif (newEdge == null)\n\t\t{\n\t\t\tnewEdge = this.cloneCell(edge);\n\t\t\t\n\t\t\t// Removes waypoints before/after new cell\n\t\t\tvar state = this.view.getState(edge);\n\t\t\tvar geo = this.getCellGeometry(newEdge);\n\t\t\t\n\t\t\tif (geo != null && geo.points != null && state != null)\n\t\t\t{\n\t\t\t\tvar t = this.view.translate;\n\t\t\t\tvar s = this.view.scale;\n\t\t\t\tvar idx = mxUtils.findNearestSegment(state, (dx + t.x) * s, (dy + t.y) * s);\n\t\t\t\tgeo.points = geo.points.slice(0, idx);\n\t\t\t\t\t\t\t\t\n\t\t\t\tgeo = this.getCellGeometry(edge);\n\t\t\t\t\n\t\t\t\tif (geo != null && geo.points != null)\n\t\t\t\t{\n\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\tgeo.points = geo.points.slice(idx);\n\t\t\t\t\tthis.model.setGeometry(edge, geo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.cellsMoved(cells, dx, dy, false, false);\n\t\tthis.cellsAdded(cells, parent, this.model.getChildCount(parent), null, null,\n\t\t\t\ttrue);\n\t\tthis.cellsAdded([newEdge], parent, this.model.getChildCount(parent),\n\t\t\t\tsource, cells[0], false);\n\t\tthis.cellConnected(edge, cells[0], true);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.SPLIT_EDGE, 'edge', edge,\n\t\t\t\t'cells', cells, 'newEdge', newEdge, 'dx', dx, 'dy', dy));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn newEdge;\n};\n\n/**\n * Group: Cell visibility\n */\n\n/**\n * Function: toggleCells\n * \n * Sets the visible state of the specified cells and all connected edges\n * if includeEdges is true. The change is carried out using <cellsToggled>.\n * This method fires <mxEvent.TOGGLE_CELLS> while the transaction is in\n * progress. Returns the cells whose visible state was changed.\n * \n * Parameters:\n * \n * show - Boolean that specifies the visible state to be assigned.\n * cells - Array of <mxCells> whose visible state should be changed. If\n * null is specified then the selection cells are used.\n * includeEdges - Optional boolean indicating if the visible state of all\n * connected edges should be changed as well. Default is true.\n */\nmxGraph.prototype.toggleCells = function(show, cells, includeEdges)\n{\n\tif (cells == null)\n\t{\n\t\tcells = this.getSelectionCells();\n\t}\n\n\t// Adds all connected edges recursively\n\tif (includeEdges)\n\t{\n\t\tcells = this.addAllEdges(cells);\n\t}\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.cellsToggled(cells, show);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.TOGGLE_CELLS,\n\t\t\t'show', show, 'cells', cells, 'includeEdges', includeEdges));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: cellsToggled\n * \n * Sets the visible state of the specified cells.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> whose visible state should be changed.\n * show - Boolean that specifies the visible state to be assigned.\n */\nmxGraph.prototype.cellsToggled = function(cells, show)\n{\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tthis.model.setVisible(cells[i], show);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Group: Folding\n */\n\n/**\n * Function: foldCells\n * \n * Sets the collapsed state of the specified cells and all descendants\n * if recurse is true. The change is carried out using <cellsFolded>.\n * This method fires <mxEvent.FOLD_CELLS> while the transaction is in\n * progress. Returns the cells whose collapsed state was changed.\n * \n * Parameters:\n * \n * collapsed - Boolean indicating the collapsed state to be assigned.\n * recurse - Optional boolean indicating if the collapsed state of all\n * descendants should be set. Default is false.\n * cells - Array of <mxCells> whose collapsed state should be set. If\n * null is specified then the foldable selection cells are used.\n * checkFoldable - Optional boolean indicating of isCellFoldable should be\n * checked. Default is false.\n * evt - Optional native event that triggered the invocation.\n */\nmxGraph.prototype.foldCells = function(collapse, recurse, cells, checkFoldable, evt)\n{\n\trecurse = (recurse != null) ? recurse : false;\n\t\n\tif (cells == null)\n\t{\n\t\tcells = this.getFoldableCells(this.getSelectionCells(), collapse);\n\t}\n\n\tthis.stopEditing(false);\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.cellsFolded(cells, collapse, recurse, checkFoldable);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.FOLD_CELLS,\n\t\t\t'collapse', collapse, 'recurse', recurse, 'cells', cells));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: cellsFolded\n * \n * Sets the collapsed state of the specified cells. This method fires\n * <mxEvent.CELLS_FOLDED> while the transaction is in progress. Returns the\n * cells whose collapsed state was changed.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> whose collapsed state should be set.\n * collapsed - Boolean indicating the collapsed state to be assigned.\n * recurse - Boolean indicating if the collapsed state of all descendants\n * should be set.\n * checkFoldable - Optional boolean indicating of isCellFoldable should be\n * checked. Default is false.\n */\nmxGraph.prototype.cellsFolded = function(cells, collapse, recurse, checkFoldable)\n{\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tif ((!checkFoldable || this.isCellFoldable(cells[i], collapse)) &&\n\t\t\t\t\tcollapse != this.isCellCollapsed(cells[i]))\n\t\t\t\t{\n\t\t\t\t\tthis.model.setCollapsed(cells[i], collapse);\n\t\t\t\t\tthis.swapBounds(cells[i], collapse);\n\n\t\t\t\t\tif (this.isExtendParent(cells[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.extendParent(cells[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (recurse)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar children = this.model.getChildren(cells[i]);\n\t\t\t\t\t\tthis.cellsFolded(children, collapse, recurse);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.constrainChild(cells[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELLS_FOLDED,\n\t\t\t\t'cells', cells, 'collapse', collapse, 'recurse', recurse));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: swapBounds\n * \n * Swaps the alternate and the actual bounds in the geometry of the given\n * cell invoking <updateAlternateBounds> before carrying out the swap.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the bounds should be swapped.\n * willCollapse - Boolean indicating if the cell is going to be collapsed.\n */\nmxGraph.prototype.swapBounds = function(cell, willCollapse)\n{\n\tif (cell != null)\n\t{\n\t\tvar geo = this.model.getGeometry(cell);\n\t\t\n\t\tif (geo != null)\n\t\t{\n\t\t\tgeo = geo.clone();\n\t\t\t\n\t\t\tthis.updateAlternateBounds(cell, geo, willCollapse);\n\t\t\tgeo.swap();\n\t\t\t\n\t\t\tthis.model.setGeometry(cell, geo);\n\t\t}\n\t}\n};\n\n/**\n * Function: updateAlternateBounds\n * \n * Updates or sets the alternate bounds in the given geometry for the given\n * cell depending on whether the cell is going to be collapsed. If no\n * alternate bounds are defined in the geometry and\n * <collapseToPreferredSize> is true, then the preferred size is used for\n * the alternate bounds. The top, left corner is always kept at the same\n * location.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the geometry is being udpated.\n * g - <mxGeometry> for which the alternate bounds should be updated.\n * willCollapse - Boolean indicating if the cell is going to be collapsed.\n */\nmxGraph.prototype.updateAlternateBounds = function(cell, geo, willCollapse)\n{\n\tif (cell != null && geo != null)\n\t{\n\t\tvar style = this.getCurrentCellStyle(cell);\n\n\t\tif (geo.alternateBounds == null)\n\t\t{\n\t\t\tvar bounds = geo;\n\t\t\t\n\t\t\tif (this.collapseToPreferredSize)\n\t\t\t{\n\t\t\t\tvar tmp = this.getPreferredSizeForCell(cell);\n\t\t\t\t\n\t\t\t\tif (tmp != null)\n\t\t\t\t{\n\t\t\t\t\tbounds = tmp;\n\n\t\t\t\t\tvar startSize = mxUtils.getValue(style, mxConstants.STYLE_STARTSIZE);\n\n\t\t\t\t\tif (startSize > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbounds.height = Math.max(bounds.height, startSize);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tgeo.alternateBounds = new mxRectangle(0, 0, bounds.width, bounds.height);\n\t\t}\n\t\t\n\t\tif (geo.alternateBounds != null)\n\t\t{\n\t\t\tgeo.alternateBounds.x = geo.x;\n\t\t\tgeo.alternateBounds.y = geo.y;\n\t\t\t\n\t\t\tvar alpha = mxUtils.toRadians(style[mxConstants.STYLE_ROTATION] || 0);\n\t\t\t\n\t\t\tif (alpha != 0)\n\t\t\t{\n\t\t\t\tvar dx = geo.alternateBounds.getCenterX() - geo.getCenterX();\n\t\t\t\tvar dy = geo.alternateBounds.getCenterY() - geo.getCenterY();\n\t\n\t\t\t\tvar cos = Math.cos(alpha);\n\t\t\t\tvar sin = Math.sin(alpha);\n\t\n\t\t\t\tvar dx2 = cos * dx - sin * dy;\n\t\t\t\tvar dy2 = sin * dx + cos * dy;\n\t\t\t\t\n\t\t\t\tgeo.alternateBounds.x += dx2 - dx;\n\t\t\t\tgeo.alternateBounds.y += dy2 - dy;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: addAllEdges\n * \n * Returns an array with the given cells and all edges that are connected\n * to a cell or one of its descendants.\n */\nmxGraph.prototype.addAllEdges = function(cells)\n{\n\tvar allCells = cells.slice();\n\t\n\treturn mxUtils.removeDuplicates(allCells.concat(this.getAllEdges(cells)));\n};\n\n/**\n * Function: getAllEdges\n * \n * Returns all edges connected to the given cells or its descendants.\n */\nmxGraph.prototype.getAllEdges = function(cells)\n{\n\tvar edges = [];\n\t\n\tif (cells != null)\n\t{\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tvar edgeCount = this.model.getEdgeCount(cells[i]);\n\t\t\t\n\t\t\tfor (var j = 0; j < edgeCount; j++)\n\t\t\t{\n\t\t\t\tedges.push(this.model.getEdgeAt(cells[i], j));\n\t\t\t}\n\n\t\t\t// Recurses\n\t\t\tvar children = this.model.getChildren(cells[i]);\n\t\t\tedges = edges.concat(this.getAllEdges(children));\n\t\t}\n\t}\n\t\n\treturn edges;\n};\n\n/**\n * Group: Cell sizing\n */\n\n/**\n * Function: updateCellSize\n * \n * Updates the size of the given cell in the model using <cellSizeUpdated>.\n * This method fires <mxEvent.UPDATE_CELL_SIZE> while the transaction is in\n * progress. Returns the cell whose size was updated.\n * \n * Parameters:\n * \n * cell - <mxCell> whose size should be updated.\n */\nmxGraph.prototype.updateCellSize = function(cell, ignoreChildren)\n{\n\tignoreChildren = (ignoreChildren != null) ? ignoreChildren : false;\n\t\n\tthis.model.beginUpdate();\t\t\t\t\n\ttry\n\t{\n\t\tthis.cellSizeUpdated(cell, ignoreChildren);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.UPDATE_CELL_SIZE,\n\t\t\t\t'cell', cell, 'ignoreChildren', ignoreChildren));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\t\n\treturn cell;\n};\n\n/**\n * Function: cellSizeUpdated\n * \n * Updates the size of the given cell in the model using\n * <getPreferredSizeForCell> to get the new size.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the size should be changed.\n */\nmxGraph.prototype.cellSizeUpdated = function(cell, ignoreChildren)\n{\n\tif (cell != null)\n\t{\n\t\tthis.model.beginUpdate();\t\t\t\t\n\t\ttry\n\t\t{\n\t\t\tvar size = this.getPreferredSizeForCell(cell);\n\t\t\tvar geo = this.model.getGeometry(cell);\n\t\t\t\n\t\t\tif (size != null && geo != null)\n\t\t\t{\n\t\t\t\tvar collapsed = this.isCellCollapsed(cell);\n\t\t\t\tgeo = geo.clone();\n\n\t\t\t\tif (this.isSwimlane(cell))\n\t\t\t\t{\n\t\t\t\t\tvar style = this.getCellStyle(cell);\n\t\t\t\t\tvar cellStyle = this.model.getStyle(cell);\n\n\t\t\t\t\tif (cellStyle == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tcellStyle = '';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true))\n\t\t\t\t\t{\n\t\t\t\t\t\tcellStyle = mxUtils.setStyle(cellStyle,\n\t\t\t\t\t\t\t\tmxConstants.STYLE_STARTSIZE, size.height + 8);\n\n\t\t\t\t\t\tif (collapsed)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.height = size.height + 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeo.width = size.width;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcellStyle = mxUtils.setStyle(cellStyle,\n\t\t\t\t\t\t\t\tmxConstants.STYLE_STARTSIZE, size.width + 8);\n\n\t\t\t\t\t\tif (collapsed)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.width = size.width + 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeo.height = size.height;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.model.setStyle(cell, cellStyle);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar state = this.view.createState(cell);\n\t\t\t\t\tvar align = (state.style[mxConstants.STYLE_ALIGN] || mxConstants.ALIGN_CENTER);\n\t\t\t\t\t\n\t\t\t\t\tif (align == mxConstants.ALIGN_RIGHT)\n\t\t\t\t\t{\n\t\t\t\t\t\tgeo.x += geo.width - size.width;\n\t\t\t\t\t}\n\t\t\t\t\telse if (align == mxConstants.ALIGN_CENTER)\n\t\t\t\t\t{\n\t\t\t\t\t\tgeo.x += Math.round((geo.width - size.width) / 2);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar valign = this.getVerticalAlign(state);\n\t\t\t\t\t\n\t\t\t\t\tif (valign == mxConstants.ALIGN_BOTTOM)\n\t\t\t\t\t{\n\t\t\t\t\t\tgeo.y += geo.height - size.height;\n\t\t\t\t\t}\n\t\t\t\t\telse if (valign == mxConstants.ALIGN_MIDDLE)\n\t\t\t\t\t{\n\t\t\t\t\t\tgeo.y += Math.round((geo.height - size.height) / 2);\n\t\t\t\t\t}\n\n\t\t\t\t\tgeo.width = size.width;\n\t\t\t\t\tgeo.height = size.height;\n\t\t\t\t}\n\n\t\t\t\tif (!ignoreChildren && !collapsed)\n\t\t\t\t{\n\t\t\t\t\tvar bounds = this.view.getBounds(this.model.getChildren(cell));\n\n\t\t\t\t\tif (bounds != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar tr = this.view.translate;\n\t\t\t\t\t\tvar scale = this.view.scale;\n\n\t\t\t\t\t\tvar width = (bounds.x + bounds.width) / scale - geo.x - tr.x;\n\t\t\t\t\t\tvar height = (bounds.y + bounds.height) / scale - geo.y - tr.y;\n\n\t\t\t\t\t\tgeo.width = Math.max(geo.width, width);\n\t\t\t\t\t\tgeo.height = Math.max(geo.height, height);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.cellsResized([cell], [geo], false);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: getPreferredSizeForCell\n * \n * Returns the preferred width and height of the given <mxCell> as an\n * <mxRectangle>. To implement a minimum width, add a new style eg.\n * minWidth in the vertex and override this method as follows.\n * \n * (code)\n * var graphGetPreferredSizeForCell = graph.getPreferredSizeForCell;\n * graph.getPreferredSizeForCell = function(cell)\n * {\n *   var result = graphGetPreferredSizeForCell.apply(this, arguments);\n *   var style = this.getCellStyle(cell);\n *   \n *   if (style['minWidth'] > 0)\n *   {\n *     result.width = Math.max(style['minWidth'], result.width);\n *   }\n * \n *   return result;\n * };\n * (end)\n * \n * Parameters:\n * \n * cell - <mxCell> for which the preferred size should be returned.\n * textWidth - Optional maximum text width for word wrapping.\n */\nmxGraph.prototype.getPreferredSizeForCell = function(cell, textWidth)\n{\n\tvar result = null;\n\t\n\tif (cell != null)\n\t{\n\t\tvar state = this.view.createState(cell);\n\t\tvar style = state.style;\n\n\t\tif (!this.model.isEdge(cell))\n\t\t{\n\t\t\tvar fontSize = style[mxConstants.STYLE_FONTSIZE] || mxConstants.DEFAULT_FONTSIZE;\n\t\t\tvar dx = 0;\n\t\t\tvar dy = 0;\n\t\t\t\n\t\t\t// Adds dimension of image if shape is a label\n\t\t\tif (this.getImage(state) != null || style[mxConstants.STYLE_IMAGE] != null)\n\t\t\t{\n\t\t\t\tif (style[mxConstants.STYLE_SHAPE] == mxConstants.SHAPE_LABEL)\n\t\t\t\t{\n\t\t\t\t\tif (style[mxConstants.STYLE_VERTICAL_ALIGN] == mxConstants.ALIGN_MIDDLE)\n\t\t\t\t\t{\n\t\t\t\t\t\tdx += parseFloat(style[mxConstants.STYLE_IMAGE_WIDTH]) || mxLabel.prototype.imageSize;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (style[mxConstants.STYLE_ALIGN] != mxConstants.ALIGN_CENTER)\n\t\t\t\t\t{\n\t\t\t\t\t\tdy += parseFloat(style[mxConstants.STYLE_IMAGE_HEIGHT]) || mxLabel.prototype.imageSize;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Adds spacings\n\t\t\tdx += 2 * (style[mxConstants.STYLE_SPACING] || 0);\n\t\t\tdx += style[mxConstants.STYLE_SPACING_LEFT] || 0;\n\t\t\tdx += style[mxConstants.STYLE_SPACING_RIGHT] || 0;\n\n\t\t\tdy += 2 * (style[mxConstants.STYLE_SPACING] || 0);\n\t\t\tdy += style[mxConstants.STYLE_SPACING_TOP] || 0;\n\t\t\tdy += style[mxConstants.STYLE_SPACING_BOTTOM] || 0;\n\t\t\t\n\t\t\t// Add spacing for collapse/expand icon\n\t\t\t// LATER: Check alignment and use constants\n\t\t\t// for image spacing\n\t\t\tvar image = this.getFoldingImage(state);\n\t\t\t\n\t\t\tif (image != null)\n\t\t\t{\n\t\t\t\tdx += image.width + 8;\n\t\t\t}\n\n\t\t\t// Adds space for label\n\t\t\tvar value = this.cellRenderer.getLabelValue(state);\n\n\t\t\tif (value != null && value.length > 0)\n\t\t\t{\n\t\t\t\tif (!this.isHtmlLabel(state.cell))\n\t\t\t\t{\n\t\t\t\t\tvalue = mxUtils.htmlEntities(value, false);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvalue = value.replace(/\\n/g, '<br>');\n\t\t\t\t\n\t\t\t\tvar size = mxUtils.getSizeForString(value, fontSize,\n\t\t\t\t\tstyle[mxConstants.STYLE_FONTFAMILY], textWidth,\n\t\t\t\t\tstyle[mxConstants.STYLE_FONTSTYLE]);\n\t\t\t\tvar width = size.width + dx;\n\t\t\t\tvar height = size.height + dy;\n\t\t\t\t\n\t\t\t\tif (!mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true))\n\t\t\t\t{\n\t\t\t\t\tvar tmp = height;\n\t\t\t\t\t\n\t\t\t\t\theight = width;\n\t\t\t\t\twidth = tmp;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tif (this.gridEnabled)\n\t\t\t\t{\n\t\t\t\t\twidth = this.snap(width + this.gridSize / 2);\n\t\t\t\t\theight = this.snap(height + this.gridSize / 2);\n\t\t\t\t}\n\n\t\t\t\tresult = new mxRectangle(0, 0, width, height);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar gs2 = 4 * this.gridSize;\n\t\t\t\tresult = new mxRectangle(0, 0, gs2, gs2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: resizeCell\n * \n * Sets the bounds of the given cell using <resizeCells>. Returns the\n * cell which was passed to the function.\n * \n * Parameters:\n * \n * cell - <mxCell> whose bounds should be changed.\n * bounds - <mxRectangle> that represents the new bounds.\n */\nmxGraph.prototype.resizeCell = function(cell, bounds, recurse)\n{\n\treturn this.resizeCells([cell], [bounds], recurse)[0];\n};\n\n/**\n * Function: resizeCells\n * \n * Sets the bounds of the given cells and fires a <mxEvent.RESIZE_CELLS>\n * event while the transaction is in progress. Returns the cells which\n * have been passed to the function.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> whose bounds should be changed.\n * bounds - Array of <mxRectangles> that represent the new bounds.\n */\nmxGraph.prototype.resizeCells = function(cells, bounds, recurse)\n{\n\trecurse = (recurse != null) ? recurse : this.isRecursiveResize();\n\t\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tvar prev = this.cellsResized(cells, bounds, recurse);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.RESIZE_CELLS,\n\t\t\t'cells', cells, 'bounds', bounds, 'previous', prev));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: cellsResized\n * \n * Sets the bounds of the given cells and fires a <mxEvent.CELLS_RESIZED>\n * event. If <extendParents> is true, then the parent is extended if a\n * child size is changed so that it overlaps with the parent.\n * \n * The following example shows how to control group resizes to make sure\n * that all child cells stay within the group.\n * \n * (code)\n * graph.addListener(mxEvent.CELLS_RESIZED, function(sender, evt)\n * {\n *   var cells = evt.getProperty('cells');\n *   \n *   if (cells != null)\n *   {\n *     for (var i = 0; i < cells.length; i++)\n *     {\n *       if (graph.getModel().getChildCount(cells[i]) > 0)\n *       {\n *         var geo = graph.getCellGeometry(cells[i]);\n *         \n *         if (geo != null)\n *         {\n *           var children = graph.getChildCells(cells[i], true, true);\n *           var bounds = graph.getBoundingBoxFromGeometry(children, true);\n *           \n *           geo = geo.clone();\n *           geo.width = Math.max(geo.width, bounds.width);\n *           geo.height = Math.max(geo.height, bounds.height);\n *           \n *           graph.getModel().setGeometry(cells[i], geo);\n *         }\n *       }\n *     }\n *   }\n * });\n * (end)\n * \n * Parameters:\n * \n * cells - Array of <mxCells> whose bounds should be changed.\n * bounds - Array of <mxRectangles> that represent the new bounds.\n * recurse - Optional boolean that specifies if the children should be resized.\n */\nmxGraph.prototype.cellsResized = function(cells, bounds, recurse)\n{\n\trecurse = (recurse != null) ? recurse : false;\n\tvar prev = [];\n\n\tif (cells != null && bounds != null && cells.length == bounds.length)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tprev.push(this.cellResized(cells[i], bounds[i], false, recurse));\n\n\t\t\t\tif (this.isExtendParent(cells[i]))\n\t\t\t\t{\n\t\t\t\t\tthis.extendParent(cells[i]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.constrainChild(cells[i]);\n\t\t\t}\n\n\t\t\tif (this.resetEdgesOnResize)\n\t\t\t{\n\t\t\t\tthis.resetEdges(cells);\n\t\t\t}\n\t\t\t\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELLS_RESIZED,\n\t\t\t\t'cells', cells, 'bounds', bounds, 'previous', prev));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n\t\n\treturn prev;\n};\n\n/**\n * Function: cellResized\n * \n * Resizes the parents recursively so that they contain the complete area\n * of the resized child cell.\n * \n * Parameters:\n * \n * cell - <mxCell> whose bounds should be changed.\n * bounds - <mxRectangles> that represent the new bounds.\n * ignoreRelative - Boolean that indicates if relative cells should be ignored.\n * recurse - Optional boolean that specifies if the children should be resized.\n */\nmxGraph.prototype.cellResized = function(cell, bounds, ignoreRelative, recurse)\n{\n\tvar prev = this.model.getGeometry(cell);\n\n\tif (prev != null && (prev.x != bounds.x || prev.y != bounds.y ||\n\t\tprev.width != bounds.width || prev.height != bounds.height))\n\t{\n\t\tvar geo = prev.clone();\n\n\t\tif (!ignoreRelative && geo.relative)\n\t\t{\n\t\t\tvar offset = geo.offset;\n\n\t\t\tif (offset != null)\n\t\t\t{\n\t\t\t\toffset.x += bounds.x - geo.x;\n\t\t\t\toffset.y += bounds.y - geo.y;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgeo.x = bounds.x;\n\t\t\tgeo.y = bounds.y;\n\t\t}\n\n\t\tgeo.width = bounds.width;\n\t\tgeo.height = bounds.height;\n\n\t\tif (!geo.relative && this.model.isVertex(cell) && !this.isAllowNegativeCoordinates())\n\t\t{\n\t\t\tgeo.x = Math.max(0, geo.x);\n\t\t\tgeo.y = Math.max(0, geo.y);\n\t\t}\n\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tif (recurse)\n\t\t\t{\n\t\t\t\tthis.resizeChildCells(cell, geo);\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\tthis.model.setGeometry(cell, geo);\n\t\t\tthis.constrainChildCells(cell);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n\t\n\treturn prev;\n};\n\n/**\n * Function: resizeChildCells\n * \n * Resizes the child cells of the given cell for the given new geometry with\n * respect to the current geometry of the cell.\n * \n * Parameters:\n * \n * cell - <mxCell> that has been resized.\n * newGeo - <mxGeometry> that represents the new bounds.\n */\nmxGraph.prototype.resizeChildCells = function(cell, newGeo)\n{\n\tvar geo = this.model.getGeometry(cell);\n\tvar dx = (geo.width != 0) ? newGeo.width / geo.width : 1;\n\tvar dy = (geo.height != 0) ? newGeo.height / geo.height : 1;\n\tvar childCount = this.model.getChildCount(cell);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tthis.scaleCell(this.model.getChildAt(cell, i), dx, dy, true);\n\t}\n};\n\n/**\n * Function: constrainChildCells\n * \n * Constrains the children of the given cell using <constrainChild>.\n * \n * Parameters:\n * \n * cell - <mxCell> that has been resized.\n */\nmxGraph.prototype.constrainChildCells = function(cell)\n{\n\tvar childCount = this.model.getChildCount(cell);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tthis.constrainChild(this.model.getChildAt(cell, i));\n\t}\n};\n\n/**\n * Function: scaleCell\n * \n * Scales the points, position and size of the given cell according to the\n * given vertical and horizontal scaling factors.\n * \n * Parameters:\n * \n * cell - <mxCell> whose geometry should be scaled.\n * dx - Horizontal scaling factor.\n * dy - Vertical scaling factor.\n * recurse - Boolean indicating if the child cells should be scaled.\n */\nmxGraph.prototype.scaleCell = function(cell, dx, dy, recurse)\n{\n\tvar geo = this.model.getGeometry(cell);\n\t\n\tif (geo != null)\n\t{\n\t\tvar style = this.getCurrentCellStyle(cell);\n\t\tgeo = geo.clone();\n\t\t\n\t\t// Stores values for restoring based on style\n\t\tvar x = geo.x;\n\t\tvar y = geo.y\n\t\tvar w = geo.width;\n\t\tvar h = geo.height;\n\t\t\n\t\tgeo.scale(dx, dy, style[mxConstants.STYLE_ASPECT] == 'fixed');\n\t\t\n\t\tif (style[mxConstants.STYLE_RESIZE_WIDTH] == '1')\n\t\t{\n\t\t\tgeo.width = w * dx;\n\t\t}\n\t\telse if (style[mxConstants.STYLE_RESIZE_WIDTH] == '0')\n\t\t{\n\t\t\tgeo.width = w;\n\t\t}\n\t\t\n\t\tif (style[mxConstants.STYLE_RESIZE_HEIGHT] == '1')\n\t\t{\n\t\t\tgeo.height = h * dy;\n\t\t}\n\t\telse if (style[mxConstants.STYLE_RESIZE_HEIGHT] == '0')\n\t\t{\n\t\t\tgeo.height = h;\n\t\t}\n\t\t\n\t\tif (!this.isCellMovable(cell))\n\t\t{\n\t\t\tgeo.x = x;\n\t\t\tgeo.y = y;\n\t\t}\n\t\t\n\t\tif (!this.isCellResizable(cell))\n\t\t{\n\t\t\tgeo.width = w;\n\t\t\tgeo.height = h;\n\t\t}\n\n\t\tif (this.model.isVertex(cell))\n\t\t{\n\t\t\tthis.cellResized(cell, geo, true, recurse);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.model.setGeometry(cell, geo);\n\t\t}\n\t}\n};\n\n/**\n * Function: extendParent\n * \n * Resizes the parents recursively so that they contain the complete area\n * of the resized child cell.\n * \n * Parameters:\n * \n * cell - <mxCell> that has been resized.\n */\nmxGraph.prototype.extendParent = function(cell)\n{\n\tif (cell != null)\n\t{\n\t\tvar parent = this.model.getParent(cell);\n\t\tvar p = this.getCellGeometry(parent);\n\t\t\n\t\tif (parent != null && p != null && !this.isCellCollapsed(parent))\n\t\t{\n\t\t\tvar geo = this.getCellGeometry(cell);\n\t\t\t\n\t\t\tif (geo != null && !geo.relative &&\n\t\t\t\t(p.width < geo.x + geo.width ||\n\t\t\t\tp.height < geo.y + geo.height))\n\t\t\t{\n\t\t\t\tp = p.clone();\n\t\t\t\t\n\t\t\t\tp.width = Math.max(p.width, geo.x + geo.width);\n\t\t\t\tp.height = Math.max(p.height, geo.y + geo.height);\n\t\t\t\t\n\t\t\t\tthis.cellsResized([parent], [p], false);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Group: Cell moving\n */\n\n/**\n * Function: importCells\n * \n * Clones and inserts the given cells into the graph using the move\n * method and returns the inserted cells. This shortcut is used if\n * cells are inserted via datatransfer.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be imported.\n * dx - Integer that specifies the x-coordinate of the vector. Default is 0.\n * dy - Integer that specifies the y-coordinate of the vector. Default is 0.\n * target - <mxCell> that represents the new parent of the cells.\n * evt - Mouseevent that triggered the invocation.\n * mapping - Optional mapping for existing clones.\n */\nmxGraph.prototype.importCells = function(cells, dx, dy, target, evt, mapping)\n{\t\n\treturn this.moveCells(cells, dx, dy, true, target, evt, mapping);\n};\n\n/**\n * Function: moveCells\n * \n * Moves or clones the specified cells and moves the cells or clones by the\n * given amount, adding them to the optional target cell. The evt is the\n * mouse event as the mouse was released. The change is carried out using\n * <cellsMoved>. This method fires <mxEvent.MOVE_CELLS> while the\n * transaction is in progress. Returns the cells that were moved.\n * \n * Use the following code to move all cells in the graph.\n * \n * (code)\n * graph.moveCells(graph.getChildCells(null, true, true), 10, 10);\n * (end)\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be moved, cloned or added to the target.\n * dx - Integer that specifies the x-coordinate of the vector. Default is 0.\n * dy - Integer that specifies the y-coordinate of the vector. Default is 0.\n * clone - Boolean indicating if the cells should be cloned. Default is false.\n * target - <mxCell> that represents the new parent of the cells.\n * evt - Mouseevent that triggered the invocation.\n * mapping - Optional mapping for existing clones.\n */\nmxGraph.prototype.moveCells = function(cells, dx, dy, clone, target, evt, mapping)\n{\n\tdx = (dx != null) ? dx : 0;\n\tdy = (dy != null) ? dy : 0;\n\tclone = (clone != null) ? clone : false;\n\t\n\tif (cells != null && (dx != 0 || dy != 0 || clone || target != null))\n\t{\n\t\t// Removes descendants with ancestors in cells to avoid multiple moving\n\t\tcells = this.model.getTopmostCells(cells);\n\t\tvar origCells = cells;\n\t\t\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\t// Faster cell lookups to remove relative edge labels with selected\n\t\t\t// terminals to avoid explicit and implicit move at same time\n\t\t\tvar dict = new mxDictionary();\n\t\t\t\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tdict.put(cells[i], true);\n\t\t\t}\n\t\t\t\n\t\t\tvar isSelected = mxUtils.bind(this, function(cell)\n\t\t\t{\n\t\t\t\twhile (cell != null)\n\t\t\t\t{\n\t\t\t\t\tif (dict.get(cell))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcell = this.model.getParent(cell);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn false;\n\t\t\t});\n\t\t\t\n\t\t\t// Removes relative edge labels with selected terminals\n\t\t\tvar checked = [];\n\t\t\t\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tvar geo = this.getCellGeometry(cells[i]);\n\t\t\t\tvar parent = this.model.getParent(cells[i]);\n\t\t\n\t\t\t\tif ((geo == null || !geo.relative) || !this.model.isEdge(parent) ||\n\t\t\t\t\t(!isSelected(this.model.getTerminal(parent, true)) &&\n\t\t\t\t\t!isSelected(this.model.getTerminal(parent, false))))\n\t\t\t\t{\n\t\t\t\t\tchecked.push(cells[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcells = checked;\n\t\t\t\n\t\t\tif (clone)\n\t\t\t{\n\t\t\t\tcells = this.cloneCells(cells, this.isCloneInvalidEdges(), mapping);\n\n\t\t\t\tif (target == null)\n\t\t\t\t{\n\t\t\t\t\ttarget = this.getDefaultParent();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// FIXME: Cells should always be inserted first before any other edit\n\t\t\t// to avoid forward references in sessions.\n\t\t\t// Need to disable allowNegativeCoordinates if target not null to\n\t\t\t// allow for temporary negative numbers until cellsAdded is called.\n\t\t\tvar previous = this.isAllowNegativeCoordinates();\n\t\t\t\n\t\t\tif (target != null)\n\t\t\t{\n\t\t\t\tthis.setAllowNegativeCoordinates(true);\n\t\t\t}\n\t\t\t\n\t\t\tthis.cellsMoved(cells, dx, dy, !clone && this.isDisconnectOnMove()\n\t\t\t\t\t&& this.isAllowDanglingEdges(), target == null,\n\t\t\t\t\tthis.isExtendParentsOnMove() && target == null);\n\t\t\t\n\t\t\tthis.setAllowNegativeCoordinates(previous);\n\n\t\t\tif (target != null)\n\t\t\t{\n\t\t\t\tvar index = this.model.getChildCount(target);\n\t\t\t\tthis.cellsAdded(cells, target, index, null, null, true);\n\t\t\t\t\n\t\t\t\t// Restores parent edge on cloned edge labels\n\t\t\t\tif (clone)\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar geo = this.getCellGeometry(cells[i]);\n\t\t\t\t\t\tvar parent = this.model.getParent(origCells[i]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (geo != null && geo.relative &&\n\t\t\t\t\t\t\tthis.model.isEdge(parent) &&\n\t\t\t\t\t\t\tthis.model.contains(parent))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.model.add(parent, cells[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Dispatches a move event\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.MOVE_CELLS, 'cells', cells,\n\t\t\t\t'dx', dx, 'dy', dy, 'clone', clone, 'target', target, 'event', evt));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: cellsMoved\n * \n * Moves the specified cells by the given vector, disconnecting the cells\n * using disconnectGraph is disconnect is true. This method fires\n * <mxEvent.CELLS_MOVED> while the transaction is in progress.\n */\nmxGraph.prototype.cellsMoved = function(cells, dx, dy, disconnect, constrain, extend)\n{\n\tif (cells != null && (dx != 0 || dy != 0))\n\t{\n\t\textend = (extend != null) ? extend : false;\n\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tif (disconnect)\n\t\t\t{\n\t\t\t\tthis.disconnectGraph(cells);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tthis.translateCell(cells[i], dx, dy);\n\t\t\t\t\n\t\t\t\tif (extend && this.isExtendParent(cells[i]))\n\t\t\t\t{\n\t\t\t\t\tthis.extendParent(cells[i]);\n\t\t\t\t}\n\t\t\t\telse if (constrain)\n\t\t\t\t{\n\t\t\t\t\tthis.constrainChild(cells[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.resetEdgesOnMove)\n\t\t\t{\n\t\t\t\tthis.resetEdges(cells);\n\t\t\t}\n\t\t\t\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELLS_MOVED,\n\t\t\t\t'cells', cells, 'dx', dx, 'dy', dy, 'disconnect', disconnect));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: translateCell\n * \n * Translates the geometry of the given cell and stores the new,\n * translated geometry in the model as an atomic change.\n */\nmxGraph.prototype.translateCell = function(cell, dx, dy)\n{\n\tvar geo = this.model.getGeometry(cell);\n\n\tif (geo != null)\n\t{\n\t\tdx = parseFloat(dx);\n\t\tdy = parseFloat(dy);\n\t\tgeo = geo.clone();\n\t\tgeo.translate(dx, dy);\n\n\t\tif (!geo.relative && this.model.isVertex(cell) && !this.isAllowNegativeCoordinates())\n\t\t{\n\t\t\tgeo.x = Math.max(0, parseFloat(geo.x));\n\t\t\tgeo.y = Math.max(0, parseFloat(geo.y));\n\t\t}\n\t\t\n\t\tif (geo.relative && !this.model.isEdge(cell))\n\t\t{\n\t\t\tvar parent = this.model.getParent(cell);\n\t\t\tvar angle = 0;\n\t\t\t\n\t\t\tif (this.model.isVertex(parent))\n\t\t\t{\n\t\t\t\tvar style = this.getCurrentCellStyle(parent);\n\t\t\t\tangle = mxUtils.getValue(style, mxConstants.STYLE_ROTATION, 0);\n\t\t\t}\n\t\t\t\n\t\t\tif (angle != 0)\n\t\t\t{\n\t\t\t\tvar rad = mxUtils.toRadians(-angle);\n\t\t\t\tvar cos = Math.cos(rad);\n\t\t\t\tvar sin = Math.sin(rad);\n\t\t\t\tvar pt = mxUtils.getRotatedPoint(new mxPoint(dx, dy), cos, sin, new mxPoint(0, 0));\n\t\t\t\tdx = pt.x;\n\t\t\t\tdy = pt.y;\n\t\t\t}\n\t\t\t\n\t\t\tif (geo.offset == null)\n\t\t\t{\n\t\t\t\tgeo.offset = new mxPoint(dx, dy);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgeo.offset.x = parseFloat(geo.offset.x) + dx;\n\t\t\t\tgeo.offset.y = parseFloat(geo.offset.y) + dy;\n\t\t\t}\n\t\t}\n\n\t\tthis.model.setGeometry(cell, geo);\n\t}\n};\n\n/**\n * Function: getCellContainmentArea\n * \n * Returns the <mxRectangle> inside which a cell is to be kept.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the area should be returned.\n */\nmxGraph.prototype.getCellContainmentArea = function(cell)\n{\n\tif (cell != null && !this.model.isEdge(cell))\n\t{\n\t\tvar parent = this.model.getParent(cell);\n\t\t\n\t\tif (parent != null && parent != this.getDefaultParent())\n\t\t{\n\t\t\tvar g = this.model.getGeometry(parent);\n\t\t\t\n\t\t\tif (g != null)\n\t\t\t{\n\t\t\t\tvar x = 0;\n\t\t\t\tvar y = 0;\n\t\t\t\tvar w = g.width;\n\t\t\t\tvar h = g.height;\n\t\t\t\t\n\t\t\t\tif (this.isSwimlane(parent))\n\t\t\t\t{\n\t\t\t\t\tvar size = this.getStartSize(parent);\n\t\t\t\t\tvar style = this.getCurrentCellStyle(parent);\n\t\t\t\t\tvar dir = mxUtils.getValue(style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);\n\t\t\t\t\tvar flipH = mxUtils.getValue(style, mxConstants.STYLE_FLIPH, 0) == 1;\n\t\t\t\t\tvar flipV = mxUtils.getValue(style, mxConstants.STYLE_FLIPV, 0) == 1;\n\t\t\t\t\t\n\t\t\t\t\tif (dir == mxConstants.DIRECTION_SOUTH || dir == mxConstants.DIRECTION_NORTH)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar tmp = size.width;\n\t\t\t\t\t\tsize.width = size.height;\n\t\t\t\t\t\tsize.height = tmp;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((dir == mxConstants.DIRECTION_EAST && !flipV) || (dir == mxConstants.DIRECTION_NORTH && !flipH) ||\n\t\t\t\t\t\t(dir == mxConstants.DIRECTION_WEST && flipV) || (dir == mxConstants.DIRECTION_SOUTH && flipH))\n\t\t\t\t\t{\n\t\t\t\t\t\tx = size.width;\n\t\t\t\t\t\ty = size.height;\n\t\t\t\t\t}\n\n\t\t\t\t\tw -= size.width;\n\t\t\t\t\th -= size.height;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn new mxRectangle(x, y, w, h);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: getMaximumGraphBounds\n * \n * Returns the bounds inside which the diagram should be kept as an\n * <mxRectangle>.\n */\nmxGraph.prototype.getMaximumGraphBounds = function()\n{\n\treturn this.maximumGraphBounds;\n};\n\n/**\n * Function: constrainChild\n * \n * Keeps the given cell inside the bounds returned by\n * <getCellContainmentArea> for its parent, according to the rules defined by\n * <getOverlap> and <isConstrainChild>. This modifies the cell's geometry\n * in-place and does not clone it.\n * \n * Parameters:\n * \n * cells - <mxCell> which should be constrained.\n * sizeFirst - Specifies if the size should be changed first. Default is true.\n */\nmxGraph.prototype.constrainChild = function(cell, sizeFirst)\n{\n\tsizeFirst = (sizeFirst != null) ? sizeFirst : true;\n\t\n\tif (cell != null)\n\t{\n\t\tvar geo = this.getCellGeometry(cell);\n\t\t\n\t\tif (geo != null && (this.isConstrainRelativeChildren() || !geo.relative))\n\t\t{\n\t\t\tvar parent = this.model.getParent(cell);\n\t\t\tvar pgeo = this.getCellGeometry(parent);\n\t\t\tvar max = this.getMaximumGraphBounds();\n\t\t\t\n\t\t\t// Finds parent offset\n\t\t\tif (max != null)\n\t\t\t{\n\t\t\t\tvar off = this.getBoundingBoxFromGeometry([parent], false);\n\t\t\t\t\n\t\t\t\tif (off != null)\n\t\t\t\t{\n\t\t\t\t\tmax = mxRectangle.fromRectangle(max);\n\t\t\t\t\t\n\t\t\t\t\tmax.x -= off.x;\n\t\t\t\t\tmax.y -= off.y;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (this.isConstrainChild(cell))\n\t\t\t{\n\t\t\t\tvar tmp = this.getCellContainmentArea(cell);\n\t\t\t\t\n\t\t\t\tif (tmp != null)\n\t\t\t\t{\n\t\t\t\t\tvar overlap = this.getOverlap(cell);\n\t\n\t\t\t\t\tif (overlap > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp = mxRectangle.fromRectangle(tmp);\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmp.x -= tmp.width * overlap;\n\t\t\t\t\t\ttmp.y -= tmp.height * overlap;\n\t\t\t\t\t\ttmp.width += 2 * tmp.width * overlap;\n\t\t\t\t\t\ttmp.height += 2 * tmp.height * overlap;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Find the intersection between max and tmp\n\t\t\t\t\tif (max == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tmax = tmp;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmax = mxRectangle.fromRectangle(max);\n\t\t\t\t\t\tmax.intersect(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (max != null)\n\t\t\t{\n\t\t\t\tvar cells = [cell];\n\t\t\t\t\n\t\t\t\tif (!this.isCellCollapsed(cell))\n\t\t\t\t{\n\t\t\t\t\tvar desc = this.model.getDescendants(cell);\n\t\t\t\t\t\n\t\t\t\t\tfor (var i = 0; i < desc.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.isCellVisible(desc[i]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcells.push(desc[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar bbox = this.getBoundingBoxFromGeometry(cells, false);\n\t\t\t\t\n\t\t\t\tif (bbox != null)\n\t\t\t\t{\n\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\n\t\t\t\t\t// Cumulative horizontal movement\n\t\t\t\t\tvar dx = 0;\n\t\t\t\t\t\n\t\t\t\t\tif (geo.width > max.width)\n\t\t\t\t\t{\n\t\t\t\t\t\tdx = geo.width - max.width;\n\t\t\t\t\t\tgeo.width -= dx;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (bbox.x + bbox.width > max.x + max.width)\n\t\t\t\t\t{\n\t\t\t\t\t\tdx -= bbox.x + bbox.width - max.x - max.width - dx;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Cumulative vertical movement\n\t\t\t\t\tvar dy = 0;\n\t\t\t\t\t\n\t\t\t\t\tif (geo.height > max.height)\n\t\t\t\t\t{\n\t\t\t\t\t\tdy = geo.height - max.height;\n\t\t\t\t\t\tgeo.height -= dy;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (bbox.y + bbox.height > max.y + max.height)\n\t\t\t\t\t{\n\t\t\t\t\t\tdy -= bbox.y + bbox.height - max.y - max.height - dy;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (bbox.x < max.x)\n\t\t\t\t\t{\n\t\t\t\t\t\tdx -= bbox.x - max.x;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (bbox.y < max.y)\n\t\t\t\t\t{\n\t\t\t\t\t\tdy -= bbox.y - max.y;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (dx != 0 || dy != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (geo.relative)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Relative geometries are moved via absolute offset\n\t\t\t\t\t\t\tif (geo.offset == null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.offset = new mxPoint();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tgeo.offset.x += dx;\n\t\t\t\t\t\t\tgeo.offset.y += dy;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.x += dx;\n\t\t\t\t\t\t\tgeo.y += dy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.model.setGeometry(cell, geo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: resetEdges\n * \n * Resets the control points of the edges that are connected to the given\n * cells if not both ends of the edge are in the given cells array.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> for which the connected edges should be\n * reset.\n */\nmxGraph.prototype.resetEdges = function(cells)\n{\n\tif (cells != null)\n\t{\n\t\t// Prepares faster cells lookup\n\t\tvar dict = new mxDictionary();\n\t\t\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tdict.put(cells[i], true);\n\t\t}\n\t\t\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tvar edges = this.model.getEdges(cells[i]);\n\t\t\t\t\n\t\t\t\tif (edges != null)\n\t\t\t\t{\n\t\t\t\t\tfor (var j = 0; j < edges.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar state = this.view.getState(edges[j]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar source = (state != null) ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[j], true);\n\t\t\t\t\t\tvar target = (state != null) ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[j], false);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Checks if one of the terminals is not in the given array\n\t\t\t\t\t\tif (!dict.get(source) || !dict.get(target))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.resetEdge(edges[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.resetEdges(this.model.getChildren(cells[i]));\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: resetEdge\n * \n * Resets the control points of the given edge.\n * \n * Parameters:\n * \n * edge - <mxCell> whose points should be reset.\n */\nmxGraph.prototype.resetEdge = function(edge)\n{\n\tvar geo = this.model.getGeometry(edge);\n\t\n\t// Resets the control points\n\tif (geo != null && geo.points != null && geo.points.length > 0)\n\t{\n\t\tgeo = geo.clone();\n\t\tgeo.points = [];\n\t\tthis.model.setGeometry(edge, geo);\n\t}\n\t\n\treturn edge;\n};\n\n/**\n * Group: Cell connecting and connection constraints\n */\n\n/**\n * Function: getOutlineConstraint\n * \n * Returns the constraint used to connect to the outline of the given state.\n */\nmxGraph.prototype.getOutlineConstraint = function(point, terminalState, me)\n{\n\tif (terminalState.shape != null)\n\t{\n\t\tvar bounds = this.view.getPerimeterBounds(terminalState);\n\t\tvar direction = terminalState.style[mxConstants.STYLE_DIRECTION];\n\t\t\n\t\tif (direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH)\n\t\t{\n\t\t\tbounds.x += bounds.width / 2 - bounds.height / 2;\n\t\t\tbounds.y += bounds.height / 2 - bounds.width / 2;\n\t\t\tvar tmp = bounds.width;\n\t\t\tbounds.width = bounds.height;\n\t\t\tbounds.height = tmp;\n\t\t}\n\t\n\t\tvar alpha = mxUtils.toRadians(terminalState.shape.getShapeRotation());\n\t\t\n\t\tif (alpha != 0)\n\t\t{\n\t\t\tvar cos = Math.cos(-alpha);\n\t\t\tvar sin = Math.sin(-alpha);\n\t\n\t\t\tvar ct = new mxPoint(bounds.getCenterX(), bounds.getCenterY());\n\t\t\tpoint = mxUtils.getRotatedPoint(point, cos, sin, ct);\n\t\t}\n\n\t\tvar sx = 1;\n\t\tvar sy = 1;\n\t\tvar dx = 0;\n\t\tvar dy = 0;\n\t\t\n\t\t// LATER: Add flipping support for image shapes\n\t\tif (this.getModel().isVertex(terminalState.cell))\n\t\t{\n\t\t\tvar flipH = terminalState.style[mxConstants.STYLE_FLIPH];\n\t\t\tvar flipV = terminalState.style[mxConstants.STYLE_FLIPV];\n\t\t\t\n\t\t\t// Legacy support for stencilFlipH/V\n\t\t\tif (terminalState.shape != null && terminalState.shape.stencil != null)\n\t\t\t{\n\t\t\t\tflipH = mxUtils.getValue(terminalState.style, 'stencilFlipH', 0) == 1 || flipH;\n\t\t\t\tflipV = mxUtils.getValue(terminalState.style, 'stencilFlipV', 0) == 1 || flipV;\n\t\t\t}\n\t\t\t\n\t\t\tif (direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH)\n\t\t\t{\n\t\t\t\tvar tmp = flipH;\n\t\t\t\tflipH = flipV;\n\t\t\t\tflipV = tmp;\n\t\t\t}\n\t\t\t\n\t\t\tif (flipH)\n\t\t\t{\n\t\t\t\tsx = -1;\n\t\t\t\tdx = -bounds.width;\n\t\t\t}\n\t\t\t\n\t\t\tif (flipV)\n\t\t\t{\n\t\t\t\tsy = -1;\n\t\t\t\tdy = -bounds.height ;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpoint = new mxPoint((point.x - bounds.x) * sx - dx + bounds.x, (point.y - bounds.y) * sy - dy + bounds.y);\n\t\t\n\t\tvar x = (bounds.width == 0) ? 0 : Math.round((point.x - bounds.x) * 1000 / bounds.width) / 1000;\n\t\tvar y = (bounds.height == 0) ? 0 : Math.round((point.y - bounds.y) * 1000 / bounds.height) / 1000;\n\t\t\n\t\treturn new mxConnectionConstraint(new mxPoint(x, y), false);\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: getAllConnectionConstraints\n * \n * Returns an array of all <mxConnectionConstraints> for the given terminal. If\n * the shape of the given terminal is a <mxStencilShape> then the constraints\n * of the corresponding <mxStencil> are returned.\n * \n * Parameters:\n * \n * terminal - <mxCellState> that represents the terminal.\n * source - Boolean that specifies if the terminal is the source or target.\n */\nmxGraph.prototype.getAllConnectionConstraints = function(terminal, source)\n{\n\tif (terminal != null && terminal.shape != null && terminal.shape.stencil != null)\n\t{\n\t\treturn terminal.shape.stencil.constraints;\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: getConnectionConstraint\n * \n * Returns an <mxConnectionConstraint> that describes the given connection\n * point. This result can then be passed to <getConnectionPoint>.\n * \n * Parameters:\n * \n * edge - <mxCellState> that represents the edge.\n * terminal - <mxCellState> that represents the terminal.\n * source - Boolean indicating if the terminal is the source or target.\n */\nmxGraph.prototype.getConnectionConstraint = function(edge, terminal, source)\n{\n\tvar point = null;\n\tvar x = edge.style[(source) ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X];\n\n\tif (x != null)\n\t{\n\t\tvar y = edge.style[(source) ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y];\n\t\t\n\t\tif (y != null)\n\t\t{\n\t\t\tpoint = new mxPoint(parseFloat(x), parseFloat(y));\n\t\t}\n\t}\n\t\n\tvar perimeter = false;\n\tvar dx = 0, dy = 0;\n\t\n\tif (point != null)\n\t{\n\t\tperimeter = mxUtils.getValue(edge.style, (source) ? mxConstants.STYLE_EXIT_PERIMETER :\n\t\t\tmxConstants.STYLE_ENTRY_PERIMETER, true);\n\n\t\t//Add entry/exit offset\n\t\tdx = parseFloat(edge.style[(source) ? mxConstants.STYLE_EXIT_DX : mxConstants.STYLE_ENTRY_DX]);\n\t\tdy = parseFloat(edge.style[(source) ? mxConstants.STYLE_EXIT_DY : mxConstants.STYLE_ENTRY_DY]);\n\t\t\n\t\tdx = isFinite(dx)? dx : 0;\n\t\tdy = isFinite(dy)? dy : 0;\n\t}\n\n\treturn new mxConnectionConstraint(point, perimeter, null, dx, dy);\n};\n\n/**\n * Function: setConnectionConstraint\n * \n * Sets the <mxConnectionConstraint> that describes the given connection point.\n * If no constraint is given then nothing is changed. To remove an existing\n * constraint from the given edge, use an empty constraint instead.\n * \n * Parameters:\n * \n * edge - <mxCell> that represents the edge.\n * terminal - <mxCell> that represents the terminal.\n * source - Boolean indicating if the terminal is the source or target.\n * constraint - Optional <mxConnectionConstraint> to be used for this\n * connection.\n */\nmxGraph.prototype.setConnectionConstraint = function(edge, terminal, source, constraint)\n{\n\tif (constraint != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\t\n\t\ttry\n\t\t{\n\t\t\tif (constraint == null || constraint.point == null)\n\t\t\t{\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_X :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_X, null, [edge]);\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_Y :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_Y, null, [edge]);\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_DX :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_DX, null, [edge]);\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_DY :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_DY, null, [edge]);\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_PERIMETER :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_PERIMETER, null, [edge]);\n\t\t\t}\n\t\t\telse if (constraint.point != null)\n\t\t\t{\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_X :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_X, constraint.point.x, [edge]);\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_Y :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_Y, constraint.point.y, [edge]);\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_DX :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_DX, constraint.dx, [edge]);\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_DY :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_DY, constraint.dy, [edge]);\n\t\t\t\t\n\t\t\t\t// Only writes 0 since 1 is default\n\t\t\t\tif (!constraint.perimeter)\n\t\t\t\t{\n\t\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_PERIMETER :\n\t\t\t\t\t\tmxConstants.STYLE_ENTRY_PERIMETER, '0', [edge]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_PERIMETER :\n\t\t\t\t\t\tmxConstants.STYLE_ENTRY_PERIMETER, null, [edge]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: getConnectionPoint\n *\n * Returns the nearest point in the list of absolute points or the center\n * of the opposite terminal.\n * \n * Parameters:\n * \n * vertex - <mxCellState> that represents the vertex.\n * constraint - <mxConnectionConstraint> that represents the connection point\n * constraint as returned by <getConnectionConstraint>.\n */\nmxGraph.prototype.getConnectionPoint = function(vertex, constraint, round)\n{\n\tround = (round != null) ? round : true;\n\tvar point = null;\n\t\n\tif (vertex != null && constraint.point != null)\n\t{\n\t\tvar bounds = this.view.getPerimeterBounds(vertex);\n        var cx = new mxPoint(bounds.getCenterX(), bounds.getCenterY());\n\t\tvar direction = vertex.style[mxConstants.STYLE_DIRECTION];\n\t\tvar r1 = 0;\n\t\t\n\t\t// Bounds need to be rotated by 90 degrees for further computation\n\t\tif (direction != null && mxUtils.getValue(vertex.style,\n\t\t\tmxConstants.STYLE_ANCHOR_POINT_DIRECTION, 1) == 1)\n\t\t{\n\t\t\tif (direction == mxConstants.DIRECTION_NORTH)\n\t\t\t{\n\t\t\t\tr1 += 270;\n\t\t\t}\n\t\t\telse if (direction == mxConstants.DIRECTION_WEST)\n\t\t\t{\n\t\t\t\tr1 += 180;\n\t\t\t}\n\t\t\telse if (direction == mxConstants.DIRECTION_SOUTH)\n\t\t\t{\n\t\t\t\tr1 += 90;\n\t\t\t}\n\n\t\t\t// Bounds need to be rotated by 90 degrees for further computation\n\t\t\tif (direction == mxConstants.DIRECTION_NORTH ||\n\t\t\t\tdirection == mxConstants.DIRECTION_SOUTH)\n\t\t\t{\n\t\t\t\tbounds.rotate90();\n\t\t\t}\n\t\t}\n\n\t\tvar scale = this.view.scale;\n\t\tpoint = new mxPoint(bounds.x + constraint.point.x * bounds.width + constraint.dx * scale,\n\t\t\t\tbounds.y + constraint.point.y * bounds.height + constraint.dy * scale);\n\t\t\n\t\t// Rotation for direction before projection on perimeter\n\t\tvar r2 = vertex.style[mxConstants.STYLE_ROTATION] || 0;\n\t\t\n\t\tif (constraint.perimeter)\n\t\t{\n\t\t\tif (r1 != 0)\n\t\t\t{\n\t\t\t\t// Only 90 degrees steps possible here so no trig needed\n\t\t\t\tvar cos = 0;\n\t\t\t\tvar sin = 0;\n\t\t\t\t\n\t\t\t\tif (r1 == 90)\n\t\t\t\t{\n\t\t\t\t\tsin = 1;\n\t\t\t\t}\n\t\t\t\telse if (r1 == 180)\n\t\t\t\t{\n\t\t\t\t\tcos = -1;\n\t\t\t\t}\n\t\t\t\telse if (r1 == 270)\n\t\t\t\t{\n\t\t\t\t\tsin = -1;\n\t\t\t\t}\n\t\t\t\t\n\t\t        point = mxUtils.getRotatedPoint(point, cos, sin, cx);\n\t\t\t}\n\t\n\t\t\tpoint = this.view.getPerimeterPoint(vertex, point, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr2 += r1;\n\t\t\t\n\t\t\tif (this.getModel().isVertex(vertex.cell))\n\t\t\t{\n\t\t\t\tvar flipH = vertex.style[mxConstants.STYLE_FLIPH] == 1;\n\t\t\t\tvar flipV = vertex.style[mxConstants.STYLE_FLIPV] == 1;\n\t\t\t\t\n\t\t\t\t// Legacy support for stencilFlipH/V\n\t\t\t\tif (vertex.shape != null && vertex.shape.stencil != null)\n\t\t\t\t{\n\t\t\t\t\tflipH = (mxUtils.getValue(vertex.style, 'stencilFlipH', 0) == 1) || flipH;\n\t\t\t\t\tflipV = (mxUtils.getValue(vertex.style, 'stencilFlipV', 0) == 1) || flipV;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (direction == mxConstants.DIRECTION_NORTH ||\n\t\t\t\t\tdirection == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t{\n\t\t\t\t\tvar temp = flipH;\n\t\t\t\t\tflipH = flipV\n\t\t\t\t\tflipV = temp;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (flipH)\n\t\t\t\t{\n\t\t\t\t\tpoint.x = 2 * bounds.getCenterX() - point.x;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (flipV)\n\t\t\t\t{\n\t\t\t\t\tpoint.y = 2 * bounds.getCenterY() - point.y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Generic rotation after projection on perimeter\n\t\tif (r2 != 0 && point != null)\n\t\t{\n\t        var rad = mxUtils.toRadians(r2);\n\t        var cos = Math.cos(rad);\n\t        var sin = Math.sin(rad);\n\t        \n\t        point = mxUtils.getRotatedPoint(point, cos, sin, cx);\n\t\t}\n\t}\n\t\n\tif (round && point != null)\n\t{\n\t\tpoint.x = Math.round(point.x);\n\t\tpoint.y = Math.round(point.y);\n\t}\n\n\treturn point;\n};\n\n/**\n * Function: connectCell\n * \n * Connects the specified end of the given edge to the given terminal\n * using <cellConnected> and fires <mxEvent.CONNECT_CELL> while the\n * transaction is in progress. Returns the updated edge.\n * \n * Parameters:\n * \n * edge - <mxCell> whose terminal should be updated.\n * terminal - <mxCell> that represents the new terminal to be used.\n * source - Boolean indicating if the new terminal is the source or target.\n * constraint - Optional <mxConnectionConstraint> to be used for this\n * connection.\n */\nmxGraph.prototype.connectCell = function(edge, terminal, source, constraint)\n{\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tvar previous = this.model.getTerminal(edge, source);\n\t\tthis.cellConnected(edge, terminal, source, constraint);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.CONNECT_CELL,\n\t\t\t'edge', edge, 'terminal', terminal, 'source', source,\n\t\t\t'previous', previous));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn edge;\n};\n\n/**\n * Function: cellConnected\n * \n * Sets the new terminal for the given edge and resets the edge points if\n * <resetEdgesOnConnect> is true. This method fires\n * <mxEvent.CELL_CONNECTED> while the transaction is in progress.\n * \n * Parameters:\n * \n * edge - <mxCell> whose terminal should be updated.\n * terminal - <mxCell> that represents the new terminal to be used.\n * source - Boolean indicating if the new terminal is the source or target.\n * constraint - <mxConnectionConstraint> to be used for this connection.\n */\nmxGraph.prototype.cellConnected = function(edge, terminal, source, constraint)\n{\n\tif (edge != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tvar previous = this.model.getTerminal(edge, source);\n\n\t\t\t// Updates the constraint\n\t\t\tthis.setConnectionConstraint(edge, terminal, source, constraint);\n\t\t\t\n\t\t\t// Checks if the new terminal is a port, uses the ID of the port in the\n\t\t\t// style and the parent of the port as the actual terminal of the edge.\n\t\t\tif (this.isPortsEnabled())\n\t\t\t{\n\t\t\t\tvar id = null;\n\t\n\t\t\t\tif (this.isPort(terminal))\n\t\t\t\t{\n\t\t\t\t\tid = terminal.getId();\n\t\t\t\t\tterminal = this.getTerminalForPort(terminal, source);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Sets or resets all previous information for connecting to a child port\n\t\t\t\tvar key = (source) ? mxConstants.STYLE_SOURCE_PORT :\n\t\t\t\t\tmxConstants.STYLE_TARGET_PORT;\n\t\t\t\tthis.setCellStyles(key, id, [edge]);\n\t\t\t}\n\t\t\t\n\t\t\tthis.model.setTerminal(edge, terminal, source);\n\t\t\t\n\t\t\tif (this.resetEdgesOnConnect)\n\t\t\t{\n\t\t\t\tthis.resetEdge(edge);\n\t\t\t}\n\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELL_CONNECTED,\n\t\t\t\t'edge', edge, 'terminal', terminal, 'source', source,\n\t\t\t\t'previous', previous));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: disconnectGraph\n * \n * Disconnects the given edges from the terminals which are not in the\n * given array.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be disconnected.\n */\nmxGraph.prototype.disconnectGraph = function(cells)\n{\n\tif (cells != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\t\t\t\t\t\t\t\n\t\t\tvar scale = this.view.scale;\n\t\t\tvar tr = this.view.translate;\n\t\t\t\n\t\t\t// Fast lookup for finding cells in array\n\t\t\tvar dict = new mxDictionary();\n\t\t\t\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tdict.put(cells[i], true);\n\t\t\t}\n\t\t\t\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tif (this.model.isEdge(cells[i]))\n\t\t\t\t{\n\t\t\t\t\tvar geo = this.model.getGeometry(cells[i]);\n\t\t\t\t\t\n\t\t\t\t\tif (geo != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar state = this.view.getState(cells[i]);\n\t\t\t\t\t\tvar pstate = this.view.getState(\n\t\t\t\t\t\t\tthis.model.getParent(cells[i]));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (state != null &&\n\t\t\t\t\t\t\tpstate != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar dx = -pstate.origin.x;\n\t\t\t\t\t\t\tvar dy = -pstate.origin.y;\n\t\t\t\t\t\t\tvar pts = state.absolutePoints;\n\n\t\t\t\t\t\t\tvar src = this.model.getTerminal(cells[i], true);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (src != null && this.isCellDisconnectable(cells[i], src, true))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twhile (src != null && !dict.get(src))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tsrc = this.model.getParent(src);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (src == null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tgeo.setTerminalPoint(\n\t\t\t\t\t\t\t\t\t\tnew mxPoint(pts[0].x / scale - tr.x + dx,\n\t\t\t\t\t\t\t\t\t\t\tpts[0].y / scale - tr.y + dy), true);\n\t\t\t\t\t\t\t\t\tthis.model.setTerminal(cells[i], null, true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar trg = this.model.getTerminal(cells[i], false);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (trg != null && this.isCellDisconnectable(cells[i], trg, false))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twhile (trg != null && !dict.get(trg))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttrg = this.model.getParent(trg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (trg == null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvar n = pts.length - 1;\n\t\t\t\t\t\t\t\t\tgeo.setTerminalPoint(\n\t\t\t\t\t\t\t\t\t\tnew mxPoint(pts[n].x / scale - tr.x + dx,\n\t\t\t\t\t\t\t\t\t\t\tpts[n].y / scale - tr.y + dy), false);\n\t\t\t\t\t\t\t\t\tthis.model.setTerminal(cells[i], null, false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.model.setGeometry(cells[i], geo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Group: Drilldown\n */\n\n/**\n * Function: getCurrentRoot\n * \n * Returns the current root of the displayed cell hierarchy. This is a\n * shortcut to <mxGraphView.currentRoot> in <view>.\n */\nmxGraph.prototype.getCurrentRoot = function()\n{\n\treturn this.view.currentRoot;\n};\n \n/**\n * Function: getTranslateForRoot\n * \n * Returns the translation to be used if the given cell is the root cell as\n * an <mxPoint>. This implementation returns null.\n * \n * Example:\n * \n * To keep the children at their absolute position while stepping into groups,\n * this function can be overridden as follows.\n * \n * (code)\n * var offset = new mxPoint(0, 0);\n * \n * while (cell != null)\n * {\n *   var geo = this.model.getGeometry(cell);\n * \n *   if (geo != null)\n *   {\n *     offset.x -= geo.x;\n *     offset.y -= geo.y;\n *   }\n * \n *   cell = this.model.getParent(cell);\n * }\n * \n * return offset;\n * (end)\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the root.\n */\nmxGraph.prototype.getTranslateForRoot = function(cell)\n{\n\treturn null;\n};\n\n/**\n * Function: isPort\n * \n * Returns true if the given cell is a \"port\", that is, when connecting to\n * it, the cell returned by getTerminalForPort should be used as the\n * terminal and the port should be referenced by the ID in either the\n * mxConstants.STYLE_SOURCE_PORT or the or the\n * mxConstants.STYLE_TARGET_PORT. Note that a port should not be movable.\n * This implementation always returns false.\n * \n * A typical implementation is the following:\n * \n * (code)\n * graph.isPort = function(cell)\n * {\n *   var geo = this.getCellGeometry(cell);\n *   \n *   return (geo != null) ? geo.relative : false;\n * };\n * (end)\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the port.\n */\nmxGraph.prototype.isPort = function(cell)\n{\n\treturn false;\n};\n\n/**\n * Function: getTerminalForPort\n * \n * Returns the terminal to be used for a given port. This implementation\n * always returns the parent cell.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the port.\n * source - If the cell is the source or target port.\n */\nmxGraph.prototype.getTerminalForPort = function(cell, source)\n{\n\treturn this.model.getParent(cell);\n};\n\n/**\n * Function: getChildOffsetForCell\n * \n * Returns the offset to be used for the cells inside the given cell. The\n * root and layer cells may be identified using <mxGraphModel.isRoot> and\n * <mxGraphModel.isLayer>. For all other current roots, the\n * <mxGraphView.currentRoot> field points to the respective cell, so that\n * the following holds: cell == this.view.currentRoot. This implementation\n * returns null.\n * \n * Parameters:\n * \n * cell - <mxCell> whose offset should be returned.\n */\nmxGraph.prototype.getChildOffsetForCell = function(cell)\n{\n\treturn null;\n};\n\n/**\n * Function: enterGroup\n * \n * Uses the given cell as the root of the displayed cell hierarchy. If no\n * cell is specified then the selection cell is used. The cell is only used\n * if <isValidRoot> returns true.\n * \n * Parameters:\n * \n * cell - Optional <mxCell> to be used as the new root. Default is the\n * selection cell.\n */\nmxGraph.prototype.enterGroup = function(cell)\n{\n\tcell = cell || this.getSelectionCell();\n\t\n\tif (cell != null && this.isValidRoot(cell))\n\t{\n\t\tthis.view.setCurrentRoot(cell);\n\t\tthis.clearSelection();\n\t}\n};\n\n/**\n * Function: exitGroup\n * \n * Changes the current root to the next valid root in the displayed cell\n * hierarchy.\n */\nmxGraph.prototype.exitGroup = function()\n{\n\tvar root = this.model.getRoot();\n\tvar current = this.getCurrentRoot();\n\t\n\tif (current != null)\n\t{\n\t\tvar next = this.model.getParent(current);\n\t\t\n\t\t// Finds the next valid root in the hierarchy\n\t\twhile (next != root && !this.isValidRoot(next) &&\n\t\t\t\tthis.model.getParent(next) != root)\n\t\t{\n\t\t\tnext = this.model.getParent(next);\n\t\t}\n\t\t\n\t\t// Clears the current root if the new root is\n\t\t// the model's root or one of the layers.\n\t\tif (next == root || this.model.getParent(next) == root)\n\t\t{\n\t\t\tthis.view.setCurrentRoot(null);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.view.setCurrentRoot(next);\n\t\t}\n\t\t\n\t\tvar state = this.view.getState(current);\n\t\t\n\t\t// Selects the previous root in the graph\n\t\tif (state != null)\n\t\t{\n\t\t\tthis.setSelectionCell(current);\n\t\t}\n\t}\n};\n\n/**\n * Function: home\n * \n * Uses the root of the model as the root of the displayed cell hierarchy\n * and selects the previous root.\n */\nmxGraph.prototype.home = function()\n{\n\tvar current = this.getCurrentRoot();\n\t\n\tif (current != null)\n\t{\n\t\tthis.view.setCurrentRoot(null);\n\t\tvar state = this.view.getState(current);\n\t\t\n\t\tif (state != null)\n\t\t{\n\t\t\tthis.setSelectionCell(current);\n\t\t}\n\t}\n};\n\n/**\n * Function: isValidRoot\n * \n * Returns true if the given cell is a valid root for the cell display\n * hierarchy. This implementation returns true for all non-null values.\n * \n * Parameters:\n * \n * cell - <mxCell> which should be checked as a possible root.\n */\nmxGraph.prototype.isValidRoot = function(cell)\n{\n\treturn (cell != null);\n};\n\n/**\n * Group: Graph display\n */\n \n/**\n * Function: getGraphBounds\n * \n * Returns the bounds of the visible graph. Shortcut to\n * <mxGraphView.getGraphBounds>. See also: <getBoundingBoxFromGeometry>.\n */\n mxGraph.prototype.getGraphBounds = function()\n {\n \treturn this.view.getGraphBounds();\n };\n\n/**\n * Function: getCellBounds\n * \n * Returns the scaled, translated bounds for the given cell. See\n * <mxGraphView.getBounds> for arrays.\n * \n * Parameters:\n * \n * cell - <mxCell> whose bounds should be returned.\n * includeEdge - Optional boolean that specifies if the bounds of\n * the connected edges should be included. Default is false.\n * includeDescendants - Optional boolean that specifies if the bounds\n * of all descendants should be included. Default is false.\n */\nmxGraph.prototype.getCellBounds = function(cell, includeEdges, includeDescendants)\n{\n\tvar cells = [cell];\n\t\n\t// Includes all connected edges\n\tif (includeEdges)\n\t{\n\t\tcells = cells.concat(this.model.getEdges(cell));\n\t}\n\t\n\tvar result = this.view.getBounds(cells);\n\t\n\t// Recursively includes the bounds of the children\n\tif (includeDescendants)\n\t{\n\t\tvar childCount = this.model.getChildCount(cell);\n\t\t\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar tmp = this.getCellBounds(this.model.getChildAt(cell, i),\n\t\t\t\tincludeEdges, true);\n\n\t\t\tif (result != null)\n\t\t\t{\n\t\t\t\tresult.add(tmp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = tmp;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getBoundingBoxFromGeometry\n * \n * Returns the bounding box for the geometries of the vertices in the\n * given array of cells. This can be used to find the graph bounds during\n * a layout operation (ie. before the last endUpdate) as follows:\n * \n * (code)\n * var cells = graph.getChildCells(graph.getDefaultParent(), true, true);\n * var bounds = graph.getBoundingBoxFromGeometry(cells, true);\n * (end)\n * \n * This can then be used to move cells to the origin:\n * \n * (code)\n * if (bounds.x < 0 || bounds.y < 0)\n * {\n *   graph.moveCells(cells, -Math.min(bounds.x, 0), -Math.min(bounds.y, 0))\n * }\n * (end)\n * \n * Or to translate the graph view:\n * \n * (code)\n * if (bounds.x < 0 || bounds.y < 0)\n * {\n *   graph.view.setTranslate(-Math.min(bounds.x, 0), -Math.min(bounds.y, 0));\n * }\n * (end)\n * \n * Parameters:\n * \n * cells - Array of <mxCells> whose bounds should be returned.\n * includeEdges - Specifies if edge bounds should be included by computing\n * the bounding box for all points in geometry. Default is false.\n */\nmxGraph.prototype.getBoundingBoxFromGeometry = function(cells, includeEdges)\n{\n\tincludeEdges = (includeEdges != null) ? includeEdges : false;\n\tvar result = null;\n\t\n\tif (cells != null)\n\t{\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (includeEdges || this.model.isVertex(cells[i]))\n\t\t\t{\n\t\t\t\t// Computes the bounding box for the points in the geometry\n\t\t\t\tvar geo = this.getCellGeometry(cells[i]);\n\t\t\t\t\n\t\t\t\tif (geo != null)\n\t\t\t\t{\n\t\t\t\t\tvar bbox = null;\n\t\t\t\t\t\n\t\t\t\t\tif (this.model.isEdge(cells[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar addPoint = function(pt)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pt != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (tmp == null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttmp = new mxRectangle(pt.x, pt.y, 0, 0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttmp.add(new mxRectangle(pt.x, pt.y, 0, 0));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (this.model.getTerminal(cells[i], true) == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddPoint(geo.getTerminalPoint(true));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (this.model.getTerminal(cells[i], false) == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddPoint(geo.getTerminalPoint(false));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tvar pts = geo.points;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (pts != null && pts.length > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar tmp = new mxRectangle(pts[0].x, pts[0].y, 0, 0);\n\n\t\t\t\t\t\t\tfor (var j = 1; j < pts.length; j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\taddPoint(pts[j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tbbox = tmp;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar parent = this.model.getParent(cells[i]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (geo.relative)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (this.model.isVertex(parent) && parent != this.view.currentRoot)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar tmp = this.getBoundingBoxFromGeometry([parent], false);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (tmp != null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbbox = new mxRectangle(geo.x * tmp.width, geo.y * tmp.height, geo.width, geo.height);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif (mxUtils.indexOf(cells, parent) >= 0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tbbox.x += tmp.x;\n\t\t\t\t\t\t\t\t\t\tbbox.y += tmp.y;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbbox = mxRectangle.fromRectangle(geo);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (this.model.isVertex(parent) && mxUtils.indexOf(cells, parent) >= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar tmp = this.getBoundingBoxFromGeometry([parent], false);\n\n\t\t\t\t\t\t\t\tif (tmp != null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbbox.x += tmp.x;\n\t\t\t\t\t\t\t\t\tbbox.y += tmp.y;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (bbox != null && geo.offset != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbbox.x += geo.offset.x;\n\t\t\t\t\t\t\tbbox.y += geo.offset.y;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar style = this.getCurrentCellStyle(cells[i]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (bbox != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar angle = mxUtils.getValue(style, mxConstants.STYLE_ROTATION, 0);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (angle != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbbox = mxUtils.getBoundingBox(bbox, angle);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (bbox != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (result == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult = mxRectangle.fromRectangle(bbox);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult.add(bbox);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: refresh\n * \n * Clears all cell states or the states for the hierarchy starting at the\n * given cell and validates the graph. This fires a refresh event as the\n * last step.\n * \n * Parameters:\n * \n * cell - Optional <mxCell> for which the cell states should be cleared.\n */\nmxGraph.prototype.refresh = function(cell)\n{\n\tthis.view.clear(cell, cell == null);\n\tthis.view.validate();\n\tthis.sizeDidChange();\n\tthis.fireEvent(new mxEventObject(mxEvent.REFRESH));\n};\n\n/**\n * Function: snap\n * \n * Snaps the given numeric value to the grid if <gridEnabled> is true.\n * \n * Parameters:\n * \n * value - Numeric value to be snapped to the grid.\n */\nmxGraph.prototype.snap = function(value)\n{\n\tif (this.gridEnabled)\n\t{\n\t\tvalue = Math.round(value / this.gridSize ) * this.gridSize;\n\t}\n\t\n\treturn value;\n};\n\n/**\n * Function: snapDelta\n * \n * Snaps the given delta with the given scaled bounds.\n */\nmxGraph.prototype.snapDelta = function(delta, bounds, ignoreGrid, ignoreHorizontal, ignoreVertical)\n{\n\tvar t = this.view.translate;\n\tvar s = this.view.scale;\n\t\n\tif (!ignoreGrid && this.gridEnabled)\n\t{\n\t\tvar tol = this.gridSize * s * 0.5;\n\t\t\n\t\tif (!ignoreHorizontal)\n\t\t{\n\t\t\tvar tx = bounds.x - (this.snap(bounds.x / s - t.x) + t.x) * s;\n\t\t\t\n\t\t\tif (Math.abs(delta.x- tx) < tol)\n\t\t\t{\n\t\t\t\tdelta.x = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdelta.x = this.snap(delta.x / s) * s - tx;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!ignoreVertical)\n\t\t{\n\t\t\tvar ty = bounds.y - (this.snap(bounds.y / s - t.y) + t.y) * s;\n\t\t\t\t\n\t\t\tif (Math.abs(delta.y - ty) < tol)\n\t\t\t{\n\t\t\t\tdelta.y = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdelta.y = this.snap(delta.y / s) * s - ty;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tvar tol = 0.5 * s;\n\t\t\n\t\tif (!ignoreHorizontal)\n\t\t{\n\t\t\tvar tx = bounds.x - (Math.round(bounds.x / s - t.x) + t.x) * s;\n\t\t\t\n\t\t\tif (Math.abs(delta.x - tx) < tol)\n\t\t\t{\n\t\t\t\tdelta.x = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdelta.x = Math.round(delta.x / s) * s - tx;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!ignoreVertical)\n\t\t{\t\t\n\t\t\tvar ty = bounds.y - (Math.round(bounds.y / s - t.y) + t.y) * s;\n\t\t\t\n\t\t\tif (Math.abs(delta.y - ty) < tol)\n\t\t\t{\n\t\t\t\tdelta.y = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdelta.y = Math.round(delta.y / s) * s - ty;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn delta;\n};\n\n/**\n * Function: panGraph\n * \n * Shifts the graph display by the given amount. This is used to preview\n * panning operations, use <mxGraphView.setTranslate> to set a persistent\n * translation of the view. Fires <mxEvent.PAN>.\n * \n * Parameters:\n * \n * dx - Amount to shift the graph along the x-axis.\n * dy - Amount to shift the graph along the y-axis.\n */\nmxGraph.prototype.panGraph = function(dx, dy)\n{\n\tif (this.useScrollbarsForPanning && mxUtils.hasScrollbars(this.container))\n\t{\n\t\tthis.container.scrollLeft = -dx;\n\t\tthis.container.scrollTop = -dy;\n\t}\n\telse\n\t{\n\t\tvar canvas = this.view.getCanvas();\n\t\t\n\t\tif (this.dialect == mxConstants.DIALECT_SVG)\n\t\t{\n\t\t\t// Puts everything inside the container in a DIV so that it\n\t\t\t// can be moved without changing the state of the container\n\t\t\tif (dx == 0 && dy == 0)\n\t\t\t{\n\t\t\t\t// Workaround for ignored removeAttribute on SVG element in IE9 standards\n\t\t\t\tif (mxClient.IS_IE)\n\t\t\t\t{\n\t\t\t\t\tcanvas.setAttribute('transform', 'translate(' + dx + ',' + dy + ')');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcanvas.removeAttribute('transform');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (this.shiftPreview1 != null)\n\t\t\t\t{\n\t\t\t\t\tvar child = this.shiftPreview1.firstChild;\n\t\t\t\t\t\n\t\t\t\t\twhile (child != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar next = child.nextSibling;\n\t\t\t\t\t\tthis.container.appendChild(child);\n\t\t\t\t\t\tchild = next;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.shiftPreview1.parentNode != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.shiftPreview1.parentNode.removeChild(this.shiftPreview1);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.shiftPreview1 = null;\n\t\t\t\t\t\n\t\t\t\t\tthis.container.appendChild(canvas.parentNode);\n\t\t\t\t\t\n\t\t\t\t\tchild = this.shiftPreview2.firstChild;\n\t\t\t\t\t\n\t\t\t\t\twhile (child != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar next = child.nextSibling;\n\t\t\t\t\t\tthis.container.appendChild(child);\n\t\t\t\t\t\tchild = next;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.shiftPreview2.parentNode != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.shiftPreview2.parentNode.removeChild(this.shiftPreview2);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.shiftPreview2 = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcanvas.setAttribute('transform', 'translate(' + dx + ',' + dy + ')');\n\t\t\t\t\n\t\t\t\tif (this.shiftPreview1 == null)\n\t\t\t\t{\n\t\t\t\t\t// Needs two divs for stuff before and after the SVG element\n\t\t\t\t\tthis.shiftPreview1 = document.createElement('div');\n\t\t\t\t\tthis.shiftPreview1.style.position = 'absolute';\n\t\t\t\t\tthis.shiftPreview1.style.overflow = 'visible';\n\t\t\t\t\t\n\t\t\t\t\tthis.shiftPreview2 = document.createElement('div');\n\t\t\t\t\tthis.shiftPreview2.style.position = 'absolute';\n\t\t\t\t\tthis.shiftPreview2.style.overflow = 'visible';\n\n\t\t\t\t\tvar current = this.shiftPreview1;\n\t\t\t\t\tvar child = this.container.firstChild;\n\t\t\t\t\t\n\t\t\t\t\twhile (child != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar next = child.nextSibling;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// SVG element is moved via transform attribute\n\t\t\t\t\t\tif (child != canvas.parentNode)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurrent.appendChild(child);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurrent = this.shiftPreview2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tchild = next;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Inserts elements only if not empty\n\t\t\t\t\tif (this.shiftPreview1.firstChild != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.container.insertBefore(this.shiftPreview1, canvas.parentNode);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (this.shiftPreview2.firstChild != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.container.appendChild(this.shiftPreview2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.shiftPreview1.style.left = dx + 'px';\n\t\t\t\tthis.shiftPreview1.style.top = dy + 'px';\n\t\t\t\tthis.shiftPreview2.style.left = dx + 'px';\n\t\t\t\tthis.shiftPreview2.style.top = dy + 'px';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcanvas.style.left = dx + 'px';\n\t\t\tcanvas.style.top = dy + 'px';\n\t\t}\n\t\t\n\t\tthis.panDx = dx;\n\t\tthis.panDy = dy;\n\n\t\tthis.fireEvent(new mxEventObject(mxEvent.PAN));\n\t}\n};\n\n/**\n * Function: zoomIn\n * \n * Zooms into the graph by <zoomFactor>.\n */\nmxGraph.prototype.zoomIn = function()\n{\n\tthis.zoom(this.zoomFactor);\n};\n\n/**\n * Function: zoomOut\n * \n * Zooms out of the graph by <zoomFactor>.\n */\nmxGraph.prototype.zoomOut = function()\n{\n\tthis.zoom(1 / this.zoomFactor);\n};\n\n/**\n * Function: zoomActual\n * \n * Resets the zoom and panning in the view.\n */\nmxGraph.prototype.zoomActual = function()\n{\n\tif (this.view.scale == 1)\n\t{\n\t\tthis.view.setTranslate(0, 0);\n\t}\n\telse\n\t{\n\t\tthis.view.translate.x = 0;\n\t\tthis.view.translate.y = 0;\n\n\t\tthis.view.setScale(1);\n\t}\n};\n\n/**\n * Function: zoomTo\n * \n * Zooms the graph to the given scale with an optional boolean center\n * argument, which is passd to <zoom>.\n */\nmxGraph.prototype.zoomTo = function(scale, center)\n{\n\tthis.zoom(scale / this.view.scale, center);\n};\n\n/**\n * Function: center\n * \n * Centers the graph in the container.\n * \n * Parameters:\n * \n * horizontal - Optional boolean that specifies if the graph should be centered\n * horizontally. Default is true.\n * vertical - Optional boolean that specifies if the graph should be centered\n * vertically. Default is true.\n * cx - Optional float that specifies the horizontal center. Default is 0.5.\n * cy - Optional float that specifies the vertical center. Default is 0.5.\n */\nmxGraph.prototype.center = function(horizontal, vertical, cx, cy)\n{\n\thorizontal = (horizontal != null) ? horizontal : true;\n\tvertical = (vertical != null) ? vertical : true;\n\tcx = (cx != null) ? cx : 0.5;\n\tcy = (cy != null) ? cy : 0.5;\n\t\n\tvar hasScrollbars = mxUtils.hasScrollbars(this.container);\n\tvar padding = 2 * this.getBorder();\n\tvar cw = this.container.clientWidth - padding;\n\tvar ch = this.container.clientHeight - padding;\n\tvar bounds = this.getGraphBounds();\n\n\tvar t = this.view.translate;\n\tvar s = this.view.scale;\n\n\tvar dx = (horizontal) ? cw - bounds.width : 0;\n\tvar dy = (vertical) ? ch - bounds.height : 0;\n\t\n\tif (!hasScrollbars)\n\t{\n\t\tthis.view.setTranslate((horizontal) ? Math.floor(t.x - bounds.x * s + dx * cx / s) : t.x,\n\t\t\t(vertical) ? Math.floor(t.y - bounds.y * s + dy * cy / s) : t.y);\n\t}\n\telse\n\t{\n\t\tbounds.x -= t.x;\n\t\tbounds.y -= t.y;\n\t\n\t\tvar sw = this.container.scrollWidth;\n\t\tvar sh = this.container.scrollHeight;\n\t\t\n\t\tif (sw > cw)\n\t\t{\n\t\t\tdx = 0;\n\t\t}\n\t\t\n\t\tif (sh > ch)\n\t\t{\n\t\t\tdy = 0;\n\t\t}\n\n\t\tthis.view.setTranslate(Math.floor(dx / 2 - bounds.x), Math.floor(dy / 2 - bounds.y));\n\t\tthis.container.scrollLeft = (sw - cw) / 2;\n\t\tthis.container.scrollTop = (sh - ch) / 2;\n\t}\n};\n\n/**\n * Function: zoom\n * \n * Zooms the graph using the given factor. Center is an optional boolean\n * argument that keeps the graph scrolled to the center. If the center argument\n * is omitted, then <centerZoom> will be used as its value.\n */\nmxGraph.prototype.zoom = function(factor, center)\n{\n\tcenter = (center != null) ? center : this.centerZoom;\n\tvar scale = Math.round(this.view.scale * factor * 100) / 100;\n\tvar state = this.view.getState(this.getSelectionCell());\n\tfactor = scale / this.view.scale;\n\t\n\tif (this.keepSelectionVisibleOnZoom && state != null)\n\t{\n\t\tvar rect = new mxRectangle(state.x * factor, state.y * factor,\n\t\t\tstate.width * factor, state.height * factor);\n\t\t\n\t\t// Refreshes the display only once if a scroll is carried out\n\t\tthis.view.scale = scale;\n\t\t\n\t\tif (!this.scrollRectToVisible(rect))\n\t\t{\n\t\t\tthis.view.revalidate();\n\t\t\t\n\t\t\t// Forces an event to be fired but does not revalidate again\n\t\t\tthis.view.setScale(scale);\n\t\t}\n\t}\n\telse\n\t{\n\t\tvar hasScrollbars = mxUtils.hasScrollbars(this.container);\n\t\t\n\t\tif (center && !hasScrollbars)\n\t\t{\n\t\t\tvar dx = this.container.offsetWidth;\n\t\t\tvar dy = this.container.offsetHeight;\n\t\t\t\n\t\t\tif (factor > 1)\n\t\t\t{\n\t\t\t\tvar f = (factor - 1) / (scale * 2);\n\t\t\t\tdx *= -f;\n\t\t\t\tdy *= -f;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar f = (1 / factor - 1) / (this.view.scale * 2);\n\t\t\t\tdx *= f;\n\t\t\t\tdy *= f;\n\t\t\t}\n\n\t\t\tthis.view.scaleAndTranslate(scale,\n\t\t\t\tthis.view.translate.x + dx,\n\t\t\t\tthis.view.translate.y + dy);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Allows for changes of translate and scrollbars during setscale\n\t\t\tvar tx = this.view.translate.x;\n\t\t\tvar ty = this.view.translate.y;\n\t\t\tvar sl = this.container.scrollLeft;\n\t\t\tvar st = this.container.scrollTop;\n\t\t\t\n\t\t\tthis.view.setScale(scale);\n\t\t\t\n\t\t\tif (hasScrollbars)\n\t\t\t{\n\t\t\t\tvar dx = 0;\n\t\t\t\tvar dy = 0;\n\t\t\t\t\n\t\t\t\tif (center)\n\t\t\t\t{\n\t\t\t\t\tdx = this.container.offsetWidth * (factor - 1) / 2;\n\t\t\t\t\tdy = this.container.offsetHeight * (factor - 1) / 2;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.container.scrollLeft = (this.view.translate.x - tx) * this.view.scale + Math.round(sl * factor + dx);\n\t\t\t\tthis.container.scrollTop = (this.view.translate.y - ty) * this.view.scale + Math.round(st * factor + dy);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: zoomToRect\n * \n * Zooms the graph to the specified rectangle. If the rectangle does not have same aspect\n * ratio as the display container, it is increased in the smaller relative dimension only\n * until the aspect match. The original rectangle is centralised within this expanded one.\n * \n * Note that the input rectangular must be un-scaled and un-translated.\n * \n * Parameters:\n * \n * rect - The un-scaled and un-translated rectangluar region that should be just visible \n * after the operation\n */\nmxGraph.prototype.zoomToRect = function(rect)\n{\n\tvar scaleX = this.container.clientWidth / rect.width;\n\tvar scaleY = this.container.clientHeight / rect.height;\n\tvar aspectFactor = scaleX / scaleY;\n\n\t// Remove any overlap of the rect outside the client area\n\trect.x = Math.max(0, rect.x);\n\trect.y = Math.max(0, rect.y);\n\tvar rectRight = Math.min(this.container.scrollWidth, rect.x + rect.width);\n\tvar rectBottom = Math.min(this.container.scrollHeight, rect.y + rect.height);\n\trect.width = rectRight - rect.x;\n\trect.height = rectBottom - rect.y;\n\n\t// The selection area has to be increased to the same aspect\n\t// ratio as the container, centred around the centre point of the \n\t// original rect passed in.\n\tif (aspectFactor < 1.0)\n\t{\n\t\t// Height needs increasing\n\t\tvar newHeight = rect.height / aspectFactor;\n\t\tvar deltaHeightBuffer = (newHeight - rect.height) / 2.0;\n\t\trect.height = newHeight;\n\t\t\n\t\t// Assign up to half the buffer to the upper part of the rect, not crossing 0\n\t\t// put the rest on the bottom\n\t\tvar upperBuffer = Math.min(rect.y , deltaHeightBuffer);\n\t\trect.y = rect.y - upperBuffer;\n\t\t\n\t\t// Check if the bottom has extended too far\n\t\trectBottom = Math.min(this.container.scrollHeight, rect.y + rect.height);\n\t\trect.height = rectBottom - rect.y;\n\t}\n\telse\n\t{\n\t\t// Width needs increasing\n\t\tvar newWidth = rect.width * aspectFactor;\n\t\tvar deltaWidthBuffer = (newWidth - rect.width) / 2.0;\n\t\trect.width = newWidth;\n\t\t\n\t\t// Assign up to half the buffer to the upper part of the rect, not crossing 0\n\t\t// put the rest on the bottom\n\t\tvar leftBuffer = Math.min(rect.x , deltaWidthBuffer);\n\t\trect.x = rect.x - leftBuffer;\n\t\t\n\t\t// Check if the right hand side has extended too far\n\t\trectRight = Math.min(this.container.scrollWidth, rect.x + rect.width);\n\t\trect.width = rectRight - rect.x;\n\t}\n\n\tvar scale = this.container.clientWidth / rect.width;\n\tvar newScale = this.view.scale * scale;\n\n\tif (!mxUtils.hasScrollbars(this.container))\n\t{\n\t\tthis.view.scaleAndTranslate(newScale, (this.view.translate.x - rect.x / this.view.scale), (this.view.translate.y - rect.y / this.view.scale));\n\t}\n\telse\n\t{\n\t\tthis.view.setScale(newScale);\n\t\tthis.container.scrollLeft = Math.round(rect.x * scale);\n\t\tthis.container.scrollTop = Math.round(rect.y * scale);\n\t}\n};\n\n/**\n * Function: scrollCellToVisible\n * \n * Pans the graph so that it shows the given cell. Optionally the cell may\n * be centered in the container.\n * \n * To center a given graph if the <container> has no scrollbars, use the following code.\n * \n * [code]\n * var bounds = graph.getGraphBounds();\n * graph.view.setTranslate(-bounds.x - (bounds.width - container.clientWidth) / 2,\n * \t\t\t\t\t\t   -bounds.y - (bounds.height - container.clientHeight) / 2);\n * [/code]\n * \n * Parameters:\n * \n * cell - <mxCell> to be made visible.\n * center - Optional boolean flag. Default is false.\n */\nmxGraph.prototype.scrollCellToVisible = function(cell, center)\n{\n\tvar x = -this.view.translate.x;\n\tvar y = -this.view.translate.y;\n\n\tvar state = this.view.getState(cell);\n\n\tif (state != null)\n\t{\n\t\tvar bounds = new mxRectangle(x + state.x, y + state.y, state.width,\n\t\t\tstate.height);\n\n\t\tif (center && this.container != null)\n\t\t{\n\t\t\tvar w = this.container.clientWidth;\n\t\t\tvar h = this.container.clientHeight;\n\n\t\t\tbounds.x = bounds.getCenterX() - w / 2;\n\t\t\tbounds.width = w;\n\t\t\tbounds.y = bounds.getCenterY() - h / 2;\n\t\t\tbounds.height = h;\n\t\t}\n\t\t\n\t\tvar tr = new mxPoint(this.view.translate.x, this.view.translate.y);\n\n\t\tif (this.scrollRectToVisible(bounds))\n\t\t{\n\t\t\t// Triggers an update via the view's event source\n\t\t\tvar tr2 = new mxPoint(this.view.translate.x, this.view.translate.y);\n\t\t\tthis.view.translate.x = tr.x;\n\t\t\tthis.view.translate.y = tr.y;\n\t\t\tthis.view.setTranslate(tr2.x, tr2.y);\n\t\t}\n\t}\n};\n\n/**\n * Function: scrollRectToVisible\n * \n * Pans the graph so that it shows the given rectangle.\n * \n * Parameters:\n * \n * rect - <mxRectangle> to be made visible.\n */\nmxGraph.prototype.scrollRectToVisible = function(rect)\n{\n\tvar isChanged = false;\n\t\n\tif (rect != null)\n\t{\n\t\tvar w = this.container.offsetWidth;\n\t\tvar h = this.container.offsetHeight;\n\n        var widthLimit = Math.min(w, rect.width);\n        var heightLimit = Math.min(h, rect.height);\n\n\t\tif (mxUtils.hasScrollbars(this.container))\n\t\t{\n\t\t\tvar c = this.container;\n\t\t\trect.x += this.view.translate.x;\n\t\t\trect.y += this.view.translate.y;\n\t\t\tvar dx = c.scrollLeft - rect.x;\n\t\t\tvar ddx = Math.max(dx - c.scrollLeft, 0);\n\n\t\t\tif (dx > 0)\n\t\t\t{\n\t\t\t\tc.scrollLeft -= dx + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdx = rect.x + widthLimit - c.scrollLeft - c.clientWidth;\n\n\t\t\t\tif (dx > 0)\n\t\t\t\t{\n\t\t\t\t\tc.scrollLeft += dx + 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar dy = c.scrollTop - rect.y;\n\t\t\tvar ddy = Math.max(0, dy - c.scrollTop);\n\n\t\t\tif (dy > 0)\n\t\t\t{\n\t\t\t\tc.scrollTop -= dy + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdy = rect.y + heightLimit - c.scrollTop - c.clientHeight;\n\n\t\t\t\tif (dy > 0)\n\t\t\t\t{\n\t\t\t\t\tc.scrollTop += dy + 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this.useScrollbarsForPanning && (ddx != 0 || ddy != 0))\n\t\t\t{\n\t\t\t\tthis.view.setTranslate(ddx, ddy);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar x = -this.view.translate.x;\n\t\t\tvar y = -this.view.translate.y;\n\n\t\t\tvar s = this.view.scale;\n\n\t\t\tif (rect.x + widthLimit > x + w)\n\t\t\t{\n\t\t\t\tthis.view.translate.x -= (rect.x + widthLimit - w - x) / s;\n\t\t\t\tisChanged = true;\n\t\t\t}\n\n\t\t\tif (rect.y + heightLimit > y + h)\n\t\t\t{\n\t\t\t\tthis.view.translate.y -= (rect.y + heightLimit - h - y) / s;\n\t\t\t\tisChanged = true;\n\t\t\t}\n\n\t\t\tif (rect.x < x)\n\t\t\t{\n\t\t\t\tthis.view.translate.x += (x - rect.x) / s;\n\t\t\t\tisChanged = true;\n\t\t\t}\n\n\t\t\tif (rect.y  < y)\n\t\t\t{\n\t\t\t\tthis.view.translate.y += (y - rect.y) / s;\n\t\t\t\tisChanged = true;\n\t\t\t}\n\n\t\t\tif (isChanged)\n\t\t\t{\n\t\t\t\tthis.view.refresh();\n\t\t\t\t\n\t\t\t\t// Repaints selection marker (ticket 18)\n\t\t\t\tif (this.selectionCellsHandler != null)\n\t\t\t\t{\n\t\t\t\t\tthis.selectionCellsHandler.refresh();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn isChanged;\n};\n\n/**\n * Function: getCellGeometry\n * \n * Returns the <mxGeometry> for the given cell. This implementation uses\n * <mxGraphModel.getGeometry>. Subclasses can override this to implement\n * specific geometries for cells in only one graph, that is, it can return\n * geometries that depend on the current state of the view.\n * \n * Parameters:\n * \n * cell - <mxCell> whose geometry should be returned.\n */\nmxGraph.prototype.getCellGeometry = function(cell)\n{\n\treturn this.model.getGeometry(cell);\n};\n\n/**\n * Function: isCellVisible\n * \n * Returns true if the given cell is visible in this graph. This\n * implementation uses <mxGraphModel.isVisible>. Subclassers can override\n * this to implement specific visibility for cells in only one graph, that\n * is, without affecting the visible state of the cell.\n * \n * When using dynamic filter expressions for cell visibility, then the\n * graph should be revalidated after the filter expression has changed.\n * \n * Parameters:\n * \n * cell - <mxCell> whose visible state should be returned.\n */\nmxGraph.prototype.isCellVisible = function(cell)\n{\n\treturn this.model.isVisible(cell);\n};\n\n/**\n * Function: isCellCollapsed\n * \n * Returns true if the given cell is collapsed in this graph. This\n * implementation uses <mxGraphModel.isCollapsed>. Subclassers can override\n * this to implement specific collapsed states for cells in only one graph,\n * that is, without affecting the collapsed state of the cell.\n * \n * When using dynamic filter expressions for the collapsed state, then the\n * graph should be revalidated after the filter expression has changed.\n * \n * Parameters:\n * \n * cell - <mxCell> whose collapsed state should be returned.\n */\nmxGraph.prototype.isCellCollapsed = function(cell)\n{\n\treturn this.model.isCollapsed(cell);\n};\n\n/**\n * Function: isCellConnectable\n * \n * Returns true if the given cell is connectable in this graph. This\n * implementation uses <mxGraphModel.isConnectable>. Subclassers can override\n * this to implement specific connectable states for cells in only one graph,\n * that is, without affecting the connectable state of the cell in the model.\n * \n * Parameters:\n * \n * cell - <mxCell> whose connectable state should be returned.\n */\nmxGraph.prototype.isCellConnectable = function(cell)\n{\n\treturn this.model.isConnectable(cell);\n};\n\n/**\n * Function: isOrthogonal\n * \n * Returns true if perimeter points should be computed such that the\n * resulting edge has only horizontal or vertical segments.\n * \n * Parameters:\n * \n * edge - <mxCellState> that represents the edge.\n */\nmxGraph.prototype.isOrthogonal = function(edge)\n{\n\tvar orthogonal = edge.style[mxConstants.STYLE_ORTHOGONAL];\n\t\n\tif (orthogonal != null)\n\t{\n\t\treturn orthogonal;\n\t}\n\t\n\tvar tmp = this.view.getEdgeStyle(edge);\n\t\n\treturn tmp == mxEdgeStyle.SegmentConnector ||\n\t\ttmp == mxEdgeStyle.ElbowConnector ||\n\t\ttmp == mxEdgeStyle.SideToSide ||\n\t\ttmp == mxEdgeStyle.TopToBottom ||\n\t\ttmp == mxEdgeStyle.EntityRelation ||\n\t\ttmp == mxEdgeStyle.OrthConnector;\n};\n\n/**\n * Function: isLoop\n * \n * Returns true if the given cell state is a loop.\n * \n * Parameters:\n * \n * state - <mxCellState> that represents a potential loop.\n */\nmxGraph.prototype.isLoop = function(state)\n{\n\tvar src = state.getVisibleTerminalState(true);\n\tvar trg = state.getVisibleTerminalState(false);\n\t\n\treturn (src != null && src == trg);\n};\n\n/**\n * Function: isCloneEvent\n * \n * Returns true if the given event is a clone event. This implementation\n * returns true if control is pressed.\n */\nmxGraph.prototype.isCloneEvent = function(evt)\n{\n\treturn mxEvent.isControlDown(evt);\n};\n\n/**\n * Function: isTransparentClickEvent\n * \n * Hook for implementing click-through behaviour on selected cells. If this\n * returns true the cell behind the selected cell will be selected. This\n * implementation returns false;\n */\nmxGraph.prototype.isTransparentClickEvent = function(evt)\n{\n\treturn false;\n};\n\n/**\n * Function: isToggleEvent\n * \n * Returns true if the given event is a toggle event. This implementation\n * returns true if the meta key (Cmd) is pressed on Macs or if control is\n * pressed on any other platform.\n */\nmxGraph.prototype.isToggleEvent = function(evt)\n{\n\treturn (mxClient.IS_MAC) ? mxEvent.isMetaDown(evt) : mxEvent.isControlDown(evt);\n};\n\n/**\n * Function: isGridEnabledEvent\n * \n * Returns true if the given mouse event should be aligned to the grid.\n */\nmxGraph.prototype.isGridEnabledEvent = function(evt)\n{\n\treturn evt != null && !mxEvent.isAltDown(evt);\n};\n\n/**\n * Function: isConstrainedEvent\n * \n * Returns true if the given mouse event should be aligned to the grid.\n */\nmxGraph.prototype.isConstrainedEvent = function(evt)\n{\n\treturn mxEvent.isShiftDown(evt);\n};\n\n/**\n * Function: isIgnoreTerminalEvent\n * \n * Returns true if the given mouse event should not allow any connections to be\n * made. This implementation returns false.\n */\nmxGraph.prototype.isIgnoreTerminalEvent = function(evt)\n{\n\treturn false;\n};\n\n/**\n * Group: Validation\n */\n\n/**\n * Function: validationAlert\n * \n * Displays the given validation error in a dialog. This implementation uses\n * mxUtils.alert.\n */\nmxGraph.prototype.validationAlert = function(message)\n{\n\tmxUtils.alert(message);\n};\n\n/**\n * Function: isEdgeValid\n * \n * Checks if the return value of <getEdgeValidationError> for the given\n * arguments is null.\n *  \n * Parameters:\n * \n * edge - <mxCell> that represents the edge to validate.\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n */\nmxGraph.prototype.isEdgeValid = function(edge, source, target)\n{\n\treturn this.getEdgeValidationError(edge, source, target) == null;\n};\n\n/**\n * Function: getEdgeValidationError\n * \n * Returns the validation error message to be displayed when inserting or\n * changing an edges' connectivity. A return value of null means the edge\n * is valid, a return value of '' means it's not valid, but do not display\n * an error message. Any other (non-empty) string returned from this method\n * is displayed as an error message when trying to connect an edge to a\n * source and target. This implementation uses the <multiplicities>, and\n * checks <multigraph>, <allowDanglingEdges> and <allowLoops> to generate\n * validation errors.\n * \n * For extending this method with specific checks for source/target cells,\n * the method can be extended as follows. Returning an empty string means\n * the edge is invalid with no error message, a non-null string specifies\n * the error message, and null means the edge is valid.\n * \n * (code)\n * graph.getEdgeValidationError = function(edge, source, target)\n * {\n *   if (source != null && target != null &&\n *     this.model.getValue(source) != null &&\n *     this.model.getValue(target) != null)\n *   {\n *     if (target is not valid for source)\n *     {\n *       return 'Invalid Target';\n *     }\n *   }\n *   \n *   // \"Supercall\"\n *   return mxGraph.prototype.getEdgeValidationError.apply(this, arguments);\n * }\n * (end)\n *  \n * Parameters:\n * \n * edge - <mxCell> that represents the edge to validate.\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n */\nmxGraph.prototype.getEdgeValidationError = function(edge, source, target)\n{\n\tif (edge != null && !this.isAllowDanglingEdges() && (source == null || target == null))\n\t{\n\t\treturn '';\n\t}\n\t\n\tif (edge != null && this.model.getTerminal(edge, true) == null &&\n\t\tthis.model.getTerminal(edge, false) == null)\t\n\t{\n\t\treturn null;\n\t}\n\t\n\t// Checks if we're dealing with a loop\n\tif (!this.allowLoops && source == target && source != null)\n\t{\n\t\treturn '';\n\t}\n\t\n\t// Checks if the connection is generally allowed\n\tif (!this.isValidConnection(source, target))\n\t{\n\t\treturn '';\n\t}\n\n\tif (source != null && target != null)\n\t{\n\t\tvar error = '';\n\n\t\t// Checks if the cells are already connected\n\t\t// and adds an error message if required\t\t\t\n\t\tif (!this.multigraph)\n\t\t{\n\t\t\tvar tmp = this.model.getEdgesBetween(source, target, true);\n\t\t\t\n\t\t\t// Checks if the source and target are not connected by another edge\n\t\t\tif (tmp.length > 1 || (tmp.length == 1 && tmp[0] != edge))\n\t\t\t{\n\t\t\t\terror += (mxResources.get(this.alreadyConnectedResource) ||\n\t\t\t\t\tthis.alreadyConnectedResource)+'\\n';\n\t\t\t}\n\t\t}\n\n\t\t// Gets the number of outgoing edges from the source\n\t\t// and the number of incoming edges from the target\n\t\t// without counting the edge being currently changed.\n\t\tvar sourceOut = this.model.getDirectedEdgeCount(source, true, edge);\n\t\tvar targetIn = this.model.getDirectedEdgeCount(target, false, edge);\n\n\t\t// Checks the change against each multiplicity rule\n\t\tif (this.multiplicities != null)\n\t\t{\n\t\t\tfor (var i = 0; i < this.multiplicities.length; i++)\n\t\t\t{\n\t\t\t\tvar err = this.multiplicities[i].check(this, edge, source,\n\t\t\t\t\ttarget, sourceOut, targetIn);\n\t\t\t\t\n\t\t\t\tif (err != null)\n\t\t\t\t{\n\t\t\t\t\terror += err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Validates the source and target terminals independently\n\t\tvar err = this.validateEdge(edge, source, target);\n\t\t\n\t\tif (err != null)\n\t\t{\n\t\t\terror += err;\n\t\t}\n\t\t\n\t\treturn (error.length > 0) ? error : null;\n\t}\n\t\n\treturn (this.allowDanglingEdges) ? null : '';\n};\n\n/**\n * Function: validateEdge\n * \n * Hook method for subclassers to return an error message for the given\n * edge and terminals. This implementation returns null.\n * \n * Parameters:\n * \n * edge - <mxCell> that represents the edge to validate.\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n */\nmxGraph.prototype.validateEdge = function(edge, source, target)\n{\n\treturn null;\n};\n\n/**\n * Function: validateGraph\n * \n * Validates the graph by validating each descendant of the given cell or\n * the root of the model. Context is an object that contains the validation\n * state for the complete validation run. The validation errors are\n * attached to their cells using <setCellWarning>. Returns null in the case of\n * successful validation or an array of strings (warnings) in the case of\n * failed validations.\n * \n * Paramters:\n * \n * cell - Optional <mxCell> to start the validation recursion. Default is\n * the graph root.\n * context - Object that represents the global validation state.\n */\nmxGraph.prototype.validateGraph = function(cell, context)\n{\n\tcell = (cell != null) ? cell : this.model.getRoot();\n\tcontext = (context != null) ? context : new Object();\n\t\n\tvar isValid = true;\n\tvar childCount = this.model.getChildCount(cell);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar tmp = this.model.getChildAt(cell, i);\n\t\tvar ctx = context;\n\t\t\n\t\tif (this.isValidRoot(tmp))\n\t\t{\n\t\t\tctx = new Object();\n\t\t}\n\t\t\n\t\tvar warn = this.validateGraph(tmp, ctx);\n\t\t\n\t\tif (warn != null)\n\t\t{\n\t\t\tthis.setCellWarning(tmp, warn.replace(/\\n/g, '<br>'));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.setCellWarning(tmp, null);\n\t\t}\n\t\t\n\t\tisValid = isValid && warn == null;\n\t}\n\t\n\tvar warning = '';\n\t\n\t// Adds error for invalid children if collapsed (children invisible)\n\tif (this.isCellCollapsed(cell) && !isValid)\n\t{\n\t\twarning += (mxResources.get(this.containsValidationErrorsResource) ||\n\t\t\tthis.containsValidationErrorsResource) + '\\n';\n\t}\n\t\n\t// Checks edges and cells using the defined multiplicities\n\tif (this.model.isEdge(cell))\n\t{\n\t\twarning += this.getEdgeValidationError(cell,\n\t\tthis.model.getTerminal(cell, true),\n\t\tthis.model.getTerminal(cell, false)) || '';\n\t}\n\telse\n\t{\n\t\twarning += this.getCellValidationError(cell) || '';\n\t}\n\t\n\t// Checks custom validation rules\n\tvar err = this.validateCell(cell, context);\n\t\n\tif (err != null)\n\t{\n\t\twarning += err;\n\t}\n\t\n\t// Updates the display with the warning icons\n\t// before any potential alerts are displayed.\n\t// LATER: Move this into addCellOverlay. Redraw\n\t// should check if overlay was added or removed.\n\tif (this.model.getParent(cell) == null)\n\t{\n\t\tthis.view.validate();\n\t}\n\n\treturn (warning.length > 0 || !isValid) ? warning : null;\n};\n\n/**\n * Function: getCellValidationError\n * \n * Checks all <multiplicities> that cannot be enforced while the graph is\n * being modified, namely, all multiplicities that require a minimum of\n * 1 edge.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the multiplicities should be checked.\n */\nmxGraph.prototype.getCellValidationError = function(cell)\n{\n\tvar outCount = this.model.getDirectedEdgeCount(cell, true);\n\tvar inCount = this.model.getDirectedEdgeCount(cell, false);\n\tvar value = this.model.getValue(cell);\n\tvar error = '';\n\n\tif (this.multiplicities != null)\n\t{\n\t\tfor (var i = 0; i < this.multiplicities.length; i++)\n\t\t{\n\t\t\tvar rule = this.multiplicities[i];\n\t\t\t\n\t\t\tif (rule.source && mxUtils.isNode(value, rule.type,\n\t\t\t\trule.attr, rule.value) && (outCount > rule.max ||\n\t\t\t\toutCount < rule.min))\n\t\t\t{\n\t\t\t\terror += rule.countError + '\\n';\n\t\t\t}\n\t\t\telse if (!rule.source && mxUtils.isNode(value, rule.type,\n\t\t\t\t\trule.attr, rule.value) && (inCount > rule.max ||\n\t\t\t\t\tinCount < rule.min))\n\t\t\t{\n\t\t\t\terror += rule.countError + '\\n';\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (error.length > 0) ? error : null;\n};\n\n/**\n * Function: validateCell\n * \n * Hook method for subclassers to return an error message for the given\n * cell and validation context. This implementation returns null. Any HTML\n * breaks will be converted to linefeeds in the calling method.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the cell to validate.\n * context - Object that represents the global validation state.\n */\nmxGraph.prototype.validateCell = function(cell, context)\n{\n\treturn null;\n};\n\n/**\n * Group: Graph appearance\n */\n\n/**\n * Function: getBackgroundImage\n * \n * Returns the <backgroundImage> as an <mxImage>.\n */\nmxGraph.prototype.getBackgroundImage = function()\n{\n\treturn this.backgroundImage;\n};\n\n/**\n * Function: setBackgroundImage\n * \n * Sets the new <backgroundImage>.\n * \n * Parameters:\n * \n * image - New <mxImage> to be used for the background.\n */\nmxGraph.prototype.setBackgroundImage = function(image)\n{\n\tthis.backgroundImage = image;\n};\n\n/**\n * Function: getFoldingImage\n * \n * Returns the <mxImage> used to display the collapsed state of\n * the specified cell state. This returns null for all edges.\n */\nmxGraph.prototype.getFoldingImage = function(state)\n{\n\tif (state != null && this.foldingEnabled && !this.getModel().isEdge(state.cell))\n\t{\n\t\tvar tmp = this.isCellCollapsed(state.cell);\n\t\t\n\t\tif (this.isCellFoldable(state.cell, !tmp))\n\t\t{\n\t\t\treturn (tmp) ? this.collapsedImage : this.expandedImage;\n\t\t}\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: convertValueToString\n * \n * Returns the textual representation for the given cell. This\n * implementation returns the nodename or string-representation of the user\n * object.\n *\n * Example:\n * \n * The following returns the label attribute from the cells user\n * object if it is an XML node.\n * \n * (code)\n * graph.convertValueToString = function(cell)\n * {\n * \treturn cell.getAttribute('label');\n * }\n * (end)\n * \n * See also: <cellLabelChanged>.\n * \n * Parameters:\n * \n * cell - <mxCell> whose textual representation should be returned.\n */\nmxGraph.prototype.convertValueToString = function(cell)\n{\n\tvar value = this.model.getValue(cell);\n\t\n\tif (value != null)\n\t{\n\t\tif (mxUtils.isNode(value))\n\t\t{\n\t\t\treturn value.nodeName;\n\t\t}\n\t\telse if (typeof(value.toString) == 'function')\n\t\t{\n\t\t\treturn value.toString();\n\t\t}\n\t}\n\t\n\treturn '';\n};\n\n/**\n * Function: getLabel\n * \n * Returns a string or DOM node that represents the label for the given\n * cell. This implementation uses <convertValueToString> if <labelsVisible>\n * is true. Otherwise it returns an empty string.\n * \n * To truncate a label to match the size of the cell, the following code\n * can be used.\n * \n * (code)\n * graph.getLabel = function(cell)\n * {\n *   var label = mxGraph.prototype.getLabel.apply(this, arguments);\n * \n *   if (label != null && this.model.isVertex(cell))\n *   {\n *     var geo = this.getCellGeometry(cell);\n * \n *     if (geo != null)\n *     {\n *       var max = parseInt(geo.width / 8);\n * \n *       if (label.length > max)\n *       {\n *         label = label.substring(0, max)+'...';\n *       }\n *     }\n *   } \n *   return mxUtils.htmlEntities(label);\n * }\n * (end)\n * \n * A resize listener is needed in the graph to force a repaint of the label\n * after a resize.\n * \n * (code)\n * graph.addListener(mxEvent.RESIZE_CELLS, function(sender, evt)\n * {\n *   var cells = evt.getProperty('cells');\n * \n *   for (var i = 0; i < cells.length; i++)\n *   {\n *     this.view.removeState(cells[i]);\n *   }\n * });\n * (end)\n * \n * Parameters:\n * \n * cell - <mxCell> whose label should be returned.\n */\nmxGraph.prototype.getLabel = function(cell)\n{\n\tvar result = '';\n\t\n\tif (this.labelsVisible && cell != null)\n\t{\n\t\tvar style = this.getCurrentCellStyle(cell);\n\t\t\n\t\tif (!mxUtils.getValue(style, mxConstants.STYLE_NOLABEL, false))\n\t\t{\n\t\t\tresult = this.convertValueToString(cell);\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: isHtmlLabel\n * \n * Returns true if the label must be rendered as HTML markup. The default\n * implementation returns <htmlLabels>.\n * \n * Parameters:\n * \n * cell - <mxCell> whose label should be displayed as HTML markup.\n */\nmxGraph.prototype.isHtmlLabel = function(cell)\n{\n\treturn this.isHtmlLabels();\n};\n \n/**\n * Function: isHtmlLabels\n * \n * Returns <htmlLabels>.\n */\nmxGraph.prototype.isHtmlLabels = function()\n{\n\treturn this.htmlLabels;\n};\n \n/**\n * Function: setHtmlLabels\n * \n * Sets <htmlLabels>.\n */\nmxGraph.prototype.setHtmlLabels = function(value)\n{\n\tthis.htmlLabels = value;\n};\n\n/**\n * Function: isWrapping\n * \n * This enables wrapping for HTML labels.\n * \n * Returns true if no white-space CSS style directive should be used for\n * displaying the given cells label. This implementation returns true if\n * <mxConstants.STYLE_WHITE_SPACE> in the style of the given cell is 'wrap'.\n * \n * This is used as a workaround for IE ignoring the white-space directive\n * of child elements if the directive appears in a parent element. It\n * should be overridden to return true if a white-space directive is used\n * in the HTML markup that represents the given cells label. In order for\n * HTML markup to work in labels, <isHtmlLabel> must also return true\n * for the given cell.\n * \n * Example:\n * \n * (code)\n * graph.getLabel = function(cell)\n * {\n *   var tmp = mxGraph.prototype.getLabel.apply(this, arguments); // \"supercall\"\n *   \n *   if (this.model.isEdge(cell))\n *   {\n *     tmp = '<div style=\"width: 150px; white-space:normal;\">'+tmp+'</div>';\n *   }\n *   \n *   return tmp;\n * }\n * \n * graph.isWrapping = function(state)\n * {\n * \t return this.model.isEdge(state.cell);\n * }\n * (end)\n * \n * Makes sure no edge label is wider than 150 pixels, otherwise the content\n * is wrapped. Note: No width must be specified for wrapped vertex labels as\n * the vertex defines the width in its geometry.\n * \n * Parameters:\n * \n * state - <mxCell> whose label should be wrapped.\n */\nmxGraph.prototype.isWrapping = function(cell)\n{\n\treturn this.getCurrentCellStyle(cell)[mxConstants.STYLE_WHITE_SPACE] == 'wrap';\n};\n\n/**\n * Function: isLabelClipped\n * \n * Returns true if the overflow portion of labels should be hidden. If this\n * returns true then vertex labels will be clipped to the size of the vertices.\n * This implementation returns true if <mxConstants.STYLE_OVERFLOW> in the\n * style of the given cell is 'hidden'.\n * \n * Parameters:\n * \n * state - <mxCell> whose label should be clipped.\n */\nmxGraph.prototype.isLabelClipped = function(cell)\n{\n\treturn this.getCurrentCellStyle(cell)[mxConstants.STYLE_OVERFLOW] == 'hidden';\n};\n\n/**\n * Function: getTooltip\n * \n * Returns the string or DOM node that represents the tooltip for the given\n * state, node and coordinate pair. This implementation checks if the given\n * node is a folding icon or overlay and returns the respective tooltip. If\n * this does not result in a tooltip, the handler for the cell is retrieved\n * from <selectionCellsHandler> and the optional getTooltipForNode method is\n * called. If no special tooltip exists here then <getTooltipForCell> is used\n * with the cell in the given state as the argument to return a tooltip for the\n * given state.\n * \n * Parameters:\n * \n * state - <mxCellState> whose tooltip should be returned.\n * node - DOM node that is currently under the mouse.\n * x - X-coordinate of the mouse.\n * y - Y-coordinate of the mouse.\n */\nmxGraph.prototype.getTooltip = function(state, node, x, y)\n{\n\tvar tip = null;\n\t\n\tif (state != null)\n\t{\n\t\t// Checks if the mouse is over the folding icon\n\t\tif (state.control != null && (node == state.control.node ||\n\t\t\tnode.parentNode == state.control.node))\n\t\t{\n\t\t\ttip = this.collapseExpandResource;\n\t\t\ttip = mxUtils.htmlEntities(mxResources.get(tip) || tip).replace(/\\\\n/g, '<br>');\n\t\t}\n\n\t\tif (tip == null && state.overlays != null)\n\t\t{\n\t\t\tstate.overlays.visit(function(id, shape)\n\t\t\t{\n\t\t\t\t// LATER: Exit loop if tip is not null\n\t\t\t\tif (tip == null && (node == shape.node || node.parentNode == shape.node))\n\t\t\t\t{\n\t\t\t\t\ttip = shape.overlay.toString();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\tif (tip == null)\n\t\t{\n\t\t\tvar handler = this.selectionCellsHandler.getHandler(state.cell);\n\t\t\t\n\t\t\tif (handler != null && typeof(handler.getTooltipForNode) == 'function')\n\t\t\t{\n\t\t\t\ttip = handler.getTooltipForNode(node);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (tip == null)\n\t\t{\n\t\t\ttip = this.getTooltipForCell(state.cell);\n\t\t}\n\t}\n\t\n\treturn tip;\n};\n\n/**\n * Function: getTooltipForCell\n * \n * Returns the string or DOM node to be used as the tooltip for the given\n * cell. This implementation uses the cells getTooltip function if it\n * exists, or else it returns <convertValueToString> for the cell.\n * \n * Example:\n * \n * (code)\n * graph.getTooltipForCell = function(cell)\n * {\n *   return 'Hello, World!';\n * }\n * (end)\n * \n * Replaces all tooltips with the string Hello, World!\n * \n * Parameters:\n * \n * cell - <mxCell> whose tooltip should be returned.\n */\nmxGraph.prototype.getTooltipForCell = function(cell)\n{\n\tvar tip = null;\n\t\n\tif (cell != null && cell.getTooltip != null)\n\t{\n\t\ttip = cell.getTooltip();\n\t}\n\telse\n\t{\n\t\ttip = this.convertValueToString(cell);\n\t}\n\t\n\treturn tip;\n};\n\n/**\n * Function: getLinkForCell\n * \n * Returns the string to be used as the link for the given cell. This\n * implementation returns null.\n * \n * Parameters:\n * \n * cell - <mxCell> whose tooltip should be returned.\n */\nmxGraph.prototype.getLinkForCell = function(cell)\n{\n\treturn null;\n};\n\n/**\n * Function: getCursorForMouseEvent\n * \n * Returns the cursor value to be used for the CSS of the shape for the\n * given event. This implementation calls <getCursorForCell>.\n * \n * Parameters:\n * \n * me - <mxMouseEvent> whose cursor should be returned.\n */\nmxGraph.prototype.getCursorForMouseEvent = function(me)\n{\n\treturn this.getCursorForCell(me.getCell());\n};\n\n/**\n * Function: getCursorForCell\n * \n * Returns the cursor value to be used for the CSS of the shape for the\n * given cell. This implementation returns null.\n * \n * Parameters:\n * \n * cell - <mxCell> whose cursor should be returned.\n */\nmxGraph.prototype.getCursorForCell = function(cell)\n{\n\treturn null;\n};\n\n/**\n * Function: getStartSize\n * \n * Returns the start size of the given swimlane, that is, the width or\n * height of the part that contains the title, depending on the\n * horizontal style. The return value is an <mxRectangle> with either\n * width or height set as appropriate.\n * \n * Parameters:\n * \n * swimlane - <mxCell> whose start size should be returned.\n * ignoreState - Optional boolean that specifies if cell state should be ignored.\n */\nmxGraph.prototype.getStartSize = function(swimlane, ignoreState)\n{\n\tvar result = new mxRectangle();\n\tvar style = this.getCurrentCellStyle(swimlane, ignoreState);\n\tvar size = parseInt(mxUtils.getValue(style,\n\t\tmxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));\n\t\n\tif (mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true))\n\t{\n\t\tresult.height = size;\n\t}\n\telse\n\t{\n\t\tresult.width = size;\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getSwimlaneDirection\n * \n * Returns the direction for the given swimlane style.\n */\nmxGraph.prototype.getSwimlaneDirection = function(style)\n{\n\tvar dir = mxUtils.getValue(style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);\n\tvar flipH = mxUtils.getValue(style, mxConstants.STYLE_FLIPH, 0) == 1;\n\tvar flipV = mxUtils.getValue(style, mxConstants.STYLE_FLIPV, 0) == 1;\n\tvar h = mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true);\n\tvar n = (h) ? 0 : 3;\n\t\n\tif (dir == mxConstants.DIRECTION_NORTH)\n\t{\n\t\tn--;\n\t}\n\telse if (dir == mxConstants.DIRECTION_WEST)\n\t{\n\t\tn += 2;\n\t}\n\telse if (dir == mxConstants.DIRECTION_SOUTH)\n\t{\n\t\tn += 1;\n\t}\n\t\n\tvar mod = mxUtils.mod(n, 2);\n\t\n\tif (flipH && mod == 1)\n\t{\n\t\tn += 2;\n\t}\n\t\n\tif (flipV && mod == 0)\n\t{\n\t\tn += 2;\n\t}\n\t\n\treturn [mxConstants.DIRECTION_NORTH, mxConstants.DIRECTION_EAST,\n\t\tmxConstants.DIRECTION_SOUTH, mxConstants.DIRECTION_WEST]\n\t\t[mxUtils.mod(n, 4)];\n};\n\n/**\n * Function: getActualStartSize\n * \n * Returns the actual start size of the given swimlane taking into account\n * direction and horizontal and vertial flip styles. The start size is\n * returned as an <mxRectangle> where top, left, bottom, right start sizes\n * are returned as x, y, height and width, respectively.\n * \n * Parameters:\n * \n * swimlane - <mxCell> whose start size should be returned.\n * ignoreState - Optional boolean that specifies if cell state should be ignored.\n */\nmxGraph.prototype.getActualStartSize = function(swimlane, ignoreState)\n{\n\tvar result = new mxRectangle();\n\t\n\tif (this.isSwimlane(swimlane, ignoreState))\n\t{\n\t\tvar style = this.getCurrentCellStyle(swimlane, ignoreState);\n\t\tvar size = parseInt(mxUtils.getValue(style, mxConstants.STYLE_STARTSIZE,\n\t\t\tmxConstants.DEFAULT_STARTSIZE));\n\t\tvar dir = this.getSwimlaneDirection(style);\n\t\t\n\t\tif (dir == mxConstants.DIRECTION_NORTH)\n\t\t{\n\t\t\tresult.y = size;\n\t\t}\n\t\telse if (dir == mxConstants.DIRECTION_WEST)\n\t\t{\n\t\t\tresult.x = size;\n\t\t}\n\t\telse if (dir == mxConstants.DIRECTION_SOUTH)\n\t\t{\n\t\t\tresult.height = size;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult.width = size;\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getImage\n * \n * Returns the image URL for the given cell state. This implementation\n * returns the value stored under <mxConstants.STYLE_IMAGE> in the cell\n * style.\n * \n * Parameters:\n * \n * state - <mxCellState> whose image URL should be returned.\n */\nmxGraph.prototype.getImage = function(state)\n{\n\treturn (state != null && state.style != null) ? state.style[mxConstants.STYLE_IMAGE] : null;\n};\n\n/**\n * Function: isTransparentState\n * \n * Returns true if the given state has no stroke- or fillcolor and no image.\n * \n * Parameters:\n * \n * state - <mxCellState> to check.\n */\nmxGraph.prototype.isTransparentState = function(state)\n{\n\tvar result = false;\n\t\n\tif (state != null)\n\t{\n\t\tvar stroke = mxUtils.getValue(state.style, mxConstants.STYLE_STROKECOLOR, mxConstants.NONE);\n\t\tvar fill = mxUtils.getValue(state.style, mxConstants.STYLE_FILLCOLOR, mxConstants.NONE);\n\t\t\n\t\tresult = stroke == mxConstants.NONE && fill == mxConstants.NONE && this.getImage(state) == null;\n\t\t\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getVerticalAlign\n * \n * Returns the vertical alignment for the given cell state. This\n * implementation returns the value stored under\n * <mxConstants.STYLE_VERTICAL_ALIGN> in the cell style.\n * \n * Parameters:\n * \n * state - <mxCellState> whose vertical alignment should be\n * returned.\n */\nmxGraph.prototype.getVerticalAlign = function(state)\n{\n\treturn (state != null && state.style != null) ?\n\t\t(state.style[mxConstants.STYLE_VERTICAL_ALIGN] ||\n\t\tmxConstants.ALIGN_MIDDLE) : null;\n};\n\n/**\n * Function: getIndicatorColor\n * \n * Returns the indicator color for the given cell state. This\n * implementation returns the value stored under\n * <mxConstants.STYLE_INDICATOR_COLOR> in the cell style.\n * \n * Parameters:\n * \n * state - <mxCellState> whose indicator color should be\n * returned.\n */\nmxGraph.prototype.getIndicatorColor = function(state)\n{\n\treturn (state != null && state.style != null) ? state.style[mxConstants.STYLE_INDICATOR_COLOR] : null;\n};\n\n/**\n * Function: getIndicatorGradientColor\n * \n * Returns the indicator gradient color for the given cell state. This\n * implementation returns the value stored under\n * <mxConstants.STYLE_INDICATOR_GRADIENTCOLOR> in the cell style.\n * \n * Parameters:\n * \n * state - <mxCellState> whose indicator gradient color should be\n * returned.\n */\nmxGraph.prototype.getIndicatorGradientColor = function(state)\n{\n\treturn (state != null && state.style != null) ? state.style[mxConstants.STYLE_INDICATOR_GRADIENTCOLOR] : null;\n};\n\n/**\n * Function: getIndicatorShape\n * \n * Returns the indicator shape for the given cell state. This\n * implementation returns the value stored under\n * <mxConstants.STYLE_INDICATOR_SHAPE> in the cell style.\n * \n * Parameters:\n * \n * state - <mxCellState> whose indicator shape should be returned.\n */\nmxGraph.prototype.getIndicatorShape = function(state)\n{\n\treturn (state != null && state.style != null) ? state.style[mxConstants.STYLE_INDICATOR_SHAPE] : null;\n};\n\n/**\n * Function: getIndicatorImage\n * \n * Returns the indicator image for the given cell state. This\n * implementation returns the value stored under\n * <mxConstants.STYLE_INDICATOR_IMAGE> in the cell style.\n * \n * Parameters:\n * \n * state - <mxCellState> whose indicator image should be returned.\n */\nmxGraph.prototype.getIndicatorImage = function(state)\n{\n\treturn (state != null && state.style != null) ? state.style[mxConstants.STYLE_INDICATOR_IMAGE] : null;\n};\n\n/**\n * Function: getBorder\n * \n * Returns the value of <border>.\n */\nmxGraph.prototype.getBorder = function()\n{\n\treturn this.border;\n};\n\n/**\n * Function: setBorder\n * \n * Sets the value of <border>.\n * \n * Parameters:\n * \n * value - Positive integer that represents the border to be used.\n */\nmxGraph.prototype.setBorder = function(value)\n{\n\tthis.border = value;\n};\n\n/**\n * Function: isSwimlane\n * \n * Returns true if the given cell is a swimlane in the graph. A swimlane is\n * a container cell with some specific behaviour. This implementation\n * checks if the shape associated with the given cell is a <mxSwimlane>.\n * \n * Parameters:\n * \n * cell - <mxCell> to be checked.\n * ignoreState - Optional boolean that specifies if the cell state should be ignored.\n */\nmxGraph.prototype.isSwimlane = function(cell, ignoreState)\n{\n\tif (cell != null && this.model.getParent(cell) != this.model.getRoot() &&\n\t\t!this.model.isEdge(cell))\n\t{\n\t\treturn this.getCurrentCellStyle(cell, ignoreState)\n\t\t\t[mxConstants.STYLE_SHAPE] == mxConstants.SHAPE_SWIMLANE;\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Group: Graph behaviour\n */\n\n/**\n * Function: isResizeContainer\n * \n * Returns <resizeContainer>.\n */\nmxGraph.prototype.isResizeContainer = function()\n{\n\treturn this.resizeContainer;\n};\n\n/**\n * Function: setResizeContainer\n * \n * Sets <resizeContainer>.\n * \n * Parameters:\n * \n * value - Boolean indicating if the container should be resized.\n */\nmxGraph.prototype.setResizeContainer = function(value)\n{\n\tthis.resizeContainer = value;\n};\n\n/**\n * Function: isEnabled\n * \n * Returns true if the graph is <enabled>.\n */\nmxGraph.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n * \n * Specifies if the graph should allow any interactions. This\n * implementation updates <enabled>.\n * \n * Parameters:\n * \n * value - Boolean indicating if the graph should be enabled.\n */\nmxGraph.prototype.setEnabled = function(value)\n{\n\tthis.enabled = value;\n};\n\n/**\n * Function: isEscapeEnabled\n * \n * Returns <escapeEnabled>.\n */\nmxGraph.prototype.isEscapeEnabled = function()\n{\n\treturn this.escapeEnabled;\n};\n\n/**\n * Function: setEscapeEnabled\n * \n * Sets <escapeEnabled>.\n * \n * Parameters:\n * \n * enabled - Boolean indicating if escape should be enabled.\n */\nmxGraph.prototype.setEscapeEnabled = function(value)\n{\n\tthis.escapeEnabled = value;\n};\n\n/**\n * Function: isInvokesStopCellEditing\n * \n * Returns <invokesStopCellEditing>.\n */\nmxGraph.prototype.isInvokesStopCellEditing = function()\n{\n\treturn this.invokesStopCellEditing;\n};\n\n/**\n * Function: setInvokesStopCellEditing\n * \n * Sets <invokesStopCellEditing>.\n */\nmxGraph.prototype.setInvokesStopCellEditing = function(value)\n{\n\tthis.invokesStopCellEditing = value;\n};\n\n/**\n * Function: isEnterStopsCellEditing\n * \n * Returns <enterStopsCellEditing>.\n */\nmxGraph.prototype.isEnterStopsCellEditing = function()\n{\n\treturn this.enterStopsCellEditing;\n};\n\n/**\n * Function: setEnterStopsCellEditing\n * \n * Sets <enterStopsCellEditing>.\n */\nmxGraph.prototype.setEnterStopsCellEditing = function(value)\n{\n\tthis.enterStopsCellEditing = value;\n};\n\n/**\n * Function: isCellLocked\n * \n * Returns true if the given cell may not be moved, sized, bended,\n * disconnected, edited or selected. This implementation returns true for\n * all vertices with a relative geometry if <locked> is false.\n * \n * Parameters:\n * \n * cell - <mxCell> whose locked state should be returned.\n */\nmxGraph.prototype.isCellLocked = function(cell)\n{\n\tvar geometry = this.model.getGeometry(cell);\n\t\n\treturn this.isCellsLocked() || (geometry != null && this.model.isVertex(cell) && geometry.relative);\n};\n\n/**\n * Function: isCellsLocked\n * \n * Returns true if the given cell may not be moved, sized, bended,\n * disconnected, edited or selected. This implementation returns true for\n * all vertices with a relative geometry if <locked> is false.\n * \n * Parameters:\n * \n * cell - <mxCell> whose locked state should be returned.\n */\nmxGraph.prototype.isCellsLocked = function()\n{\n\treturn this.cellsLocked;\n};\n\n/**\n * Function: setCellsLocked\n * \n * Sets if any cell may be moved, sized, bended, disconnected, edited or\n * selected.\n * \n * Parameters:\n * \n * value - Boolean that defines the new value for <cellsLocked>.\n */\nmxGraph.prototype.setCellsLocked = function(value)\n{\n\tthis.cellsLocked = value;\n};\n\n/**\n * Function: getCloneableCells\n * \n * Returns the cells which may be exported in the given array of cells.\n */\nmxGraph.prototype.getCloneableCells = function(cells)\n{\n\treturn this.model.filterCells(cells, mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.isCellCloneable(cell);\n\t}));\n};\n\n/**\n * Function: isCellCloneable\n * \n * Returns true if the given cell is cloneable. This implementation returns\n * <isCellsCloneable> for all cells unless a cell style specifies\n * <mxConstants.STYLE_CLONEABLE> to be 0. \n * \n * Parameters:\n * \n * cell - Optional <mxCell> whose cloneable state should be returned.\n */\nmxGraph.prototype.isCellCloneable = function(cell)\n{\n\tvar style = this.getCurrentCellStyle(cell);\n\n\treturn this.isCellsCloneable() && style[mxConstants.STYLE_CLONEABLE] != 0;\n};\n\n/**\n * Function: isCellsCloneable\n * \n * Returns <cellsCloneable>, that is, if the graph allows cloning of cells\n * by using control-drag.\n */\nmxGraph.prototype.isCellsCloneable = function()\n{\n\treturn this.cellsCloneable;\n};\n\n/**\n * Function: setCellsCloneable\n * \n * Specifies if the graph should allow cloning of cells by holding down the\n * control key while cells are being moved. This implementation updates\n * <cellsCloneable>.\n * \n * Parameters:\n * \n * value - Boolean indicating if the graph should be cloneable.\n */\nmxGraph.prototype.setCellsCloneable = function(value)\n{\n\tthis.cellsCloneable = value;\n};\n\n/**\n * Function: getExportableCells\n * \n * Returns the cells which may be exported in the given array of cells.\n */\nmxGraph.prototype.getExportableCells = function(cells)\n{\n\treturn this.model.filterCells(cells, mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.canExportCell(cell);\n\t}));\n};\n\n/**\n * Function: canExportCell\n * \n * Returns true if the given cell may be exported to the clipboard. This\n * implementation returns <exportEnabled> for all cells.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the cell to be exported.\n */\nmxGraph.prototype.canExportCell = function(cell)\n{\n\treturn this.exportEnabled;\n};\n\n/**\n * Function: getImportableCells\n * \n * Returns the cells which may be imported in the given array of cells.\n */\nmxGraph.prototype.getImportableCells = function(cells)\n{\n\treturn this.model.filterCells(cells, mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.canImportCell(cell);\n\t}));\n};\n\n/**\n * Function: canImportCell\n * \n * Returns true if the given cell may be imported from the clipboard.\n * This implementation returns <importEnabled> for all cells.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the cell to be imported.\n */\nmxGraph.prototype.canImportCell = function(cell)\n{\n\treturn this.importEnabled;\n};\n\n/**\n * Function: isCellSelectable\n *\n * Returns true if the given cell is selectable. This implementation\n * returns <cellsSelectable>.\n * \n * To add a new style for making cells (un)selectable, use the following code.\n * \n * (code)\n * mxGraph.prototype.isCellSelectable = function(cell)\n * {\n *   var style = this.getCurrentCellStyle(cell);\n *   \n *   return this.isCellsSelectable() && !this.isCellLocked(cell) && style['selectable'] != 0;\n * };\n * (end)\n * \n * You can then use the new style as shown in this example.\n * \n * (code)\n * graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30, 'selectable=0');\n * (end)\n * \n * Parameters:\n * \n * cell - <mxCell> whose selectable state should be returned.\n */\nmxGraph.prototype.isCellSelectable = function(cell)\n{\n\treturn this.isCellsSelectable();\n};\n\n/**\n * Function: isCellsSelectable\n *\n * Returns <cellsSelectable>.\n */\nmxGraph.prototype.isCellsSelectable = function()\n{\n\treturn this.cellsSelectable;\n};\n\n/**\n * Function: setCellsSelectable\n *\n * Sets <cellsSelectable>.\n */\nmxGraph.prototype.setCellsSelectable = function(value)\n{\n\tthis.cellsSelectable = value;\n};\n\n/**\n * Function: getDeletableCells\n * \n * Returns the cells which may be exported in the given array of cells.\n */\nmxGraph.prototype.getDeletableCells = function(cells)\n{\n\treturn this.model.filterCells(cells, mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.isCellDeletable(cell);\n\t}));\n};\n\n/**\n * Function: isCellDeletable\n *\n * Returns true if the given cell is moveable. This returns\n * <cellsDeletable> for all given cells if a cells style does not specify\n * <mxConstants.STYLE_DELETABLE> to be 0.\n * \n * Parameters:\n * \n * cell - <mxCell> whose deletable state should be returned.\n */\nmxGraph.prototype.isCellDeletable = function(cell)\n{\n\tvar style = this.getCurrentCellStyle(cell);\n\t\n\treturn this.isCellsDeletable() && style[mxConstants.STYLE_DELETABLE] != 0;\n};\n\n/**\n * Function: isCellsDeletable\n *\n * Returns <cellsDeletable>.\n */\nmxGraph.prototype.isCellsDeletable = function()\n{\n\treturn this.cellsDeletable;\n};\n\n/**\n * Function: setCellsDeletable\n * \n * Sets <cellsDeletable>.\n * \n * Parameters:\n * \n * value - Boolean indicating if the graph should allow deletion of cells.\n */\nmxGraph.prototype.setCellsDeletable = function(value)\n{\n\tthis.cellsDeletable = value;\n};\n\n/**\n * Function: isLabelMovable\n *\n * Returns true if the given edges's label is moveable. This returns\n * <movable> for all given cells if <isLocked> does not return true\n * for the given cell.\n * \n * Parameters:\n * \n * cell - <mxCell> whose label should be moved.\n */\nmxGraph.prototype.isLabelMovable = function(cell)\n{\n\treturn !this.isCellLocked(cell) &&\n\t\t((this.model.isEdge(cell) && this.edgeLabelsMovable) ||\n\t\t(this.model.isVertex(cell) && this.vertexLabelsMovable));\n};\n\n/**\n * Function: isCellRotatable\n *\n * Returns true if the given cell is rotatable. This returns true for the given\n * cell if its style does not specify <mxConstants.STYLE_ROTATABLE> to be 0.\n * \n * Parameters:\n * \n * cell - <mxCell> whose rotatable state should be returned.\n */\nmxGraph.prototype.isCellRotatable = function(cell)\n{\n\tvar style = this.getCurrentCellStyle(cell);\n\t\n\treturn style[mxConstants.STYLE_ROTATABLE] != 0;\n};\n\n/**\n * Function: getMovableCells\n * \n * Returns the cells which are movable in the given array of cells.\n */\nmxGraph.prototype.getMovableCells = function(cells)\n{\n\treturn this.model.filterCells(cells, mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.isCellMovable(cell);\n\t}));\n};\n\n/**\n * Function: isCellMovable\n *\n * Returns true if the given cell is moveable. This returns <cellsMovable>\n * for all given cells if <isCellLocked> does not return true for the given\n * cell and its style does not specify <mxConstants.STYLE_MOVABLE> to be 0.\n * \n * Parameters:\n * \n * cell - <mxCell> whose movable state should be returned.\n */\nmxGraph.prototype.isCellMovable = function(cell)\n{\n\tvar style = this.getCurrentCellStyle(cell);\n\t\n\treturn this.isCellsMovable() && !this.isCellLocked(cell) && style[mxConstants.STYLE_MOVABLE] != 0;\n};\n\n/**\n * Function: isCellsMovable\n *\n * Returns <cellsMovable>.\n */\nmxGraph.prototype.isCellsMovable = function()\n{\n\treturn this.cellsMovable;\n};\n\n/**\n * Function: setCellsMovable\n * \n * Specifies if the graph should allow moving of cells. This implementation\n * updates <cellsMsovable>.\n * \n * Parameters:\n * \n * value - Boolean indicating if the graph should allow moving of cells.\n */\nmxGraph.prototype.setCellsMovable = function(value)\n{\n\tthis.cellsMovable = value;\n};\n\n/**\n * Function: isGridEnabled\n *\n * Returns <gridEnabled> as a boolean.\n */\nmxGraph.prototype.isGridEnabled = function()\n{\n\treturn this.gridEnabled;\n};\n\n/**\n * Function: setGridEnabled\n * \n * Specifies if the grid should be enabled.\n * \n * Parameters:\n * \n * value - Boolean indicating if the grid should be enabled.\n */\nmxGraph.prototype.setGridEnabled = function(value)\n{\n\tthis.gridEnabled = value;\n};\n\n/**\n * Function: isPortsEnabled\n *\n * Returns <portsEnabled> as a boolean.\n */\nmxGraph.prototype.isPortsEnabled = function()\n{\n\treturn this.portsEnabled;\n};\n\n/**\n * Function: setPortsEnabled\n * \n * Specifies if the ports should be enabled.\n * \n * Parameters:\n * \n * value - Boolean indicating if the ports should be enabled.\n */\nmxGraph.prototype.setPortsEnabled = function(value)\n{\n\tthis.portsEnabled = value;\n};\n\n/**\n * Function: getGridSize\n *\n * Returns <gridSize>.\n */\nmxGraph.prototype.getGridSize = function()\n{\n\treturn this.gridSize;\n};\n\n/**\n * Function: setGridSize\n * \n * Sets <gridSize>.\n */\nmxGraph.prototype.setGridSize = function(value)\n{\n\tthis.gridSize = value;\n};\n\n/**\n * Function: getTolerance\n *\n * Returns <tolerance>.\n */\nmxGraph.prototype.getTolerance = function()\n{\n\treturn this.tolerance;\n};\n\n/**\n * Function: setTolerance\n * \n * Sets <tolerance>.\n */\nmxGraph.prototype.setTolerance = function(value)\n{\n\tthis.tolerance = value;\n};\n\n/**\n * Function: isVertexLabelsMovable\n *\n * Returns <vertexLabelsMovable>.\n */\nmxGraph.prototype.isVertexLabelsMovable = function()\n{\n\treturn this.vertexLabelsMovable;\n};\n\n/**\n * Function: setVertexLabelsMovable\n * \n * Sets <vertexLabelsMovable>.\n */\nmxGraph.prototype.setVertexLabelsMovable = function(value)\n{\n\tthis.vertexLabelsMovable = value;\n};\n\n/**\n * Function: isEdgeLabelsMovable\n *\n * Returns <edgeLabelsMovable>.\n */\nmxGraph.prototype.isEdgeLabelsMovable = function()\n{\n\treturn this.edgeLabelsMovable;\n};\n\n/**\n * Function: isEdgeLabelsMovable\n * \n * Sets <edgeLabelsMovable>.\n */\nmxGraph.prototype.setEdgeLabelsMovable = function(value)\n{\n\tthis.edgeLabelsMovable = value;\n};\n\n/**\n * Function: isSwimlaneNesting\n *\n * Returns <swimlaneNesting> as a boolean.\n */\nmxGraph.prototype.isSwimlaneNesting = function()\n{\n\treturn this.swimlaneNesting;\n};\n\n/**\n * Function: setSwimlaneNesting\n * \n * Specifies if swimlanes can be nested by drag and drop. This is only\n * taken into account if dropEnabled is true.\n * \n * Parameters:\n * \n * value - Boolean indicating if swimlanes can be nested.\n */\nmxGraph.prototype.setSwimlaneNesting = function(value)\n{\n\tthis.swimlaneNesting = value;\n};\n\n/**\n * Function: isSwimlaneSelectionEnabled\n *\n * Returns <swimlaneSelectionEnabled> as a boolean.\n */\nmxGraph.prototype.isSwimlaneSelectionEnabled = function()\n{\n\treturn this.swimlaneSelectionEnabled;\n};\n\n/**\n * Function: setSwimlaneSelectionEnabled\n * \n * Specifies if swimlanes should be selected if the mouse is released\n * over their content area.\n * \n * Parameters:\n * \n * value - Boolean indicating if swimlanes content areas\n * should be selected when the mouse is released over them.\n */\nmxGraph.prototype.setSwimlaneSelectionEnabled = function(value)\n{\n\tthis.swimlaneSelectionEnabled = value;\n};\n\n/**\n * Function: isMultigraph\n *\n * Returns <multigraph> as a boolean.\n */\nmxGraph.prototype.isMultigraph = function()\n{\n\treturn this.multigraph;\n};\n\n/**\n * Function: setMultigraph\n * \n * Specifies if the graph should allow multiple connections between the\n * same pair of vertices.\n * \n * Parameters:\n * \n * value - Boolean indicating if the graph allows multiple connections\n * between the same pair of vertices.\n */\nmxGraph.prototype.setMultigraph = function(value)\n{\n\tthis.multigraph = value;\n};\n\n/**\n * Function: isAllowLoops\n *\n * Returns <allowLoops> as a boolean.\n */\nmxGraph.prototype.isAllowLoops = function()\n{\n\treturn this.allowLoops;\n};\n\n/**\n * Function: setAllowDanglingEdges\n * \n * Specifies if dangling edges are allowed, that is, if edges are allowed\n * that do not have a source and/or target terminal defined.\n * \n * Parameters:\n * \n * value - Boolean indicating if dangling edges are allowed.\n */\nmxGraph.prototype.setAllowDanglingEdges = function(value)\n{\n\tthis.allowDanglingEdges = value;\n};\n\n/**\n * Function: isAllowDanglingEdges\n *\n * Returns <allowDanglingEdges> as a boolean.\n */\nmxGraph.prototype.isAllowDanglingEdges = function()\n{\n\treturn this.allowDanglingEdges;\n};\n\n/**\n * Function: setConnectableEdges\n * \n * Specifies if edges should be connectable.\n * \n * Parameters:\n * \n * value - Boolean indicating if edges should be connectable.\n */\nmxGraph.prototype.setConnectableEdges = function(value)\n{\n\tthis.connectableEdges = value;\n};\n\n/**\n * Function: isConnectableEdges\n *\n * Returns <connectableEdges> as a boolean.\n */\nmxGraph.prototype.isConnectableEdges = function()\n{\n\treturn this.connectableEdges;\n};\n\n/**\n * Function: setCloneInvalidEdges\n * \n * Specifies if edges should be inserted when cloned but not valid wrt.\n * <getEdgeValidationError>. If false such edges will be silently ignored.\n * \n * Parameters:\n * \n * value - Boolean indicating if cloned invalid edges should be\n * inserted into the graph or ignored.\n */\nmxGraph.prototype.setCloneInvalidEdges = function(value)\n{\n\tthis.cloneInvalidEdges = value;\n};\n\n/**\n * Function: isCloneInvalidEdges\n *\n * Returns <cloneInvalidEdges> as a boolean.\n */\nmxGraph.prototype.isCloneInvalidEdges = function()\n{\n\treturn this.cloneInvalidEdges;\n};\n\n/**\n * Function: setAllowLoops\n * \n * Specifies if loops are allowed.\n * \n * Parameters:\n * \n * value - Boolean indicating if loops are allowed.\n */\nmxGraph.prototype.setAllowLoops = function(value)\n{\n\tthis.allowLoops = value;\n};\n\n/**\n * Function: isDisconnectOnMove\n *\n * Returns <disconnectOnMove> as a boolean.\n */\nmxGraph.prototype.isDisconnectOnMove = function()\n{\n\treturn this.disconnectOnMove;\n};\n\n/**\n * Function: setDisconnectOnMove\n * \n * Specifies if edges should be disconnected when moved. (Note: Cloned\n * edges are always disconnected.)\n * \n * Parameters:\n * \n * value - Boolean indicating if edges should be disconnected\n * when moved.\n */\nmxGraph.prototype.setDisconnectOnMove = function(value)\n{\n\tthis.disconnectOnMove = value;\n};\n\n/**\n * Function: isDropEnabled\n *\n * Returns <dropEnabled> as a boolean.\n */\nmxGraph.prototype.isDropEnabled = function()\n{\n\treturn this.dropEnabled;\n};\n\n/**\n * Function: setDropEnabled\n * \n * Specifies if the graph should allow dropping of cells onto or into other\n * cells.\n * \n * Parameters:\n * \n * dropEnabled - Boolean indicating if the graph should allow dropping\n * of cells into other cells.\n */\nmxGraph.prototype.setDropEnabled = function(value)\n{\n\tthis.dropEnabled = value;\n};\n\n/**\n * Function: isSplitEnabled\n *\n * Returns <splitEnabled> as a boolean.\n */\nmxGraph.prototype.isSplitEnabled = function()\n{\n\treturn this.splitEnabled;\n};\n\n/**\n * Function: setSplitEnabled\n * \n * Specifies if the graph should allow dropping of cells onto or into other\n * cells.\n * \n * Parameters:\n * \n * dropEnabled - Boolean indicating if the graph should allow dropping\n * of cells into other cells.\n */\nmxGraph.prototype.setSplitEnabled = function(value)\n{\n\tthis.splitEnabled = value;\n};\n\n/**\n * Function: isCellResizable\n *\n * Returns true if the given cell is resizable. This returns\n * <cellsResizable> for all given cells if <isCellLocked> does not return\n * true for the given cell and its style does not specify\n * <mxConstants.STYLE_RESIZABLE> to be 0.\n * \n * Parameters:\n * \n * cell - <mxCell> whose resizable state should be returned.\n */\nmxGraph.prototype.isCellResizable = function(cell)\n{\n\tvar style = this.getCurrentCellStyle(cell);\n\n\treturn this.isCellsResizable() && !this.isCellLocked(cell) &&\n\t\tmxUtils.getValue(style, mxConstants.STYLE_RESIZABLE, '1') != '0';\n};\n\n/**\n * Function: isCellsResizable\n *\n * Returns <cellsResizable>.\n */\nmxGraph.prototype.isCellsResizable = function()\n{\n\treturn this.cellsResizable;\n};\n\n/**\n * Function: setCellsResizable\n * \n * Specifies if the graph should allow resizing of cells. This\n * implementation updates <cellsResizable>.\n * \n * Parameters:\n * \n * value - Boolean indicating if the graph should allow resizing of\n * cells.\n */\nmxGraph.prototype.setCellsResizable = function(value)\n{\n\tthis.cellsResizable = value;\n};\n\n/**\n * Function: isTerminalPointMovable\n *\n * Returns true if the given terminal point is movable. This is independent\n * from <isCellConnectable> and <isCellDisconnectable> and controls if terminal\n * points can be moved in the graph if the edge is not connected. Note that it\n * is required for this to return true to connect unconnected edges. This\n * implementation returns true.\n * \n * Parameters:\n * \n * cell - <mxCell> whose terminal point should be moved.\n * source - Boolean indicating if the source or target terminal should be moved.\n */\nmxGraph.prototype.isTerminalPointMovable = function(cell, source)\n{\n\treturn true;\n};\n\n/**\n * Function: isCellBendable\n *\n * Returns true if the given cell is bendable. This returns <cellsBendable>\n * for all given cells if <isLocked> does not return true for the given\n * cell and its style does not specify <mxConstants.STYLE_BENDABLE> to be 0.\n * \n * Parameters:\n * \n * cell - <mxCell> whose bendable state should be returned.\n */\nmxGraph.prototype.isCellBendable = function(cell)\n{\n\tvar style = this.getCurrentCellStyle(cell);\n\t\n\treturn this.isCellsBendable() && !this.isCellLocked(cell) && style[mxConstants.STYLE_BENDABLE] != 0;\n};\n\n/**\n * Function: isCellsBendable\n *\n * Returns <cellsBenadable>.\n */\nmxGraph.prototype.isCellsBendable = function()\n{\n\treturn this.cellsBendable;\n};\n\n/**\n * Function: setCellsBendable\n * \n * Specifies if the graph should allow bending of edges. This\n * implementation updates <bendable>.\n * \n * Parameters:\n * \n * value - Boolean indicating if the graph should allow bending of\n * edges.\n */\nmxGraph.prototype.setCellsBendable = function(value)\n{\n\tthis.cellsBendable = value;\n};\n\n/**\n * Function: isCellEditable\n *\n * Returns true if the given cell is editable. This returns <cellsEditable> for\n * all given cells if <isCellLocked> does not return true for the given cell\n * and its style does not specify <mxConstants.STYLE_EDITABLE> to be 0.\n * \n * Parameters:\n * \n * cell - <mxCell> whose editable state should be returned.\n */\nmxGraph.prototype.isCellEditable = function(cell)\n{\n\tvar style = this.getCurrentCellStyle(cell);\n\t\n\treturn this.isCellsEditable() && !this.isCellLocked(cell) && style[mxConstants.STYLE_EDITABLE] != 0;\n};\n\n/**\n * Function: isCellsEditable\n *\n * Returns <cellsEditable>.\n */\nmxGraph.prototype.isCellsEditable = function()\n{\n\treturn this.cellsEditable;\n};\n\n/**\n * Function: setCellsEditable\n * \n * Specifies if the graph should allow in-place editing for cell labels.\n * This implementation updates <cellsEditable>.\n * \n * Parameters:\n * \n * value - Boolean indicating if the graph should allow in-place\n * editing.\n */\nmxGraph.prototype.setCellsEditable = function(value)\n{\n\tthis.cellsEditable = value;\n};\n\n/**\n * Function: isCellDisconnectable\n *\n * Returns true if the given cell is disconnectable from the source or\n * target terminal. This returns <isCellsDisconnectable> for all given\n * cells if <isCellLocked> does not return true for the given cell.\n * \n * Parameters:\n * \n * cell - <mxCell> whose disconnectable state should be returned.\n * terminal - <mxCell> that represents the source or target terminal.\n * source - Boolean indicating if the source or target terminal is to be\n * disconnected.\n */\nmxGraph.prototype.isCellDisconnectable = function(cell, terminal, source)\n{\n\treturn this.isCellsDisconnectable() && !this.isCellLocked(cell);\n};\n\n/**\n * Function: isCellsDisconnectable\n *\n * Returns <cellsDisconnectable>.\n */\nmxGraph.prototype.isCellsDisconnectable = function()\n{\n\treturn this.cellsDisconnectable;\n};\n\n/**\n * Function: setCellsDisconnectable\n *\n * Sets <cellsDisconnectable>.\n */\nmxGraph.prototype.setCellsDisconnectable = function(value)\n{\n\tthis.cellsDisconnectable = value;\n};\n\n/**\n * Function: isValidSource\n * \n * Returns true if the given cell is a valid source for new connections.\n * This implementation returns true for all non-null values and is\n * called by is called by <isValidConnection>.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents a possible source or null.\n */\nmxGraph.prototype.isValidSource = function(cell)\n{\n\treturn (cell == null && this.allowDanglingEdges) ||\n\t\t(cell != null && (!this.model.isEdge(cell) ||\n\t\tthis.connectableEdges) && this.isCellConnectable(cell));\n};\n\t\n/**\n * Function: isValidTarget\n * \n * Returns <isValidSource> for the given cell. This is called by\n * <isValidConnection>.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents a possible target or null.\n */\nmxGraph.prototype.isValidTarget = function(cell)\n{\n\treturn this.isValidSource(cell);\n};\n\n/**\n * Function: isValidConnection\n * \n * Returns true if the given target cell is a valid target for source.\n * This is a boolean implementation for not allowing connections between\n * certain pairs of vertices and is called by <getEdgeValidationError>.\n * This implementation returns true if <isValidSource> returns true for\n * the source and <isValidTarget> returns true for the target.\n * \n * Parameters:\n * \n * source - <mxCell> that represents the source cell.\n * target - <mxCell> that represents the target cell.\n */\nmxGraph.prototype.isValidConnection = function(source, target)\n{\n\treturn this.isValidSource(source) && this.isValidTarget(target);\n};\n\n/**\n * Function: setConnectable\n * \n * Specifies if the graph should allow new connections. This implementation\n * updates <mxConnectionHandler.enabled> in <connectionHandler>.\n * \n * Parameters:\n * \n * connectable - Boolean indicating if new connections should be allowed.\n */\nmxGraph.prototype.setConnectable = function(connectable)\n{\n\tthis.connectionHandler.setEnabled(connectable);\n};\n\t\n/**\n * Function: isConnectable\n * \n * Returns true if the <connectionHandler> is enabled.\n */\nmxGraph.prototype.isConnectable = function()\n{\n\treturn this.connectionHandler.isEnabled();\n};\n\n/**\n * Function: setTooltips\n * \n * Specifies if tooltips should be enabled. This implementation updates\n * <mxTooltipHandler.enabled> in <tooltipHandler>.\n * \n * Parameters:\n * \n * enabled - Boolean indicating if tooltips should be enabled.\n */\nmxGraph.prototype.setTooltips = function (enabled)\n{\n\tthis.tooltipHandler.setEnabled(enabled);\n};\n\n/**\n * Function: setPanning\n * \n * Specifies if panning should be enabled. This implementation updates\n * <mxPanningHandler.panningEnabled> in <panningHandler>.\n * \n * Parameters:\n * \n * enabled - Boolean indicating if panning should be enabled.\n */\nmxGraph.prototype.setPanning = function(enabled)\n{\n\tthis.panningHandler.panningEnabled = enabled;\n};\n\n/**\n * Function: isEditing\n * \n * Returns true if the given cell is currently being edited.\n * If no cell is specified then this returns true if any\n * cell is currently being edited.\n *\n * Parameters:\n * \n * cell - <mxCell> that should be checked.\n */\nmxGraph.prototype.isEditing = function(cell)\n{\n\tif (this.cellEditor != null)\n\t{\n\t\tvar editingCell = this.cellEditor.getEditingCell();\n\t\t\n\t\treturn (cell == null) ? editingCell != null : cell == editingCell;\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: isAutoSizeCell\n * \n * Returns true if the size of the given cell should automatically be\n * updated after a change of the label. This implementation returns\n * <autoSizeCells> or checks if the cell style does specify\n * <mxConstants.STYLE_AUTOSIZE> to be 1.\n * \n * Parameters:\n * \n * cell - <mxCell> that should be resized.\n */\nmxGraph.prototype.isAutoSizeCell = function(cell)\n{\n\tvar style = this.getCurrentCellStyle(cell);\n\t\n\treturn this.isAutoSizeCells() || style[mxConstants.STYLE_AUTOSIZE] == 1;\n};\n\n/**\n * Function: isAutoSizeCells\n * \n * Returns <autoSizeCells>.\n */\nmxGraph.prototype.isAutoSizeCells = function()\n{\n\treturn this.autoSizeCells;\n};\n\n/**\n * Function: setAutoSizeCells\n * \n * Specifies if cell sizes should be automatically updated after a label\n * change. This implementation sets <autoSizeCells> to the given parameter.\n * To update the size of cells when the cells are added, set\n * <autoSizeCellsOnAdd> to true.\n * \n * Parameters:\n * \n * value - Boolean indicating if cells should be resized\n * automatically.\n */\nmxGraph.prototype.setAutoSizeCells = function(value)\n{\n\tthis.autoSizeCells = value;\n};\n\n/**\n * Function: isExtendParent\n * \n * Returns true if the parent of the given cell should be extended if the\n * child has been resized so that it overlaps the parent. This\n * implementation returns <isExtendParents> if the cell is not an edge.\n * \n * Parameters:\n * \n * cell - <mxCell> that has been resized.\n */\nmxGraph.prototype.isExtendParent = function(cell)\n{\n\treturn !this.getModel().isEdge(cell) && this.isExtendParents();\n};\n\n/**\n * Function: isExtendParents\n * \n * Returns <extendParents>.\n */\nmxGraph.prototype.isExtendParents = function()\n{\n\treturn this.extendParents;\n};\n\n/**\n * Function: setExtendParents\n * \n * Sets <extendParents>.\n * \n * Parameters:\n * \n * value - New boolean value for <extendParents>.\n */\nmxGraph.prototype.setExtendParents = function(value)\n{\n\tthis.extendParents = value;\n};\n\n/**\n * Function: isExtendParentsOnAdd\n * \n * Returns <extendParentsOnAdd>.\n */\nmxGraph.prototype.isExtendParentsOnAdd = function(cell)\n{\n\treturn this.extendParentsOnAdd;\n};\n\n/**\n * Function: setExtendParentsOnAdd\n * \n * Sets <extendParentsOnAdd>.\n * \n * Parameters:\n * \n * value - New boolean value for <extendParentsOnAdd>.\n */\nmxGraph.prototype.setExtendParentsOnAdd = function(value)\n{\n\tthis.extendParentsOnAdd = value;\n};\n\n/**\n * Function: isExtendParentsOnMove\n * \n * Returns <extendParentsOnMove>.\n */\nmxGraph.prototype.isExtendParentsOnMove = function()\n{\n\treturn this.extendParentsOnMove;\n};\n\n/**\n * Function: setExtendParentsOnMove\n * \n * Sets <extendParentsOnMove>.\n * \n * Parameters:\n * \n * value - New boolean value for <extendParentsOnAdd>.\n */\nmxGraph.prototype.setExtendParentsOnMove = function(value)\n{\n\tthis.extendParentsOnMove = value;\n};\n\n/**\n * Function: isRecursiveResize\n * \n * Returns <recursiveResize>.\n * \n * Parameters:\n * \n * state - <mxCellState> that is being resized.\n */\nmxGraph.prototype.isRecursiveResize = function(state)\n{\n\treturn this.recursiveResize;\n};\n\n/**\n * Function: setRecursiveResize\n * \n * Sets <recursiveResize>.\n * \n * Parameters:\n * \n * value - New boolean value for <recursiveResize>.\n */\nmxGraph.prototype.setRecursiveResize = function(value)\n{\n\tthis.recursiveResize = value;\n};\n\n/**\n * Function: isConstrainChild\n * \n * Returns true if the given cell should be kept inside the bounds of its\n * parent according to the rules defined by <getOverlap> and\n * <isAllowOverlapParent>. This implementation returns false for all children\n * of edges and <isConstrainChildren> otherwise.\n * \n * Parameters:\n * \n * cell - <mxCell> that should be constrained.\n */\nmxGraph.prototype.isConstrainChild = function(cell)\n{\n\treturn this.isConstrainChildren() && !this.getModel().isEdge(this.getModel().getParent(cell));\n};\n\n/**\n * Function: isConstrainChildren\n * \n * Returns <constrainChildren>.\n */\nmxGraph.prototype.isConstrainChildren = function()\n{\n\treturn this.constrainChildren;\n};\n\n/**\n * Function: setConstrainChildren\n * \n * Sets <constrainChildren>.\n */\nmxGraph.prototype.setConstrainChildren = function(value)\n{\n\tthis.constrainChildren = value;\n};\n\n/**\n * Function: isConstrainRelativeChildren\n * \n * Returns <constrainRelativeChildren>.\n */\nmxGraph.prototype.isConstrainRelativeChildren = function()\n{\n\treturn this.constrainRelativeChildren;\n};\n\n/**\n * Function: setConstrainRelativeChildren\n * \n * Sets <constrainRelativeChildren>.\n */\nmxGraph.prototype.setConstrainRelativeChildren = function(value)\n{\n\tthis.constrainRelativeChildren = value;\n};\n\n/**\n * Function: isConstrainChildren\n * \n * Returns <allowNegativeCoordinates>.\n */\nmxGraph.prototype.isAllowNegativeCoordinates = function()\n{\n\treturn this.allowNegativeCoordinates;\n};\n\n/**\n * Function: setConstrainChildren\n * \n * Sets <allowNegativeCoordinates>.\n */\nmxGraph.prototype.setAllowNegativeCoordinates = function(value)\n{\n\tthis.allowNegativeCoordinates = value;\n};\n\n/**\n * Function: getOverlap\n * \n * Returns a decimal number representing the amount of the width and height\n * of the given cell that is allowed to overlap its parent. A value of 0\n * means all children must stay inside the parent, 1 means the child is\n * allowed to be placed outside of the parent such that it touches one of\n * the parents sides. If <isAllowOverlapParent> returns false for the given\n * cell, then this method returns 0.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the overlap ratio should be returned.\n */\nmxGraph.prototype.getOverlap = function(cell)\n{\n\treturn (this.isAllowOverlapParent(cell)) ? this.defaultOverlap : 0;\n};\n\t\n/**\n * Function: isAllowOverlapParent\n * \n * Returns true if the given cell is allowed to be placed outside of the\n * parents area.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the child to be checked.\n */\nmxGraph.prototype.isAllowOverlapParent = function(cell)\n{\n\treturn false;\n};\n\n/**\n * Function: getFoldableCells\n * \n * Returns the cells which are movable in the given array of cells.\n */\nmxGraph.prototype.getFoldableCells = function(cells, collapse)\n{\n\treturn this.model.filterCells(cells, mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.isCellFoldable(cell, collapse);\n\t}));\n};\n\n/**\n * Function: isCellFoldable\n * \n * Returns true if the given cell is foldable. This implementation\n * returns true if the cell has at least one child and its style\n * does not specify <mxConstants.STYLE_FOLDABLE> to be 0.\n * \n * Parameters:\n * \n * cell - <mxCell> whose foldable state should be returned.\n */\nmxGraph.prototype.isCellFoldable = function(cell, collapse)\n{\n\tvar style = this.getCurrentCellStyle(cell);\n\t\n\treturn this.model.getChildCount(cell) > 0 && style[mxConstants.STYLE_FOLDABLE] != 0;\n};\n\n/**\n * Function: isValidDropTarget\n *\n * Returns true if the given cell is a valid drop target for the specified\n * cells. If <splitEnabled> is true then this returns <isSplitTarget> for\n * the given arguments else it returns true if the cell is not collapsed\n * and its child count is greater than 0.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the possible drop target.\n * cells - <mxCells> that should be dropped into the target.\n * evt - Mouseevent that triggered the invocation.\n */\nmxGraph.prototype.isValidDropTarget = function(cell, cells, evt)\n{\n\treturn cell != null && ((this.isSplitEnabled() &&\n\t\tthis.isSplitTarget(cell, cells, evt)) || (!this.model.isEdge(cell) &&\n\t\t(this.isSwimlane(cell) || (this.model.getChildCount(cell) > 0 &&\n\t\t!this.isCellCollapsed(cell)))));\n};\n\n/**\n * Function: isSplitTarget\n *\n * Returns true if the given edge may be splitted into two edges with the\n * given cell as a new terminal between the two.\n * \n * Parameters:\n * \n * target - <mxCell> that represents the edge to be splitted.\n * cells - <mxCells> that should split the edge.\n * evt - Mouseevent that triggered the invocation.\n */\nmxGraph.prototype.isSplitTarget = function(target, cells, evt)\n{\n\tif (this.model.isEdge(target) && cells != null && cells.length == 1 &&\n\t\tthis.isCellConnectable(cells[0]) && this.getEdgeValidationError(target,\n\t\t\tthis.model.getTerminal(target, true), cells[0]) == null)\n\t{\n\t\tvar src = this.model.getTerminal(target, true);\n\t\tvar trg = this.model.getTerminal(target, false);\n\n\t\treturn (!this.model.isAncestor(cells[0], src) &&\n\t\t\t\t!this.model.isAncestor(cells[0], trg));\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: getDropTarget\n * \n * Returns the given cell if it is a drop target for the given cells or the\n * nearest ancestor that may be used as a drop target for the given cells.\n * If the given array contains a swimlane and <swimlaneNesting> is false\n * then this always returns null. If no cell is given, then the bottommost\n * swimlane at the location of the given event is returned.\n * \n * This function should only be used if <isDropEnabled> returns true.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> which are to be dropped onto the target.\n * evt - Mouseevent for the drag and drop.\n * cell - <mxCell> that is under the mousepointer.\n * clone - Optional boolean to indicate of cells will be cloned.\n */\nmxGraph.prototype.getDropTarget = function(cells, evt, cell, clone)\n{\n\tif (!this.isSwimlaneNesting())\n\t{\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (this.isSwimlane(cells[i]))\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar pt = mxUtils.convertPoint(this.container,\n\t\tmxEvent.getClientX(evt), mxEvent.getClientY(evt));\n\tpt.x -= this.panDx;\n\tpt.y -= this.panDy;\n\tvar swimlane = this.getSwimlaneAt(pt.x, pt.y);\n\t\n\tif (cell == null)\n\t{\n\t\tcell = swimlane;\n\t}\n\telse if (swimlane != null)\n\t{\n\t\t// Checks if the cell is an ancestor of the swimlane\n\t\t// under the mouse and uses the swimlane in that case\n\t\tvar tmp = this.model.getParent(swimlane);\n\t\t\n\t\twhile (tmp != null && this.isSwimlane(tmp) && tmp != cell)\n\t\t{\n\t\t\ttmp = this.model.getParent(tmp);\n\t\t}\n\t\t\n\t\tif (tmp == cell)\n\t\t{\n\t\t\tcell = swimlane;\n\t\t}\n\t}\n\t\n\twhile (cell != null && !this.isValidDropTarget(cell, cells, evt) &&\n\t\t!this.model.isLayer(cell))\n\t{\n\t\tcell = this.model.getParent(cell);\n\t}\n\t\n\t// Checks if parent is dropped into child if not cloning\n\tif (clone == null || !clone)\n\t{\n\t\tvar parent = cell;\n\t\t\n\t\twhile (parent != null && mxUtils.indexOf(cells, parent) < 0)\n\t\t{\n\t\t\tparent = this.model.getParent(parent);\n\t\t}\n\t}\n\n\treturn (!this.model.isLayer(cell) && parent == null) ? cell : null;\n};\n\n/**\n * Group: Cell retrieval\n */\n\n/**\n * Function: getDefaultParent\n * \n * Returns <defaultParent> or <mxGraphView.currentRoot> or the first child\n * child of <mxGraphModel.root> if both are null. The value returned by\n * this function should be used as the parent for new cells (aka default\n * layer).\n */\nmxGraph.prototype.getDefaultParent = function()\n{\n\tvar parent = this.getCurrentRoot();\n\t\n\tif (parent == null)\n\t{\n\t\tparent = this.defaultParent;\n\t\t\n\t\tif (parent == null)\n\t\t{\n\t\t\tvar root = this.model.getRoot();\n\t\t\tparent = this.model.getChildAt(root, 0);\n\t\t}\n\t}\n\t\n\treturn parent;\n};\n\n/**\n * Function: setDefaultParent\n * \n * Sets the <defaultParent> to the given cell. Set this to null to return\n * the first child of the root in getDefaultParent.\n */\nmxGraph.prototype.setDefaultParent = function(cell)\n{\n\tthis.defaultParent = cell;\n};\n\n/**\n * Function: getSwimlane\n * \n * Returns the nearest ancestor of the given cell which is a swimlane, or\n * the given cell, if it is itself a swimlane.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the ancestor swimlane should be returned.\n */\nmxGraph.prototype.getSwimlane = function(cell)\n{\n\twhile (cell != null && !this.isSwimlane(cell))\n\t{\n\t\tcell = this.model.getParent(cell);\n\t}\n\t\n\treturn cell;\n};\n\n/**\n * Function: getSwimlaneAt\n * \n * Returns the bottom-most swimlane that intersects the given point (x, y)\n * in the cell hierarchy that starts at the given parent.\n * \n * Parameters:\n * \n * x - X-coordinate of the location to be checked.\n * y - Y-coordinate of the location to be checked.\n * parent - <mxCell> that should be used as the root of the recursion.\n * Default is <defaultParent>.\n */\nmxGraph.prototype.getSwimlaneAt = function (x, y, parent)\n{\n\tif (parent == null)\n\t{\n\t\tparent = this.getCurrentRoot();\n\t\t\n\t\tif (parent == null)\n\t\t{\n\t\t\tparent = this.model.getRoot();\n\t\t}\n\t}\n\t\n\tif (parent != null)\n\t{\n\t\tvar childCount = this.model.getChildCount(parent);\n\t\t\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar child = this.model.getChildAt(parent, i);\n\t\t\t\n\t\t\tif (child != null)\n\t\t\t{\n\t\t\t\tvar result = this.getSwimlaneAt(x, y, child);\n\t\t\t\t\n\t\t\t\tif (result != null)\n\t\t\t\t{\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\telse if (this.isCellVisible(child) && this.isSwimlane(child))\n\t\t\t\t{\n\t\t\t\t\tvar state = this.view.getState(child);\n\t\t\t\t\t\n\t\t\t\t\tif (this.intersects(state, x, y))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn child;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: getCellAt\n * \n * Returns the bottom-most cell that intersects the given point (x, y) in\n * the cell hierarchy starting at the given parent. This will also return\n * swimlanes if the given location intersects the content area of the\n * swimlane. If this is not desired, then the <hitsSwimlaneContent> may be\n * used if the returned cell is a swimlane to determine if the location\n * is inside the content area or on the actual title of the swimlane.\n * \n * Parameters:\n * \n * x - X-coordinate of the location to be checked.\n * y - Y-coordinate of the location to be checked.\n * parent - <mxCell> that should be used as the root of the recursion.\n * Default is current root of the view or the root of the model.\n * vertices - Optional boolean indicating if vertices should be returned.\n * Default is true.\n * edges - Optional boolean indicating if edges should be returned. Default\n * is true.\n * ignoreFn - Optional function that returns true if cell should be ignored.\n * The function is passed the cell state and the x and y parameter.\n */\nmxGraph.prototype.getCellAt = function(x, y, parent, vertices, edges, ignoreFn)\n{\n\tvertices = (vertices != null) ? vertices : true;\n\tedges = (edges != null) ? edges : true;\n\n\tif (parent == null)\n\t{\n\t\tparent = this.getCurrentRoot();\n\t\t\n\t\tif (parent == null)\n\t\t{\n\t\t\tparent = this.getModel().getRoot();\n\t\t}\n\t}\n\n\tif (parent != null)\n\t{\n\t\tvar childCount = this.model.getChildCount(parent);\n\t\t\n\t\tfor (var i = childCount - 1; i >= 0; i--)\n\t\t{\n\t\t\tvar cell = this.model.getChildAt(parent, i);\n\t\t\tvar result = this.getCellAt(x, y, cell, vertices, edges, ignoreFn);\n\t\t\t\n\t\t\tif (result != null)\n\t\t\t{\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse if (this.isCellVisible(cell) && (edges && this.model.isEdge(cell) ||\n\t\t\t\tvertices && this.model.isVertex(cell)))\n\t\t\t{\n\t\t\t\tvar state = this.view.getState(cell);\n\n\t\t\t\tif (state != null && (ignoreFn == null || !ignoreFn(state, x, y)) &&\n\t\t\t\t\tthis.intersects(state, x, y))\n\t\t\t\t{\n\t\t\t\t\treturn cell;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: intersects\n * \n * Returns the bottom-most cell that intersects the given point (x, y) in\n * the cell hierarchy that starts at the given parent.\n * \n * Parameters:\n * \n * state - <mxCellState> that represents the cell state.\n * x - X-coordinate of the location to be checked.\n * y - Y-coordinate of the location to be checked.\n */\nmxGraph.prototype.intersects = function(state, x, y)\n{\n\tif (state != null)\n\t{\n\t\tvar pts = state.absolutePoints;\n\n\t\tif (pts != null)\n\t\t{\n\t\t\tvar t2 = this.tolerance * this.tolerance;\n\t\t\tvar pt = pts[0];\n\t\t\t\n\t\t\tfor (var i = 1; i < pts.length; i++)\n\t\t\t{\n\t\t\t\tvar next = pts[i];\n\t\t\t\tvar dist = mxUtils.ptSegDistSq(pt.x, pt.y, next.x, next.y, x, y);\n\t\t\t\t\n\t\t\t\tif (dist <= t2)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpt = next;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar alpha = mxUtils.toRadians(mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION) || 0);\n\t\t\t\n\t\t\tif (alpha != 0)\n\t\t\t{\n\t\t\t\tvar cos = Math.cos(-alpha);\n\t\t\t\tvar sin = Math.sin(-alpha);\n\t\t\t\tvar cx = new mxPoint(state.getCenterX(), state.getCenterY());\n\t\t\t\tvar pt = mxUtils.getRotatedPoint(new mxPoint(x, y), cos, sin, cx);\n\t\t\t\tx = pt.x;\n\t\t\t\ty = pt.y;\n\t\t\t}\n\t\t\t\n\t\t\tif (mxUtils.contains(state, x, y))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: hitsSwimlaneContent\n * \n * Returns true if the given coordinate pair is inside the content\n * are of the given swimlane.\n * \n * Parameters:\n * \n * swimlane - <mxCell> that specifies the swimlane.\n * x - X-coordinate of the mouse event.\n * y - Y-coordinate of the mouse event.\n */\nmxGraph.prototype.hitsSwimlaneContent = function(swimlane, x, y)\n{\n\tvar state = this.getView().getState(swimlane);\n\tvar size = this.getStartSize(swimlane);\n\t\n\tif (state != null)\n\t{\n\t\tvar scale = this.getView().getScale();\n\t\tx -= state.x;\n\t\ty -= state.y;\n\t\t\n\t\tif (size.width > 0 && x > 0 && x > size.width * scale)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse if (size.height > 0 && y > 0 && y > size.height * scale)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: getChildVertices\n * \n * Returns the visible child vertices of the given parent.\n * \n * Parameters:\n * \n * parent - <mxCell> whose children should be returned.\n */\nmxGraph.prototype.getChildVertices = function(parent)\n{\n\treturn this.getChildCells(parent, true, false);\n};\n\t\n/**\n * Function: getChildEdges\n * \n * Returns the visible child edges of the given parent.\n * \n * Parameters:\n * \n * parent - <mxCell> whose child vertices should be returned.\n */\nmxGraph.prototype.getChildEdges = function(parent)\n{\n\treturn this.getChildCells(parent, false, true);\n};\n\n/**\n * Function: getChildCells\n * \n * Returns the visible child vertices or edges in the given parent. If\n * vertices and edges is false, then all children are returned.\n * \n * Parameters:\n * \n * parent - <mxCell> whose children should be returned.\n * vertices - Optional boolean that specifies if child vertices should\n * be returned. Default is false.\n * edges - Optional boolean that specifies if child edges should\n * be returned. Default is false.\n */\nmxGraph.prototype.getChildCells = function(parent, vertices, edges)\n{\n\tparent = (parent != null) ? parent : this.getDefaultParent();\n\tvertices = (vertices != null) ? vertices : false;\n\tedges = (edges != null) ? edges : false;\n\n\tvar cells = this.model.getChildCells(parent, vertices, edges);\n\tvar result = [];\n\n\t// Filters out the non-visible child cells\n\tfor (var i = 0; i < cells.length; i++)\n\t{\n\t\tif (this.isCellVisible(cells[i]))\n\t\t{\n\t\t\tresult.push(cells[i]);\n\t\t}\n\t}\n\n\treturn result;\n};\n\t\n/**\n * Function: getConnections\n * \n * Returns all visible edges connected to the given cell without loops.\n * \n * Parameters:\n * \n * cell - <mxCell> whose connections should be returned.\n * parent - Optional parent of the opposite end for a connection to be\n * returned.\n */\nmxGraph.prototype.getConnections = function(cell, parent)\n{\n\treturn this.getEdges(cell, parent, true, true, false);\n};\n\t\n/**\n * Function: getIncomingEdges\n * \n * Returns the visible incoming edges for the given cell. If the optional\n * parent argument is specified, then only child edges of the given parent\n * are returned.\n * \n * Parameters:\n * \n * cell - <mxCell> whose incoming edges should be returned.\n * parent - Optional parent of the opposite end for an edge to be\n * returned.\n */\nmxGraph.prototype.getIncomingEdges = function(cell, parent)\n{\n\treturn this.getEdges(cell, parent, true, false, false);\n};\n\t\n/**\n * Function: getOutgoingEdges\n * \n * Returns the visible outgoing edges for the given cell. If the optional\n * parent argument is specified, then only child edges of the given parent\n * are returned.\n * \n * Parameters:\n * \n * cell - <mxCell> whose outgoing edges should be returned.\n * parent - Optional parent of the opposite end for an edge to be\n * returned.\n */\nmxGraph.prototype.getOutgoingEdges = function(cell, parent)\n{\n\treturn this.getEdges(cell, parent, false, true, false);\n};\n\t\n/**\n * Function: getEdges\n * \n * Returns the incoming and/or outgoing edges for the given cell.\n * If the optional parent argument is specified, then only edges are returned\n * where the opposite is in the given parent cell. If at least one of incoming\n * or outgoing is true, then loops are ignored, if both are false, then all\n * edges connected to the given cell are returned including loops.\n * \n * Parameters:\n * \n * cell - <mxCell> whose edges should be returned.\n * parent - Optional parent of the opposite end for an edge to be\n * returned.\n * incoming - Optional boolean that specifies if incoming edges should\n * be included in the result. Default is true.\n * outgoing - Optional boolean that specifies if outgoing edges should\n * be included in the result. Default is true.\n * includeLoops - Optional boolean that specifies if loops should be\n * included in the result. Default is true.\n * recurse - Optional boolean the specifies if the parent specified only \n * need be an ancestral parent, true, or the direct parent, false.\n * Default is false\n */\nmxGraph.prototype.getEdges = function(cell, parent, incoming, outgoing, includeLoops, recurse)\n{\n\tincoming = (incoming != null) ? incoming : true;\n\toutgoing = (outgoing != null) ? outgoing : true;\n\tincludeLoops = (includeLoops != null) ? includeLoops : true;\n\trecurse = (recurse != null) ? recurse : false;\n\t\n\tvar edges = [];\n\tvar isCollapsed = this.isCellCollapsed(cell);\n\tvar childCount = this.model.getChildCount(cell);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = this.model.getChildAt(cell, i);\n\n\t\tif (isCollapsed || !this.isCellVisible(child))\n\t\t{\n\t\t\tedges = edges.concat(this.model.getEdges(child, incoming, outgoing));\n\t\t}\n\t}\n\n\tedges = edges.concat(this.model.getEdges(cell, incoming, outgoing));\n\tvar result = [];\n\t\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar state = this.view.getState(edges[i]);\n\t\t\n\t\tvar source = (state != null) ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);\n\t\tvar target = (state != null) ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);\n\n\t\tif ((includeLoops && source == target) || ((source != target) && ((incoming &&\n\t\t\ttarget == cell && (parent == null || this.isValidAncestor(source, parent, recurse))) ||\n\t\t\t(outgoing && source == cell && (parent == null ||\n\t\t\t\t\tthis.isValidAncestor(target, parent, recurse))))))\n\t\t{\n\t\t\tresult.push(edges[i]);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: isValidAncestor\n * \n * Returns whether or not the specified parent is a valid\n * ancestor of the specified cell, either direct or indirectly\n * based on whether ancestor recursion is enabled.\n * \n * Parameters:\n * \n * cell - <mxCell> the possible child cell\n * parent - <mxCell> the possible parent cell\n * recurse - boolean whether or not to recurse the child ancestors\n */\nmxGraph.prototype.isValidAncestor = function(cell, parent, recurse)\n{\n\treturn (recurse ? this.model.isAncestor(parent, cell) : this.model\n\t\t\t.getParent(cell) == parent);\n};\n\n/**\n * Function: getOpposites\n * \n * Returns all distinct visible opposite cells for the specified terminal\n * on the given edges.\n * \n * Parameters:\n * \n * edges - Array of <mxCells> that contains the edges whose opposite\n * terminals should be returned.\n * terminal - Terminal that specifies the end whose opposite should be\n * returned.\n * sources - Optional boolean that specifies if source terminals should be\n * included in the result. Default is true.\n * targets - Optional boolean that specifies if targer terminals should be\n * included in the result. Default is true.\n */\nmxGraph.prototype.getOpposites = function(edges, terminal, sources, targets)\n{\n\tsources = (sources != null) ? sources : true;\n\ttargets = (targets != null) ? targets : true;\n\t\n\tvar terminals = [];\n\t\n\t// Fast lookup to avoid duplicates in terminals array\n\tvar dict = new mxDictionary();\n\t\n\tif (edges != null)\n\t{\n\t\tfor (var i = 0; i < edges.length; i++)\n\t\t{\n\t\t\tvar state = this.view.getState(edges[i]);\n\t\t\t\n\t\t\tvar source = (state != null) ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);\n\t\t\tvar target = (state != null) ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);\n\t\t\t\n\t\t\t// Checks if the terminal is the source of the edge and if the\n\t\t\t// target should be stored in the result\n\t\t\tif (source == terminal && target != null && target != terminal && targets)\n\t\t\t{\n\t\t\t\tif (!dict.get(target))\n\t\t\t\t{\n\t\t\t\t\tdict.put(target, true);\n\t\t\t\t\tterminals.push(target);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Checks if the terminal is the taget of the edge and if the\n\t\t\t// source should be stored in the result\n\t\t\telse if (target == terminal && source != null && source != terminal && sources)\n\t\t\t{\n\t\t\t\tif (!dict.get(source))\n\t\t\t\t{\n\t\t\t\t\tdict.put(source, true);\n\t\t\t\t\tterminals.push(source);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn terminals;\n};\n\n/**\n * Function: getEdgesBetween\n * \n * Returns the edges between the given source and target. This takes into\n * account collapsed and invisible cells and returns the connected edges\n * as displayed on the screen.\n * \n * Parameters:\n * \n * source -\n * target -\n * directed -\n */\nmxGraph.prototype.getEdgesBetween = function(source, target, directed)\n{\n\tdirected = (directed != null) ? directed : false;\n\tvar edges = this.getEdges(source);\n\tvar result = [];\n\n\t// Checks if the edge is connected to the correct\n\t// cell and returns the first match\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar state = this.view.getState(edges[i]);\n\t\t\n\t\tvar src = (state != null) ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);\n\t\tvar trg = (state != null) ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);\n\n\t\tif ((src == source && trg == target) || (!directed && src == target && trg == source))\n\t\t{\n\t\t\tresult.push(edges[i]);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getPointForEvent\n * \n * Returns an <mxPoint> representing the given event in the unscaled,\n * non-translated coordinate space of <container> and applies the grid.\n * \n * Parameters:\n * \n * evt - Mousevent that contains the mouse pointer location.\n * addOffset - Optional boolean that specifies if the position should be\n * offset by half of the <gridSize>. Default is true.\n */\n mxGraph.prototype.getPointForEvent = function(evt, addOffset)\n {\n\tvar p = mxUtils.convertPoint(this.container,\n\t\tmxEvent.getClientX(evt), mxEvent.getClientY(evt));\n\t\n\tvar s = this.view.scale;\n\tvar tr = this.view.translate;\n\tvar off = (addOffset != false) ? this.gridSize / 2 : 0;\n\t\n\tp.x = this.snap(p.x / s - tr.x - off);\n\tp.y = this.snap(p.y / s - tr.y - off);\n\t\n\treturn p;\n};\n\n/**\n * Function: getCells\n * \n * Returns the child vertices and edges of the given parent that are contained\n * in the given rectangle. The result is added to the optional result array,\n * which is returned. If no result array is specified then a new array is\n * created and returned.\n * \n * Parameters:\n * \n * x - X-coordinate of the rectangle.\n * y - Y-coordinate of the rectangle.\n * width - Width of the rectangle.\n * height - Height of the rectangle.\n * parent - <mxCell> that should be used as the root of the recursion.\n * Default is current root of the view or the root of the model.\n * result - Optional array to store the result in.\n * intersection - Optional <mxRectangle> to check vertices for intersection.\n * ignoreFn - Optional function to check if a cell state is ignored.\n * includeDescendants - Optional boolean flag to add descendants to the result.\n * Default is false.\n */\nmxGraph.prototype.getCells = function(x, y, width, height, parent, result, intersection, ignoreFn, includeDescendants)\n{\n\tresult = (result != null) ? result : [];\n\t\n\tif (width > 0 || height > 0 || intersection != null)\n\t{\n\t\tvar model = this.getModel();\n\t\tvar right = x + width;\n\t\tvar bottom = y + height;\n\n\t\tif (parent == null)\n\t\t{\n\t\t\tparent = this.getCurrentRoot();\n\t\t\t\n\t\t\tif (parent == null)\n\t\t\t{\n\t\t\t\tparent = model.getRoot();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (parent != null)\n\t\t{\n\t\t\tvar childCount = model.getChildCount(parent);\n\t\t\t\n\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t{\n\t\t\t\tvar cell = model.getChildAt(parent, i);\n\t\t\t\tvar state = this.view.getState(cell);\n\t\t\t\t\n\t\t\t\tif (state != null && this.isCellVisible(cell) &&\n\t\t\t\t\t(ignoreFn == null || !ignoreFn(state)))\n\t\t\t\t{\n\t\t\t\t\tvar deg = mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION) || 0;\n\t\t\t\t\tvar box = state;\n\t\t\t\t\t\n\t\t\t\t\tif (deg != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbox = mxUtils.getBoundingBox(box, deg);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar hit = (intersection != null && model.isVertex(cell) && mxUtils.intersects(intersection, box)) ||\n\t\t\t\t\t\t(intersection == null && (model.isEdge(cell) || model.isVertex(cell)) &&\n\t\t\t\t\t\tbox.x >= x && box.y + box.height <= bottom &&\n\t\t\t\t\t\tbox.y >= y && box.x + box.width <= right);\n\t\t\t\t\t\n\t\t\t\t\tif (hit)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.push(cell);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!hit || includeDescendants)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.getCells(x, y, width, height, cell, result, intersection, ignoreFn, includeDescendants);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getCellsBeyond\n * \n * Returns the children of the given parent that are contained in the\n * halfpane from the given point (x0, y0) rightwards or downwards\n * depending on rightHalfpane and bottomHalfpane.\n * \n * Parameters:\n * \n * x0 - X-coordinate of the origin.\n * y0 - Y-coordinate of the origin.\n * parent - Optional <mxCell> whose children should be checked. Default is\n * <defaultParent>.\n * rightHalfpane - Boolean indicating if the cells in the right halfpane\n * from the origin should be returned.\n * bottomHalfpane - Boolean indicating if the cells in the bottom halfpane\n * from the origin should be returned.\n */\nmxGraph.prototype.getCellsBeyond = function(x0, y0, parent, rightHalfpane, bottomHalfpane)\n{\n\tvar result = [];\n\t\n\tif (rightHalfpane || bottomHalfpane)\n\t{\n\t\tif (parent == null)\n\t\t{\n\t\t\tparent = this.getDefaultParent();\n\t\t}\n\t\t\n\t\tif (parent != null)\n\t\t{\n\t\t\tvar childCount = this.model.getChildCount(parent);\n\t\t\t\n\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t{\n\t\t\t\tvar child = this.model.getChildAt(parent, i);\n\t\t\t\tvar state = this.view.getState(child);\n\t\t\t\t\n\t\t\t\tif (this.isCellVisible(child) && state != null)\n\t\t\t\t{\n\t\t\t\t\tif ((!rightHalfpane || state.x >= x0) &&\n\t\t\t\t\t\t(!bottomHalfpane || state.y >= y0))\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.push(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: findTreeRoots\n * \n * Returns all children in the given parent which do not have incoming\n * edges. If the result is empty then the with the greatest difference\n * between incoming and outgoing edges is returned.\n * \n * Parameters:\n * \n * parent - <mxCell> whose children should be checked.\n * isolate - Optional boolean that specifies if edges should be ignored if\n * the opposite end is not a child of the given parent cell. Default is\n * false.\n * invert - Optional boolean that specifies if outgoing or incoming edges\n * should be counted for a tree root. If false then outgoing edges will be\n * counted. Default is false.\n */\nmxGraph.prototype.findTreeRoots = function(parent, isolate, invert)\n{\n\tisolate = (isolate != null) ? isolate : false;\n\tinvert = (invert != null) ? invert : false;\n\tvar roots = [];\n\t\n\tif (parent != null)\n\t{\n\t\tvar model = this.getModel();\n\t\tvar childCount = model.getChildCount(parent);\n\t\tvar best = null;\n\t\tvar maxDiff = 0;\n\t\t\n\t\tfor (var i=0; i<childCount; i++)\n\t\t{\n\t\t\tvar cell = model.getChildAt(parent, i);\n\t\t\t\n\t\t\tif (this.model.isVertex(cell) && this.isCellVisible(cell))\n\t\t\t{\n\t\t\t\tvar conns = this.getConnections(cell, (isolate) ? parent : null);\n\t\t\t\tvar fanOut = 0;\n\t\t\t\tvar fanIn = 0;\n\t\t\t\t\n\t\t\t\tfor (var j = 0; j < conns.length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar src = this.view.getVisibleTerminal(conns[j], true);\n\n                    if (src == cell)\n                    {\n                        fanOut++;\n                    }\n                    else\n                    {\n                        fanIn++;\n                    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ((invert && fanOut == 0 && fanIn > 0) ||\n\t\t\t\t\t(!invert && fanIn == 0 && fanOut > 0))\n\t\t\t\t{\n\t\t\t\t\troots.push(cell);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar diff = (invert) ? fanIn - fanOut : fanOut - fanIn;\n\t\t\t\t\n\t\t\t\tif (diff > maxDiff)\n\t\t\t\t{\n\t\t\t\t\tmaxDiff = diff;\n\t\t\t\t\tbest = cell;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (roots.length == 0 && best != null)\n\t\t{\n\t\t\troots.push(best);\n\t\t}\n\t}\n\t\n\treturn roots;\n};\n\n/**\n * Function: traverse\n * \n * Traverses the (directed) graph invoking the given function for each\n * visited vertex and edge. The function is invoked with the current vertex\n * and the incoming edge as a parameter. This implementation makes sure\n * each vertex is only visited once. The function may return false if the\n * traversal should stop at the given vertex.\n * \n * Example:\n * \n * (code)\n * mxLog.show();\n * var cell = graph.getSelectionCell();\n * graph.traverse(cell, false, function(vertex, edge)\n * {\n *   mxLog.debug(graph.getLabel(vertex));\n * });\n * (end)\n * \n * Parameters:\n * \n * vertex - <mxCell> that represents the vertex where the traversal starts.\n * directed - Optional boolean indicating if edges should only be traversed\n * from source to target. Default is true.\n * func - Visitor function that takes the current vertex and the incoming\n * edge as arguments. The traversal stops if the function returns false.\n * edge - Optional <mxCell> that represents the incoming edge. This is\n * null for the first step of the traversal.\n * visited - Optional <mxDictionary> from cells to true for the visited cells.\n * inverse - Optional boolean to traverse in inverse direction. Default is false.\n * This is ignored if directed is false.\n */\nmxGraph.prototype.traverse = function(vertex, directed, func, edge, visited, inverse)\n{\n\tif (func != null && vertex != null)\n\t{\n\t\tdirected = (directed != null) ? directed : true;\n\t\tinverse = (inverse != null) ? inverse : false;\n\t\tvisited = visited || new mxDictionary();\n\t\t\n\t\tif (!visited.get(vertex))\n\t\t{\n\t\t\tvisited.put(vertex, true);\n\t\t\tvar result = func(vertex, edge);\n\t\t\t\n\t\t\tif (result == null || result)\n\t\t\t{\n\t\t\t\tvar edgeCount = this.model.getEdgeCount(vertex);\n\t\t\t\t\n\t\t\t\tif (edgeCount > 0)\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < edgeCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar e = this.model.getEdgeAt(vertex, i);\n\t\t\t\t\t\tvar isSource = this.model.getTerminal(e, true) == vertex;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!directed || (!inverse == isSource))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar next = this.model.getTerminal(e, !isSource);\n\t\t\t\t\t\t\tthis.traverse(next, directed, func, e, visited, inverse);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Group: Selection\n */\n\n/**\n * Function: isCellSelected\n * \n * Returns true if the given cell is selected.\n * \n * Parameters:\n * \n * cell - <mxCell> for which the selection state should be returned.\n */\nmxGraph.prototype.isCellSelected = function(cell)\n{\n\treturn this.getSelectionModel().isSelected(cell);\n};\n\n/**\n * Function: isSelectionEmpty\n * \n * Returns true if the selection is empty.\n */\nmxGraph.prototype.isSelectionEmpty = function()\n{\n\treturn this.getSelectionModel().isEmpty();\n};\n\n/**\n * Function: clearSelection\n * \n * Clears the selection using <mxGraphSelectionModel.clear>.\n */\nmxGraph.prototype.clearSelection = function()\n{\n\treturn this.getSelectionModel().clear();\n};\n\n/**\n * Function: getSelectionCount\n * \n * Returns the number of selected cells.\n */\nmxGraph.prototype.getSelectionCount = function()\n{\n\treturn this.getSelectionModel().cells.length;\n};\n\t\n/**\n * Function: getSelectionCell\n * \n * Returns the first cell from the array of selected <mxCells>.\n */\nmxGraph.prototype.getSelectionCell = function()\n{\n\treturn this.getSelectionModel().cells[0];\n};\n\n/**\n * Function: getSelectionCells\n * \n * Returns the array of selected <mxCells>.\n */\nmxGraph.prototype.getSelectionCells = function()\n{\n\treturn this.getSelectionModel().cells.slice();\n};\n\n/**\n * Function: setSelectionCell\n * \n * Sets the selection cell.\n * \n * Parameters:\n * \n * cell - <mxCell> to be selected.\n */\nmxGraph.prototype.setSelectionCell = function(cell)\n{\n\tthis.getSelectionModel().setCell(cell);\n};\n\n/**\n * Function: setSelectionCells\n * \n * Sets the selection cell.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be selected.\n */\nmxGraph.prototype.setSelectionCells = function(cells)\n{\n\tthis.getSelectionModel().setCells(cells);\n};\n\n/**\n * Function: addSelectionCell\n * \n * Adds the given cell to the selection.\n * \n * Parameters:\n * \n * cell - <mxCell> to be add to the selection.\n */\nmxGraph.prototype.addSelectionCell = function(cell)\n{\n\tthis.getSelectionModel().addCell(cell);\n};\n\n/**\n * Function: addSelectionCells\n * \n * Adds the given cells to the selection.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be added to the selection.\n */\nmxGraph.prototype.addSelectionCells = function(cells)\n{\n\tthis.getSelectionModel().addCells(cells);\n};\n\n/**\n * Function: removeSelectionCell\n * \n * Removes the given cell from the selection.\n * \n * Parameters:\n * \n * cell - <mxCell> to be removed from the selection.\n */\nmxGraph.prototype.removeSelectionCell = function(cell)\n{\n\tthis.getSelectionModel().removeCell(cell);\n};\n\n/**\n * Function: removeSelectionCells\n * \n * Removes the given cells from the selection.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be removed from the selection.\n */\nmxGraph.prototype.removeSelectionCells = function(cells)\n{\n\tthis.getSelectionModel().removeCells(cells);\n};\n\n/**\n * Function: selectRegion\n * \n * Selects and returns the cells inside the given rectangle for the\n * specified event.\n * \n * Parameters:\n * \n * rect - <mxRectangle> that represents the region to be selected.\n * evt - Mouseevent that triggered the selection.\n */\nmxGraph.prototype.selectRegion = function(rect, evt)\n{\n\tvar cells = this.getCells(rect.x, rect.y, rect.width, rect.height);\n\tthis.selectCellsForEvent(cells, evt);\n\t\n\treturn cells;\n};\n\n/**\n * Function: selectNextCell\n * \n * Selects the next cell.\n */\nmxGraph.prototype.selectNextCell = function()\n{\n\tthis.selectCell(true);\n};\n\n/**\n * Function: selectPreviousCell\n * \n * Selects the previous cell.\n */\nmxGraph.prototype.selectPreviousCell = function()\n{\n\tthis.selectCell();\n};\n\n/**\n * Function: selectParentCell\n * \n * Selects the parent cell.\n */\nmxGraph.prototype.selectParentCell = function()\n{\n\tthis.selectCell(false, true);\n};\n\n/**\n * Function: selectChildCell\n * \n * Selects the first child cell.\n */\nmxGraph.prototype.selectChildCell = function()\n{\n\tthis.selectCell(false, false, true);\n};\n\n/**\n * Function: selectCell\n * \n * Selects the next, parent, first child or previous cell, if all arguments\n * are false.\n * \n * Parameters:\n * \n * isNext - Boolean indicating if the next cell should be selected.\n * isParent - Boolean indicating if the parent cell should be selected.\n * isChild - Boolean indicating if the first child cell should be selected.\n */\nmxGraph.prototype.selectCell = function(isNext, isParent, isChild)\n{\n\tvar sel = this.selectionModel;\n\tvar cell = (sel.cells.length > 0) ? sel.cells[0] : null;\n\t\n\tif (sel.cells.length > 1)\n\t{\n\t\tsel.clear();\n\t}\n\t\n\tvar parent = (cell != null) ?\n\t\tthis.model.getParent(cell) :\n\t\tthis.getDefaultParent();\n\t\n\tvar childCount = this.model.getChildCount(parent);\n\t\n\tif (cell == null && childCount > 0)\n\t{\n\t\tvar child = this.model.getChildAt(parent, 0);\n\t\tthis.setSelectionCell(child);\n\t}\n\telse if ((cell == null || isParent) &&\n\t\tthis.view.getState(parent) != null &&\n\t\tthis.model.getGeometry(parent) != null)\n\t{\n\t\tif (this.getCurrentRoot() != parent)\n\t\t{\n\t\t\tthis.setSelectionCell(parent);\n\t\t}\n\t}\n\telse if (cell != null && isChild)\n\t{\n\t\tvar tmp = this.model.getChildCount(cell);\n\t\t\n\t\tif (tmp > 0)\n\t\t{\n\t\t\tvar child = this.model.getChildAt(cell, 0);\n\t\t\tthis.setSelectionCell(child);\n\t\t}\n\t}\n\telse if (childCount > 0)\n\t{\n\t\tvar i = parent.getIndex(cell);\n\t\t\n\t\tif (isNext)\n\t\t{\n\t\t\ti++;\n\t\t\tvar child = this.model.getChildAt(parent, i % childCount);\n\t\t\tthis.setSelectionCell(child);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti--;\n\t\t\tvar index =  (i < 0) ? childCount - 1 : i;\n\t\t\tvar child = this.model.getChildAt(parent, index);\n\t\t\tthis.setSelectionCell(child);\n\t\t}\n\t}\n};\n\n/**\n * Function: selectAll\n * \n * Selects all children of the given parent cell or the children of the\n * default parent if no parent is specified. To select leaf vertices and/or\n * edges use <selectCells>.\n * \n * Parameters:\n * \n * parent - Optional <mxCell> whose children should be selected.\n * Default is <defaultParent>.\n * descendants - Optional boolean specifying whether all descendants should be\n * selected. Default is false.\n */\nmxGraph.prototype.selectAll = function(parent, descendants)\n{\n\tparent = parent || this.getDefaultParent();\n\t\n\tvar cells = (descendants) ? this.model.filterDescendants(mxUtils.bind(this, function(cell)\n\t{\n\t\treturn cell != parent && this.view.getState(cell) != null;\n\t}), parent) : this.model.getChildren(parent);\n\t\n\tif (cells != null)\n\t{\n\t\tthis.setSelectionCells(cells);\n\t}\n};\n\n/**\n * Function: selectVertices\n * \n * Select all vertices inside the given parent or the default parent.\n */\nmxGraph.prototype.selectVertices = function(parent, selectGroups)\n{\n\tthis.selectCells(true, false, parent, selectGroups);\n};\n\n/**\n * Function: selectVertices\n * \n * Select all vertices inside the given parent or the default parent.\n */\nmxGraph.prototype.selectEdges = function(parent)\n{\n\tthis.selectCells(false, true, parent);\n};\n\n/**\n * Function: selectCells\n * \n * Selects all vertices and/or edges depending on the given boolean\n * arguments recursively, starting at the given parent or the default\n * parent if no parent is specified. Use <selectAll> to select all cells.\n * For vertices, only cells with no children are selected.\n * \n * Parameters:\n * \n * vertices - Boolean indicating if vertices should be selected.\n * edges - Boolean indicating if edges should be selected.\n * parent - Optional <mxCell> that acts as the root of the recursion.\n * Default is <defaultParent>.\n * selectGroups - Optional boolean that specifies if groups should be\n * selected. Default is false.\n */\nmxGraph.prototype.selectCells = function(vertices, edges, parent, selectGroups)\n{\n\tparent = parent || this.getDefaultParent();\n\t\n\tvar filter = mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.view.getState(cell) != null &&\n\t\t\t(((selectGroups || this.model.getChildCount(cell) == 0) &&\n\t\t\tthis.model.isVertex(cell) && vertices\n\t\t\t&& !this.model.isEdge(this.model.getParent(cell))) ||\n\t\t\t(this.model.isEdge(cell) && edges));\n\t});\n\t\n\tvar cells = this.model.filterDescendants(filter, parent);\n\t\n\tif (cells != null)\n\t{\n\t\tthis.setSelectionCells(cells);\n\t}\n};\n\n/**\n * Function: selectCellForEvent\n * \n * Selects the given cell by either adding it to the selection or\n * replacing the selection depending on whether the given mouse event is a\n * toggle event.\n * \n * Parameters:\n * \n * cell - <mxCell> to be selected.\n * evt - Optional mouseevent that triggered the selection.\n */\nmxGraph.prototype.selectCellForEvent = function(cell, evt)\n{\n\tvar isSelected = this.isCellSelected(cell);\n\t\n\tif (this.isToggleEvent(evt))\n\t{\n\t\tif (isSelected)\n\t\t{\n\t\t\tthis.removeSelectionCell(cell);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.addSelectionCell(cell);\n\t\t}\n\t}\n\telse if (!isSelected || this.getSelectionCount() != 1)\n\t{\n\t\tthis.setSelectionCell(cell);\n\t}\n};\n\n/**\n * Function: selectCellsForEvent\n * \n * Selects the given cells by either adding them to the selection or\n * replacing the selection depending on whether the given mouse event is a\n * toggle event.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> to be selected.\n * evt - Optional mouseevent that triggered the selection.\n */\nmxGraph.prototype.selectCellsForEvent = function(cells, evt)\n{\n\tif (this.isToggleEvent(evt))\n\t{\n\t\tthis.addSelectionCells(cells);\n\t}\n\telse\n\t{\n\t\tthis.setSelectionCells(cells);\n\t}\n};\n\n/**\n * Group: Selection state\n */\n\n/**\n * Function: createHandler\n * \n * Creates a new handler for the given cell state. This implementation\n * returns a new <mxEdgeHandler> of the corresponding cell is an edge,\n * otherwise it returns an <mxVertexHandler>.\n * \n * Parameters:\n * \n * state - <mxCellState> whose handler should be created.\n */\nmxGraph.prototype.createHandler = function(state)\n{\n\tvar result = null;\n\t\n\tif (state != null)\n\t{\n\t\tif (this.model.isEdge(state.cell))\n\t\t{\n\t\t\tvar source = state.getVisibleTerminalState(true);\n\t\t\tvar target = state.getVisibleTerminalState(false);\n\t\t\tvar geo = this.getCellGeometry(state.cell);\n\t\t\t\n\t\t\tvar edgeStyle = this.view.getEdgeStyle(state, (geo != null) ? geo.points : null, source, target);\n\t\t\tresult = this.createEdgeHandler(state, edgeStyle);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = this.createVertexHandler(state);\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: createVertexHandler\n * \n * Hooks to create a new <mxVertexHandler> for the given <mxCellState>.\n * \n * Parameters:\n * \n * state - <mxCellState> to create the handler for.\n */\nmxGraph.prototype.createVertexHandler = function(state)\n{\n\treturn new mxVertexHandler(state);\n};\n\n/**\n * Function: createEdgeHandler\n * \n * Hooks to create a new <mxEdgeHandler> for the given <mxCellState>.\n * \n * Parameters:\n * \n * state - <mxCellState> to create the handler for.\n */\nmxGraph.prototype.createEdgeHandler = function(state, edgeStyle)\n{\n\tvar result = null;\n\t\n\tif (edgeStyle == mxEdgeStyle.Loop ||\n\t\tedgeStyle == mxEdgeStyle.ElbowConnector ||\n\t\tedgeStyle == mxEdgeStyle.SideToSide ||\n\t\tedgeStyle == mxEdgeStyle.TopToBottom)\n\t{\n\t\tresult = this.createElbowEdgeHandler(state);\n\t}\n\telse if (edgeStyle == mxEdgeStyle.SegmentConnector || \n\t\t\tedgeStyle == mxEdgeStyle.OrthConnector)\n\t{\n\t\tresult = this.createEdgeSegmentHandler(state);\n\t}\n\telse\n\t{\n\t\tresult = new mxEdgeHandler(state);\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: createEdgeSegmentHandler\n * \n * Hooks to create a new <mxEdgeSegmentHandler> for the given <mxCellState>.\n * \n * Parameters:\n * \n * state - <mxCellState> to create the handler for.\n */\nmxGraph.prototype.createEdgeSegmentHandler = function(state)\n{\n\treturn new mxEdgeSegmentHandler(state);\n};\n\n/**\n * Function: createElbowEdgeHandler\n * \n * Hooks to create a new <mxElbowEdgeHandler> for the given <mxCellState>.\n * \n * Parameters:\n * \n * state - <mxCellState> to create the handler for.\n */\nmxGraph.prototype.createElbowEdgeHandler = function(state)\n{\n\treturn new mxElbowEdgeHandler(state);\n};\n\n/**\n * Group: Graph events\n */\n\n/**\n * Function: addMouseListener\n * \n * Adds a listener to the graph event dispatch loop. The listener\n * must implement the mouseDown, mouseMove and mouseUp methods\n * as shown in the <mxMouseEvent> class.\n * \n * Parameters:\n * \n * listener - Listener to be added to the graph event listeners.\n */\nmxGraph.prototype.addMouseListener = function(listener)\n{\n\tif (this.mouseListeners == null)\n\t{\n\t\tthis.mouseListeners = [];\n\t}\n\t\n\tthis.mouseListeners.push(listener);\n};\n\n/**\n * Function: removeMouseListener\n * \n * Removes the specified graph listener.\n * \n * Parameters:\n * \n * listener - Listener to be removed from the graph event listeners.\n */\nmxGraph.prototype.removeMouseListener = function(listener)\n{\n\tif (this.mouseListeners != null)\n\t{\n\t\tfor (var i = 0; i < this.mouseListeners.length; i++)\n\t\t{\n\t\t\tif (this.mouseListeners[i] == listener)\n\t\t\t{\n\t\t\t\tthis.mouseListeners.splice(i, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: updateMouseEvent\n * \n * Sets the graphX and graphY properties if the given <mxMouseEvent> if\n * required and returned the event.\n * \n * Parameters:\n * \n * me - <mxMouseEvent> to be updated.\n * evtName - Name of the mouse event.\n */\nmxGraph.prototype.updateMouseEvent = function(me, evtName)\n{\n\tif (me.graphX == null || me.graphY == null)\n\t{\n\t\tvar pt = mxUtils.convertPoint(this.container, me.getX(), me.getY());\n\t\t\n\t\tme.graphX = pt.x - this.panDx;\n\t\tme.graphY = pt.y - this.panDy;\n\t\t\n\t\t// Searches for rectangles using method if native hit detection is disabled on shape\n\t\tif (me.getCell() == null && this.isMouseDown && evtName == mxEvent.MOUSE_MOVE)\n\t\t{\n\t\t\tme.state = this.view.getState(this.getCellAt(pt.x, pt.y, null, null, null, function(state)\n\t\t\t{\n\t\t\t\treturn state.shape == null || state.shape.paintBackground != mxRectangleShape.prototype.paintBackground ||\n\t\t\t\t\tmxUtils.getValue(state.style, mxConstants.STYLE_POINTER_EVENTS, '1') == '1' ||\n\t\t\t\t\t(state.shape.fill != null && state.shape.fill != mxConstants.NONE);\n\t\t\t}));\n\t\t}\n\t}\n\t\n\treturn me;\n};\n\n/**\n * Function: getStateForEvent\n * \n * Returns the state for the given touch event.\n */\nmxGraph.prototype.getStateForTouchEvent = function(evt)\n{\n\tvar x = mxEvent.getClientX(evt);\n\tvar y = mxEvent.getClientY(evt);\n\t\n\t// Dispatches the drop event to the graph which\n\t// consumes and executes the source function\n\tvar pt = mxUtils.convertPoint(this.container, x, y);\n\n\treturn this.view.getState(this.getCellAt(pt.x, pt.y));\n};\n\n/**\n * Function: isEventIgnored\n * \n * Returns true if the event should be ignored in <fireMouseEvent>.\n */\nmxGraph.prototype.isEventIgnored = function(evtName, me, sender)\n{\n\tvar mouseEvent = mxEvent.isMouseEvent(me.getEvent());\n\tvar result = false;\n\n\t// Drops events that are fired more than once\n\tif (me.getEvent() == this.lastEvent)\n\t{\n\t\tresult = true;\n\t}\n\telse\n\t{\n\t\tthis.lastEvent = me.getEvent();\n\t}\n\n\t// Installs event listeners to capture the complete gesture from the event source\n\t// for non-MS touch events as a workaround for all events for the same geture being\n\t// fired from the event source even if that was removed from the DOM.\n\tif (this.eventSource != null && evtName != mxEvent.MOUSE_MOVE)\n\t{\n\t\tmxEvent.removeGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);\n\t\tthis.mouseMoveRedirect = null;\n\t\tthis.mouseUpRedirect = null;\n\t\tthis.eventSource = null;\n\t}\n\telse if (!mxClient.IS_GC && this.eventSource != null && me.getSource() != this.eventSource)\n\t{\n\t\tresult = true;\n\t}\n\telse if (mxClient.IS_TOUCH && evtName == mxEvent.MOUSE_DOWN &&\n\t\t\t!mouseEvent && !mxEvent.isPenEvent(me.getEvent()))\n\t{\n\t\tthis.eventSource = me.getSource();\n\n\t\tthis.mouseMoveRedirect = mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tthis.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, this.getStateForTouchEvent(evt)));\n\t\t});\n\t\tthis.mouseUpRedirect = mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tthis.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, this.getStateForTouchEvent(evt)));\n\t\t});\n\t\t\n\t\tmxEvent.addGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);\n\t}\n\n\t// Factored out the workarounds for FF to make it easier to override/remove\n\t// Note this method has side-effects!\n\tif (this.isSyntheticEventIgnored(evtName, me, sender))\n\t{\n\t\tresult = true;\n\t}\n\n\t// Never fires mouseUp/-Down for double clicks\n\tif (!mxEvent.isPopupTrigger(this.lastEvent) && evtName != mxEvent.MOUSE_MOVE && this.lastEvent.detail == 2)\n\t{\n\t\treturn true;\n\t}\n\t\n\t// Filters out of sequence events or mixed event types during a gesture\n\tif (evtName == mxEvent.MOUSE_UP && this.isMouseDown)\n\t{\n\t\tthis.isMouseDown = false;\n\t}\n\telse if (evtName == mxEvent.MOUSE_DOWN && !this.isMouseDown)\n\t{\n\t\tthis.isMouseDown = true;\n\t\tthis.isMouseTrigger = mouseEvent;\n\t}\n\t// Drops mouse events that are fired during touch gestures as a workaround for Webkit\n\t// and mouse events that are not in sync with the current internal button state\n\telse if (!result && (((!mxClient.IS_FF || evtName != mxEvent.MOUSE_MOVE) &&\n\t\tthis.isMouseDown && this.isMouseTrigger != mouseEvent) ||\n\t\t(evtName == mxEvent.MOUSE_DOWN && this.isMouseDown) ||\n\t\t(evtName == mxEvent.MOUSE_UP && !this.isMouseDown)))\n\t{\n\t\tresult = true;\n\t}\n\t\n\tif (!result && evtName == mxEvent.MOUSE_DOWN)\n\t{\n\t\tthis.lastMouseX = me.getX();\n\t\tthis.lastMouseY = me.getY();\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: isSyntheticEventIgnored\n * \n * Hook for ignoring synthetic mouse events after touchend in Firefox.\n */\nmxGraph.prototype.isSyntheticEventIgnored = function(evtName, me, sender)\n{\n\tvar result = false;\n\tvar mouseEvent = mxEvent.isMouseEvent(me.getEvent());\n\t\n\t// LATER: This does not cover all possible cases that can go wrong in FF\n\tif (this.ignoreMouseEvents && mouseEvent && evtName != mxEvent.MOUSE_MOVE)\n\t{\n\t\tthis.ignoreMouseEvents = evtName != mxEvent.MOUSE_UP;\n\t\tresult = true;\n\t}\n\telse if (mxClient.IS_FF && !mouseEvent && evtName == mxEvent.MOUSE_UP)\n\t{\n\t\tthis.ignoreMouseEvents = true;\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: isEventSourceIgnored\n * \n * Returns true if the event should be ignored in <fireMouseEvent>. This\n * implementation returns true for select, option and input (if not of type\n * checkbox, radio, button, submit or file) event sources if the event is not\n * a mouse event or a left mouse button press event.\n * \n * Parameters:\n * \n * evtName - The name of the event.\n * me - <mxMouseEvent> that should be ignored.\n */\nmxGraph.prototype.isEventSourceIgnored = function(evtName, me)\n{\n\tvar source = me.getSource();\n\tvar name = (source.nodeName != null) ? source.nodeName.toLowerCase() : '';\n\tvar candidate = !mxEvent.isMouseEvent(me.getEvent()) || mxEvent.isLeftMouseButton(me.getEvent());\n\t\n\treturn evtName == mxEvent.MOUSE_DOWN && candidate && (name == 'select' || name == 'option' ||\n\t\t(name == 'input' && source.type != 'checkbox' && source.type != 'radio' &&\n\t\tsource.type != 'button' && source.type != 'submit' && source.type != 'file'));\n};\n\n/**\n * Function: getEventState\n * \n * Returns the <mxCellState> to be used when firing the mouse event for the\n * given state. This implementation returns the given state.\n * \n * Parameters:\n * \n * <mxCellState> - State whose event source should be returned.\n */\nmxGraph.prototype.getEventState = function(state)\n{\n\treturn state;\n};\n\n/**\n * Function: fireMouseEvent\n * \n * Dispatches the given event in the graph event dispatch loop. Possible\n * event names are <mxEvent.MOUSE_DOWN>, <mxEvent.MOUSE_MOVE> and\n * <mxEvent.MOUSE_UP>. All listeners are invoked for all events regardless\n * of the consumed state of the event.\n * \n * Parameters:\n * \n * evtName - String that specifies the type of event to be dispatched.\n * me - <mxMouseEvent> to be fired.\n * sender - Optional sender argument. Default is this.\n */\nmxGraph.prototype.fireMouseEvent = function(evtName, me, sender)\n{\n\tif (this.isEventSourceIgnored(evtName, me))\n\t{\n\t\tif (this.tooltipHandler != null)\n\t\t{\n\t\t\tthis.tooltipHandler.hide();\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\t\n\tif (sender == null)\n\t{\n\t\tsender = this;\n\t}\n\n\t// Updates the graph coordinates in the event\n\tme = this.updateMouseEvent(me, evtName);\n\n\t// Detects and processes double taps for touch-based devices which do not have native double click events\n\t// or where detection of double click is not always possible (quirks, IE10+). Note that this can only handle\n\t// double clicks on cells because the sequence of events in IE prevents detection on the background, it fires\n\t// two mouse ups, one of which without a cell but no mousedown for the second click which means we cannot\n\t// detect which mouseup(s) are part of the first click, ie we do not know when the first click ends.\n\tif ((!this.nativeDblClickEnabled && !mxEvent.isPopupTrigger(me.getEvent())) || (this.doubleTapEnabled &&\n\t\tmxClient.IS_TOUCH && (mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent()))))\n\t{\n\t\tvar currentTime = new Date().getTime();\n\t\t\n\t\t// NOTE: Second mouseDown for double click missing in quirks mode\n\t\tif ((!mxClient.IS_QUIRKS && evtName == mxEvent.MOUSE_DOWN) || (mxClient.IS_QUIRKS && evtName == mxEvent.MOUSE_UP && !this.fireDoubleClick))\n\t\t{\n\t\t\tif (this.lastTouchEvent != null && this.lastTouchEvent != me.getEvent() &&\n\t\t\t\tcurrentTime - this.lastTouchTime < this.doubleTapTimeout &&\n\t\t\t\tMath.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance &&\n\t\t\t\tMath.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance &&\n\t\t\t\tthis.doubleClickCounter < 2)\n\t\t\t{\n\t\t\t\tthis.doubleClickCounter++;\n\t\t\t\tvar doubleClickFired = false;\n\t\t\t\t\n\t\t\t\tif (evtName == mxEvent.MOUSE_UP)\n\t\t\t\t{\n\t\t\t\t\tif (me.getCell() == this.lastTouchCell && this.lastTouchCell != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.lastTouchTime = 0;\n\t\t\t\t\t\tvar cell = this.lastTouchCell;\n\t\t\t\t\t\tthis.lastTouchCell = null;\n\n\t\t\t\t\t\t// Fires native dblclick event via event source\n\t\t\t\t\t\t// NOTE: This fires two double click events on edges in quirks mode. While\n\t\t\t\t\t\t// trying to fix this, we realized that nativeDoubleClick can be disabled for\n\t\t\t\t\t\t// quirks and IE10+ (or we didn't find the case mentioned above where it\n\t\t\t\t\t\t// would not work), ie. all double clicks seem to be working without this.\n\t\t\t\t\t\tif (mxClient.IS_QUIRKS)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tme.getSource().fireEvent('ondblclick');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.dblClick(me.getEvent(), cell);\n\t\t\t\t\t\tdoubleClickFired = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.fireDoubleClick = true;\n\t\t\t\t\tthis.lastTouchTime = 0;\n\t\t\t\t}\n\n\t\t\t\t// Do not ignore mouse up in quirks in this case\n\t\t\t\tif (!mxClient.IS_QUIRKS || doubleClickFired)\n\t\t\t\t{\n\t\t\t\t\tmxEvent.consume(me.getEvent());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (this.lastTouchEvent == null || this.lastTouchEvent != me.getEvent())\n\t\t\t{\n\t\t\t\tthis.lastTouchCell = me.getCell();\n\t\t\t\tthis.lastTouchX = me.getX();\n\t\t\t\tthis.lastTouchY = me.getY();\n\t\t\t\tthis.lastTouchTime = currentTime;\n\t\t\t\tthis.lastTouchEvent = me.getEvent();\n\t\t\t\tthis.doubleClickCounter = 0;\n\t\t\t}\n\t\t}\n\t\telse if ((this.isMouseDown || evtName == mxEvent.MOUSE_UP) && this.fireDoubleClick)\n\t\t{\n\t\t\tthis.fireDoubleClick = false;\n\t\t\tvar cell = this.lastTouchCell;\n\t\t\tthis.lastTouchCell = null;\n\t\t\tthis.isMouseDown = false;\n\t\t\t\n\t\t\t// Workaround for Chrome/Safari not firing native double click events for double touch on background\n\t\t\tvar valid = (cell != null) || ((mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent())) &&\n\t\t\t\t(mxClient.IS_GC || mxClient.IS_SF));\n\t\t\t\n\t\t\tif (valid && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance &&\n\t\t\t\tMath.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance)\n\t\t\t{\n\t\t\t\tthis.dblClick(me.getEvent(), cell);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmxEvent.consume(me.getEvent());\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!this.isEventIgnored(evtName, me, sender))\n\t{\n\t\t// Updates the event state via getEventState\n\t\tme.state = this.getEventState(me.getState());\n\t\tthis.fireEvent(new mxEventObject(mxEvent.FIRE_MOUSE_EVENT, 'eventName', evtName, 'event', me));\n\t\t\n\t\tif ((mxClient.IS_OP || mxClient.IS_SF || mxClient.IS_GC || mxClient.IS_IE11 ||\n\t\t\t(mxClient.IS_IE && mxClient.IS_SVG) || me.getEvent().target != this.container))\n\t\t{\n\t\t\tif (evtName == mxEvent.MOUSE_MOVE && this.isMouseDown && this.autoScroll && !mxEvent.isMultiTouchEvent(me.getEvent))\n\t\t\t{\n\t\t\t\tthis.scrollPointToVisible(me.getGraphX(), me.getGraphY(), this.autoExtend);\n\t\t\t}\n\t\t\telse if (evtName == mxEvent.MOUSE_UP && this.ignoreScrollbars && this.translateToScrollPosition &&\n\t\t\t\t\t(this.container.scrollLeft != 0 || this.container.scrollTop != 0))\n\t\t\t{\n\t\t\t\tvar s = this.view.scale;\n\t\t\t\tvar tr = this.view.translate;\n\t\t\t\tthis.view.setTranslate(tr.x - this.container.scrollLeft / s, tr.y - this.container.scrollTop / s);\n\t\t\t\tthis.container.scrollLeft = 0;\n\t\t\t\tthis.container.scrollTop = 0;\n\t\t\t}\n\t\t\t\n\t\t\tif (this.mouseListeners != null)\n\t\t\t{\n\t\t\t\tvar args = [sender, me];\n\t\n\t\t\t\t// Does not change returnValue in Opera\n\t\t\t\tif (!me.getEvent().preventDefault)\n\t\t\t\t{\n\t\t\t\t\tme.getEvent().returnValue = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (var i = 0; i < this.mouseListeners.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar l = this.mouseListeners[i];\n\t\t\t\t\t\n\t\t\t\t\tif (evtName == mxEvent.MOUSE_DOWN)\n\t\t\t\t\t{\n\t\t\t\t\t\tl.mouseDown.apply(l, args);\n\t\t\t\t\t}\n\t\t\t\t\telse if (evtName == mxEvent.MOUSE_MOVE)\n\t\t\t\t\t{\n\t\t\t\t\t\tl.mouseMove.apply(l, args);\n\t\t\t\t\t}\n\t\t\t\t\telse if (evtName == mxEvent.MOUSE_UP)\n\t\t\t\t\t{\n\t\t\t\t\t\tl.mouseUp.apply(l, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Invokes the click handler\n\t\t\tif (evtName == mxEvent.MOUSE_UP)\n\t\t\t{\n\t\t\t\tthis.click(me);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Detects tapAndHold events using a timer\n\t\tif ((mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent())) &&\n\t\t\tevtName == mxEvent.MOUSE_DOWN && this.tapAndHoldEnabled && !this.tapAndHoldInProgress)\n\t\t{\n\t\t\tthis.tapAndHoldInProgress = true;\n\t\t\tthis.initialTouchX = me.getGraphX();\n\t\t\tthis.initialTouchY = me.getGraphY();\n\t\t\t\n\t\t\tvar handler = function()\n\t\t\t{\n\t\t\t\tif (this.tapAndHoldValid)\n\t\t\t\t{\n\t\t\t\t\tthis.tapAndHold(me);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.tapAndHoldInProgress = false;\n\t\t\t\tthis.tapAndHoldValid = false;\n\t\t\t};\n\t\t\t\n\t\t\tif (this.tapAndHoldThread)\n\t\t\t{\n\t\t\t\twindow.clearTimeout(this.tapAndHoldThread);\n\t\t\t}\n\t\n\t\t\tthis.tapAndHoldThread = window.setTimeout(mxUtils.bind(this, handler), this.tapAndHoldDelay);\n\t\t\tthis.tapAndHoldValid = true;\n\t\t}\n\t\telse if (evtName == mxEvent.MOUSE_UP)\n\t\t{\n\t\t\tthis.tapAndHoldInProgress = false;\n\t\t\tthis.tapAndHoldValid = false;\n\t\t}\n\t\telse if (this.tapAndHoldValid)\n\t\t{\n\t\t\tthis.tapAndHoldValid =\n\t\t\t\tMath.abs(this.initialTouchX - me.getGraphX()) < this.tolerance &&\n\t\t\t\tMath.abs(this.initialTouchY - me.getGraphY()) < this.tolerance;\n\t\t}\n\n\t\t// Stops editing for all events other than from cellEditor\n\t\tif (evtName == mxEvent.MOUSE_DOWN && this.isEditing() && !this.cellEditor.isEventSource(me.getEvent()))\n\t\t{\n\t\t\tthis.stopEditing(!this.isInvokesStopCellEditing());\n\t\t}\n\n\t\tthis.consumeMouseEvent(evtName, me, sender);\n\t}\n};\n\n/**\n * Function: consumeMouseEvent\n * \n * Consumes the given <mxMouseEvent> if it's a touchStart event.\n */\nmxGraph.prototype.consumeMouseEvent = function(evtName, me, sender)\n{\n\t// Workaround for duplicate click in Windows 8 with Chrome/FF/Opera with touch\n\tif (evtName == mxEvent.MOUSE_DOWN && mxEvent.isTouchEvent(me.getEvent()))\n\t{\n\t\tme.consume(false);\n\t}\n};\n\n/**\n * Function: fireGestureEvent\n * \n * Dispatches a <mxEvent.GESTURE> event. The following example will resize the\n * cell under the mouse based on the scale property of the native touch event.\n * \n * (code)\n * graph.addListener(mxEvent.GESTURE, function(sender, eo)\n * {\n *   var evt = eo.getProperty('event');\n *   var state = graph.view.getState(eo.getProperty('cell'));\n *   \n *   if (graph.isEnabled() && graph.isCellResizable(state.cell) && Math.abs(1 - evt.scale) > 0.2)\n *   {\n *     var scale = graph.view.scale;\n *     var tr = graph.view.translate;\n *     \n *     var w = state.width * evt.scale;\n *     var h = state.height * evt.scale;\n *     var x = state.x - (w - state.width) / 2;\n *     var y = state.y - (h - state.height) / 2;\n *     \n *     var bounds = new mxRectangle(graph.snap(x / scale) - tr.x,\n *     \t\tgraph.snap(y / scale) - tr.y, graph.snap(w / scale), graph.snap(h / scale));\n *     graph.resizeCell(state.cell, bounds);\n *     eo.consume();\n *   }\n * });\n * (end)\n * \n * Parameters:\n * \n * evt - Gestureend event that represents the gesture.\n * cell - Optional <mxCell> associated with the gesture.\n */\nmxGraph.prototype.fireGestureEvent = function(evt, cell)\n{\n\t// Resets double tap event handling when gestures take place\n\tthis.lastTouchTime = 0;\n\tthis.fireEvent(new mxEventObject(mxEvent.GESTURE, 'event', evt, 'cell', cell));\n};\n\n/**\n * Function: destroy\n * \n * Destroys the graph and all its resources.\n */\nmxGraph.prototype.destroy = function()\n{\n\tif (!this.destroyed)\n\t{\n\t\tthis.destroyed = true;\n\t\t\n\t\tif (this.tooltipHandler != null)\n\t\t{\n\t\t\tthis.tooltipHandler.destroy();\n\t\t}\n\t\t\n\t\tif (this.selectionCellsHandler != null)\n\t\t{\n\t\t\tthis.selectionCellsHandler.destroy();\n\t\t}\n\n\t\tif (this.panningHandler != null)\n\t\t{\n\t\t\tthis.panningHandler.destroy();\n\t\t}\n\n\t\tif (this.popupMenuHandler != null)\n\t\t{\n\t\t\tthis.popupMenuHandler.destroy();\n\t\t}\n\t\t\n\t\tif (this.connectionHandler != null)\n\t\t{\n\t\t\tthis.connectionHandler.destroy();\n\t\t}\n\t\t\n\t\tif (this.graphHandler != null)\n\t\t{\n\t\t\tthis.graphHandler.destroy();\n\t\t}\n\t\t\n\t\tif (this.cellEditor != null)\n\t\t{\n\t\t\tthis.cellEditor.destroy();\n\t\t}\n\t\t\n\t\tif (this.view != null)\n\t\t{\n\t\t\tthis.view.destroy();\n\t\t}\n\n\t\tif (this.model != null && this.graphModelChangeListener != null)\n\t\t{\n\t\t\tthis.model.removeListener(this.graphModelChangeListener);\n\t\t\tthis.graphModelChangeListener = null;\n\t\t}\n\n\t\tthis.container = null;\n\t}\n};\n\n__mxOutput.mxGraph = typeof mxGraph !== 'undefined' ? mxGraph : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCellOverlay\n *\n * Extends <mxEventSource> to implement a graph overlay, represented by an icon\n * and a tooltip. Overlays can handle and fire <click> events and are added to\n * the graph using <mxGraph.addCellOverlay>, and removed using\n * <mxGraph.removeCellOverlay>, or <mxGraph.removeCellOverlays> to remove all overlays.\n * The <mxGraph.getCellOverlays> function returns the array of overlays for a given\n * cell in a graph. If multiple overlays exist for the same cell, then\n * <getBounds> should be overridden in at least one of the overlays.\n * \n * Overlays appear on top of all cells in a special layer. If this is not\n * desirable, then the image must be rendered as part of the shape or label of\n * the cell instead.\n *\n * Example:\n * \n * The following adds a new overlays for a given vertex and selects the cell\n * if the overlay is clicked.\n *\n * (code)\n * var overlay = new mxCellOverlay(img, html);\n * graph.addCellOverlay(vertex, overlay);\n * overlay.addListener(mxEvent.CLICK, function(sender, evt)\n * {\n *   var cell = evt.getProperty('cell');\n *   graph.setSelectionCell(cell);\n * });\n * (end)\n * \n * For cell overlays to be printed use <mxPrintPreview.printOverlays>.\n *\n * Event: mxEvent.CLICK\n *\n * Fires when the user clicks on the overlay. The <code>event</code> property\n * contains the corresponding mouse event and the <code>cell</code> property\n * contains the cell. For touch devices this is fired if the element receives\n * a touchend event.\n * \n * Constructor: mxCellOverlay\n *\n * Constructs a new overlay using the given image and tooltip.\n * \n * Parameters:\n * \n * image - <mxImage> that represents the icon to be displayed.\n * tooltip - Optional string that specifies the tooltip.\n * align - Optional horizontal alignment for the overlay. Possible\n * values are <ALIGN_LEFT>, <ALIGN_CENTER> and <ALIGN_RIGHT>\n * (default).\n * verticalAlign - Vertical alignment for the overlay. Possible\n * values are <ALIGN_TOP>, <ALIGN_MIDDLE> and <ALIGN_BOTTOM>\n * (default).\n */\nfunction mxCellOverlay(image, tooltip, align, verticalAlign, offset, cursor)\n{\n\tthis.image = image;\n\tthis.tooltip = tooltip;\n\tthis.align = (align != null) ? align : this.align;\n\tthis.verticalAlign = (verticalAlign != null) ? verticalAlign : this.verticalAlign;\n\tthis.offset = (offset != null) ? offset : new mxPoint();\n\tthis.cursor = (cursor != null) ? cursor : 'help';\n};\n\n/**\n * Extends mxEventSource.\n */\nmxCellOverlay.prototype = new mxEventSource();\nmxCellOverlay.prototype.constructor = mxCellOverlay;\n\n/**\n * Variable: image\n *\n * Holds the <mxImage> to be used as the icon.\n */\nmxCellOverlay.prototype.image = null;\n\n/**\n * Variable: tooltip\n * \n * Holds the optional string to be used as the tooltip.\n */\nmxCellOverlay.prototype.tooltip = null;\n\n/**\n * Variable: align\n * \n * Holds the horizontal alignment for the overlay. Default is\n * <mxConstants.ALIGN_RIGHT>. For edges, the overlay always appears in the\n * center of the edge.\n */\nmxCellOverlay.prototype.align = mxConstants.ALIGN_RIGHT;\n\n/**\n * Variable: verticalAlign\n * \n * Holds the vertical alignment for the overlay. Default is\n * <mxConstants.ALIGN_BOTTOM>. For edges, the overlay always appears in the\n * center of the edge.\n */\nmxCellOverlay.prototype.verticalAlign = mxConstants.ALIGN_BOTTOM;\n\n/**\n * Variable: offset\n * \n * Holds the offset as an <mxPoint>. The offset will be scaled according to the\n * current scale.\n */\nmxCellOverlay.prototype.offset = null;\n\n/**\n * Variable: cursor\n * \n * Holds the cursor for the overlay. Default is 'help'.\n */\nmxCellOverlay.prototype.cursor = null;\n\n/**\n * Variable: defaultOverlap\n * \n * Defines the overlapping for the overlay, that is, the proportional distance\n * from the origin to the point defined by the alignment. Default is 0.5.\n */\nmxCellOverlay.prototype.defaultOverlap = 0.5;\n\n/**\n * Function: getBounds\n * \n * Returns the bounds of the overlay for the given <mxCellState> as an\n * <mxRectangle>. This should be overridden when using multiple overlays\n * per cell so that the overlays do not overlap.\n * \n * The following example will place the overlay along an edge (where\n * x=[-1..1] from the start to the end of the edge and y is the\n * orthogonal offset in px).\n * \n * (code)\n * overlay.getBounds = function(state)\n * {\n *   var bounds = mxCellOverlay.prototype.getBounds.apply(this, arguments);\n *   \n *   if (state.view.graph.getModel().isEdge(state.cell))\n *   {\n *     var pt = state.view.getPoint(state, {x: 0, y: 0, relative: true});\n *     \n *     bounds.x = pt.x - bounds.width / 2;\n *     bounds.y = pt.y - bounds.height / 2;\n *   }\n *   \n *   return bounds;\n * };\n * (end)\n * \n * Parameters:\n * \n * state - <mxCellState> that represents the current state of the\n * associated cell.\n */\nmxCellOverlay.prototype.getBounds = function(state)\n{\n\tvar isEdge = state.view.graph.getModel().isEdge(state.cell);\n\tvar s = state.view.scale;\n\tvar pt = null;\n\n\tvar w = this.image.width;\n\tvar h = this.image.height;\n\t\n\tif (isEdge)\n\t{\n\t\tvar pts = state.absolutePoints;\n\t\t\n\t\tif (pts.length % 2 == 1)\n\t\t{\n\t\t\tpt = pts[Math.floor(pts.length / 2)];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar idx = pts.length / 2;\n\t\t\tvar p0 = pts[idx-1];\n\t\t\tvar p1 = pts[idx];\n\t\t\tpt = new mxPoint(p0.x + (p1.x - p0.x) / 2,\n\t\t\t\tp0.y + (p1.y - p0.y) / 2);\n\t\t}\n\t}\n\telse\n\t{\n\t\tpt = new mxPoint();\n\t\t\n\t\tif (this.align == mxConstants.ALIGN_LEFT)\n\t\t{\n\t\t\tpt.x = state.x;\n\t\t}\n\t\telse if (this.align == mxConstants.ALIGN_CENTER)\n\t\t{\n\t\t\tpt.x = state.x + state.width / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpt.x = state.x + state.width;\n\t\t}\n\t\t\n\t\tif (this.verticalAlign == mxConstants.ALIGN_TOP)\n\t\t{\n\t\t\tpt.y = state.y;\n\t\t}\n\t\telse if (this.verticalAlign == mxConstants.ALIGN_MIDDLE)\n\t\t{\n\t\t\tpt.y = state.y + state.height / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpt.y = state.y + state.height;\n\t\t}\n\t}\n\n\treturn new mxRectangle(Math.round(pt.x - (w * this.defaultOverlap - this.offset.x) * s),\n\t\tMath.round(pt.y - (h * this.defaultOverlap - this.offset.y) * s), w * s, h * s);\n};\n\n/**\n * Function: toString\n * \n * Returns the textual representation of the overlay to be used as the\n * tooltip. This implementation returns <tooltip>.\n */\nmxCellOverlay.prototype.toString = function()\n{\n\treturn this.tooltip;\n};\n\n__mxOutput.mxCellOverlay = typeof mxCellOverlay !== 'undefined' ? mxCellOverlay : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxOutline\n *\n * Implements an outline (aka overview) for a graph. Set <updateOnPan> to true\n * to enable updates while the source graph is panning.\n * \n * Example:\n * \n * (code)\n * var outline = new mxOutline(graph, div);\n * (end)\n * \n * If an outline is used in an <mxWindow> in IE8 standards mode, the following\n * code makes sure that the shadow filter is not inherited and that any\n * transparent elements in the graph do not show the page background, but the\n * background of the graph container.\n * \n * (code)\n * if (document.documentMode == 8)\n * {\n *   container.style.filter = 'progid:DXImageTransform.Microsoft.alpha(opacity=100)';\n * }\n * (end)\n * \n * To move the graph to the top, left corner the following code can be used.\n * \n * (code)\n * var scale = graph.view.scale;\n * var bounds = graph.getGraphBounds();\n * graph.view.setTranslate(-bounds.x / scale, -bounds.y / scale);\n * (end)\n * \n * To toggle the suspended mode, the following can be used.\n * \n * (code)\n * outline.suspended = !outln.suspended;\n * if (!outline.suspended)\n * {\n *   outline.update(true);\n * }\n * (end)\n * \n * Constructor: mxOutline\n *\n * Constructs a new outline for the specified graph inside the given\n * container.\n * \n * Parameters:\n * \n * source - <mxGraph> to create the outline for.\n * container - DOM node that will contain the outline.\n */\nfunction mxOutline(source, container)\n{\n\tthis.source = source;\n\n\tif (container != null)\n\t{\n\t\tthis.init(container);\n\t}\n};\n\n/**\n * Function: source\n * \n * Reference to the source <mxGraph>.\n */\nmxOutline.prototype.source = null;\n\n/**\n * Function: outline\n * \n * Reference to the <mxGraph> that renders the outline.\n */\nmxOutline.prototype.outline = null;\n\n/**\n * Function: graphRenderHint\n * \n * Renderhint to be used for the outline graph. Default is faster.\n */\nmxOutline.prototype.graphRenderHint = mxConstants.RENDERING_HINT_FASTER;\n\n/**\n * Variable: enabled\n * \n * Specifies if events are handled. Default is true.\n */\nmxOutline.prototype.enabled = true;\n\n/**\n * Variable: showViewport\n * \n * Specifies a viewport rectangle should be shown. Default is true.\n */\nmxOutline.prototype.showViewport = true;\n\n/**\n * Variable: border\n * \n * Border to be added at the bottom and right. Default is 10.\n */\nmxOutline.prototype.border = 10;\n\n/**\n * Variable: enabled\n * \n * Specifies the size of the sizer handler. Default is 8.\n */\nmxOutline.prototype.sizerSize = 8;\n\n/**\n * Variable: labelsVisible\n * \n * Specifies if labels should be visible in the outline. Default is false.\n */\nmxOutline.prototype.labelsVisible = false;\n\n/**\n * Variable: updateOnPan\n * \n * Specifies if <update> should be called for <mxEvent.PAN> in the source\n * graph. Default is false.\n */\nmxOutline.prototype.updateOnPan = false;\n\n/**\n * Variable: sizerImage\n * \n * Optional <mxImage> to be used for the sizer. Default is null.\n */\nmxOutline.prototype.sizerImage = null;\n\n/**\n * Variable: minScale\n * \n * Minimum scale to be used. Default is 0.0001.\n */\nmxOutline.prototype.minScale = 0.0001;\n\n/**\n * Variable: suspended\n * \n * Optional boolean flag to suspend updates. Default is false. This flag will\n * also suspend repaints of the outline. To toggle this switch, use the\n * following code.\n * \n * (code)\n * nav.suspended = !nav.suspended;\n * \n * if (!nav.suspended)\n * {\n *   nav.update(true);\n * }\n * (end)\n */\nmxOutline.prototype.suspended = false;\n\n/**\n * Variable: forceVmlHandles\n * \n * Specifies if VML should be used to render the handles in this control. This\n * is true for IE8 standards mode and false for all other browsers and modes.\n * This is a workaround for rendering issues of HTML elements over elements\n * with filters in IE 8 standards mode.\n */\nmxOutline.prototype.forceVmlHandles = document.documentMode == 8;\n\n/**\n * Function: createGraph\n * \n * Creates the <mxGraph> used in the outline.\n */\nmxOutline.prototype.createGraph = function(container)\n{\n\tvar graph = new mxGraph(container, this.source.getModel(), this.graphRenderHint, this.source.getStylesheet());\n\tgraph.foldingEnabled = false;\n\tgraph.autoScroll = false;\n\t\n\treturn graph;\n};\n\n/**\n * Function: init\n * \n * Initializes the outline inside the given container.\n */\nmxOutline.prototype.init = function(container)\n{\n\tthis.outline = this.createGraph(container);\n\t\n\t// Do not repaint when suspended\n\tvar outlineGraphModelChanged = this.outline.graphModelChanged;\n\tthis.outline.graphModelChanged = mxUtils.bind(this, function(changes)\n\t{\n\t\tif (!this.suspended && this.outline != null)\n\t\t{\n\t\t\toutlineGraphModelChanged.apply(this.outline, arguments);\n\t\t}\n\t});\n\n\t// Enables faster painting in SVG\n\tif (mxClient.IS_SVG)\n\t{\n\t\tvar node = this.outline.getView().getCanvas().parentNode;\n\t\tnode.setAttribute('shape-rendering', 'optimizeSpeed');\n\t\tnode.setAttribute('image-rendering', 'optimizeSpeed');\n\t}\n\t\n\t// Hides cursors and labels\n\tthis.outline.labelsVisible = this.labelsVisible;\n\tthis.outline.setEnabled(false);\n\t\n\tthis.updateHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tif (!this.suspended && !this.active)\n\t\t{\n\t\t\tthis.update();\n\t\t}\n\t});\n\t\n\t// Updates the scale of the outline after a change of the main graph\n\tthis.source.getModel().addListener(mxEvent.CHANGE, this.updateHandler);\n\tthis.outline.addMouseListener(this);\n\t\n\t// Adds listeners to keep the outline in sync with the source graph\n\tvar view = this.source.getView();\n\tview.addListener(mxEvent.SCALE, this.updateHandler);\n\tview.addListener(mxEvent.TRANSLATE, this.updateHandler);\n\tview.addListener(mxEvent.SCALE_AND_TRANSLATE, this.updateHandler);\n\tview.addListener(mxEvent.DOWN, this.updateHandler);\n\tview.addListener(mxEvent.UP, this.updateHandler);\n\n\t// Updates blue rectangle on scroll\n\tmxEvent.addListener(this.source.container, 'scroll', this.updateHandler);\n\t\n\tthis.panHandler = mxUtils.bind(this, function(sender)\n\t{\n\t\tif (this.updateOnPan)\n\t\t{\n\t\t\tthis.updateHandler.apply(this, arguments);\n\t\t}\n\t});\n\tthis.source.addListener(mxEvent.PAN, this.panHandler);\n\t\n\t// Refreshes the graph in the outline after a refresh of the main graph\n\tthis.refreshHandler = mxUtils.bind(this, function(sender)\n\t{\n\t\tthis.outline.setStylesheet(this.source.getStylesheet());\n\t\tthis.outline.refresh();\n\t});\n\tthis.source.addListener(mxEvent.REFRESH, this.refreshHandler);\n\n\t// Creates the blue rectangle for the viewport\n\tthis.bounds = new mxRectangle(0, 0, 0, 0);\n\tthis.selectionBorder = new mxRectangleShape(this.bounds, null,\n\t\tmxConstants.OUTLINE_COLOR, mxConstants.OUTLINE_STROKEWIDTH);\n\tthis.selectionBorder.dialect = this.outline.dialect;\n\n\tif (this.forceVmlHandles)\n\t{\n\t\tthis.selectionBorder.isHtmlAllowed = function()\n\t\t{\n\t\t\treturn false;\n\t\t};\n\t}\n\t\n\tthis.selectionBorder.init(this.outline.getView().getOverlayPane());\n\n\t// Handles event by catching the initial pointer start and then listening to the\n\t// complete gesture on the event target. This is needed because all the events\n\t// are routed via the initial element even if that element is removed from the\n\t// DOM, which happens when we repaint the selection border and zoom handles.\n\tvar handler = mxUtils.bind(this, function(evt)\n\t{\n\t\tvar t = mxEvent.getSource(evt);\n\t\t\n\t\tvar redirect = mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tthis.outline.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));\n\t\t});\n\t\t\n\t\tvar redirect2 = mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tmxEvent.removeGestureListeners(t, null, redirect, redirect2);\n\t\t\tthis.outline.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));\n\t\t});\n\t\t\n\t\tmxEvent.addGestureListeners(t, null, redirect, redirect2);\n\t\tthis.outline.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));\n\t});\n\t\n\tmxEvent.addGestureListeners(this.selectionBorder.node, handler);\n\n\t// Creates a small blue rectangle for sizing (sizer handle)\n\tthis.sizer = this.createSizer();\n\t\n\tif (this.forceVmlHandles)\n\t{\n\t\tthis.sizer.isHtmlAllowed = function()\n\t\t{\n\t\t\treturn false;\n\t\t};\n\t}\n\t\n\tthis.sizer.init(this.outline.getView().getOverlayPane());\n\t\n\tif (this.enabled)\n\t{\n\t\tthis.sizer.node.style.cursor = 'nwse-resize';\n\t}\n\t\n\tmxEvent.addGestureListeners(this.sizer.node, handler);\n\n\tthis.selectionBorder.node.style.display = (this.showViewport) ? '' : 'none';\n\tthis.sizer.node.style.display = this.selectionBorder.node.style.display;\n\tthis.selectionBorder.node.style.cursor = 'move';\n\n\tthis.update(false);\n};\n\n/**\n * Function: isEnabled\n * \n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxOutline.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n * \n * Enables or disables event handling. This implementation\n * updates <enabled>.\n * \n * Parameters:\n * \n * value - Boolean that specifies the new enabled state.\n */\nmxOutline.prototype.setEnabled = function(value)\n{\n\tthis.enabled = value;\n};\n\n/**\n * Function: setZoomEnabled\n * \n * Enables or disables the zoom handling by showing or hiding the respective\n * handle.\n * \n * Parameters:\n * \n * value - Boolean that specifies the new enabled state.\n */\nmxOutline.prototype.setZoomEnabled = function(value)\n{\n\tthis.sizer.node.style.visibility = (value) ? 'visible' : 'hidden';\n};\n\n/**\n * Function: refresh\n * \n * Invokes <update> and revalidate the outline. This method is deprecated.\n */\nmxOutline.prototype.refresh = function()\n{\n\tthis.update(true);\n};\n\n/**\n * Function: createSizer\n * \n * Creates the shape used as the sizer.\n */\nmxOutline.prototype.createSizer = function()\n{\n\tif (this.sizerImage != null)\n\t{\n\t\tvar sizer = new mxImageShape(new mxRectangle(0, 0, this.sizerImage.width, this.sizerImage.height), this.sizerImage.src);\n\t\tsizer.dialect = this.outline.dialect;\n\t\t\n\t\treturn sizer;\n\t}\n\telse\n\t{\n\t\tvar sizer = new mxRectangleShape(new mxRectangle(0, 0, this.sizerSize, this.sizerSize),\n\t\t\tmxConstants.OUTLINE_HANDLE_FILLCOLOR, mxConstants.OUTLINE_HANDLE_STROKECOLOR);\n\t\tsizer.dialect = this.outline.dialect;\n\t\n\t\treturn sizer;\n\t}\n};\n\n/**\n * Function: getSourceContainerSize\n * \n * Returns the size of the source container.\n */\nmxOutline.prototype.getSourceContainerSize = function()\n{\n\treturn new mxRectangle(0, 0, this.source.container.scrollWidth, this.source.container.scrollHeight);\n};\n\n/**\n * Function: getOutlineOffset\n * \n * Returns the offset for drawing the outline graph.\n */\nmxOutline.prototype.getOutlineOffset = function(scale)\n{\n\treturn null;\n};\n\n/**\n * Function: getSourceGraphBounds\n * \n * Returns the graph bound boxing of the source.\n */\nmxOutline.prototype.getSourceGraphBounds = function()\n{\n\treturn this.source.getGraphBounds();\n};\n\n/**\n * Function: update\n * \n * Updates the outline.\n */\nmxOutline.prototype.update = function(revalidate)\n{\n\tif (this.source != null && this.source.container != null &&\n\t\tthis.outline != null && this.outline.container != null)\n\t{\n\t\tvar sourceScale = this.source.view.scale;\n\t\tvar scaledGraphBounds = this.getSourceGraphBounds();\n\t\tvar unscaledGraphBounds = new mxRectangle(scaledGraphBounds.x / sourceScale + this.source.panDx,\n\t\t\t\tscaledGraphBounds.y / sourceScale + this.source.panDy, scaledGraphBounds.width / sourceScale,\n\t\t\t\tscaledGraphBounds.height / sourceScale);\n\n\t\tvar unscaledFinderBounds = new mxRectangle(0, 0,\n\t\t\tthis.source.container.clientWidth / sourceScale,\n\t\t\tthis.source.container.clientHeight / sourceScale);\n\t\t\n\t\tvar union = unscaledGraphBounds.clone();\n\t\tunion.add(unscaledFinderBounds);\n\t\n\t\t// Zooms to the scrollable area if that is bigger than the graph\n\t\tvar size = this.getSourceContainerSize();\n\t\tvar completeWidth = Math.max(size.width / sourceScale, union.width);\n\t\tvar completeHeight = Math.max(size.height / sourceScale, union.height);\n\t\n\t\tvar availableWidth = Math.max(0, this.outline.container.clientWidth - this.border);\n\t\tvar availableHeight = Math.max(0, this.outline.container.clientHeight - this.border);\n\t\t\n\t\tvar outlineScale = Math.min(availableWidth / completeWidth, availableHeight / completeHeight);\n\t\tvar scale = (isNaN(outlineScale)) ? this.minScale : Math.max(this.minScale, outlineScale);\n\n\t\tif (scale > 0)\n\t\t{\n\t\t\tif (this.outline.getView().scale != scale)\n\t\t\t{\n\t\t\t\tthis.outline.getView().scale = scale;\n\t\t\t\trevalidate = true;\n\t\t\t}\n\t\t\n\t\t\tvar navView = this.outline.getView();\n\t\t\t\n\t\t\tif (navView.currentRoot != this.source.getView().currentRoot)\n\t\t\t{\n\t\t\t\tnavView.setCurrentRoot(this.source.getView().currentRoot);\n\t\t\t}\n\n\t\t\tvar t = this.source.view.translate;\n\t\t\tvar tx = t.x + this.source.panDx;\n\t\t\tvar ty = t.y + this.source.panDy;\n\t\t\t\n\t\t\tvar off = this.getOutlineOffset(scale);\n\t\t\t\n\t\t\tif (off != null)\n\t\t\t{\n\t\t\t\ttx += off.x;\n\t\t\t\tty += off.y;\n\t\t\t}\n\t\t\t\n\t\t\tif (unscaledGraphBounds.x < 0)\n\t\t\t{\n\t\t\t\ttx = tx - unscaledGraphBounds.x;\n\t\t\t}\n\t\t\tif (unscaledGraphBounds.y < 0)\n\t\t\t{\n\t\t\t\tty = ty - unscaledGraphBounds.y;\n\t\t\t}\n\t\t\t\n\t\t\tif (navView.translate.x != tx || navView.translate.y != ty)\n\t\t\t{\n\t\t\t\tnavView.translate.x = tx;\n\t\t\t\tnavView.translate.y = ty;\n\t\t\t\trevalidate = true;\n\t\t\t}\n\t\t\n\t\t\t// Prepares local variables for computations\n\t\t\tvar t2 = navView.translate;\n\t\t\tscale = this.source.getView().scale;\n\t\t\tvar scale2 = scale / navView.scale;\n\t\t\tvar scale3 = 1.0 / navView.scale;\n\t\t\tvar container = this.source.container;\n\t\t\t\n\t\t\t// Updates the bounds of the viewrect in the navigation\n\t\t\tthis.bounds = new mxRectangle(\n\t\t\t\t(t2.x - t.x - this.source.panDx) / scale3,\n\t\t\t\t(t2.y - t.y - this.source.panDy) / scale3,\n\t\t\t\t(container.clientWidth / scale2),\n\t\t\t\t(container.clientHeight / scale2));\n\t\t\t\n\t\t\t// Adds the scrollbar offset to the finder\n\t\t\tthis.bounds.x += this.source.container.scrollLeft * navView.scale / scale;\n\t\t\tthis.bounds.y += this.source.container.scrollTop * navView.scale / scale;\n\t\t\t\n\t\t\tvar b = this.selectionBorder.bounds;\n\t\t\t\n\t\t\tif (b.x != this.bounds.x || b.y != this.bounds.y || b.width != this.bounds.width || b.height != this.bounds.height)\n\t\t\t{\n\t\t\t\tthis.selectionBorder.bounds = this.bounds;\n\t\t\t\tthis.selectionBorder.redraw();\n\t\t\t}\n\t\t\n\t\t\t// Updates the bounds of the zoom handle at the bottom right\n\t\t\tvar b = this.sizer.bounds;\n\t\t\tvar b2 = new mxRectangle(this.bounds.x + this.bounds.width - b.width / 2,\n\t\t\t\t\tthis.bounds.y + this.bounds.height - b.height / 2, b.width, b.height);\n\n\t\t\tif (b.x != b2.x || b.y != b2.y || b.width != b2.width || b.height != b2.height)\n\t\t\t{\n\t\t\t\tthis.sizer.bounds = b2;\n\t\t\t\t\n\t\t\t\t// Avoids update of visibility in redraw for VML\n\t\t\t\tif (this.sizer.node.style.visibility != 'hidden')\n\t\t\t\t{\n\t\t\t\t\tthis.sizer.redraw();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (revalidate)\n\t\t\t{\n\t\t\t\tthis.outline.view.revalidate();\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: mouseDown\n * \n * Handles the event by starting a translation or zoom.\n */\nmxOutline.prototype.mouseDown = function(sender, me)\n{\n\tif (this.enabled && this.showViewport)\n\t{\n\t\tvar tol = (!mxEvent.isMouseEvent(me.getEvent())) ? this.source.tolerance : 0;\n\t\tvar hit = (this.source.allowHandleBoundsCheck && (mxClient.IS_IE || tol > 0)) ?\n\t\t\t\tnew mxRectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;\n\t\tthis.zoom = me.isSource(this.sizer) || (hit != null && mxUtils.intersects(shape.bounds, hit));\n\t\tthis.startX = me.getX();\n\t\tthis.startY = me.getY();\n\t\tthis.active = true;\n\n\t\tif (this.source.useScrollbarsForPanning && mxUtils.hasScrollbars(this.source.container))\n\t\t{\n\t\t\tthis.dx0 = this.source.container.scrollLeft;\n\t\t\tthis.dy0 = this.source.container.scrollTop;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.dx0 = 0;\n\t\t\tthis.dy0 = 0;\n\t\t}\n\t}\n\n\tme.consume();\n};\n\n/**\n * Function: mouseMove\n * \n * Handles the event by previewing the viewrect in <graph> and updating the\n * rectangle that represents the viewrect in the outline.\n */\nmxOutline.prototype.mouseMove = function(sender, me)\n{\n\tif (this.active)\n\t{\n\t\tthis.selectionBorder.node.style.display = (this.showViewport) ? '' : 'none';\n\t\tthis.sizer.node.style.display = this.selectionBorder.node.style.display; \n\n\t\tvar delta = this.getTranslateForEvent(me);\n\t\tvar dx = delta.x;\n\t\tvar dy = delta.y;\n\t\tvar bounds = null;\n\t\t\n\t\tif (!this.zoom)\n\t\t{\n\t\t\t// Previews the panning on the source graph\n\t\t\tvar scale = this.outline.getView().scale;\n\t\t\tbounds = new mxRectangle(this.bounds.x + dx,\n\t\t\t\tthis.bounds.y + dy, this.bounds.width, this.bounds.height);\n\t\t\tthis.selectionBorder.bounds = bounds;\n\t\t\tthis.selectionBorder.redraw();\n\t\t\tdx /= scale;\n\t\t\tdx *= this.source.getView().scale;\n\t\t\tdy /= scale;\n\t\t\tdy *= this.source.getView().scale;\n\t\t\tthis.source.panGraph(-dx - this.dx0, -dy - this.dy0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Does *not* preview zooming on the source graph\n\t\t\tvar container = this.source.container;\n\t\t\tvar viewRatio = container.clientWidth / container.clientHeight;\n\t\t\tdy = dx / viewRatio;\n\t\t\tbounds = new mxRectangle(this.bounds.x,\n\t\t\t\tthis.bounds.y,\n\t\t\t\tMath.max(1, this.bounds.width + dx),\n\t\t\t\tMath.max(1, this.bounds.height + dy));\n\t\t\tthis.selectionBorder.bounds = bounds;\n\t\t\tthis.selectionBorder.redraw();\n\t\t}\n\t\t\n\t\t// Updates the zoom handle\n\t\tvar b = this.sizer.bounds;\n\t\tthis.sizer.bounds = new mxRectangle(\n\t\t\tbounds.x + bounds.width - b.width / 2,\n\t\t\tbounds.y + bounds.height - b.height / 2,\n\t\t\tb.width, b.height);\n\t\t\n\t\t// Avoids update of visibility in redraw for VML\n\t\tif (this.sizer.node.style.visibility != 'hidden')\n\t\t{\n\t\t\tthis.sizer.redraw();\n\t\t}\n\t\t\n\t\tme.consume();\n\t}\n};\n\n/**\n * Function: getTranslateForEvent\n * \n * Gets the translate for the given mouse event. Here is an example to limit\n * the outline to stay within positive coordinates:\n * \n * (code)\n * outline.getTranslateForEvent = function(me)\n * {\n *   var pt = new mxPoint(me.getX() - this.startX, me.getY() - this.startY);\n *   \n *   if (!this.zoom)\n *   {\n *     var tr = this.source.view.translate;\n *     pt.x = Math.max(tr.x * this.outline.view.scale, pt.x);\n *     pt.y = Math.max(tr.y * this.outline.view.scale, pt.y);\n *   }\n *   \n *   return pt;\n * };\n * (end)\n */\nmxOutline.prototype.getTranslateForEvent = function(me)\n{\n\treturn new mxPoint(me.getX() - this.startX, me.getY() - this.startY);\n};\n\n/**\n * Function: mouseUp\n * \n * Handles the event by applying the translation or zoom to <graph>.\n */\nmxOutline.prototype.mouseUp = function(sender, me)\n{\n\tif (this.active)\n\t{\n\t\tvar delta = this.getTranslateForEvent(me);\n\t\tvar dx = delta.x;\n\t\tvar dy = delta.y;\n\t\t\n\t\tif (Math.abs(dx) > 0 || Math.abs(dy) > 0)\n\t\t{\n\t\t\tif (!this.zoom)\n\t\t\t{\n\t\t\t\t// Applies the new translation if the source\n\t\t\t\t// has no scrollbars\n\t\t\t\tif (!this.source.useScrollbarsForPanning ||\n\t\t\t\t\t!mxUtils.hasScrollbars(this.source.container))\n\t\t\t\t{\n\t\t\t\t\tthis.source.panGraph(0, 0);\n\t\t\t\t\tdx /= this.outline.getView().scale;\n\t\t\t\t\tdy /= this.outline.getView().scale;\n\t\t\t\t\tvar t = this.source.getView().translate;\n\t\t\t\t\tthis.source.getView().setTranslate(t.x - dx, t.y - dy);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Applies the new zoom\n\t\t\t\tvar w = this.selectionBorder.bounds.width;\n\t\t\t\tvar scale = this.source.getView().scale;\n\t\t\t\tthis.source.zoomTo(Math.max(this.minScale, scale - (dx * scale) / w), false);\n\t\t\t}\n\n\t\t\tthis.update();\n\t\t\tme.consume();\n\t\t}\n\t\t\t\n\t\t// Resets the state of the handler\n\t\tthis.index = null;\n\t\tthis.active = false;\n\t}\n};\n\n/**\n * Function: destroy\n * \n * Destroy this outline and removes all listeners from <source>.\n */\nmxOutline.prototype.destroy = function()\n{\n\tif (this.source != null)\n\t{\n\t\tthis.source.removeListener(this.panHandler);\n\t\tthis.source.removeListener(this.refreshHandler);\n\t\tthis.source.getModel().removeListener(this.updateHandler);\n\t\tthis.source.getView().removeListener(this.updateHandler);\n\t\tmxEvent.removeListener(this.source.container, 'scroll', this.updateHandler);\n\t\tthis.source = null;\n\t}\n\t\n\tif (this.outline != null)\n\t{\n\t\tthis.outline.removeMouseListener(this);\n\t\tthis.outline.destroy();\n\t\tthis.outline = null;\n\t}\n\n\tif (this.selectionBorder != null)\n\t{\n\t\tthis.selectionBorder.destroy();\n\t\tthis.selectionBorder = null;\n\t}\n\t\n\tif (this.sizer != null)\n\t{\n\t\tthis.sizer.destroy();\n\t\tthis.sizer = null;\n\t}\n};\n\n__mxOutput.mxOutline = typeof mxOutline !== 'undefined' ? mxOutline : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxMultiplicity\n * \n * Defines invalid connections along with the error messages that they produce.\n * To add or remove rules on a graph, you must add/remove instances of this\n * class to <mxGraph.multiplicities>.\n * \n * Example:\n * \n * (code)\n * graph.multiplicities.push(new mxMultiplicity(\n *   true, 'rectangle', null, null, 0, 2, ['circle'],\n *   'Only 2 targets allowed',\n *   'Only circle targets allowed'));\n * (end)\n * \n * Defines a rule where each rectangle must be connected to no more than 2\n * circles and no other types of targets are allowed.\n * \n * Constructor: mxMultiplicity\n * \n * Instantiate class mxMultiplicity in order to describe allowed\n * connections in a graph. Not all constraints can be enforced while\n * editing, some must be checked at validation time. The <countError> and\n * <typeError> are treated as resource keys in <mxResources>.\n * \n * Parameters:\n * \n * source - Boolean indicating if this rule applies to the source or target\n * terminal.\n * type - Type of the source or target terminal that this rule applies to.\n * See <type> for more information.\n * attr - Optional attribute name to match the source or target terminal.\n * value - Optional attribute value to match the source or target terminal.\n * min - Minimum number of edges for this rule. Default is 1.\n * max - Maximum number of edges for this rule. n means infinite. Default\n * is n.\n * validNeighbors - Array of types of the opposite terminal for which this\n * rule applies.\n * countError - Error to be displayed for invalid number of edges.\n * typeError - Error to be displayed for invalid opposite terminals.\n * validNeighborsAllowed - Optional boolean indicating if the array of\n * opposite types should be valid or invalid.\n */\nfunction mxMultiplicity(source, type, attr, value, min, max,\n\tvalidNeighbors, countError, typeError, validNeighborsAllowed)\n{\n\tthis.source = source;\n\tthis.type = type;\n\tthis.attr = attr;\n\tthis.value = value;\n\tthis.min = (min != null) ? min : 0;\n\tthis.max = (max != null) ? max : 'n';\n\tthis.validNeighbors = validNeighbors;\n\tthis.countError = mxResources.get(countError) || countError;\n\tthis.typeError = mxResources.get(typeError) || typeError;\n\tthis.validNeighborsAllowed = (validNeighborsAllowed != null) ?\n\t\tvalidNeighborsAllowed : true;\n};\n\n/**\n * Variable: type\n * \n * Defines the type of the source or target terminal. The type is a string\n * passed to <mxUtils.isNode> together with the source or target vertex\n * value as the first argument.\n */\nmxMultiplicity.prototype.type = null;\n\n/**\n * Variable: attr\n * \n * Optional string that specifies the attributename to be passed to\n * <mxUtils.isNode> to check if the rule applies to a cell.\n */\nmxMultiplicity.prototype.attr = null;\n\n/**\n * Variable: value\n * \n * Optional string that specifies the value of the attribute to be passed\n * to <mxUtils.isNode> to check if the rule applies to a cell.\n */\nmxMultiplicity.prototype.value = null;\n\n/**\n * Variable: source\n * \n * Boolean that specifies if the rule is applied to the source or target\n * terminal of an edge.\n */\nmxMultiplicity.prototype.source = null;\n\n/**\n * Variable: min\n * \n * Defines the minimum number of connections for which this rule applies.\n * Default is 0.\n */\nmxMultiplicity.prototype.min = null;\n\n/**\n * Variable: max\n * \n * Defines the maximum number of connections for which this rule applies.\n * A value of 'n' means unlimited times. Default is 'n'. \n */\nmxMultiplicity.prototype.max = null;\n\n/**\n * Variable: validNeighbors\n * \n * Holds an array of strings that specify the type of neighbor for which\n * this rule applies. The strings are used in <mxCell.is> on the opposite\n * terminal to check if the rule applies to the connection.\n */\nmxMultiplicity.prototype.validNeighbors = null;\n\n/**\n * Variable: validNeighborsAllowed\n * \n * Boolean indicating if the list of validNeighbors are those that are allowed\n * for this rule or those that are not allowed for this rule.\n */\nmxMultiplicity.prototype.validNeighborsAllowed = true;\n\n/**\n * Variable: countError\n * \n * Holds the localized error message to be displayed if the number of\n * connections for which the rule applies is smaller than <min> or greater\n * than <max>.\n */\nmxMultiplicity.prototype.countError = null;\n\n/**\n * Variable: typeError\n * \n * Holds the localized error message to be displayed if the type of the\n * neighbor for a connection does not match the rule.\n */\nmxMultiplicity.prototype.typeError = null;\n\n/**\n * Function: check\n * \n * Checks the multiplicity for the given arguments and returns the error\n * for the given connection or null if the multiplicity does not apply.\n *  \n * Parameters:\n * \n * graph - Reference to the enclosing <mxGraph> instance.\n * edge - <mxCell> that represents the edge to validate.\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n * sourceOut - Number of outgoing edges from the source terminal.\n * targetIn - Number of incoming edges for the target terminal.\n */\nmxMultiplicity.prototype.check = function(graph, edge, source, target, sourceOut, targetIn)\n{\n\tvar error = '';\n\n\tif ((this.source && this.checkTerminal(graph, source, edge)) ||\n\t\t(!this.source && this.checkTerminal(graph, target, edge)))\n\t{\n\t\tif (this.countError != null && \n\t\t\t((this.source && (this.max == 0 || (sourceOut >= this.max))) ||\n\t\t\t(!this.source && (this.max == 0 || (targetIn >= this.max)))))\n\t\t{\n\t\t\terror += this.countError + '\\n';\n\t\t}\n\n\t\tif (this.validNeighbors != null && this.typeError != null && this.validNeighbors.length > 0)\n\t\t{\n\t\t\tvar isValid = this.checkNeighbors(graph, edge, source, target);\n\n\t\t\tif (!isValid)\n\t\t\t{\n\t\t\t\terror += this.typeError + '\\n';\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (error.length > 0) ? error : null;\n};\n\n/**\n * Function: checkNeighbors\n * \n * Checks if there are any valid neighbours in <validNeighbors>. This is only\n * called if <validNeighbors> is a non-empty array.\n */\nmxMultiplicity.prototype.checkNeighbors = function(graph, edge, source, target)\n{\n\tvar sourceValue = graph.model.getValue(source);\n\tvar targetValue = graph.model.getValue(target);\n\tvar isValid = !this.validNeighborsAllowed;\n\tvar valid = this.validNeighbors;\n\t\n\tfor (var j = 0; j < valid.length; j++)\n\t{\n\t\tif (this.source &&\n\t\t\tthis.checkType(graph, targetValue, valid[j]))\n\t\t{\n\t\t\tisValid = this.validNeighborsAllowed;\n\t\t\tbreak;\n\t\t}\n\t\telse if (!this.source && \n\t\t\tthis.checkType(graph, sourceValue, valid[j]))\n\t\t{\n\t\t\tisValid = this.validNeighborsAllowed;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn isValid;\n};\n\n/**\n * Function: checkTerminal\n * \n * Checks the given terminal cell and returns true if this rule applies. The\n * given cell is the source or target of the given edge, depending on\n * <source>. This implementation uses <checkType> on the terminal's value.\n */\nmxMultiplicity.prototype.checkTerminal = function(graph, terminal, edge)\n{\n\tvar value = graph.model.getValue(terminal);\n\t\n\treturn this.checkType(graph, value, this.type, this.attr, this.value);\n};\n\n/**\n * Function: checkType\n * \n * Checks the type of the given value.\n */\nmxMultiplicity.prototype.checkType = function(graph, value, type, attr, attrValue)\n{\n\tif (value != null)\n\t{\n\t\tif (!isNaN(value.nodeType)) // Checks if value is a DOM node\n\t\t{\n\t\t\treturn mxUtils.isNode(value, type, attr, attrValue);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn value == type;\n\t\t}\n\t}\n\t\n\treturn false;\n};\n\n__mxOutput.mxMultiplicity = typeof mxMultiplicity !== 'undefined' ? mxMultiplicity : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxLayoutManager\n * \n * Implements a layout manager that runs a given layout after any changes to the graph:\n * \n * Example:\n * \n * (code)\n * var layoutMgr = new mxLayoutManager(graph);\n * layoutMgr.getLayout = function(cell, eventName)\n * {\n *   return layout;\n * };\n * (end)\n * \n * See <getLayout> for a description of the possible eventNames.\n * \n * Event: mxEvent.LAYOUT_CELLS\n * \n * Fires between begin- and endUpdate after all cells have been layouted in\n * <layoutCells>. The <code>cells</code> property contains all cells that have\n * been passed to <layoutCells>.\n * \n * Constructor: mxLayoutManager\n *\n * Constructs a new automatic layout for the given graph.\n *\n * Arguments:\n * \n * graph - Reference to the enclosing graph. \n */\nfunction mxLayoutManager(graph)\n{\n\t// Executes the layout before the changes are dispatched\n\tthis.undoHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tif (this.isEnabled())\n\t\t{\n\t\t\tthis.beforeUndo(evt.getProperty('edit'));\n\t\t}\n\t});\n\t\n\t// Notifies the layout of a move operation inside a parent\n\tthis.moveHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tif (this.isEnabled())\n\t\t{\n\t\t\tthis.cellsMoved(evt.getProperty('cells'), evt.getProperty('event'));\n\t\t}\n\t});\n\t\t\n\t// Notifies the layout of a move operation inside a parent\n\tthis.resizeHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tif (this.isEnabled())\n\t\t{\n\t\t\tthis.cellsResized(evt.getProperty('cells'), evt.getProperty('bounds'),\n\t\t\t\tevt.getProperty('previous'));\n\t\t}\n\t});\n\t\n\tthis.setGraph(graph);\n};\n\n/**\n * Extends mxEventSource.\n */\nmxLayoutManager.prototype = new mxEventSource();\nmxLayoutManager.prototype.constructor = mxLayoutManager;\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxLayoutManager.prototype.graph = null;\n\n/**\n * Variable: bubbling\n * \n * Specifies if the layout should bubble along\n * the cell hierarchy. Default is true.\n */\nmxLayoutManager.prototype.bubbling = true;\n\n/**\n * Variable: enabled\n * \n * Specifies if event handling is enabled. Default is true.\n */\nmxLayoutManager.prototype.enabled = true;\n\n/**\n * Variable: undoHandler\n * \n * Holds the function that handles the endUpdate event.\n */\nmxLayoutManager.prototype.undoHandler = null;\n\n/**\n * Variable: moveHandler\n * \n * Holds the function that handles the move event.\n */\nmxLayoutManager.prototype.moveHandler = null;\n\n/**\n * Variable: resizeHandler\n * \n * Holds the function that handles the resize event.\n */\nmxLayoutManager.prototype.resizeHandler = null;\n\n/**\n * Function: isEnabled\n * \n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxLayoutManager.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n * \n * Enables or disables event handling. This implementation\n * updates <enabled>.\n * \n * Parameters:\n * \n * enabled - Boolean that specifies the new enabled state.\n */\nmxLayoutManager.prototype.setEnabled = function(enabled)\n{\n\tthis.enabled = enabled;\n};\n\n/**\n * Function: isBubbling\n * \n * Returns true if a layout should bubble, that is, if the parent layout\n * should be executed whenever a cell layout (layout of the children of\n * a cell) has been executed. This implementation returns <bubbling>.\n */\nmxLayoutManager.prototype.isBubbling = function()\n{\n\treturn this.bubbling;\n};\n\n/**\n * Function: setBubbling\n * \n * Sets <bubbling>.\n */\nmxLayoutManager.prototype.setBubbling = function(value)\n{\n\tthis.bubbling = value;\n};\n\n/**\n * Function: getGraph\n * \n * Returns the graph that this layout operates on.\n */\nmxLayoutManager.prototype.getGraph = function()\n{\n\treturn this.graph;\n};\n\n/**\n * Function: setGraph\n * \n * Sets the graph that the layouts operate on.\n */\nmxLayoutManager.prototype.setGraph = function(graph)\n{\n\tif (this.graph != null)\n\t{\n\t\tvar model = this.graph.getModel();\t\t\n\t\tmodel.removeListener(this.undoHandler);\n\t\tthis.graph.removeListener(this.moveHandler);\n\t\tthis.graph.removeListener(this.resizeHandler);\n\t}\n\t\n\tthis.graph = graph;\n\t\n\tif (this.graph != null)\n\t{\n\t\tvar model = this.graph.getModel();\t\n\t\tmodel.addListener(mxEvent.BEFORE_UNDO, this.undoHandler);\n\t\tthis.graph.addListener(mxEvent.MOVE_CELLS, this.moveHandler);\n\t\tthis.graph.addListener(mxEvent.RESIZE_CELLS, this.resizeHandler);\n\t}\n};\n\n/**\n * Function: hasLayout\n * \n * Returns true if the given cell has a layout. This implementation invokes\n * <getLayout> with <mxEvent.LAYOUT_CELLS> as the eventName. Override this\n * if creating layouts in <getLayout> is expensive and return true if\n * <getLayout> will return a layout for the given cell for\n * <mxEvent.BEGIN_UPDATE> or <mxEvent.END_UPDATE>.\n */\nmxLayoutManager.prototype.hasLayout = function(cell)\n{\n\treturn this.getLayout(cell, mxEvent.LAYOUT_CELLS);\n};\n\n/**\n * Function: getLayout\n * \n * Returns the layout for the given cell and eventName. Possible\n * event names are <mxEvent.MOVE_CELLS> and <mxEvent.RESIZE_CELLS>\n * when cells are moved or resized and <mxEvent.BEGIN_UPDATE> or\n * <mxEvent.END_UPDATE> for the bottom up and top down phases after\n * changes to the graph model. <mxEvent.LAYOUT_CELLS> is used to\n * check if a layout exists for the given cell. This is called\n * from <hasLayout>.\n */\nmxLayoutManager.prototype.getLayout = function(cell, eventName)\n{\n\treturn null;\n};\n\n/**\n * Function: beforeUndo\n * \n * Called from <undoHandler>.\n *\n * Parameters:\n * \n * cell - Array of <mxCells> that have been moved.\n * evt - Mouse event that represents the mousedown.\n */\nmxLayoutManager.prototype.beforeUndo = function(undoableEdit)\n{\n\tthis.executeLayoutForCells(this.getCellsForChanges(undoableEdit.changes));\n};\n\n/**\n * Function: cellsMoved\n * \n * Called from <moveHandler>.\n *\n * Parameters:\n * \n * cell - Array of <mxCells> that have been moved.\n * evt - Mouse event that represents the mousedown.\n */\nmxLayoutManager.prototype.cellsMoved = function(cells, evt)\n{\n\tif (cells != null && evt != null)\n\t{\n\t\tvar point = mxUtils.convertPoint(this.getGraph().container,\n\t\t\tmxEvent.getClientX(evt), mxEvent.getClientY(evt));\n\t\tvar model = this.getGraph().getModel();\n\t\t\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tvar layout = this.getLayout(model.getParent(cells[i]), mxEvent.MOVE_CELLS);\n\n\t\t\tif (layout != null)\n\t\t\t{\n\t\t\t\tlayout.moveCell(cells[i], point.x, point.y);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: cellsResized\n * \n * Called from <resizeHandler>.\n *\n * Parameters:\n * \n * cell - Array of <mxCells> that have been resized.\n * bounds - <mxRectangle> taht represents the new bounds.\n */\nmxLayoutManager.prototype.cellsResized = function(cells, bounds, prev)\n{\n\tif (cells != null && bounds != null)\n\t{\n\t\tvar model = this.getGraph().getModel();\n\t\t\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tvar layout = this.getLayout(model.getParent(cells[i]), mxEvent.RESIZE_CELLS);\n\n\t\t\tif (layout != null)\n\t\t\t{\n\t\t\t\tlayout.resizeCell(cells[i], bounds[i], prev[i]);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: getCellsForChanges\n * \n * Returns the cells for which a layout should be executed.\n */\nmxLayoutManager.prototype.getCellsForChanges = function(changes)\n{\n\tvar result = [];\n\t\n\tfor (var i = 0; i < changes.length; i++)\n\t{\n\t\tvar change = changes[i];\n\t\t\n\t\tif (change instanceof mxRootChange)\n\t\t{\n\t\t\treturn [];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = result.concat(this.getCellsForChange(change));\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getCellsForChange\n * \n * Executes all layouts which have been scheduled during the\n * changes.\n */\nmxLayoutManager.prototype.getCellsForChange = function(change)\n{\n\tif (change instanceof mxChildChange)\n\t{\n\t\treturn this.addCellsWithLayout(change.child,\n\t\t\tthis.addCellsWithLayout(change.previous));\n\t}\n\telse if (change instanceof mxTerminalChange ||\n\t\tchange instanceof mxGeometryChange)\n\t{\n\t\treturn this.addCellsWithLayout(change.cell);\n\t}\n\telse if (change instanceof mxVisibleChange ||\n\t\tchange instanceof mxStyleChange)\n\t{\n\t\treturn this.addCellsWithLayout(change.cell);\n\t}\n\t\n\treturn [];\n};\n\n/**\n * Function: addCellsWithLayout\n * \n * Adds all ancestors of the given cell that have a layout.\n */\nmxLayoutManager.prototype.addCellsWithLayout = function(cell, result)\n{\n\treturn this.addDescendantsWithLayout(cell,\n\t\tthis.addAncestorsWithLayout(cell, result));\n};\n\n/**\n * Function: addAncestorsWithLayout\n * \n * Adds all ancestors of the given cell that have a layout.\n */\nmxLayoutManager.prototype.addAncestorsWithLayout = function(cell, result)\n{\n\tresult = (result != null) ? result : [];\n\t\n\tif (cell != null)\n\t{\n\t\tvar layout = this.hasLayout(cell);\n\t\t\n\t\tif (layout != null)\n\t\t{\n\t\t\tresult.push(cell);\n\t\t}\n\t\t\n\t\tif (this.isBubbling())\n\t\t{\n\t\t\tvar model = this.getGraph().getModel();\n\t\t\tthis.addAncestorsWithLayout(\n\t\t\t\tmodel.getParent(cell), result);\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: addDescendantsWithLayout\n * \n * Adds all descendants of the given cell that have a layout.\n */\nmxLayoutManager.prototype.addDescendantsWithLayout = function(cell, result)\n{\n\tresult = (result != null) ? result : [];\n\t\n\tif (cell != null && this.hasLayout(cell))\n\t{\n\t\tvar model = this.getGraph().getModel();\n\t\t\n\t\tfor (var i = 0; i < model.getChildCount(cell); i++)\n\t\t{\n\t\t\tvar child = model.getChildAt(cell, i);\n\t\t\t\n\t\t\tif (this.hasLayout(child))\n\t\t\t{\n\t\t\t\tresult.push(child);\n\t\t\t\tthis.addDescendantsWithLayout(child, result);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: executeLayoutForCells\n * \n * Executes all layouts for the given cells in two phases: In the first phase\n * layouts for child cells are executed before layouts for parent cells with\n * <mxEvent.BEGIN_UPDATE>, in the second phase layouts for parent cells are\n * executed before layouts for child cells with <mxEvent.END_UPDATE>.\n */\nmxLayoutManager.prototype.executeLayoutForCells = function(cells)\n{\n\tvar sorted = mxUtils.sortCells(cells, false);\n\tthis.layoutCells(sorted, true);\n\tthis.layoutCells(sorted.reverse(), false);\n};\n\n/**\n * Function: layoutCells\n * \n * Executes all layouts which have been scheduled during the changes.\n */\nmxLayoutManager.prototype.layoutCells = function(cells, bubble)\n{\n\tif (cells.length > 0)\n\t{\n\t\t// Invokes the layouts while removing duplicates\n\t\tvar model = this.getGraph().getModel();\n\t\t\n\t\tmodel.beginUpdate();\n\t\ttry \n\t\t{\n\t\t\tvar last = null;\n\t\t\t\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tif (cells[i] != model.getRoot() && cells[i] != last)\n\t\t\t\t{\n\t\t\t\t\tthis.executeLayout(cells[i], bubble);\n\t\t\t\t\tlast = cells[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.LAYOUT_CELLS, 'cells', cells));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tmodel.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: executeLayout\n * \n * Executes the given layout on the given parent.\n */\nmxLayoutManager.prototype.executeLayout = function(cell, bubble)\n{\n\tvar layout = this.getLayout(cell, (bubble) ?\n\t\tmxEvent.BEGIN_UPDATE : mxEvent.END_UPDATE);\n\n\tif (layout != null)\n\t{\n\t\tlayout.execute(cell);\n\t}\n};\n\n/**\n * Function: destroy\n * \n * Removes all handlers from the <graph> and deletes the reference to it.\n */\nmxLayoutManager.prototype.destroy = function()\n{\n\tthis.setGraph(null);\n};\n\n__mxOutput.mxLayoutManager = typeof mxLayoutManager !== 'undefined' ? mxLayoutManager : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxSwimlaneManager\n * \n * Manager for swimlanes and nested swimlanes that sets the size of newly added\n * swimlanes to that of their siblings, and propagates changes to the size of a\n * swimlane to its siblings, if <siblings> is true, and its ancestors, if\n * <bubbling> is true.\n * \n * Constructor: mxSwimlaneManager\n *\n * Constructs a new swimlane manager for the given graph.\n *\n * Arguments:\n * \n * graph - Reference to the enclosing graph. \n */\nfunction mxSwimlaneManager(graph, horizontal, addEnabled, resizeEnabled)\n{\n\tthis.horizontal = (horizontal != null) ? horizontal : true;\n\tthis.addEnabled = (addEnabled != null) ? addEnabled : true;\n\tthis.resizeEnabled = (resizeEnabled != null) ? resizeEnabled : true;\n\n\tthis.addHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tif (this.isEnabled() && this.isAddEnabled())\n\t\t{\n\t\t\tthis.cellsAdded(evt.getProperty('cells'));\n\t\t}\n\t});\n\t\n\tthis.resizeHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tif (this.isEnabled() && this.isResizeEnabled())\n\t\t{\n\t\t\tthis.cellsResized(evt.getProperty('cells'));\n\t\t}\n\t});\n\t\n\tthis.setGraph(graph);\n};\n\n/**\n * Extends mxEventSource.\n */\nmxSwimlaneManager.prototype = new mxEventSource();\nmxSwimlaneManager.prototype.constructor = mxSwimlaneManager;\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxSwimlaneManager.prototype.graph = null;\n\n/**\n * Variable: enabled\n * \n * Specifies if event handling is enabled. Default is true.\n */\nmxSwimlaneManager.prototype.enabled = true;\n\n/**\n * Variable: horizontal\n * \n * Specifies the orientation of the swimlanes. Default is true.\n */\nmxSwimlaneManager.prototype.horizontal = true;\n\n/**\n * Variable: addEnabled\n * \n * Specifies if newly added cells should be resized to match the size of their\n * existing siblings. Default is true.\n */\nmxSwimlaneManager.prototype.addEnabled = true;\n\n/**\n * Variable: resizeEnabled\n * \n * Specifies if resizing of swimlanes should be handled. Default is true.\n */\nmxSwimlaneManager.prototype.resizeEnabled = true;\n\n/**\n * Variable: moveHandler\n * \n * Holds the function that handles the move event.\n */\nmxSwimlaneManager.prototype.addHandler = null;\n\n/**\n * Variable: moveHandler\n * \n * Holds the function that handles the move event.\n */\nmxSwimlaneManager.prototype.resizeHandler = null;\n\n/**\n * Function: isEnabled\n * \n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxSwimlaneManager.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n * \n * Enables or disables event handling. This implementation\n * updates <enabled>.\n * \n * Parameters:\n * \n * enabled - Boolean that specifies the new enabled state.\n */\nmxSwimlaneManager.prototype.setEnabled = function(value)\n{\n\tthis.enabled = value;\n};\n\n/**\n * Function: isHorizontal\n * \n * Returns <horizontal>.\n */\nmxSwimlaneManager.prototype.isHorizontal = function()\n{\n\treturn this.horizontal;\n};\n\n/**\n * Function: setHorizontal\n * \n * Sets <horizontal>.\n */\nmxSwimlaneManager.prototype.setHorizontal = function(value)\n{\n\tthis.horizontal = value;\n};\n\n/**\n * Function: isAddEnabled\n * \n * Returns <addEnabled>.\n */\nmxSwimlaneManager.prototype.isAddEnabled = function()\n{\n\treturn this.addEnabled;\n};\n\n/**\n * Function: setAddEnabled\n * \n * Sets <addEnabled>.\n */\nmxSwimlaneManager.prototype.setAddEnabled = function(value)\n{\n\tthis.addEnabled = value;\n};\n\n/**\n * Function: isResizeEnabled\n * \n * Returns <resizeEnabled>.\n */\nmxSwimlaneManager.prototype.isResizeEnabled = function()\n{\n\treturn this.resizeEnabled;\n};\n\n/**\n * Function: setResizeEnabled\n * \n * Sets <resizeEnabled>.\n */\nmxSwimlaneManager.prototype.setResizeEnabled = function(value)\n{\n\tthis.resizeEnabled = value;\n};\n\n/**\n * Function: getGraph\n * \n * Returns the graph that this manager operates on.\n */\nmxSwimlaneManager.prototype.getGraph = function()\n{\n\treturn this.graph;\n};\n\n/**\n * Function: setGraph\n * \n * Sets the graph that the manager operates on.\n */\nmxSwimlaneManager.prototype.setGraph = function(graph)\n{\n\tif (this.graph != null)\n\t{\n\t\tthis.graph.removeListener(this.addHandler);\n\t\tthis.graph.removeListener(this.resizeHandler);\n\t}\n\t\n\tthis.graph = graph;\n\t\n\tif (this.graph != null)\n\t{\n\t\tthis.graph.addListener(mxEvent.ADD_CELLS, this.addHandler);\n\t\tthis.graph.addListener(mxEvent.CELLS_RESIZED, this.resizeHandler);\n\t}\n};\n\n/**\n * Function: isSwimlaneIgnored\n * \n * Returns true if the given swimlane should be ignored.\n */\nmxSwimlaneManager.prototype.isSwimlaneIgnored = function(swimlane)\n{\n\treturn !this.getGraph().isSwimlane(swimlane);\n};\n\n/**\n * Function: isCellHorizontal\n * \n * Returns true if the given cell is horizontal. If the given cell is not a\n * swimlane, then the global orientation is returned.\n */\nmxSwimlaneManager.prototype.isCellHorizontal = function(cell)\n{\n\tif (this.graph.isSwimlane(cell))\n\t{\n\t\tvar style = this.graph.getCellStyle(cell);\n\t\t\n\t\treturn mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, 1) == 1;\n\t}\n\t\n\treturn !this.isHorizontal();\n};\n\n/**\n * Function: cellsAdded\n * \n * Called if any cells have been added.\n * \n * Parameters:\n * \n * cell - Array of <mxCells> that have been added.\n */\nmxSwimlaneManager.prototype.cellsAdded = function(cells)\n{\n\tif (cells != null)\n\t{\n\t\tvar model = this.getGraph().getModel();\n\n\t\tmodel.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tif (!this.isSwimlaneIgnored(cells[i]))\n\t\t\t\t{\n\t\t\t\t\tthis.swimlaneAdded(cells[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tmodel.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: swimlaneAdded\n * \n * Updates the size of the given swimlane to match that of any existing\n * siblings swimlanes.\n * \n * Parameters:\n * \n * swimlane - <mxCell> that represents the new swimlane.\n */\nmxSwimlaneManager.prototype.swimlaneAdded = function(swimlane)\n{\n\tvar model = this.getGraph().getModel();\n\tvar parent = model.getParent(swimlane);\n\tvar childCount = model.getChildCount(parent);\n\tvar geo = null;\n\t\n\t// Finds the first valid sibling swimlane as reference\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = model.getChildAt(parent, i);\n\t\t\n\t\tif (child != swimlane && !this.isSwimlaneIgnored(child))\n\t\t{\n\t\t\tgeo = model.getGeometry(child);\n\t\t\t\n\t\t\tif (geo != null)\n\t\t\t{\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Applies the size of the refernece to the newly added swimlane\n\tif (geo != null)\n\t{\n\t\tvar parentHorizontal = (parent != null) ? this.isCellHorizontal(parent) : this.horizontal;\n\t\tthis.resizeSwimlane(swimlane, geo.width, geo.height, parentHorizontal);\n\t}\n};\n\n/**\n * Function: cellsResized\n * \n * Called if any cells have been resizes. Calls <swimlaneResized> for all\n * swimlanes where <isSwimlaneIgnored> returns false.\n * \n * Parameters:\n * \n * cells - Array of <mxCells> whose size was changed.\n */\nmxSwimlaneManager.prototype.cellsResized = function(cells)\n{\n\tif (cells != null)\n\t{\n\t\tvar model = this.getGraph().getModel();\n\t\t\n\t\tmodel.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\t// Finds the top-level swimlanes and adds offsets\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tif (!this.isSwimlaneIgnored(cells[i]))\n\t\t\t\t{\n\t\t\t\t\tvar geo = model.getGeometry(cells[i]);\n\n\t\t\t\t\tif (geo != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar size = new mxRectangle(0, 0, geo.width, geo.height);\n\t\t\t\t\t\tvar top = cells[i];\n\t\t\t\t\t\tvar current = top;\n\t\t\t\t\t\t\n\t\t\t\t\t\twhile (current != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttop = current;\n\t\t\t\t\t\t\tcurrent = model.getParent(current);\n\t\t\t\t\t\t\tvar tmp = (this.graph.isSwimlane(current)) ?\n\t\t\t\t\t\t\t\t\tthis.graph.getStartSize(current) :\n\t\t\t\t\t\t\t\t\tnew mxRectangle();\n\t\t\t\t\t\t\tsize.width += tmp.width;\n\t\t\t\t\t\t\tsize.height += tmp.height;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar parentHorizontal = (current != null) ? this.isCellHorizontal(current) : this.horizontal;\n\t\t\t\t\t\tthis.resizeSwimlane(top, size.width, size.height, parentHorizontal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tmodel.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: resizeSwimlane\n * \n * Called from <cellsResized> for all swimlanes that are not ignored to update\n * the size of the siblings and the size of the parent swimlanes, recursively,\n * if <bubbling> is true.\n * \n * Parameters:\n * \n * swimlane - <mxCell> whose size has changed.\n */\nmxSwimlaneManager.prototype.resizeSwimlane = function(swimlane, w, h, parentHorizontal)\n{\n\tvar model = this.getGraph().getModel();\n\t\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tvar horizontal = this.isCellHorizontal(swimlane);\n\t\t\n\t\tif (!this.isSwimlaneIgnored(swimlane))\n\t\t{\n\t\t\tvar geo = model.getGeometry(swimlane);\n\t\t\t\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tif ((parentHorizontal && geo.height != h) || (!parentHorizontal && geo.width != w))\n\t\t\t\t{\n\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\n\t\t\t\t\tif (parentHorizontal)\n\t\t\t\t\t{\n\t\t\t\t\t\tgeo.height = h;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tgeo.width = w;\n\t\t\t\t\t}\n\n\t\t\t\t\tmodel.setGeometry(swimlane, geo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar tmp = (this.graph.isSwimlane(swimlane)) ?\n\t\t\t\tthis.graph.getStartSize(swimlane) :\n\t\t\t\tnew mxRectangle();\n\t\tw -= tmp.width;\n\t\th -= tmp.height;\n\t\t\n\t\tvar childCount = model.getChildCount(swimlane);\n\t\t\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar child = model.getChildAt(swimlane, i);\n\t\t\tthis.resizeSwimlane(child, w, h, horizontal);\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n};\n\n/**\n * Function: destroy\n * \n * Removes all handlers from the <graph> and deletes the reference to it.\n */\nmxSwimlaneManager.prototype.destroy = function()\n{\n\tthis.setGraph(null);\n};\n\n__mxOutput.mxSwimlaneManager = typeof mxSwimlaneManager !== 'undefined' ? mxSwimlaneManager : undefined;\n\n/**\n * Copyright (c) 2006-2017, JGraph Ltd\n * Copyright (c) 2006-2017, Gaudenz Alder\n */\n/**\n * Class: mxTemporaryCellStates\n * \n * Creates a temporary set of cell states.\n */\nfunction mxTemporaryCellStates(view, scale, cells, isCellVisibleFn, getLinkForCellState)\n{\n\tscale = (scale != null) ? scale : 1;\n\tthis.view = view;\n\t\n\t// Stores the previous state\n\tthis.oldValidateCellState = view.validateCellState;\n\tthis.oldBounds = view.getGraphBounds();\n\tthis.oldStates = view.getStates();\n\tthis.oldScale = view.getScale();\n\tthis.oldDoRedrawShape = view.graph.cellRenderer.doRedrawShape;\n\n\tvar self = this;\n\n\t// Overrides doRedrawShape and paint shape to add links on shapes\n\tif (getLinkForCellState != null)\n\t{\n\t\tview.graph.cellRenderer.doRedrawShape = function(state)\n\t\t{\n\t\t\tvar oldPaint = state.shape.paint;\n\t\t\t\n\t\t\tstate.shape.paint = function(c)\n\t\t\t{\n\t\t\t\tvar link = getLinkForCellState(state);\n\t\t\t\t\n\t\t\t\tif (link != null)\n\t\t\t\t{\n\t\t\t\t\tc.setLink(link);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\toldPaint.apply(this, arguments);\n\t\t\t\t\n\t\t\t\tif (link != null)\n\t\t\t\t{\n\t\t\t\t\tc.setLink(null);\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\tself.oldDoRedrawShape.apply(view.graph.cellRenderer, arguments);\n\t\t\tstate.shape.paint = oldPaint;\n\t\t};\n\t}\n\n\t// Overrides validateCellState to ignore invisible cells\n\tview.validateCellState = function(cell, resurse)\n\t{\n\t\tif (cell == null || isCellVisibleFn == null || isCellVisibleFn(cell))\n\t\t{\n\t\t\treturn self.oldValidateCellState.apply(view, arguments);\n\t\t}\n\t\t\n\t\treturn null;\n\t};\n\t\n\t// Creates space for new states\n\tview.setStates(new mxDictionary());\n\tview.setScale(scale);\n\t\n\tif (cells != null)\n\t{\n\t\tview.resetValidationState();\n\t\tvar bbox = null;\n\n\t\t// Validates the vertices and edges without adding them to\n\t\t// the model so that the original cells are not modified\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tvar bounds = view.getBoundingBox(view.validateCellState(view.validateCell(cells[i])));\n\t\t\t\n\t\t\tif (bbox == null)\n\t\t\t{\n\t\t\t\tbbox = bounds;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbbox.add(bounds);\n\t\t\t}\n\t\t}\n\n\t\tview.setGraphBounds(bbox || new mxRectangle());\n\t}\n};\n\n/**\n * Variable: view\n *\n * Holds the width of the rectangle. Default is 0.\n */\nmxTemporaryCellStates.prototype.view = null;\n\n/**\n * Variable: oldStates\n *\n * Holds the height of the rectangle. Default is 0.\n */\nmxTemporaryCellStates.prototype.oldStates = null;\n\n/**\n * Variable: oldBounds\n *\n * Holds the height of the rectangle. Default is 0.\n */\nmxTemporaryCellStates.prototype.oldBounds = null;\n\n/**\n * Variable: oldScale\n *\n * Holds the height of the rectangle. Default is 0.\n */\nmxTemporaryCellStates.prototype.oldScale = null;\n\n/**\n * Function: destroy\n * \n * Returns the top, left corner as a new <mxPoint>.\n */\nmxTemporaryCellStates.prototype.destroy = function()\n{\n\tthis.view.setScale(this.oldScale);\n\tthis.view.setStates(this.oldStates);\n\tthis.view.setGraphBounds(this.oldBounds);\n\tthis.view.validateCellState = this.oldValidateCellState;\n\tthis.view.graph.cellRenderer.doRedrawShape = this.oldDoRedrawShape;\n};\n\n__mxOutput.mxTemporaryCellStates = typeof mxTemporaryCellStates !== 'undefined' ? mxTemporaryCellStates : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n *\n * Class: mxCellStatePreview\n * \n * Implements a live preview for moving cells.\n * \n * Constructor: mxCellStatePreview\n * \n * Constructs a move preview for the given graph.\n * \n * Parameters:\n * \n * graph - Reference to the enclosing <mxGraph>.\n */\nfunction mxCellStatePreview(graph)\n{\n\tthis.deltas = new mxDictionary();\n\tthis.graph = graph;\n};\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxCellStatePreview.prototype.graph = null;\n\n/**\n * Variable: deltas\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxCellStatePreview.prototype.deltas = null;\n\n/**\n * Variable: count\n * \n * Contains the number of entries in the map.\n */\nmxCellStatePreview.prototype.count = 0;\n\n/**\n * Function: isEmpty\n * \n * Returns true if this contains no entries.\n */\nmxCellStatePreview.prototype.isEmpty = function()\n{\n\treturn this.count == 0;\n};\n\n/**\n * Function: moveState\n */\nmxCellStatePreview.prototype.moveState = function(state, dx, dy, add, includeEdges)\n{\n\tadd = (add != null) ? add : true;\n\tincludeEdges = (includeEdges != null) ? includeEdges : true;\n\t\n\tvar delta = this.deltas.get(state.cell);\n\n\tif (delta == null)\n\t{\n\t\t// Note: Deltas stores the point and the state since the key is a string.\n\t\tdelta = {point: new mxPoint(dx, dy), state: state};\n\t\tthis.deltas.put(state.cell, delta);\n\t\tthis.count++;\n\t}\n\telse if (add)\n\t{\n\t\tdelta.point.x += dx;\n\t\tdelta.point.y += dy;\n\t}\n\telse\n\t{\n\t\tdelta.point.x = dx;\n\t\tdelta.point.y = dy;\n\t}\n\t\n\tif (includeEdges)\n\t{\n\t\tthis.addEdges(state);\n\t}\n\t\n\treturn delta.point;\n};\n\n/**\n * Function: show\n */\nmxCellStatePreview.prototype.show = function(visitor)\n{\n\tthis.deltas.visit(mxUtils.bind(this, function(key, delta)\n\t{\n\t\tthis.translateState(delta.state, delta.point.x, delta.point.y);\n\t}));\n\t\n\tthis.deltas.visit(mxUtils.bind(this, function(key, delta)\n\t{\n\t\tthis.revalidateState(delta.state, delta.point.x, delta.point.y, visitor);\n\t}));\n};\n\n/**\n * Function: translateState\n */\nmxCellStatePreview.prototype.translateState = function(state, dx, dy)\n{\n\tif (state != null)\n\t{\n\t\tvar model = this.graph.getModel();\n\t\t\n\t\tif (model.isVertex(state.cell))\n\t\t{\n\t\t\tstate.view.updateCellState(state);\n\t\t\tvar geo = model.getGeometry(state.cell);\n\t\t\t\n\t\t\t// Moves selection cells and non-relative vertices in\n\t\t\t// the first phase so that edge terminal points will\n\t\t\t// be updated in the second phase\n\t\t\tif ((dx != 0 || dy != 0) && geo != null && (!geo.relative || this.deltas.get(state.cell) != null))\n\t\t\t{\n\t\t\t\tstate.x += dx;\n\t\t\t\tstate.y += dy;\n\t\t\t}\n\t\t}\n\t    \n\t    var childCount = model.getChildCount(state.cell);\n\t    \n\t    for (var i = 0; i < childCount; i++)\n\t    {\n\t    \tthis.translateState(state.view.getState(model.getChildAt(state.cell, i)), dx, dy);\n\t    }\n\t}\n};\n\n/**\n * Function: revalidateState\n */\nmxCellStatePreview.prototype.revalidateState = function(state, dx, dy, visitor)\n{\n\tif (state != null)\n\t{\n\t\tvar model = this.graph.getModel();\n\t\t\n\t\t// Updates the edge terminal points and restores the\n\t\t// (relative) positions of any (relative) children\n\t\tif (model.isEdge(state.cell))\n\t\t{\n\t\t\tstate.view.updateCellState(state);\n\t\t}\n\n\t\tvar geo = this.graph.getCellGeometry(state.cell);\n\t\tvar pState = state.view.getState(model.getParent(state.cell));\n\t\t\n\t\t// Moves selection vertices which are relative\n\t\tif ((dx != 0 || dy != 0) && geo != null && geo.relative &&\n\t\t\tmodel.isVertex(state.cell) && (pState == null ||\n\t\t\tmodel.isVertex(pState.cell) || this.deltas.get(state.cell) != null))\n\t\t{\n\t\t\tstate.x += dx;\n\t\t\tstate.y += dy;\n\t\t}\n\t\t\n\t\tthis.graph.cellRenderer.redraw(state);\n\t\n\t\t// Invokes the visitor on the given state\n\t\tif (visitor != null)\n\t\t{\n\t\t\tvisitor(state);\n\t\t}\n\t\t\t\t\t\t\n\t    var childCount = model.getChildCount(state.cell);\n\t    \n\t    for (var i = 0; i < childCount; i++)\n\t    {\n\t    \tthis.revalidateState(this.graph.view.getState(model.getChildAt(state.cell, i)), dx, dy, visitor);\n\t    }\n\t}\n};\n\n/**\n * Function: addEdges\n */\nmxCellStatePreview.prototype.addEdges = function(state)\n{\n\tvar model = this.graph.getModel();\n\tvar edgeCount = model.getEdgeCount(state.cell);\n\n\tfor (var i = 0; i < edgeCount; i++)\n\t{\n\t\tvar s = state.view.getState(model.getEdgeAt(state.cell, i));\n\n\t\tif (s != null)\n\t\t{\n\t\t\tthis.moveState(s, 0, 0);\n\t\t}\n\t}\n};\n\n__mxOutput.mxCellStatePreview = typeof mxCellStatePreview !== 'undefined' ? mxCellStatePreview : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxConnectionConstraint\n * \n * Defines an object that contains the constraints about how to connect one\n * side of an edge to its terminal.\n * \n * Constructor: mxConnectionConstraint\n * \n * Constructs a new connection constraint for the given point and boolean\n * arguments.\n * \n * Parameters:\n * \n * point - Optional <mxPoint> that specifies the fixed location of the point\n * in relative coordinates. Default is null.\n * perimeter - Optional boolean that specifies if the fixed point should be\n * projected onto the perimeter of the terminal. Default is true.\n */\nfunction mxConnectionConstraint(point, perimeter, name, dx, dy)\n{\n\tthis.point = point;\n\tthis.perimeter = (perimeter != null) ? perimeter : true;\n\tthis.name = name;\n\tthis.dx = dx? dx : 0;\n\tthis.dy = dy? dy : 0;\n};\n\n/**\n * Variable: point\n * \n * <mxPoint> that specifies the fixed location of the connection point.\n */\nmxConnectionConstraint.prototype.point = null;\n\n/**\n * Variable: perimeter\n * \n * Boolean that specifies if the point should be projected onto the perimeter\n * of the terminal.\n */\nmxConnectionConstraint.prototype.perimeter = null;\n\n/**\n * Variable: name\n * \n * Optional string that specifies the name of the constraint.\n */\nmxConnectionConstraint.prototype.name = null;\n\n/**\n * Variable: dx\n * \n * Optional float that specifies the horizontal offset of the constraint.\n */\nmxConnectionConstraint.prototype.dx = null;\n\n/**\n * Variable: dy\n * \n * Optional float that specifies the vertical offset of the constraint.\n */\nmxConnectionConstraint.prototype.dy = null;\n\n\n__mxOutput.mxConnectionConstraint = typeof mxConnectionConstraint !== 'undefined' ? mxConnectionConstraint : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraphHandler\n * \n * Graph event handler that handles selection. Individual cells are handled\n * separately using <mxVertexHandler> or one of the edge handlers. These\n * handlers are created using <mxGraph.createHandler> in\n * <mxGraphSelectionModel.cellAdded>.\n * \n * To avoid the container to scroll a moved cell into view, set\n * <scrollAfterMove> to false.\n * \n * Constructor: mxGraphHandler\n * \n * Constructs an event handler that creates handles for the\n * selection cells.\n * \n * Parameters:\n * \n * graph - Reference to the enclosing <mxGraph>.\n */\nfunction mxGraphHandler(graph)\n{\n\tthis.graph = graph;\n\tthis.graph.addMouseListener(this);\n\t\n\t// Repaints the handler after autoscroll\n\tthis.panHandler = mxUtils.bind(this, function()\n\t{\n\t\tif (!this.suspended)\n\t\t{\n\t\t\tthis.updatePreview();\n\t\t\tthis.updateHint();\n\t\t}\n\t});\n\t\n\tthis.graph.addListener(mxEvent.PAN, this.panHandler);\n\t\n\t// Handles escape keystrokes\n\tthis.escapeHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tthis.reset();\n\t});\n\t\n\tthis.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);\n\t\n\t// Updates the preview box for remote changes\n\tthis.refreshHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\t// Merges multiple pending calls\n\t\tif (this.refreshThread)\n\t\t{\n\t\t\twindow.clearTimeout(this.refreshThread);\n\t\t}\n\n\t\t// Waits for the states and handlers to be updated\n\t\tthis.refreshThread = window.setTimeout(mxUtils.bind(this, function()\n\t\t{\n\t\t\tthis.refreshThread = null;\n\t\t\t\n\t\t\tif (this.first != null && !this.suspended)\n\t\t\t{\n\t\t\t\t// Updates preview with no translate to compute bounding box\n\t\t\t\tvar dx = this.currentDx;\n\t\t\t\tvar dy = this.currentDy;\n\t\t\t\tthis.currentDx = 0;\n\t\t\t\tthis.currentDy = 0;\n\t\t\t\tthis.updatePreview();\n\t\t\t\tthis.bounds = this.graph.getView().getBounds(this.cells);\n\t\t\t\tthis.pBounds = this.getPreviewBounds(this.cells);\n\n\t\t\t\tif (this.pBounds == null && !this.livePreviewUsed)\n\t\t\t\t{\n\t\t\t\t\tthis.reset();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Restores translate and updates preview\n\t\t\t\t\tthis.currentDx = dx;\n\t\t\t\t\tthis.currentDy = dy;\n\t\t\t\t\tthis.updatePreview();\n\t\t\t\t\tthis.updateHint();\n\n\t\t\t\t\tif (this.livePreviewUsed)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Forces update to ignore last visible state\n\t\t\t\t\t\tthis.setHandlesVisibleForCells(\n\t\t\t\t\t\t\tthis.graph.selectionCellsHandler.\n\t\t\t\t\t\t\tgetHandledSelectionCells(), false, true);\n\t\t\t\t\t\tthis.updatePreview();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}), 0);\n\t});\n\t\n\tthis.graph.getModel().addListener(mxEvent.CHANGE, this.refreshHandler);\n\tthis.graph.addListener(mxEvent.REFRESH, this.refreshHandler);\n\t\n\tthis.keyHandler = mxUtils.bind(this, function(e)\n\t{\n\t\tif (this.graph.container != null && this.graph.container.style.visibility != 'hidden' &&\n\t\t\tthis.first != null && !this.suspended)\n\t\t{\n\t\t\tvar clone = this.graph.isCloneEvent(e) &&\n\t\t\t\tthis.graph.isCellsCloneable() &&\n\t\t\t\tthis.isCloneEnabled();\n\t\t\t\n\t\t\tif (clone != this.cloning)\n\t\t\t{\n\t\t\t\tthis.cloning = clone;\n\t\t\t\tthis.checkPreview();\n\t\t\t\tthis.updatePreview();\n\t\t\t}\n\t\t}\n\t});\n\t\n\tmxEvent.addListener(document, 'keydown', this.keyHandler);\n\tmxEvent.addListener(document, 'keyup', this.keyHandler);\n};\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxGraphHandler.prototype.graph = null;\n\n/**\n * Variable: maxCells\n * \n * Defines the maximum number of cells to paint subhandles\n * for. Default is 50 for Firefox and 20 for IE. Set this\n * to 0 if you want an unlimited number of handles to be\n * displayed. This is only recommended if the number of\n * cells in the graph is limited to a small number, eg.\n * 500.\n */\nmxGraphHandler.prototype.maxCells = (mxClient.IS_IE) ? 20 : 50;\n\n/**\n * Variable: enabled\n * \n * Specifies if events are handled. Default is true.\n */\nmxGraphHandler.prototype.enabled = true;\n\n/**\n * Variable: highlightEnabled\n * \n * Specifies if drop targets under the mouse should be enabled. Default is\n * true.\n */\nmxGraphHandler.prototype.highlightEnabled = true;\n\n/**\n * Variable: cloneEnabled\n * \n * Specifies if cloning by control-drag is enabled. Default is true.\n */\nmxGraphHandler.prototype.cloneEnabled = true;\n\n/**\n * Variable: moveEnabled\n * \n * Specifies if moving is enabled. Default is true.\n */\nmxGraphHandler.prototype.moveEnabled = true;\n\n/**\n * Variable: guidesEnabled\n * \n * Specifies if other cells should be used for snapping the right, center or\n * left side of the current selection. Default is false.\n */\nmxGraphHandler.prototype.guidesEnabled = false;\n\n/**\n * Variable: handlesVisible\n * \n * Whether the handles of the selection are currently visible.\n */\nmxGraphHandler.prototype.handlesVisible = true;\n\n/**\n * Variable: guide\n * \n * Holds the <mxGuide> instance that is used for alignment.\n */\nmxGraphHandler.prototype.guide = null;\n\n/**\n * Variable: currentDx\n * \n * Stores the x-coordinate of the current mouse move.\n */\nmxGraphHandler.prototype.currentDx = null;\n\n/**\n * Variable: currentDy\n * \n * Stores the y-coordinate of the current mouse move.\n */\nmxGraphHandler.prototype.currentDy = null;\n\n/**\n * Variable: updateCursor\n * \n * Specifies if a move cursor should be shown if the mouse is over a movable\n * cell. Default is true.\n */\nmxGraphHandler.prototype.updateCursor = true;\n\n/**\n * Variable: selectEnabled\n * \n * Specifies if selecting is enabled. Default is true.\n */\nmxGraphHandler.prototype.selectEnabled = true;\n\n/**\n * Variable: removeCellsFromParent\n * \n * Specifies if cells may be moved out of their parents. Default is true.\n */\nmxGraphHandler.prototype.removeCellsFromParent = true;\n\n/**\n * Variable: removeEmptyParents\n * \n * If empty parents should be removed from the model after all child cells\n * have been moved out. Default is true.\n */\nmxGraphHandler.prototype.removeEmptyParents = false;\n\n/**\n * Variable: connectOnDrop\n * \n * Specifies if drop events are interpreted as new connections if no other\n * drop action is defined. Default is false.\n */\nmxGraphHandler.prototype.connectOnDrop = false;\n\n/**\n * Variable: scrollOnMove\n * \n * Specifies if the view should be scrolled so that a moved cell is\n * visible. Default is true.\n */\nmxGraphHandler.prototype.scrollOnMove = true;\n\n/**\n * Variable: minimumSize\n * \n * Specifies the minimum number of pixels for the width and height of a\n * selection border. Default is 6.\n */\nmxGraphHandler.prototype.minimumSize = 6;\n\n/**\n * Variable: previewColor\n * \n * Specifies the color of the preview shape. Default is black.\n */\nmxGraphHandler.prototype.previewColor = 'black';\n\n/**\n * Variable: htmlPreview\n * \n * Specifies if the graph container should be used for preview. If this is used\n * then drop target detection relies entirely on <mxGraph.getCellAt> because\n * the HTML preview does not \"let events through\". Default is false.\n */\nmxGraphHandler.prototype.htmlPreview = false;\n\n/**\n * Variable: shape\n * \n * Reference to the <mxShape> that represents the preview.\n */\nmxGraphHandler.prototype.shape = null;\n\n/**\n * Variable: scaleGrid\n * \n * Specifies if the grid should be scaled. Default is false.\n */\nmxGraphHandler.prototype.scaleGrid = false;\n\n/**\n * Variable: rotationEnabled\n * \n * Specifies if the bounding box should allow for rotation. Default is true.\n */\nmxGraphHandler.prototype.rotationEnabled = true;\n\n/**\n * Variable: maxLivePreview\n * \n * Maximum number of cells for which live preview should be used. Default is 0\n * which means no live preview.\n */\nmxGraphHandler.prototype.maxLivePreview = 0;\n\n/**\n * Variable: allowLivePreview\n * \n * If live preview is allowed on this system. Default is true for systems with\n * SVG support.\n */\nmxGraphHandler.prototype.allowLivePreview = mxClient.IS_SVG;\n\n/**\n * Function: isEnabled\n * \n * Returns <enabled>.\n */\nmxGraphHandler.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n * \n * Sets <enabled>.\n */\nmxGraphHandler.prototype.setEnabled = function(value)\n{\n\tthis.enabled = value;\n};\n\n/**\n * Function: isCloneEnabled\n * \n * Returns <cloneEnabled>.\n */\nmxGraphHandler.prototype.isCloneEnabled = function()\n{\n\treturn this.cloneEnabled;\n};\n\n/**\n * Function: setCloneEnabled\n * \n * Sets <cloneEnabled>.\n * \n * Parameters:\n * \n * value - Boolean that specifies the new clone enabled state.\n */\nmxGraphHandler.prototype.setCloneEnabled = function(value)\n{\n\tthis.cloneEnabled = value;\n};\n\n/**\n * Function: isMoveEnabled\n * \n * Returns <moveEnabled>.\n */\nmxGraphHandler.prototype.isMoveEnabled = function()\n{\n\treturn this.moveEnabled;\n};\n\n/**\n * Function: setMoveEnabled\n * \n * Sets <moveEnabled>.\n */\nmxGraphHandler.prototype.setMoveEnabled = function(value)\n{\n\tthis.moveEnabled = value;\n};\n\n/**\n * Function: isSelectEnabled\n * \n * Returns <selectEnabled>.\n */\nmxGraphHandler.prototype.isSelectEnabled = function()\n{\n\treturn this.selectEnabled;\n};\n\n/**\n * Function: setSelectEnabled\n * \n * Sets <selectEnabled>.\n */\nmxGraphHandler.prototype.setSelectEnabled = function(value)\n{\n\tthis.selectEnabled = value;\n};\n\n/**\n * Function: isRemoveCellsFromParent\n * \n * Returns <removeCellsFromParent>.\n */\nmxGraphHandler.prototype.isRemoveCellsFromParent = function()\n{\n\treturn this.removeCellsFromParent;\n};\n\n/**\n * Function: setRemoveCellsFromParent\n * \n * Sets <removeCellsFromParent>.\n */\nmxGraphHandler.prototype.setRemoveCellsFromParent = function(value)\n{\n\tthis.removeCellsFromParent = value;\n};\n\n/**\n * Function: isPropagateSelectionCell\n * \n * Returns true if the given cell and parent should propagate\n * selection state to the parent.\n */\nmxGraphHandler.prototype.isPropagateSelectionCell = function(cell, immediate, me)\n{\n\tvar parent = this.graph.model.getParent(cell);\n\n\tif (immediate)\n\t{\n\t\tvar geo = (this.graph.model.isEdge(cell)) ? null :\n\t\t\tthis.graph.getCellGeometry(cell);\n\t\t\n\t\treturn !this.graph.isSiblingSelected(cell) &&\n\t\t\t((geo != null && geo.relative) ||\n\t\t\t!this.graph.isSwimlane(parent));\n\t}\n\telse\n\t{\n\t\treturn (!this.graph.isToggleEvent(me.getEvent()) ||\n\t\t\t(!this.graph.isSiblingSelected(cell) &&\n\t\t\t!this.graph.isCellSelected(cell) &&\n\t\t\t(!this.graph.isSwimlane(parent)) ||\n\t\t\tthis.graph.isCellSelected(parent))) &&\n\t\t\t(this.graph.isToggleEvent(me.getEvent()) ||\n\t\t\t!this.graph.isCellSelected(parent));\n\t}\n};\n\n/**\n * Function: getInitialCellForEvent\n * \n * Hook to return initial cell for the given event. This returns\n * the topmost cell that is not a swimlane or is selected.\n */\nmxGraphHandler.prototype.getInitialCellForEvent = function(me)\n{\n\tvar state = me.getState();\n\t\n\tif ((!this.graph.isToggleEvent(me.getEvent()) || !mxEvent.isAltDown(me.getEvent())) &&\n\t\tstate != null && !this.graph.isCellSelected(state.cell))\n\t{\n\t\tvar model = this.graph.model;\n\t\tvar next = this.graph.view.getState(model.getParent(state.cell));\n\n\t\twhile (next != null && !this.graph.isCellSelected(next.cell) &&\n\t\t\t(model.isVertex(next.cell) || model.isEdge(next.cell)) &&\n\t\t\tthis.isPropagateSelectionCell(state.cell, true, me))\n\t\t{\n\t\t\tstate = next;\n\t\t\tnext = this.graph.view.getState(this.graph.getModel().getParent(state.cell));\n\t\t}\n\t}\n\t\n\treturn (state != null) ? state.cell : null;\n};\n\n/**\n * Function: isDelayedSelection\n * \n * Returns true if the cell or one of its ancestors is selected.\n */\nmxGraphHandler.prototype.isDelayedSelection = function(cell, me)\n{\n\tif (!this.graph.isToggleEvent(me.getEvent()) || !mxEvent.isAltDown(me.getEvent()))\n\t{\n\t\twhile (cell != null)\n\t\t{\n\t\t\tif (this.graph.selectionCellsHandler.isHandled(cell))\n\t\t\t{\n\t\t\t\treturn this.graph.cellEditor.getEditingCell() != cell;\n\t\t\t}\n\t\t\t\n\t\t\tcell = this.graph.model.getParent(cell);\n\t\t}\n\t}\n\t\n\treturn this.graph.isToggleEvent(me.getEvent()) && !mxEvent.isAltDown(me.getEvent());\n};\n\n/**\n * Function: selectDelayed\n * \n * Implements the delayed selection for the given mouse event.\n */\nmxGraphHandler.prototype.selectDelayed = function(me)\n{\n\tif (!this.graph.popupMenuHandler.isPopupTrigger(me))\n\t{\n\t\tvar cell = me.getCell();\n\t\t\n\t\tif (cell == null)\n\t\t{\n\t\t\tcell = this.cell;\n\t\t}\n\t\t\n\t\tthis.selectCellForEvent(cell, me);\n\t}\n};\n\n/**\n * Function: selectCellForEvent\n * \n * Selects the given cell for the given <mxMouseEvent>.\n */\nmxGraphHandler.prototype.selectCellForEvent = function(cell, me)\n{\n\tvar state = this.graph.view.getState(cell);\n\t\n\tif (state != null)\n\t{\n\t\tif (me.isSource(state.control))\n\t\t{\n\t\t\tthis.graph.selectCellForEvent(cell, me.getEvent());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!this.graph.isToggleEvent(me.getEvent()) ||\n\t\t\t\t!mxEvent.isAltDown(me.getEvent()))\n\t\t\t{\n\t\t\t\tvar model = this.graph.getModel();\n\t\t\t\tvar parent = model.getParent(cell);\n\t\t\t\t\n\t\t\t\twhile (this.graph.view.getState(parent) != null &&\n\t\t\t\t\t(model.isVertex(parent) || model.isEdge(parent)) &&\n\t\t\t\t\tthis.isPropagateSelectionCell(cell, false, me))\n\t\t\t\t{\n\t\t\t\t\tcell = parent;\n\t\t\t\t\tparent = model.getParent(cell);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.graph.selectCellForEvent(cell, me.getEvent());\n\t\t}\n\t}\n\t\n\treturn cell;\n};\n\n/**\n * Function: consumeMouseEvent\n * \n * Consumes the given mouse event. NOTE: This may be used to enable click\n * events for links in labels on iOS as follows as consuming the initial\n * touchStart disables firing the subsequent click event on the link.\n * \n * <code>\n * mxGraphHandler.prototype.consumeMouseEvent = function(evtName, me)\n * {\n *   var source = mxEvent.getSource(me.getEvent());\n *   \n *   if (!mxEvent.isTouchEvent(me.getEvent()) || source.nodeName != 'A')\n *   {\n *     me.consume();\n *   }\n * }\n * </code>\n */\nmxGraphHandler.prototype.consumeMouseEvent = function(evtName, me)\n{\n\tme.consume();\n};\n\n/**\n * Function: mouseDown\n * \n * Handles the event by selecing the given cell and creating a handle for\n * it. By consuming the event all subsequent events of the gesture are\n * redirected to this handler.\n */\nmxGraphHandler.prototype.mouseDown = function(sender, me)\n{\n\tif (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() &&\n\t\tme.getState() != null && !mxEvent.isMultiTouchEvent(me.getEvent()))\n\t{\n\t\tvar cell = this.getInitialCellForEvent(me);\n\t\tthis.delayedSelection = this.isDelayedSelection(cell, me);\n\t\tthis.cell = null;\n\t\t\n\t\tif (this.isSelectEnabled() && !this.delayedSelection)\n\t\t{\n\t\t\tthis.graph.selectCellForEvent(cell, me.getEvent());\n\t\t}\n\n\t\tif (this.isMoveEnabled())\n\t\t{\n\t\t\tvar model = this.graph.model;\n\t\t\tvar geo = model.getGeometry(cell);\n\n\t\t\tif (this.graph.isCellMovable(cell) && ((!model.isEdge(cell) || this.graph.getSelectionCount() > 1 ||\n\t\t\t\t(geo.points != null && geo.points.length > 0) || model.getTerminal(cell, true) == null ||\n\t\t\t\tmodel.getTerminal(cell, false) == null) || this.graph.allowDanglingEdges || \n\t\t\t\t(this.graph.isCloneEvent(me.getEvent()) && this.graph.isCellsCloneable())))\n\t\t\t{\n\t\t\t\tthis.start(cell, me.getX(), me.getY());\n\t\t\t}\n\t\t\telse if (this.delayedSelection)\n\t\t\t{\n\t\t\t\tthis.cell = cell;\n\t\t\t}\n\n\t\t\tthis.cellWasClicked = true;\n\t\t\tthis.consumeMouseEvent(mxEvent.MOUSE_DOWN, me);\n\t\t}\n\t}\n};\n\n/**\n * Function: getGuideStates\n * \n * Creates an array of cell states which should be used as guides.\n */\nmxGraphHandler.prototype.getGuideStates = function()\n{\n\tvar parent = this.graph.getDefaultParent();\n\tvar model = this.graph.getModel();\n\t\n\tvar filter = mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.graph.view.getState(cell) != null &&\n\t\t\tmodel.isVertex(cell) &&\n\t\t\tmodel.getGeometry(cell) != null &&\n\t\t\t!model.getGeometry(cell).relative;\n\t});\n\t\n\treturn this.graph.view.getCellStates(model.filterDescendants(filter, parent));\n};\n\n/**\n * Function: getCells\n * \n * Returns the cells to be modified by this handler. This implementation\n * returns all selection cells that are movable, or the given initial cell if\n * the given cell is not selected and movable. This handles the case of moving\n * unselectable or unselected cells.\n * \n * Parameters:\n * \n * initialCell - <mxCell> that triggered this handler.\n */\nmxGraphHandler.prototype.getCells = function(initialCell)\n{\n\tif (!this.delayedSelection && this.graph.isCellMovable(initialCell))\n\t{\n\t\treturn [initialCell];\n\t}\n\telse\n\t{\n\t\treturn this.graph.getMovableCells(this.graph.getSelectionCells());\n\t}\n};\n\n/**\n * Function: getPreviewBounds\n * \n * Returns the <mxRectangle> used as the preview bounds for\n * moving the given cells.\n */\nmxGraphHandler.prototype.getPreviewBounds = function(cells)\n{\n\tvar bounds = this.getBoundingBox(cells);\n\t\n\tif (bounds != null)\n\t{\n\t\t// Corrects width and height\n\t\tbounds.width = Math.max(0, bounds.width - 1);\n\t\tbounds.height = Math.max(0, bounds.height - 1);\n\t\t\n\t\tif (bounds.width < this.minimumSize)\n\t\t{\n\t\t\tvar dx = this.minimumSize - bounds.width;\n\t\t\tbounds.x -= dx / 2;\n\t\t\tbounds.width = this.minimumSize;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbounds.x = Math.round(bounds.x);\n\t\t\tbounds.width = Math.ceil(bounds.width);\n\t\t}\n\t\t\n\t\tvar tr = this.graph.view.translate;\n\t\tvar s = this.graph.view.scale;\n\t\t\n\t\tif (bounds.height < this.minimumSize)\n\t\t{\n\t\t\tvar dy = this.minimumSize - bounds.height;\n\t\t\tbounds.y -= dy / 2;\n\t\t\tbounds.height = this.minimumSize;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbounds.y = Math.round(bounds.y);\n\t\t\tbounds.height = Math.ceil(bounds.height);\n\t\t}\n\t}\n\t\n\treturn bounds;\n};\n\n/**\n * Function: getBoundingBox\n * \n * Returns the union of the <mxCellStates> for the given array of <mxCells>.\n * For vertices, this method uses the bounding box of the corresponding shape\n * if one exists. The bounding box of the corresponding text label and all\n * controls and overlays are ignored. See also: <mxGraphView.getBounds> and\n * <mxGraph.getBoundingBox>.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> whose bounding box should be returned.\n */\nmxGraphHandler.prototype.getBoundingBox = function(cells)\n{\n\tvar result = null;\n\t\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tvar model = this.graph.getModel();\n\t\t\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (model.isVertex(cells[i]) || model.isEdge(cells[i]))\n\t\t\t{\n\t\t\t\tvar state = this.graph.view.getState(cells[i]);\n\t\t\t\n\t\t\t\tif (state != null)\n\t\t\t\t{\n\t\t\t\t\tvar bbox = state;\n\t\t\t\t\t\n\t\t\t\t\tif (model.isVertex(cells[i]) && state.shape != null && state.shape.boundingBox != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tbbox = state.shape.boundingBox;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (result == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = mxRectangle.fromRectangle(bbox);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.add(bbox);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: createPreviewShape\n * \n * Creates the shape used to draw the preview for the given bounds.\n */\nmxGraphHandler.prototype.createPreviewShape = function(bounds)\n{\n\tvar shape = new mxRectangleShape(bounds, null, this.previewColor);\n\tshape.isDashed = true;\n\t\n\tif (this.htmlPreview)\n\t{\n\t\tshape.dialect = mxConstants.DIALECT_STRICTHTML;\n\t\tshape.init(this.graph.container);\n\t}\n\telse\n\t{\n\t\t// Makes sure to use either VML or SVG shapes in order to implement\n\t\t// event-transparency on the background area of the rectangle since\n\t\t// HTML shapes do not let mouseevents through even when transparent\n\t\tshape.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\t\tmxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;\n\t\tshape.init(this.graph.getView().getOverlayPane());\n\t\tshape.pointerEvents = false;\n\t\t\n\t\t// Workaround for artifacts on iOS\n\t\tif (mxClient.IS_IOS)\n\t\t{\n\t\t\tshape.getSvgScreenOffset = function()\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t}\n\t}\n\t\n\treturn shape;\n};\n\n/**\n * Function: start\n * \n * Starts the handling of the mouse gesture.\n */\nmxGraphHandler.prototype.start = function(cell, x, y, cells)\n{\n\tthis.cell = cell;\n\tthis.first = mxUtils.convertPoint(this.graph.container, x, y);\n\tthis.cells = (cells != null) ? cells : this.getCells(this.cell);\n\tthis.bounds = this.graph.getView().getBounds(this.cells);\n\tthis.pBounds = this.getPreviewBounds(this.cells);\n\tthis.allCells = new mxDictionary();\n\tthis.cloning = false;\n\tthis.cellCount = 0;\n\t\n\tfor (var i = 0; i < this.cells.length; i++)\n\t{\n\t\tthis.cellCount += this.addStates(this.cells[i], this.allCells);\n\t}\n\t\n\tif (this.guidesEnabled)\n\t{\n\t\tthis.guide = new mxGuide(this.graph, this.getGuideStates());\n\t\tvar parent = this.graph.model.getParent(cell);\n\t\tvar ignore = this.graph.model.getChildCount(parent) < 2;\n\t\t\n\t\t// Uses connected states as guides\n\t\tvar connected = new mxDictionary();\n\t\tvar opps = this.graph.getOpposites(this.graph.getEdges(this.cell), this.cell);\n\t\t\n\t\tfor (var i = 0; i < opps.length; i++)\n\t\t{\n\t\t\tvar state = this.graph.view.getState(opps[i]);\n\t\t\t\n\t\t\tif (state != null && !connected.get(state))\n\t\t\t{\n\t\t\t\tconnected.put(state, true);\n\t\t\t}\n\t\t}\n\n\t\tthis.guide.isStateIgnored = mxUtils.bind(this, function(state)\n\t\t{\n\t\t\tvar p = this.graph.model.getParent(state.cell);\n\t\t\t\n\t\t\treturn state.cell != null && ((!this.cloning &&\n\t\t\t\tthis.isCellMoving(state.cell)) ||\n\t\t\t\t(state.cell != (this.target || parent) && !ignore &&\n\t\t\t\t!connected.get(state) &&\n\t\t\t\t(this.target == null || this.graph.model.getChildCount(\n\t\t\t\tthis.target) >= 2) && p != (this.target || parent)));  \n\t\t});\n\t}\n};\n\n/**\n * Function: addStates\n * \n * Adds the states for the given cell recursively to the given dictionary.\n */\nmxGraphHandler.prototype.addStates = function(cell, dict)\n{\n\tvar state = this.graph.view.getState(cell);\n\tvar count = 0;\n\t\n\tif (state != null && dict.get(cell) == null)\n\t{\n\t\tdict.put(cell, state);\n\t\tcount++;\n\t\t\n\t\tvar childCount = this.graph.model.getChildCount(cell);\n\t\t\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tcount += this.addStates(this.graph.model.getChildAt(cell, i), dict);\n\t\t}\n\t}\n\t\n\treturn count;\n};\n\n/**\n * Function: isCellMoving\n * \n * Returns true if the given cell is currently being moved.\n */\nmxGraphHandler.prototype.isCellMoving = function(cell)\n{\n\treturn this.allCells.get(cell) != null;\n};\n\n/**\n * Function: useGuidesForEvent\n * \n * Returns true if the guides should be used for the given <mxMouseEvent>.\n * This implementation returns <mxGuide.isEnabledForEvent>.\n */\nmxGraphHandler.prototype.useGuidesForEvent = function(me)\n{\n\treturn (this.guide != null) ? this.guide.isEnabledForEvent(me.getEvent()) &&\n\t\t!this.graph.isConstrainedEvent(me.getEvent()) : true;\n};\n\n\n/**\n * Function: snap\n * \n * Snaps the given vector to the grid and returns the given mxPoint instance.\n */\nmxGraphHandler.prototype.snap = function(vector)\n{\n\tvar scale = (this.scaleGrid) ? this.graph.view.scale : 1;\n\t\n\tvector.x = this.graph.snap(vector.x / scale) * scale;\n\tvector.y = this.graph.snap(vector.y / scale) * scale;\n\t\n\treturn vector;\n};\n\n/**\n * Function: getDelta\n * \n * Returns an <mxPoint> that represents the vector for moving the cells\n * for the given <mxMouseEvent>.\n */\nmxGraphHandler.prototype.getDelta = function(me)\n{\n\tvar point = mxUtils.convertPoint(this.graph.container, me.getX(), me.getY());\n\t\n\treturn new mxPoint(point.x - this.first.x - this.graph.panDx,\n\t\tpoint.y - this.first.y - this.graph.panDy);\n};\n\n/**\n * Function: updateHint\n * \n * Hook for subclassers do show details while the handler is active.\n */\nmxGraphHandler.prototype.updateHint = function(me) { };\n\n/**\n * Function: removeHint\n * \n * Hooks for subclassers to hide details when the handler gets inactive.\n */\nmxGraphHandler.prototype.removeHint = function() { };\n\n/**\n * Function: roundLength\n * \n * Hook for rounding the unscaled vector. Allows for half steps in the raster so\n * numbers coming in should be rounded if no half steps are allowed (ie for non\n * aligned standard moving where pixel steps should be preferred).\n */\nmxGraphHandler.prototype.roundLength = function(length)\n{\n\treturn Math.round(length * 100) / 100;\n};\n\n/**\n * Function: isValidDropTarget\n * \n * Returns true if the given cell is a valid drop target.\n */\nmxGraphHandler.prototype.isValidDropTarget = function(target, me)\n{\n\treturn this.graph.model.getParent(this.cell) != target;\n};\n\n/**\n * Function: checkPreview\n * \n * Updates the preview if cloning state has changed.\n */\nmxGraphHandler.prototype.checkPreview = function()\n{\n\tif (this.livePreviewActive && this.cloning)\n\t{\n\t\tthis.resetLivePreview();\n\t\tthis.livePreviewActive = false;\n\t}\n\telse if (this.maxLivePreview >= this.cellCount && !this.livePreviewActive && this.allowLivePreview)\n\t{\n\t\tif (!this.cloning || !this.livePreviewActive)\n\t\t{\n\t\t\tthis.livePreviewActive = true;\n\t\t\tthis.livePreviewUsed = true;\n\t\t}\n\t}\n\telse if (!this.livePreviewUsed && this.shape == null)\n\t{\n\t\tthis.shape = this.createPreviewShape(this.bounds);\n\t}\n};\n\n/**\n * Function: mouseMove\n * \n * Handles the event by highlighting possible drop targets and updating the\n * preview.\n */\nmxGraphHandler.prototype.mouseMove = function(sender, me)\n{\n\tvar graph = this.graph;\n\n\tif (!me.isConsumed() && graph.isMouseDown && this.cell != null &&\n\t\tthis.first != null && this.bounds != null && !this.suspended)\n\t{\n\t\t// Stops moving if a multi touch event is received\n\t\tif (mxEvent.isMultiTouchEvent(me.getEvent()))\n\t\t{\n\t\t\tthis.reset();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar delta = this.getDelta(me);\n\t\tvar tol = graph.tolerance;\n\n\t\tif (this.shape != null || this.livePreviewActive || Math.abs(delta.x) > tol || Math.abs(delta.y) > tol)\n\t\t{\n\t\t\t// Highlight is used for highlighting drop targets\n\t\t\tif (this.highlight == null)\n\t\t\t{\n\t\t\t\tthis.highlight = new mxCellHighlight(this.graph,\n\t\t\t\t\tmxConstants.DROP_TARGET_COLOR, 3);\n\t\t\t}\n\n\t\t\tvar clone = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();\n\t\t\tvar gridEnabled = graph.isGridEnabledEvent(me.getEvent());\n\t\t\tvar cell = me.getCell();\n\t\t\tvar hideGuide = true;\n\t\t\tvar target = null;\n\t\t\tthis.cloning = clone;\n\t\t\t\n\t\t\tif (graph.isDropEnabled() && this.highlightEnabled)\n\t\t\t{\n\t\t\t\t// Contains a call to getCellAt to find the cell under the mouse\n\t\t\t\ttarget = graph.getDropTarget(this.cells, me.getEvent(), cell, clone);\n\t\t\t}\n\n\t\t\tvar state = graph.getView().getState(target);\n\t\t\tvar highlight = false;\n\t\t\t\n\t\t\tif (state != null && (clone || this.isValidDropTarget(target, me)))\n\t\t\t{\n\t\t\t    if (this.target != target)\n\t\t\t    {\n\t\t\t\t    this.target = target;\n\t\t\t\t    this.setHighlightColor(mxConstants.DROP_TARGET_COLOR);\n\t\t\t\t}\n\t\t\t    \n\t\t\t    highlight = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.target = null;\n\n\t\t\t\tif (this.connectOnDrop && cell != null && this.cells.length == 1 &&\n\t\t\t\t\tgraph.getModel().isVertex(cell) && graph.isCellConnectable(cell))\n\t\t\t\t{\n\t\t\t\t\tstate = graph.getView().getState(cell);\n\t\t\t\t\t\n\t\t\t\t\tif (state != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar error = graph.getEdgeValidationError(null, this.cell, cell);\n\t\t\t\t\t\tvar color = (error == null) ?\n\t\t\t\t\t\t\tmxConstants.VALID_COLOR :\n\t\t\t\t\t\t\tmxConstants.INVALID_CONNECT_TARGET_COLOR;\n\t\t\t\t\t\tthis.setHighlightColor(color);\n\t\t\t\t\t\thighlight = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (state != null && highlight)\n\t\t\t{\n\t\t\t\tthis.highlight.highlight(state);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.highlight.hide();\n\t\t\t}\n\n\t\t\tif (this.guide != null && this.useGuidesForEvent(me))\n\t\t\t{\n\t\t\t\tdelta = this.guide.move(this.bounds, delta, gridEnabled, clone);\n\t\t\t\thideGuide = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdelta = this.graph.snapDelta(delta, this.bounds, !gridEnabled, false, false);\n\t\t\t}\n\t\t\t\n\t\t\tif (this.guide != null && hideGuide)\n\t\t\t{\n\t\t\t\tthis.guide.hide();\n\t\t\t}\n\n\t\t\t// Constrained movement if shift key is pressed\n\t\t\tif (graph.isConstrainedEvent(me.getEvent()))\n\t\t\t{\n\t\t\t\tif (Math.abs(delta.x) > Math.abs(delta.y))\n\t\t\t\t{\n\t\t\t\t\tdelta.y = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdelta.x = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.checkPreview();\n\t\t\t\n\t\t\tif (this.currentDx != delta.x || this.currentDy != delta.y)\n\t\t\t{\n\t\t\t\tthis.currentDx = delta.x;\n\t\t\t\tthis.currentDy = delta.y;\n\t\t\t\tthis.updatePreview();\n\t\t\t}\n\t\t}\n\n\t\tthis.updateHint(me);\n\t\tthis.consumeMouseEvent(mxEvent.MOUSE_MOVE, me);\n\t\t\n\t\t// Cancels the bubbling of events to the container so\n\t\t// that the droptarget is not reset due to an mouseMove\n\t\t// fired on the container with no associated state.\n\t\tmxEvent.consume(me.getEvent());\n\t}\n\telse if ((this.isMoveEnabled() || this.isCloneEnabled()) && this.updateCursor && !me.isConsumed() &&\n\t\t\t(me.getState() != null || me.sourceState != null) && !graph.isMouseDown)\n\t{\n\t\tvar cursor = graph.getCursorForMouseEvent(me);\n\t\t\n\t\tif (cursor == null && graph.isEnabled() && graph.isCellMovable(me.getCell()))\n\t\t{\n\t\t\tif (graph.getModel().isEdge(me.getCell()))\n\t\t\t{\n\t\t\t\tcursor = mxConstants.CURSOR_MOVABLE_EDGE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcursor = mxConstants.CURSOR_MOVABLE_VERTEX;\n\t\t\t}\n\t\t}\n\n\t\t// Sets the cursor on the original source state under the mouse\n\t\t// instead of the event source state which can be the parent\n\t\tif (cursor != null && me.sourceState != null)\n\t\t{\n\t\t\tme.sourceState.setCursor(cursor);\n\t\t}\n\t}\n};\n\n/**\n * Function: updatePreview\n * \n * Updates the bounds of the preview shape.\n */\nmxGraphHandler.prototype.updatePreview = function(remote)\n{\n\tif (this.livePreviewUsed && !remote)\n\t{\n\t\tif (this.cells != null)\n\t\t{\n\t\t\tthis.setHandlesVisibleForCells(\n\t\t\t\tthis.graph.selectionCellsHandler.\n\t\t\t\tgetHandledSelectionCells(), false);\n\t\t\tthis.updateLivePreview(this.currentDx, this.currentDy);\n\t\t}\n\t}\n\telse\n\t{\n\t\tthis.updatePreviewShape();\n\t}\n};\n\n/**\n * Function: updatePreviewShape\n * \n * Updates the bounds of the preview shape.\n */\nmxGraphHandler.prototype.updatePreviewShape = function()\n{\n\tif (this.shape != null && this.pBounds != null)\n\t{\n\t\tthis.shape.bounds = new mxRectangle(Math.round(this.pBounds.x + this.currentDx),\n\t\t\t\tMath.round(this.pBounds.y + this.currentDy), this.pBounds.width, this.pBounds.height);\n\t\tthis.shape.redraw();\n\t}\n};\n\n/**\n * Function: updateLivePreview\n * \n * Updates the bounds of the preview shape.\n */\nmxGraphHandler.prototype.updateLivePreview = function(dx, dy)\n{\n\tif (!this.suspended)\n\t{\n\t\tvar states = [];\n\t\t\n\t\tif (this.allCells != null)\n\t\t{\n\t\t\tthis.allCells.visit(mxUtils.bind(this, function(key, state)\n\t\t\t{\n\t\t\t\tvar realState = this.graph.view.getState(state.cell);\n\t\t\t\t\n\t\t\t\t// Checks if cell was removed or replaced\n\t\t\t\tif (realState != state)\n\t\t\t\t{\n\t\t\t\t\tstate.destroy();\n\t\t\t\t\t\n\t\t\t\t\tif (realState != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.allCells.put(state.cell, realState);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.allCells.remove(state.cell);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tstate = realState;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (state != null)\n\t\t\t\t{\n\t\t\t\t\t// Saves current state\n\t\t\t\t\tvar tempState = state.clone();\n\t\t\t\t\tstates.push([state, tempState]);\n\t\t\n\t\t\t\t\t// Makes transparent for events to detect drop targets\n\t\t\t\t\tif (state.shape != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (state.shape.originalPointerEvents == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstate.shape.originalPointerEvents = state.shape.pointerEvents;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tstate.shape.pointerEvents = false;\n\t\t\n\t\t\t\t\t\tif (state.text != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (state.text.originalPointerEvents == null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstate.text.originalPointerEvents = state.text.pointerEvents;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tstate.text.pointerEvents = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\t// Temporarily changes position\n\t\t\t\t\tif (this.graph.model.isVertex(state.cell))\n\t\t\t\t\t{\n\t\t\t\t\t\tstate.x += dx;\n\t\t\t\t\t\tstate.y += dy;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Draws the live preview\n\t\t\t\t\t\tif (!this.cloning)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstate.view.graph.cellRenderer.redraw(state, true);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Forces redraw of connected edges after all states\n\t\t\t\t\t\t\t// have been updated but avoids update of state\n\t\t\t\t\t\t\tstate.view.invalidate(state.cell);\n\t\t\t\t\t\t\tstate.invalid = false;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Hides folding icon\n\t\t\t\t\t\t\tif (state.control != null && state.control.node != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstate.control.node.style.visibility = 'hidden';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Clone live preview may use text bounds\n\t\t\t\t\t\telse if (state.text != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstate.text.updateBoundingBox();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Fixes preview box for edge labels\n\t\t\t\t\t\t\tif (state.text.boundingBox != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstate.text.boundingBox.x += dx;\n\t\t\t\t\t\t\t\tstate.text.boundingBox.y += dy;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (state.text.unrotatedBoundingBox != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstate.text.unrotatedBoundingBox.x += dx;\n\t\t\t\t\t\t\t\tstate.text.unrotatedBoundingBox.y += dy;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t\t\n\t\t// Resets the handler if everything was removed\n\t\tif (states.length == 0)\n\t\t{\n\t\t\tthis.reset();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Redraws connected edges\n\t\t\tvar s = this.graph.view.scale;\n\t\t\t\n\t\t\tfor (var i = 0; i < states.length; i++)\n\t\t\t{\n\t\t\t\tvar state = states[i][0];\n\t\t\t\t\n\t\t\t\tif (this.graph.model.isEdge(state.cell))\n\t\t\t\t{\n\t\t\t\t\tvar geometry = this.graph.getCellGeometry(state.cell);\n\t\t\t\t\tvar points = [];\n\t\t\t\t\t\n\t\t\t\t\tif (geometry != null && geometry.points != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (var j = 0; j < geometry.points.length; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (geometry.points[j] != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpoints.push(new mxPoint(\n\t\t\t\t\t\t\t\t\tgeometry.points[j].x + dx / s,\n\t\t\t\t\t\t\t\t\tgeometry.points[j].y + dy / s));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tvar source = state.visibleSourceState;\n\t\t\t\t\tvar target = state.visibleTargetState;\n\t\t\t\t\tvar pts = states[i][1].absolutePoints;\n\t\t\t\t\t\n\t\t\t\t\tif (source == null || !this.isCellMoving(source.cell))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar pt0 = pts[0];\n\t\t\t\t\t\tstate.setAbsoluteTerminalPoint(new mxPoint(pt0.x + dx, pt0.y + dy), true);\n\t\t\t\t\t\tsource = null;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tstate.view.updateFixedTerminalPoint(state, source, true,\n\t\t\t\t\t\t\tthis.graph.getConnectionConstraint(state, source, true));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (target == null || !this.isCellMoving(target.cell))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar ptn = pts[pts.length - 1];\n\t\t\t\t\t\tstate.setAbsoluteTerminalPoint(new mxPoint(ptn.x + dx, ptn.y + dy), false);\n\t\t\t\t\t\ttarget = null;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tstate.view.updateFixedTerminalPoint(state, target, false,\n\t\t\t\t\t\t\tthis.graph.getConnectionConstraint(state, target, false));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tstate.view.updatePoints(state, points, source, target);\n\t\t\t\t\tstate.view.updateFloatingTerminalPoints(state, source, target);\n\t\t\t\t\tstate.view.updateEdgeLabelOffset(state);\n\t\t\t\t\tstate.invalid = false;\n\t\n\t\t\t\t\t// Draws the live preview but avoids update of state\n\t\t\t\t\tif (!this.cloning)\n\t\t\t\t\t{\n\t\t\t\t\t\tstate.view.graph.cellRenderer.redraw(state, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tthis.graph.view.validate();\n\t\t\tthis.redrawHandles(states);\n\t\t\tthis.resetPreviewStates(states);\n\t\t}\n\t}\n};\n\n/**\n * Function: redrawHandles\n * \n * Redraws the preview shape for the given states array.\n */\nmxGraphHandler.prototype.redrawHandles = function(states)\n{\n\tfor (var i = 0; i < states.length; i++)\n\t{\n\t\tvar handler = this.graph.selectionCellsHandler.getHandler(states[i][0].cell);\n\t\t\n\t\tif (handler != null)\n\t\t{\n\t\t\thandler.redraw(true);\n\t\t}\n\t}\n};\n\n/**\n * Function: resetPreviewStates\n * \n * Resets the given preview states array.\n */\nmxGraphHandler.prototype.resetPreviewStates = function(states)\n{\n\tfor (var i = 0; i < states.length; i++)\n\t{\n\t\tstates[i][0].setState(states[i][1]);\n\t}\n};\n\n/**\n * Function: suspend\n * \n * Suspends the livew preview.\n */\nmxGraphHandler.prototype.suspend = function()\n{\n\tif (!this.suspended)\n\t{\n\t\tif (this.livePreviewUsed)\n\t\t{\n\t\t\tthis.updateLivePreview(0, 0);\n\t\t}\n\t\t\n\t\tif (this.shape != null)\n\t\t{\n\t\t\tthis.shape.node.style.visibility = 'hidden';\n\t\t} \n\t\n\t\tif (this.guide != null)\n\t\t{\n\t\t\tthis.guide.setVisible(false);\n\t\t}\n\t\t\n\t\tthis.suspended = true;\n\t}\n};\n\n/**\n * Function: resume\n * \n * Suspends the livew preview.\n */\nmxGraphHandler.prototype.resume = function()\n{\n\tif (this.suspended)\n\t{\n\t\tthis.suspended = null;\n\t\t\n\t\tif (this.livePreviewUsed)\n\t\t{\n\t\t\tthis.livePreviewActive = true;\n\t\t}\n\t\t\n\t\tif (this.shape != null)\n\t\t{\n\t\t\tthis.shape.node.style.visibility = 'visible';\n\t\t}\n\t\t\n\t\tif (this.guide != null)\n\t\t{\n\t\t\tthis.guide.setVisible(true);\n\t\t}\n\t}\n};\n\n/**\n * Function: resetLivePreview\n * \n * Resets the livew preview.\n */\nmxGraphHandler.prototype.resetLivePreview = function()\n{\n\tif (this.allCells != null)\n\t{\n\t\tthis.allCells.visit(mxUtils.bind(this, function(key, state)\n\t\t{\n\t\t\t// Restores event handling\n\t\t\tif (state.shape != null && state.shape.originalPointerEvents != null)\n\t\t\t{\n\t\t\t\tstate.shape.pointerEvents = state.shape.originalPointerEvents;\n\t\t\t\tstate.shape.originalPointerEvents = null;\n\t\t\t\t\n\t\t\t\t// Forces repaint even if not moved to update pointer events\n\t\t\t\tstate.shape.bounds = null;\n\t\t\t\t\n\t\t\t\tif (state.text != null)\n\t\t\t\t{\n\t\t\t\t\tstate.text.pointerEvents = state.text.originalPointerEvents;\n\t\t\t\t\tstate.text.originalPointerEvents = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Shows folding icon\n\t\t\tif (state.control != null && state.control.node != null &&\n\t\t\t\tstate.control.node.style.visibility == 'hidden')\n\t\t\t{\n\t\t\t\tstate.control.node.style.visibility = '';\n\t\t\t}\n\t\t\t\n\t\t\t// Fixes preview box for edge labels\n\t\t\tif (!this.cloning)\n\t\t\t{\n\t\t\t\tif (state.text != null)\n\t\t\t\t{\n\t\t\t\t\tstate.text.updateBoundingBox();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Forces repaint of connected edges\n\t\t\tstate.view.invalidate(state.cell);\n\t\t}));\n\n\t\t// Repaints all invalid states\n\t\tthis.graph.view.validate();\n\t}\n};\n\n/**\n * Function: setHandlesVisibleForCells\n * \n * Sets wether the handles attached to the given cells are visible.\n * \n * Parameters:\n * \n * cells - Array of <mxCells>.\n * visible - Boolean that specifies if the handles should be visible.\n * force - Forces an update of the handler regardless of the last used value.\n */\nmxGraphHandler.prototype.setHandlesVisibleForCells = function(cells, visible, force)\n{\n\tif (force || this.handlesVisible != visible)\n\t{\n\t\tthis.handlesVisible = visible;\n\t\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tvar handler = this.graph.selectionCellsHandler.getHandler(cells[i]);\n\t\t\t\n\t\t\tif (handler != null)\n\t\t\t{\n\t\t\t\thandler.setHandlesVisible(visible);\n\t\t\t\t\n\t\t\t\tif (visible)\n\t\t\t\t{\n\t\t\t\t\thandler.redraw();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: setHighlightColor\n * \n * Sets the color of the rectangle used to highlight drop targets.\n * \n * Parameters:\n * \n * color - String that represents the new highlight color.\n */\nmxGraphHandler.prototype.setHighlightColor = function(color)\n{\n\tif (this.highlight != null)\n\t{\n\t\tthis.highlight.setHighlightColor(color);\n\t}\n};\n\n/**\n * Function: mouseUp\n * \n * Handles the event by applying the changes to the selection cells.\n */\nmxGraphHandler.prototype.mouseUp = function(sender, me)\n{\n\tif (!me.isConsumed())\n\t{\n\t\tif (this.livePreviewUsed)\n\t\t{\n\t\t\tthis.resetLivePreview();\n\t\t}\n\t\t\n\t\tif (this.cell != null && this.first != null && (this.shape != null || this.livePreviewUsed) &&\n\t\t\tthis.currentDx != null && this.currentDy != null)\n\t\t{\n\t\t\tvar graph = this.graph;\n\t\t\tvar cell = me.getCell();\n\t\t\t\n\t\t\tif (this.connectOnDrop && this.target == null && cell != null && graph.getModel().isVertex(cell) &&\n\t\t\t\tgraph.isCellConnectable(cell) && graph.isEdgeValid(null, this.cell, cell))\n\t\t\t{\n\t\t\t\tgraph.connectionHandler.connect(this.cell, cell, me.getEvent());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar clone = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();\n\t\t\t\tvar scale = graph.getView().scale;\n\t\t\t\tvar dx = this.roundLength(this.currentDx / scale);\n\t\t\t\tvar dy = this.roundLength(this.currentDy / scale);\n\t\t\t\tvar target = this.target;\n\t\t\t\t\n\t\t\t\tif (graph.isSplitEnabled() && graph.isSplitTarget(target, this.cells, me.getEvent()))\n\t\t\t\t{\n\t\t\t\t\tgraph.splitEdge(target, this.cells, null, dx, dy,\n\t\t\t\t\t\tme.getGraphX(), me.getGraphY());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.moveCells(this.cells, dx, dy, clone, this.target, me.getEvent());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (this.isSelectEnabled() && this.delayedSelection && this.cell != null)\n\t\t{\n\t\t\tthis.selectDelayed(me);\n\t\t}\n\t}\n\n\t// Consumes the event if a cell was initially clicked\n\tif (this.cellWasClicked)\n\t{\n\t\tthis.consumeMouseEvent(mxEvent.MOUSE_UP, me);\n\t}\n\n\tthis.reset();\n};\n\n/**\n * Function: reset\n * \n * Resets the state of this handler.\n */\nmxGraphHandler.prototype.reset = function()\n{\n\tif (this.livePreviewUsed)\n\t{\n\t\tthis.resetLivePreview();\n\t\tthis.setHandlesVisibleForCells(\n\t\t\tthis.graph.selectionCellsHandler.\n\t\t\tgetHandledSelectionCells(), true);\n\t}\n\t\n\tthis.destroyShapes();\n\tthis.removeHint();\n\n\tthis.delayedSelection = false;\n\tthis.livePreviewActive = null;\n\tthis.livePreviewUsed = null;\n\tthis.cellWasClicked = false;\n\tthis.suspended = null;\n\tthis.currentDx = null;\n\tthis.currentDy = null;\n\tthis.cellCount = null;\n\tthis.cloning = false;\n\tthis.allCells = null;\n\tthis.pBounds = null;\n\tthis.guides = null;\n\tthis.target = null;\n\tthis.first = null;\n\tthis.cells = null;\n\tthis.cell = null;\n};\n\n/**\n * Function: shouldRemoveCellsFromParent\n * \n * Returns true if the given cells should be removed from the parent for the specified\n * mousereleased event.\n */\nmxGraphHandler.prototype.shouldRemoveCellsFromParent = function(parent, cells, evt)\n{\n\tif (this.graph.getModel().isVertex(parent))\n\t{\n\t\tvar pState = this.graph.getView().getState(parent);\n\t\t\n\t\tif (pState != null)\n\t\t{\n\t\t\tvar pt = mxUtils.convertPoint(this.graph.container,\n\t\t\t\tmxEvent.getClientX(evt), mxEvent.getClientY(evt));\n\t\t\tvar alpha = mxUtils.toRadians(mxUtils.getValue(pState.style, mxConstants.STYLE_ROTATION) || 0);\n\t\t\t\n\t\t\tif (alpha != 0)\n\t\t\t{\n\t\t\t\tvar cos = Math.cos(-alpha);\n\t\t\t\tvar sin = Math.sin(-alpha);\n\t\t\t\tvar cx = new mxPoint(pState.getCenterX(), pState.getCenterY());\n\t\t\t\tpt = mxUtils.getRotatedPoint(pt, cos, sin, cx);\n\t\t\t}\n\t\t\n\t\t\treturn !mxUtils.contains(pState, pt.x, pt.y);\n\t\t}\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: moveCells\n * \n * Moves the given cells by the specified amount.\n */\nmxGraphHandler.prototype.moveCells = function(cells, dx, dy, clone, target, evt)\n{\n\tif (clone)\n\t{\n\t\tcells = this.graph.getCloneableCells(cells);\n\t}\n\t\n\t// Removes cells from parent\n\tvar parent = this.graph.getModel().getParent(this.cell);\n\t\n\tif (target == null && this.isRemoveCellsFromParent() &&\n\t\tthis.shouldRemoveCellsFromParent(parent, cells, evt))\n\t{\n\t\ttarget = this.graph.getDefaultParent();\n\t}\n\t\n\t// Cloning into locked cells is not allowed\n\tclone = clone && !this.graph.isCellLocked(target || this.graph.getDefaultParent());\n\n\tthis.graph.getModel().beginUpdate();\n\ttry\n\t{\n\t\tvar parents = [];\n\t\t\n\t\t// Removes parent if all child cells are removed\n\t\tif (!clone && target != null && this.removeEmptyParents)\n\t\t{\n\t\t\t// Collects all non-selected parents\n\t\t\tvar dict = new mxDictionary();\n\t\t\t\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tdict.put(cells[i], true);\n\t\t\t}\n\t\t\t\n\t\t\t// LATER: Recurse up the cell hierarchy\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tvar par = this.graph.model.getParent(cells[i]);\n\n\t\t\t\tif (par != null && !dict.get(par))\n\t\t\t\t{\n\t\t\t\t\tdict.put(par, true);\n\t\t\t\t\tparents.push(par);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Passes all selected cells in order to correctly clone or move into\n\t\t// the target cell. The method checks for each cell if its movable.\n\t\tcells = this.graph.moveCells(cells, dx, dy, clone, target, evt);\n\n\t\t// Removes parent if all child cells are removed\n\t\tvar temp = [];\n\t\t\n\t\tfor (var i = 0; i < parents.length; i++)\n\t\t{\n\t\t\tif (this.shouldRemoveParent(parents[i]))\n\t\t\t{\n\t\t\t\ttemp.push(parents[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.graph.removeCells(temp, false);\n\t}\n\tfinally\n\t{\n\t\tthis.graph.getModel().endUpdate();\n\t}\n\n\t// Selects the new cells if cells have been cloned\n\tif (clone)\n\t{\n\t\tthis.graph.setSelectionCells(cells);\n\t}\n\n\tif (this.isSelectEnabled() && this.scrollOnMove)\n\t{\n\t\tthis.graph.scrollCellToVisible(cells[0]);\n\t}\n};\n\n/**\n * Function: shouldRemoveParent\n * \n * Returns true if the given parent should be removed after removal of child cells.\n */\nmxGraphHandler.prototype.shouldRemoveParent = function(parent)\n{\n\tvar state = this.graph.view.getState(parent);\n\t\n\treturn state != null && (this.graph.model.isEdge(state.cell) || this.graph.model.isVertex(state.cell)) &&\n\t\tthis.graph.isCellDeletable(state.cell) && this.graph.model.getChildCount(state.cell) == 0 &&\n\t\tthis.graph.isTransparentState(state);\n};\n\n/**\n * Function: destroyShapes\n * \n * Destroy the preview and highlight shapes.\n */\nmxGraphHandler.prototype.destroyShapes = function()\n{\n\t// Destroys the preview dashed rectangle\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.destroy();\n\t\tthis.shape = null;\n\t}\n\t\n\tif (this.guide != null)\n\t{\n\t\tthis.guide.destroy();\n\t\tthis.guide = null;\n\t}\n\t\n\t// Destroys the drop target highlight\n\tif (this.highlight != null)\n\t{\n\t\tthis.highlight.destroy();\n\t\tthis.highlight = null;\n\t}\n};\n\n/**\n * Function: destroy\n * \n * Destroys the handler and all its resources and DOM nodes.\n */\nmxGraphHandler.prototype.destroy = function()\n{\n\tthis.graph.removeMouseListener(this);\n\tthis.graph.removeListener(this.panHandler);\n\t\n\tif (this.escapeHandler != null)\n\t{\n\t\tthis.graph.removeListener(this.escapeHandler);\n\t\tthis.escapeHandler = null;\n\t}\n\t\n\tif (this.refreshHandler != null)\n\t{\n\t\tthis.graph.getModel().removeListener(this.refreshHandler);\n\t\tthis.graph.removeListener(this.refreshHandler);\n\t\tthis.refreshHandler = null;\n\t}\n\t\n\tmxEvent.removeListener(document, 'keydown', this.keyHandler);\n\tmxEvent.removeListener(document, 'keyup', this.keyHandler);\n\t\n\tthis.destroyShapes();\n\tthis.removeHint();\n};\n\n__mxOutput.mxGraphHandler = typeof mxGraphHandler !== 'undefined' ? mxGraphHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxPanningHandler\n * \n * Event handler that pans and creates popupmenus. To use the left\n * mousebutton for panning without interfering with cell moving and\n * resizing, use <isUseLeftButton> and <isIgnoreCell>. For grid size\n * steps while panning, use <useGrid>. This handler is built-into\n * <mxGraph.panningHandler> and enabled using <mxGraph.setPanning>.\n * \n * Constructor: mxPanningHandler\n * \n * Constructs an event handler that creates a <mxPopupMenu>\n * and pans the graph.\n *\n * Event: mxEvent.PAN_START\n *\n * Fires when the panning handler changes its <active> state to true. The\n * <code>event</code> property contains the corresponding <mxMouseEvent>.\n *\n * Event: mxEvent.PAN\n *\n * Fires while handle is processing events. The <code>event</code> property contains\n * the corresponding <mxMouseEvent>.\n *\n * Event: mxEvent.PAN_END\n *\n * Fires when the panning handler changes its <active> state to false. The\n * <code>event</code> property contains the corresponding <mxMouseEvent>.\n */\nfunction mxPanningHandler(graph)\n{\n\tif (graph != null)\n\t{\n\t\tthis.graph = graph;\n\t\tthis.graph.addMouseListener(this);\n\n\t\t// Handles force panning event\n\t\tthis.forcePanningHandler = mxUtils.bind(this, function(sender, evt)\n\t\t{\n\t\t\tvar evtName = evt.getProperty('eventName');\n\t\t\tvar me = evt.getProperty('event');\n\t\t\t\n\t\t\tif (evtName == mxEvent.MOUSE_DOWN && this.isForcePanningEvent(me))\n\t\t\t{\n\t\t\t\tthis.start(me);\n\t\t\t\tthis.active = true;\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.PAN_START, 'event', me));\n\t\t\t\tme.consume();\n\t\t\t}\n\t\t});\n\n\t\tthis.graph.addListener(mxEvent.FIRE_MOUSE_EVENT, this.forcePanningHandler);\n\t\t\n\t\t// Handles pinch gestures\n\t\tthis.gestureHandler = mxUtils.bind(this, function(sender, eo)\n\t\t{\n\t\t\tif (this.isPinchEnabled())\n\t\t\t{\n\t\t\t\tvar evt = eo.getProperty('event');\n\t\t\t\t\n\t\t\t\tif (!mxEvent.isConsumed(evt) && evt.type == 'gesturestart')\n\t\t\t\t{\n\t\t\t\t\tthis.initialScale = this.graph.view.scale;\n\t\t\t\t\n\t\t\t\t\t// Forces start of panning when pinch gesture starts\n\t\t\t\t\tif (!this.active && this.mouseDownEvent != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.start(this.mouseDownEvent);\n\t\t\t\t\t\tthis.mouseDownEvent = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (evt.type == 'gestureend' && this.initialScale != null)\n\t\t\t\t{\n\t\t\t\t\tthis.initialScale = null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (this.initialScale != null)\n\t\t\t\t{\n\t\t\t\t\tthis.zoomGraph(evt);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\tthis.graph.addListener(mxEvent.GESTURE, this.gestureHandler);\n\t\t\n\t\tthis.mouseUpListener = mxUtils.bind(this, function()\n\t\t{\n\t    \tif (this.active)\n\t    \t{\n\t    \t\tthis.reset();\n\t    \t}\n\t\t});\n\t\t\n\t\t// Stops scrolling on every mouseup anywhere in the document\n\t\tmxEvent.addListener(document, 'mouseup', this.mouseUpListener);\n\t}\n};\n\n/**\n * Extends mxEventSource.\n */\nmxPanningHandler.prototype = new mxEventSource();\nmxPanningHandler.prototype.constructor = mxPanningHandler;\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxPanningHandler.prototype.graph = null;\n\n/**\n * Variable: useLeftButtonForPanning\n * \n * Specifies if panning should be active for the left mouse button.\n * Setting this to true may conflict with <mxRubberband>. Default is false.\n */\nmxPanningHandler.prototype.useLeftButtonForPanning = false;\n\n/**\n * Variable: usePopupTrigger\n * \n * Specifies if <mxEvent.isPopupTrigger> should also be used for panning.\n */\nmxPanningHandler.prototype.usePopupTrigger = true;\n\n/**\n * Variable: ignoreCell\n * \n * Specifies if panning should be active even if there is a cell under the\n * mousepointer. Default is false.\n */\nmxPanningHandler.prototype.ignoreCell = false;\n\n/**\n * Variable: previewEnabled\n * \n * Specifies if the panning should be previewed. Default is true.\n */\nmxPanningHandler.prototype.previewEnabled = true;\n\n/**\n * Variable: useGrid\n * \n * Specifies if the panning steps should be aligned to the grid size.\n * Default is false.\n */\nmxPanningHandler.prototype.useGrid = false;\n\n/**\n * Variable: panningEnabled\n * \n * Specifies if panning should be enabled. Default is true.\n */\nmxPanningHandler.prototype.panningEnabled = true;\n\n/**\n * Variable: pinchEnabled\n * \n * Specifies if pinch gestures should be handled as zoom. Default is true.\n */\nmxPanningHandler.prototype.pinchEnabled = true;\n\n/**\n * Variable: maxScale\n * \n * Specifies the maximum scale. Default is 8.\n */\nmxPanningHandler.prototype.maxScale = 8;\n\n/**\n * Variable: minScale\n * \n * Specifies the minimum scale. Default is 0.01.\n */\nmxPanningHandler.prototype.minScale = 0.01;\n\n/**\n * Variable: dx\n * \n * Holds the current horizontal offset.\n */\nmxPanningHandler.prototype.dx = null;\n\n/**\n * Variable: dy\n * \n * Holds the current vertical offset.\n */\nmxPanningHandler.prototype.dy = null;\n\n/**\n * Variable: startX\n * \n * Holds the x-coordinate of the start point.\n */\nmxPanningHandler.prototype.startX = 0;\n\n/**\n * Variable: startY\n * \n * Holds the y-coordinate of the start point.\n */\nmxPanningHandler.prototype.startY = 0;\n\n/**\n * Function: isActive\n * \n * Returns true if the handler is currently active.\n */\nmxPanningHandler.prototype.isActive = function()\n{\n\treturn this.active || this.initialScale != null;\n};\n\n/**\n * Function: isPanningEnabled\n * \n * Returns <panningEnabled>.\n */\nmxPanningHandler.prototype.isPanningEnabled = function()\n{\n\treturn this.panningEnabled;\n};\n\n/**\n * Function: setPanningEnabled\n * \n * Sets <panningEnabled>.\n */\nmxPanningHandler.prototype.setPanningEnabled = function(value)\n{\n\tthis.panningEnabled = value;\n};\n\n/**\n * Function: isPinchEnabled\n * \n * Returns <pinchEnabled>.\n */\nmxPanningHandler.prototype.isPinchEnabled = function()\n{\n\treturn this.pinchEnabled;\n};\n\n/**\n * Function: setPinchEnabled\n * \n * Sets <pinchEnabled>.\n */\nmxPanningHandler.prototype.setPinchEnabled = function(value)\n{\n\tthis.pinchEnabled = value;\n};\n\n/**\n * Function: isPanningTrigger\n * \n * Returns true if the given event is a panning trigger for the optional\n * given cell. This returns true if control-shift is pressed or if\n * <usePopupTrigger> is true and the event is a popup trigger.\n */\nmxPanningHandler.prototype.isPanningTrigger = function(me)\n{\n\tvar evt = me.getEvent();\n\t\n\treturn (this.useLeftButtonForPanning && me.getState() == null &&\n\t\t\tmxEvent.isLeftMouseButton(evt)) || (mxEvent.isControlDown(evt) &&\n\t\t\tmxEvent.isShiftDown(evt)) || (this.usePopupTrigger && mxEvent.isPopupTrigger(evt));\n};\n\n/**\n * Function: isForcePanningEvent\n * \n * Returns true if the given <mxMouseEvent> should start panning. This\n * implementation always returns true if <ignoreCell> is true or for\n * multi touch events.\n */\nmxPanningHandler.prototype.isForcePanningEvent = function(me)\n{\n\treturn this.ignoreCell || mxEvent.isMultiTouchEvent(me.getEvent());\n};\n\n/**\n * Function: mouseDown\n * \n * Handles the event by initiating the panning. By consuming the event all\n * subsequent events of the gesture are redirected to this handler.\n */\nmxPanningHandler.prototype.mouseDown = function(sender, me)\n{\n\tthis.mouseDownEvent = me;\n\t\n\tif (!me.isConsumed() && this.isPanningEnabled() && !this.active && this.isPanningTrigger(me))\n\t{\n\t\tthis.start(me);\n\t\tthis.consumePanningTrigger(me);\n\t}\n};\n\n/**\n * Function: start\n * \n * Starts panning at the given event.\n */\nmxPanningHandler.prototype.start = function(me)\n{\n\tthis.dx0 = -this.graph.container.scrollLeft;\n\tthis.dy0 = -this.graph.container.scrollTop;\n\n\t// Stores the location of the trigger event\n\tthis.startX = me.getX();\n\tthis.startY = me.getY();\n\tthis.dx = null;\n\tthis.dy = null;\n\t\n\tthis.panningTrigger = true;\n};\n\n/**\n * Function: consumePanningTrigger\n * \n * Consumes the given <mxMouseEvent> if it was a panning trigger in\n * <mouseDown>. The default is to invoke <mxMouseEvent.consume>. Note that this\n * will block any further event processing. If you haven't disabled built-in\n * context menus and require immediate selection of the cell on mouseDown in\n * Safari and/or on the Mac, then use the following code:\n * \n * (code)\n * mxPanningHandler.prototype.consumePanningTrigger = function(me)\n * {\n *   if (me.evt.preventDefault)\n *   {\n *     me.evt.preventDefault();\n *   }\n *   \n *   // Stops event processing in IE\n *   me.evt.returnValue = false;\n *   \n *   // Sets local consumed state\n *   if (!mxClient.IS_SF && !mxClient.IS_MAC)\n *   {\n *     me.consumed = true;\n *   }\n * };\n * (end)\n */\nmxPanningHandler.prototype.consumePanningTrigger = function(me)\n{\n\tme.consume();\n};\n\n/**\n * Function: mouseMove\n * \n * Handles the event by updating the panning on the graph.\n */\nmxPanningHandler.prototype.mouseMove = function(sender, me)\n{\n\tthis.dx = me.getX() - this.startX;\n\tthis.dy = me.getY() - this.startY;\n\t\n\tif (this.active)\n\t{\n\t\tif (this.previewEnabled)\n\t\t{\n\t\t\t// Applies the grid to the panning steps\n\t\t\tif (this.useGrid)\n\t\t\t{\n\t\t\t\tthis.dx = this.graph.snap(this.dx);\n\t\t\t\tthis.dy = this.graph.snap(this.dy);\n\t\t\t}\n\t\t\t\n\t\t\tthis.graph.panGraph(this.dx + this.dx0, this.dy + this.dy0);\n\t\t}\n\n\t\tthis.fireEvent(new mxEventObject(mxEvent.PAN, 'event', me));\n\t}\n\telse if (this.panningTrigger)\n\t{\n\t\tvar tmp = this.active;\n\n\t\t// Panning is activated only if the mouse is moved\n\t\t// beyond the graph tolerance\n\t\tthis.active = Math.abs(this.dx) > this.graph.tolerance || Math.abs(this.dy) > this.graph.tolerance;\n\n\t\tif (!tmp && this.active)\n\t\t{\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.PAN_START, 'event', me));\n\t\t}\n\t}\n\t\n\tif (this.active || this.panningTrigger)\n\t{\n\t\tme.consume();\n\t}\n};\n\n/**\n * Function: mouseUp\n * \n * Handles the event by setting the translation on the view or showing the\n * popupmenu.\n */\nmxPanningHandler.prototype.mouseUp = function(sender, me)\n{\n\tif (this.active)\n\t{\n\t\tif (this.dx != null && this.dy != null)\n\t\t{\n\t\t\t// Ignores if scrollbars have been used for panning\n\t\t\tif (!this.graph.useScrollbarsForPanning || !mxUtils.hasScrollbars(this.graph.container))\n\t\t\t{\n\t\t\t\tvar scale = this.graph.getView().scale;\n\t\t\t\tvar t = this.graph.getView().translate;\n\t\t\t\tthis.graph.panGraph(0, 0);\n\t\t\t\tthis.panGraph(t.x + this.dx / scale, t.y + this.dy / scale);\n\t\t\t}\n\t\t\t\n\t\t\tme.consume();\n\t\t}\n\t\t\n\t\tthis.fireEvent(new mxEventObject(mxEvent.PAN_END, 'event', me));\n\t}\n\t\n\tthis.reset();\n};\n\n/**\n * Function: zoomGraph\n * \n * Zooms the graph to the given value and consumed the event if needed.\n */\nmxPanningHandler.prototype.zoomGraph = function(evt)\n{\n\tvar value = Math.round(this.initialScale * evt.scale * 100) / 100;\n\t\n\tif (this.minScale != null)\n\t{\n\t\tvalue = Math.max(this.minScale, value);\n\t}\n\t\n\tif (this.maxScale != null)\n\t{\n\t\tvalue = Math.min(this.maxScale, value);\n\t}\n\n\tif (this.graph.view.scale != value)\n\t{\n\t\tthis.graph.zoomTo(value);\n\t\tmxEvent.consume(evt);\n\t}\n};\n\n/**\n * Function: reset\n * \n * Resets the state of this handler.\n */\nmxPanningHandler.prototype.reset = function()\n{\n\tthis.panningTrigger = false;\n\tthis.mouseDownEvent = null;\n\tthis.active = false;\n\tthis.dx = null;\n\tthis.dy = null;\n};\n\n/**\n * Function: panGraph\n * \n * Pans <graph> by the given amount.\n */\nmxPanningHandler.prototype.panGraph = function(dx, dy)\n{\n\tthis.graph.getView().setTranslate(dx, dy);\n};\n\n/**\n * Function: destroy\n * \n * Destroys the handler and all its resources and DOM nodes.\n */\nmxPanningHandler.prototype.destroy = function()\n{\n\tthis.graph.removeMouseListener(this);\n\tthis.graph.removeListener(this.forcePanningHandler);\n\tthis.graph.removeListener(this.gestureHandler);\n\tmxEvent.removeListener(document, 'mouseup', this.mouseUpListener);\n};\n\n__mxOutput.mxPanningHandler = typeof mxPanningHandler !== 'undefined' ? mxPanningHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxPopupMenuHandler\n * \n * Event handler that creates popupmenus.\n * \n * Constructor: mxPopupMenuHandler\n * \n * Constructs an event handler that creates a <mxPopupMenu>.\n */\nfunction mxPopupMenuHandler(graph, factoryMethod)\n{\n\tif (graph != null)\n\t{\n\t\tthis.graph = graph;\n\t\tthis.factoryMethod = factoryMethod;\n\t\tthis.graph.addMouseListener(this);\n\t\t\n\t\t// Does not show menu if any touch gestures take place after the trigger\n\t\tthis.gestureHandler = mxUtils.bind(this, function(sender, eo)\n\t\t{\n\t\t\tthis.inTolerance = false;\n\t\t});\n\t\t\n\t\tthis.graph.addListener(mxEvent.GESTURE, this.gestureHandler);\n\t\t\n\t\tthis.init();\n\t}\n};\n\n/**\n * Extends mxPopupMenu.\n */\nmxPopupMenuHandler.prototype = new mxPopupMenu();\nmxPopupMenuHandler.prototype.constructor = mxPopupMenuHandler;\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxPopupMenuHandler.prototype.graph = null;\n\n/**\n * Variable: selectOnPopup\n * \n * Specifies if cells should be selected if a popupmenu is displayed for\n * them. Default is true.\n */\nmxPopupMenuHandler.prototype.selectOnPopup = true;\n\n/**\n * Variable: clearSelectionOnBackground\n * \n * Specifies if cells should be deselected if a popupmenu is displayed for\n * the diagram background. Default is true.\n */\nmxPopupMenuHandler.prototype.clearSelectionOnBackground = true;\n\n/**\n * Variable: triggerX\n * \n * X-coordinate of the mouse down event.\n */\nmxPopupMenuHandler.prototype.triggerX = null;\n\n/**\n * Variable: triggerY\n * \n * Y-coordinate of the mouse down event.\n */\nmxPopupMenuHandler.prototype.triggerY = null;\n\n/**\n * Variable: screenX\n * \n * Screen X-coordinate of the mouse down event.\n */\nmxPopupMenuHandler.prototype.screenX = null;\n\n/**\n * Variable: screenY\n * \n * Screen Y-coordinate of the mouse down event.\n */\nmxPopupMenuHandler.prototype.screenY = null;\n\n/**\n * Function: init\n * \n * Initializes the shapes required for this vertex handler.\n */\nmxPopupMenuHandler.prototype.init = function()\n{\n\t// Supercall\n\tmxPopupMenu.prototype.init.apply(this);\n\n\t// Hides the tooltip if the mouse is over\n\t// the context menu\n\tmxEvent.addGestureListeners(this.div, mxUtils.bind(this, function(evt)\n\t{\n\t\tthis.graph.tooltipHandler.hide();\n\t}));\n};\n\n/**\n * Function: isSelectOnPopup\n * \n * Hook for returning if a cell should be selected for a given <mxMouseEvent>.\n * This implementation returns <selectOnPopup>.\n */\nmxPopupMenuHandler.prototype.isSelectOnPopup = function(me)\n{\n\treturn this.selectOnPopup;\n};\n\n/**\n * Function: mouseDown\n * \n * Handles the event by initiating the panning. By consuming the event all\n * subsequent events of the gesture are redirected to this handler.\n */\nmxPopupMenuHandler.prototype.mouseDown = function(sender, me)\n{\n\tif (this.isEnabled() && !mxEvent.isMultiTouchEvent(me.getEvent()))\n\t{\n\t\t// Hides the popupmenu if is is being displayed\n\t\tthis.hideMenu();\n\t\tthis.triggerX = me.getGraphX();\n\t\tthis.triggerY = me.getGraphY();\n\t\tthis.screenX = mxEvent.getMainEvent(me.getEvent()).screenX;\n\t\tthis.screenY = mxEvent.getMainEvent(me.getEvent()).screenY;\n\t\tthis.popupTrigger = this.isPopupTrigger(me);\n\t\tthis.inTolerance = true;\n\t}\n};\n\n/**\n * Function: mouseMove\n * \n * Handles the event by updating the panning on the graph.\n */\nmxPopupMenuHandler.prototype.mouseMove = function(sender, me)\n{\n\t// Popup trigger may change on mouseUp so ignore it\n\tif (this.inTolerance && this.screenX != null && this.screenY != null)\n\t{\n\t\tif (Math.abs(mxEvent.getMainEvent(me.getEvent()).screenX - this.screenX) > this.graph.tolerance ||\n\t\t\tMath.abs(mxEvent.getMainEvent(me.getEvent()).screenY - this.screenY) > this.graph.tolerance)\n\t\t{\n\t\t\tthis.inTolerance = false;\n\t\t}\n\t}\n};\n\n/**\n * Function: mouseUp\n * \n * Handles the event by setting the translation on the view or showing the\n * popupmenu.\n */\nmxPopupMenuHandler.prototype.mouseUp = function(sender, me)\n{\n\tif (this.popupTrigger && this.inTolerance && this.triggerX != null && this.triggerY != null)\n\t{\n\t\tvar cell = this.getCellForPopupEvent(me);\n\n\t\t// Selects the cell for which the context menu is being displayed\n\t\tif (this.graph.isEnabled() && this.isSelectOnPopup(me) &&\n\t\t\tcell != null && !this.graph.isCellSelected(cell))\n\t\t{\n\t\t\tthis.graph.setSelectionCell(cell);\n\t\t}\n\t\telse if (this.clearSelectionOnBackground && cell == null)\n\t\t{\n\t\t\tthis.graph.clearSelection();\n\t\t}\n\t\t\n\t\t// Hides the tooltip if there is one\n\t\tthis.graph.tooltipHandler.hide();\n\n\t\t// Menu is shifted by 1 pixel so that the mouse up event\n\t\t// is routed via the underlying shape instead of the DIV\n\t\tvar origin = mxUtils.getScrollOrigin();\n\t\tthis.popup(me.getX() + origin.x + 1, me.getY() + origin.y + 1, cell, me.getEvent());\n\t\tme.consume();\n\t}\n\t\n\tthis.popupTrigger = false;\n\tthis.inTolerance = false;\n};\n\n/**\n * Function: getCellForPopupEvent\n * \n * Hook to return the cell for the mouse up popup trigger handling.\n */\nmxPopupMenuHandler.prototype.getCellForPopupEvent = function(me)\n{\n\treturn me.getCell();\n};\n\n/**\n * Function: destroy\n * \n * Destroys the handler and all its resources and DOM nodes.\n */\nmxPopupMenuHandler.prototype.destroy = function()\n{\n\tthis.graph.removeMouseListener(this);\n\tthis.graph.removeListener(this.gestureHandler);\n\t\n\t// Supercall\n\tmxPopupMenu.prototype.destroy.apply(this);\n};\n\n__mxOutput.mxPopupMenuHandler = typeof mxPopupMenuHandler !== 'undefined' ? mxPopupMenuHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCellMarker\n * \n * A helper class to process mouse locations and highlight cells.\n * \n * Helper class to highlight cells. To add a cell marker to an existing graph\n * for highlighting all cells, the following code is used:\n * \n * (code)\n * var marker = new mxCellMarker(graph);\n * graph.addMouseListener({\n *   mouseDown: function() {},\n *   mouseMove: function(sender, me)\n *   {\n *     marker.process(me);\n *   },\n *   mouseUp: function() {}\n * });\n * (end)\n *\n * Event: mxEvent.MARK\n * \n * Fires after a cell has been marked or unmarked. The <code>state</code>\n * property contains the marked <mxCellState> or null if no state is marked.\n * \n * Constructor: mxCellMarker\n * \n * Constructs a new cell marker.\n * \n * Parameters:\n * \n * graph - Reference to the enclosing <mxGraph>.\n * validColor - Optional marker color for valid states. Default is\n * <mxConstants.DEFAULT_VALID_COLOR>.\n * invalidColor - Optional marker color for invalid states. Default is\n * <mxConstants.DEFAULT_INVALID_COLOR>.\n * hotspot - Portion of the width and hight where a state intersects a\n * given coordinate pair. A value of 0 means always highlight. Default is\n * <mxConstants.DEFAULT_HOTSPOT>.\n */\nfunction mxCellMarker(graph, validColor, invalidColor, hotspot)\n{\n\tmxEventSource.call(this);\n\t\n\tif (graph != null)\n\t{\n\t\tthis.graph = graph;\n\t\tthis.validColor = (validColor != null) ? validColor : mxConstants.DEFAULT_VALID_COLOR;\n\t\tthis.invalidColor = (invalidColor != null) ? invalidColor : mxConstants.DEFAULT_INVALID_COLOR;\n\t\tthis.hotspot = (hotspot != null) ? hotspot : mxConstants.DEFAULT_HOTSPOT;\n\t\t\n\t\tthis.highlight = new mxCellHighlight(graph);\n\t}\n};\n\n/**\n * Extends mxEventSource.\n */\nmxUtils.extend(mxCellMarker, mxEventSource);\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxCellMarker.prototype.graph = null;\n\n/**\n * Variable: enabled\n * \n * Specifies if the marker is enabled. Default is true.\n */\nmxCellMarker.prototype.enabled = true;\n\n/**\n * Variable: hotspot\n * \n * Specifies the portion of the width and height that should trigger\n * a highlight. The area around the center of the cell to be marked is used\n * as the hotspot. Possible values are between 0 and 1. Default is\n * mxConstants.DEFAULT_HOTSPOT.\n */\nmxCellMarker.prototype.hotspot = mxConstants.DEFAULT_HOTSPOT; \n\n/**\n * Variable: hotspotEnabled\n * \n * Specifies if the hotspot is enabled. Default is false.\n */\nmxCellMarker.prototype.hotspotEnabled = false;\n\n/**\n * Variable: validColor\n * \n * Holds the valid marker color.\n */\nmxCellMarker.prototype.validColor = null;\n\n/**\n * Variable: invalidColor\n * \n * Holds the invalid marker color.\n */\nmxCellMarker.prototype.invalidColor = null;\n\n/**\n * Variable: currentColor\n * \n * Holds the current marker color.\n */\nmxCellMarker.prototype.currentColor = null;\n\n/**\n * Variable: validState\n * \n * Holds the marked <mxCellState> if it is valid.\n */\nmxCellMarker.prototype.validState = null; \n\n/**\n * Variable: markedState\n * \n * Holds the marked <mxCellState>.\n */\nmxCellMarker.prototype.markedState = null;\n\n/**\n * Function: setEnabled\n * \n * Enables or disables event handling. This implementation\n * updates <enabled>.\n * \n * Parameters:\n * \n * enabled - Boolean that specifies the new enabled state.\n */\nmxCellMarker.prototype.setEnabled = function(enabled)\n{\n\tthis.enabled = enabled;\n};\n\n/**\n * Function: isEnabled\n * \n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxCellMarker.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setHotspot\n * \n * Sets the <hotspot>.\n */\nmxCellMarker.prototype.setHotspot = function(hotspot)\n{\n\tthis.hotspot = hotspot;\n};\n\n/**\n * Function: getHotspot\n * \n * Returns the <hotspot>.\n */\nmxCellMarker.prototype.getHotspot = function()\n{\n\treturn this.hotspot;\n};\n\n/**\n * Function: setHotspotEnabled\n * \n * Specifies whether the hotspot should be used in <intersects>.\n */\nmxCellMarker.prototype.setHotspotEnabled = function(enabled)\n{\n\tthis.hotspotEnabled = enabled;\n};\n\n/**\n * Function: isHotspotEnabled\n * \n * Returns true if hotspot is used in <intersects>.\n */\nmxCellMarker.prototype.isHotspotEnabled = function()\n{\n\treturn this.hotspotEnabled;\n};\n\n/**\n * Function: hasValidState\n * \n * Returns true if <validState> is not null.\n */\nmxCellMarker.prototype.hasValidState = function()\n{\n\treturn this.validState != null;\n};\n\n/**\n * Function: getValidState\n * \n * Returns the <validState>.\n */\nmxCellMarker.prototype.getValidState = function()\n{\n\treturn this.validState;\n};\n\n/**\n * Function: getMarkedState\n * \n * Returns the <markedState>.\n */\nmxCellMarker.prototype.getMarkedState = function()\n{\n\treturn this.markedState;\n};\n\n/**\n * Function: reset\n * \n * Resets the state of the cell marker.\n */\nmxCellMarker.prototype.reset = function()\n{\n\tthis.validState = null;\n\t\n\tif (this.markedState != null)\n\t{\n\t\tthis.markedState = null;\n\t\tthis.unmark();\n\t}\n};\n\n/**\n * Function: process\n * \n * Processes the given event and cell and marks the state returned by\n * <getState> with the color returned by <getMarkerColor>. If the\n * markerColor is not null, then the state is stored in <markedState>. If\n * <isValidState> returns true, then the state is stored in <validState>\n * regardless of the marker color. The state is returned regardless of the\n * marker color and valid state. \n */\nmxCellMarker.prototype.process = function(me)\n{\n\tvar state = null;\n\t\n\tif (this.isEnabled())\n\t{\n\t\tstate = this.getState(me);\n\t\tthis.setCurrentState(state, me);\n\t}\n\t\n\treturn state;\n};\n\n/**\n * Function: setCurrentState\n * \n * Sets and marks the current valid state.\n */\nmxCellMarker.prototype.setCurrentState = function(state, me, color)\n{\n\tvar isValid = (state != null) ? this.isValidState(state) : false;\n\tcolor = (color != null) ? color : this.getMarkerColor(me.getEvent(), state, isValid);\n\t\n\tif (isValid)\n\t{\n\t\tthis.validState = state;\n\t}\n\telse\n\t{\n\t\tthis.validState = null;\n\t}\n\t\n\tif (state != this.markedState || color != this.currentColor)\n\t{\n\t\tthis.currentColor = color;\n\t\t\n\t\tif (state != null && this.currentColor != null)\n\t\t{\n\t\t\tthis.markedState = state;\n\t\t\tthis.mark();\t\t\n\t\t}\n\t\telse if (this.markedState != null)\n\t\t{\n\t\t\tthis.markedState = null;\n\t\t\tthis.unmark();\n\t\t}\n\t}\n};\n\n/**\n * Function: markCell\n * \n * Marks the given cell using the given color, or <validColor> if no color is specified.\n */\nmxCellMarker.prototype.markCell = function(cell, color)\n{\n\tvar state = this.graph.getView().getState(cell);\n\t\n\tif (state != null)\n\t{\n\t\tthis.currentColor = (color != null) ? color : this.validColor;\n\t\tthis.markedState = state;\n\t\tthis.mark();\n\t}\n};\n\n/**\n * Function: mark\n * \n * Marks the <markedState> and fires a <mark> event.\n */\nmxCellMarker.prototype.mark = function()\n{\n\tthis.highlight.setHighlightColor(this.currentColor);\n\tthis.highlight.highlight(this.markedState);\n\tthis.fireEvent(new mxEventObject(mxEvent.MARK, 'state', this.markedState));\n};\n\n/**\n * Function: unmark\n * \n * Hides the marker and fires a <mark> event.\n */\nmxCellMarker.prototype.unmark = function()\n{\n\tthis.mark();\n};\n\n/**\n * Function: isValidState\n * \n * Returns true if the given <mxCellState> is a valid state. If this\n * returns true, then the state is stored in <validState>. The return value\n * of this method is used as the argument for <getMarkerColor>.\n */\nmxCellMarker.prototype.isValidState = function(state)\n{\n\treturn true;\n};\n\n/**\n * Function: getMarkerColor\n * \n * Returns the valid- or invalidColor depending on the value of isValid.\n * The given <mxCellState> is ignored by this implementation.\n */\nmxCellMarker.prototype.getMarkerColor = function(evt, state, isValid)\n{\n\treturn (isValid) ? this.validColor : this.invalidColor;\n};\n\n/**\n * Function: getState\n * \n * Uses <getCell>, <getStateToMark> and <intersects> to return the\n * <mxCellState> for the given <mxMouseEvent>.\n */\nmxCellMarker.prototype.getState = function(me)\n{\n\tvar view = this.graph.getView();\n\tvar cell = this.getCell(me);\n\tvar state = this.getStateToMark(view.getState(cell));\n\n\treturn (state != null && this.intersects(state, me)) ? state : null;\n};\n\n/**\n * Function: getCell\n * \n * Returns the <mxCell> for the given event and cell. This returns the\n * given cell.\n */\nmxCellMarker.prototype.getCell = function(me)\n{\n\treturn me.getCell();\n};\n\n/**\n * Function: getStateToMark\n * \n * Returns the <mxCellState> to be marked for the given <mxCellState> under\n * the mouse. This returns the given state.\n */\nmxCellMarker.prototype.getStateToMark = function(state)\n{\n\treturn state;\n};\n\n/**\n * Function: intersects\n * \n * Returns true if the given coordinate pair intersects the given state.\n * This returns true if the <hotspot> is 0 or the coordinates are inside\n * the hotspot for the given cell state.\n */\nmxCellMarker.prototype.intersects = function(state, me)\n{\n\tif (this.hotspotEnabled)\n\t{\n\t\treturn mxUtils.intersectsHotspot(state, me.getGraphX(), me.getGraphY(),\n\t\t\tthis.hotspot, mxConstants.MIN_HOTSPOT_SIZE,\n\t\t\tmxConstants.MAX_HOTSPOT_SIZE);\n\t}\n\t\n\treturn true;\n};\n\n/**\n * Function: destroy\n * \n * Destroys the handler and all its resources and DOM nodes.\n */\nmxCellMarker.prototype.destroy = function()\n{\n\tthis.graph.getView().removeListener(this.resetHandler);\n\tthis.graph.getModel().removeListener(this.resetHandler);\n\tthis.highlight.destroy();\n};\n\n__mxOutput.mxCellMarker = typeof mxCellMarker !== 'undefined' ? mxCellMarker : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxSelectionCellsHandler\n * \n * An event handler that manages cell handlers and invokes their mouse event\n * processing functions.\n * \n * Group: Events\n * \n * Event: mxEvent.ADD\n * \n * Fires if a cell has been added to the selection. The <code>state</code>\n * property contains the <mxCellState> that has been added.\n * \n * Event: mxEvent.REMOVE\n * \n * Fires if a cell has been remove from the selection. The <code>state</code>\n * property contains the <mxCellState> that has been removed.\n * \n * Parameters:\n * \n * graph - Reference to the enclosing <mxGraph>.\n */\nfunction mxSelectionCellsHandler(graph)\n{\n\tmxEventSource.call(this);\n\t\n\tthis.graph = graph;\n\tthis.handlers = new mxDictionary();\n\tthis.graph.addMouseListener(this);\n\t\n\tthis.refreshHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tif (this.isEnabled())\n\t\t{\n\t\t\tthis.refresh();\n\t\t}\n\t});\n\t\n\tthis.graph.getSelectionModel().addListener(mxEvent.CHANGE, this.refreshHandler);\n\tthis.graph.getModel().addListener(mxEvent.CHANGE, this.refreshHandler);\n\tthis.graph.getView().addListener(mxEvent.SCALE, this.refreshHandler);\n\tthis.graph.getView().addListener(mxEvent.TRANSLATE, this.refreshHandler);\n\tthis.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.refreshHandler);\n\tthis.graph.getView().addListener(mxEvent.DOWN, this.refreshHandler);\n\tthis.graph.getView().addListener(mxEvent.UP, this.refreshHandler);\n};\n\n/**\n * Extends mxEventSource.\n */\nmxUtils.extend(mxSelectionCellsHandler, mxEventSource);\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxSelectionCellsHandler.prototype.graph = null;\n\n/**\n * Variable: enabled\n * \n * Specifies if events are handled. Default is true.\n */\nmxSelectionCellsHandler.prototype.enabled = true;\n\n/**\n * Variable: refreshHandler\n * \n * Keeps a reference to an event listener for later removal.\n */\nmxSelectionCellsHandler.prototype.refreshHandler = null;\n\n/**\n * Variable: maxHandlers\n * \n * Defines the maximum number of handlers to paint individually. Default is 100.\n */\nmxSelectionCellsHandler.prototype.maxHandlers = 100;\n\n/**\n * Variable: handlers\n * \n * <mxDictionary> that maps from cells to handlers.\n */\nmxSelectionCellsHandler.prototype.handlers = null;\n\n/**\n * Function: isEnabled\n * \n * Returns <enabled>.\n */\nmxSelectionCellsHandler.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n * \n * Sets <enabled>.\n */\nmxSelectionCellsHandler.prototype.setEnabled = function(value)\n{\n\tthis.enabled = value;\n};\n\n/**\n * Function: getHandler\n * \n * Returns the handler for the given cell.\n */\nmxSelectionCellsHandler.prototype.getHandler = function(cell)\n{\n\treturn this.handlers.get(cell);\n};\n\n/**\n * Function: isHandled\n * \n * Returns true if the given cell has a handler.\n */\nmxSelectionCellsHandler.prototype.isHandled = function(cell)\n{\n\treturn this.getHandler(cell) != null;\n};\n\n/**\n * Function: reset\n * \n * Resets all handlers.\n */\nmxSelectionCellsHandler.prototype.reset = function()\n{\n\tthis.handlers.visit(function(key, handler)\n\t{\n\t\thandler.reset.apply(handler);\n\t});\n};\n\n/**\n * Function: getHandledSelectionCells\n * \n * Reloads or updates all handlers.\n */\nmxSelectionCellsHandler.prototype.getHandledSelectionCells = function()\n{\n\treturn this.graph.getSelectionCells();\n};\n\n/**\n * Function: refresh\n * \n * Reloads or updates all handlers.\n */\nmxSelectionCellsHandler.prototype.refresh = function()\n{\n\t// Removes all existing handlers\n\tvar oldHandlers = this.handlers;\n\tthis.handlers = new mxDictionary();\n\t\n\t// Creates handles for all selection cells\n\tvar tmp = mxUtils.sortCells(this.getHandledSelectionCells(), false);\n\n\t// Destroys or updates old handlers\n\tfor (var i = 0; i < tmp.length; i++)\n\t{\n\t\tvar state = this.graph.view.getState(tmp[i]);\n\n\t\tif (state != null)\n\t\t{\n\t\t\tvar handler = oldHandlers.remove(tmp[i]);\n\n\t\t\tif (handler != null)\n\t\t\t{\n\t\t\t\tif (handler.state != state)\n\t\t\t\t{\n\t\t\t\t\thandler.destroy();\n\t\t\t\t\thandler = null;\n\t\t\t\t}\n\t\t\t\telse if (!this.isHandlerActive(handler))\n\t\t\t\t{\n\t\t\t\t\tif (handler.refresh != null)\n\t\t\t\t\t{\n\t\t\t\t\t\thandler.refresh();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\thandler.redraw();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (handler != null)\n\t\t\t{\n\t\t\t\tthis.handlers.put(tmp[i], handler);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Destroys unused handlers\n\toldHandlers.visit(mxUtils.bind(this, function(key, handler)\n\t{\n\t\tthis.fireEvent(new mxEventObject(mxEvent.REMOVE, 'state', handler.state));\n\t\thandler.destroy();\n\t}));\n\t\n\t// Creates new handlers and updates parent highlight on existing handlers\n\tfor (var i = 0; i < tmp.length; i++)\n\t{\n\t\tvar state = this.graph.view.getState(tmp[i]);\n\n\t\tif (state != null)\n\t\t{\n\t\t\tvar handler = this.handlers.get(tmp[i]);\n\n\t\t\tif (handler == null)\n\t\t\t{\n\t\t\t\thandler = this.graph.createHandler(state);\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.ADD, 'state', state));\n\t\t\t\tthis.handlers.put(tmp[i], handler);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thandler.updateParentHighlight();\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: isHandlerActive\n * \n * Returns true if the given handler is active and should not be redrawn.\n */\nmxSelectionCellsHandler.prototype.isHandlerActive = function(handler)\n{\n\treturn handler.index != null;\n};\n\n/**\n * Function: updateHandler\n * \n * Updates the handler for the given shape if one exists.\n */\nmxSelectionCellsHandler.prototype.updateHandler = function(state)\n{\n\tvar handler = this.handlers.remove(state.cell);\n\t\n\tif (handler != null)\n\t{\n\t\t// Transfers the current state to the new handler\n\t\tvar index = handler.index;\n\t\tvar x = handler.startX;\n\t\tvar y = handler.startY;\n\t\t\n\t\thandler.destroy();\n\t\thandler = this.graph.createHandler(state);\n\n\t\tif (handler != null)\n\t\t{\n\t\t\tthis.handlers.put(state.cell, handler);\n\t\t\t\n\t\t\tif (index != null && x != null && y != null)\n\t\t\t{\n\t\t\t\thandler.start(x, y, index);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: mouseDown\n * \n * Redirects the given event to the handlers.\n */\nmxSelectionCellsHandler.prototype.mouseDown = function(sender, me)\n{\n\tif (this.graph.isEnabled() && this.isEnabled())\n\t{\n\t\tvar args = [sender, me];\n\n\t\tthis.handlers.visit(function(key, handler)\n\t\t{\n\t\t\thandler.mouseDown.apply(handler, args);\n\t\t});\n\t}\n};\n\n/**\n * Function: mouseMove\n * \n * Redirects the given event to the handlers.\n */\nmxSelectionCellsHandler.prototype.mouseMove = function(sender, me)\n{\n\tif (this.graph.isEnabled() && this.isEnabled())\n\t{\n\t\tvar args = [sender, me];\n\n\t\tthis.handlers.visit(function(key, handler)\n\t\t{\n\t\t\thandler.mouseMove.apply(handler, args);\n\t\t});\n\t}\n};\n\n/**\n * Function: mouseUp\n * \n * Redirects the given event to the handlers.\n */\nmxSelectionCellsHandler.prototype.mouseUp = function(sender, me)\n{\n\tif (this.graph.isEnabled() && this.isEnabled())\n\t{\n\t\tvar args = [sender, me];\n\n\t\tthis.handlers.visit(function(key, handler)\n\t\t{\n\t\t\thandler.mouseUp.apply(handler, args);\n\t\t});\n\t}\n};\n\n/**\n * Function: destroy\n * \n * Destroys the handler and all its resources and DOM nodes.\n */\nmxSelectionCellsHandler.prototype.destroy = function()\n{\n\tthis.graph.removeMouseListener(this);\n\t\n\tif (this.refreshHandler != null)\n\t{\n\t\tthis.graph.getSelectionModel().removeListener(this.refreshHandler);\n\t\tthis.graph.getModel().removeListener(this.refreshHandler);\n\t\tthis.graph.getView().removeListener(this.refreshHandler);\n\t\tthis.refreshHandler = null;\n\t}\n};\n\n__mxOutput.mxSelectionCellsHandler = typeof mxSelectionCellsHandler !== 'undefined' ? mxSelectionCellsHandler : undefined;\n\n/**\n * Copyright (c) 2006-2016, JGraph Ltd\n * Copyright (c) 2006-2016, Gaudenz Alder\n */\n/**\n * Class: mxConnectionHandler\n *\n * Graph event handler that creates new connections. Uses <mxTerminalMarker>\n * for finding and highlighting the source and target vertices and\n * <factoryMethod> to create the edge instance. This handler is built-into\n * <mxGraph.connectionHandler> and enabled using <mxGraph.setConnectable>.\n *\n * Example:\n * \n * (code)\n * new mxConnectionHandler(graph, function(source, target, style)\n * {\n *   edge = new mxCell('', new mxGeometry());\n *   edge.setEdge(true);\n *   edge.setStyle(style);\n *   edge.geometry.relative = true;\n *   return edge;\n * });\n * (end)\n * \n * Here is an alternative solution that just sets a specific user object for\n * new edges by overriding <insertEdge>.\n *\n * (code)\n * mxConnectionHandlerInsertEdge = mxConnectionHandler.prototype.insertEdge;\n * mxConnectionHandler.prototype.insertEdge = function(parent, id, value, source, target, style)\n * {\n *   value = 'Test';\n * \n *   return mxConnectionHandlerInsertEdge.apply(this, arguments);\n * };\n * (end)\n * \n * Using images to trigger connections:\n * \n * This handler uses mxTerminalMarker to find the source and target cell for\n * the new connection and creates a new edge using <connect>. The new edge is\n * created using <createEdge> which in turn uses <factoryMethod> or creates a\n * new default edge.\n * \n * The handler uses a \"highlight-paradigm\" for indicating if a cell is being\n * used as a source or target terminal, as seen in other diagramming products.\n * In order to allow both, moving and connecting cells at the same time,\n * <mxConstants.DEFAULT_HOTSPOT> is used in the handler to determine the hotspot\n * of a cell, that is, the region of the cell which is used to trigger a new\n * connection. The constant is a value between 0 and 1 that specifies the\n * amount of the width and height around the center to be used for the hotspot\n * of a cell and its default value is 0.5. In addition,\n * <mxConstants.MIN_HOTSPOT_SIZE> defines the minimum number of pixels for the\n * width and height of the hotspot.\n * \n * This solution, while standards compliant, may be somewhat confusing because\n * there is no visual indicator for the hotspot and the highlight is seen to\n * switch on and off while the mouse is being moved in and out. Furthermore,\n * this paradigm does not allow to create different connections depending on\n * the highlighted hotspot as there is only one hotspot per cell and it\n * normally does not allow cells to be moved and connected at the same time as\n * there is no clear indication of the connectable area of the cell.\n * \n * To come across these issues, the handle has an additional <createIcons> hook\n * with a default implementation that allows to create one icon to be used to\n * trigger new connections. If this icon is specified, then new connections can\n * only be created if the image is clicked while the cell is being highlighted.\n * The <createIcons> hook may be overridden to create more than one\n * <mxImageShape> for creating new connections, but the default implementation\n * supports one image and is used as follows:\n * \n * In order to display the \"connect image\" whenever the mouse is over the cell,\n * an DEFAULT_HOTSPOT of 1 should be used:\n * \n * (code)\n * mxConstants.DEFAULT_HOTSPOT = 1;\n * (end)\n * \n * In order to avoid confusion with the highlighting, the highlight color\n * should not be used with a connect image:\n * \n * (code)\n * mxConstants.HIGHLIGHT_COLOR = null;\n * (end)\n * \n * To install the image, the connectImage field of the mxConnectionHandler must\n * be assigned a new <mxImage> instance:\n * \n * (code)\n * mxConnectionHandler.prototype.connectImage = new mxImage('images/green-dot.gif', 14, 14);\n * (end)\n * \n * This will use the green-dot.gif with a width and height of 14 pixels as the\n * image to trigger new connections. In createIcons the icon field of the\n * handler will be set in order to remember the icon that has been clicked for\n * creating the new connection. This field will be available under selectedIcon\n * in the connect method, which may be overridden to take the icon that\n * triggered the new connection into account. This is useful if more than one\n * icon may be used to create a connection.\n *\n * Group: Events\n * \n * Event: mxEvent.START\n * \n * Fires when a new connection is being created by the user. The <code>state</code>\n * property contains the state of the source cell.\n * \n * Event: mxEvent.CONNECT\n * \n * Fires between begin- and endUpdate in <connect>. The <code>cell</code>\n * property contains the inserted edge, the <code>event</code> and <code>target</code> \n * properties contain the respective arguments that were passed to <connect> (where\n * target corresponds to the dropTarget argument). Finally, the <code>terminal</code>\n * property corresponds to the target argument in <connect> or the clone of the source\n * terminal if <createTarget> is enabled.\n * \n * Note that the target is the cell under the mouse where the mouse button was released.\n * Depending on the logic in the handler, this doesn't necessarily have to be the target\n * of the inserted edge. To print the source, target or any optional ports IDs that the\n * edge is connected to, the following code can be used. To get more details about the\n * actual connection point, <mxGraph.getConnectionConstraint> can be used. To resolve\n * the port IDs, use <mxGraphModel.getCell>.\n * \n * (code)\n * graph.connectionHandler.addListener(mxEvent.CONNECT, function(sender, evt)\n * {\n *   var edge = evt.getProperty('cell');\n *   var source = graph.getModel().getTerminal(edge, true);\n *   var target = graph.getModel().getTerminal(edge, false);\n *   \n *   var style = graph.getCellStyle(edge);\n *   var sourcePortId = style[mxConstants.STYLE_SOURCE_PORT];\n *   var targetPortId = style[mxConstants.STYLE_TARGET_PORT];\n *   \n *   mxLog.show();\n *   mxLog.debug('connect', edge, source.id, target.id, sourcePortId, targetPortId);\n * });\n * (end)\n *\n * Event: mxEvent.RESET\n * \n * Fires when the <reset> method is invoked.\n *\n * Constructor: mxConnectionHandler\n *\n * Constructs an event handler that connects vertices using the specified\n * factory method to create the new edges. Modify\n * <mxConstants.ACTIVE_REGION> to setup the region on a cell which triggers\n * the creation of a new connection or use connect icons as explained\n * above.\n * \n * Parameters:\n * \n * graph - Reference to the enclosing <mxGraph>.\n * factoryMethod - Optional function to create the edge. The function takes\n * the source and target <mxCell> as the first and second argument and an\n * optional cell style from the preview as the third argument. It returns\n * the <mxCell> that represents the new edge.\n */\nfunction mxConnectionHandler(graph, factoryMethod)\n{\n\tmxEventSource.call(this);\n\t\n\tif (graph != null)\n\t{\n\t\tthis.graph = graph;\n\t\tthis.factoryMethod = factoryMethod;\n\t\tthis.init();\n\t\t\n\t\t// Handles escape keystrokes\n\t\tthis.escapeHandler = mxUtils.bind(this, function(sender, evt)\n\t\t{\n\t\t\tthis.reset();\n\t\t});\n\t\t\n\t\tthis.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);\n\t}\n};\n\n/**\n * Extends mxEventSource.\n */\nmxUtils.extend(mxConnectionHandler, mxEventSource);\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxConnectionHandler.prototype.graph = null;\n\n/**\n * Variable: factoryMethod\n * \n * Function that is used for creating new edges. The function takes the\n * source and target <mxCell> as the first and second argument and returns\n * a new <mxCell> that represents the edge. This is used in <createEdge>.\n */\nmxConnectionHandler.prototype.factoryMethod = true;\n\n/**\n * Variable: moveIconFront\n * \n * Specifies if icons should be displayed inside the graph container instead\n * of the overlay pane. This is used for HTML labels on vertices which hide\n * the connect icon. This has precendence over <moveIconBack> when set\n * to true. Default is false.\n */\nmxConnectionHandler.prototype.moveIconFront = false;\n\n/**\n * Variable: moveIconBack\n * \n * Specifies if icons should be moved to the back of the overlay pane. This can\n * be set to true if the icons of the connection handler conflict with other\n * handles, such as the vertex label move handle. Default is false.\n */\nmxConnectionHandler.prototype.moveIconBack = false;\n\n/**\n * Variable: connectImage\n * \n * <mxImage> that is used to trigger the creation of a new connection. This\n * is used in <createIcons>. Default is null.\n */\nmxConnectionHandler.prototype.connectImage = null;\n\n/**\n * Variable: targetConnectImage\n * \n * Specifies if the connect icon should be centered on the target state\n * while connections are being previewed. Default is false.\n */\nmxConnectionHandler.prototype.targetConnectImage = false;\n\n/**\n * Variable: enabled\n * \n * Specifies if events are handled. Default is true.\n */\nmxConnectionHandler.prototype.enabled = true;\n\n/**\n * Variable: select\n * \n * Specifies if new edges should be selected. Default is true.\n */\nmxConnectionHandler.prototype.select = true;\n\n/**\n * Variable: createTarget\n * \n * Specifies if <createTargetVertex> should be called if no target was under the\n * mouse for the new connection. Setting this to true means the connection\n * will be drawn as valid if no target is under the mouse, and\n * <createTargetVertex> will be called before the connection is created between\n * the source cell and the newly created vertex in <createTargetVertex>, which\n * can be overridden to create a new target. Default is false.\n */\nmxConnectionHandler.prototype.createTarget = false;\n\n/**\n * Variable: marker\n * \n * Holds the <mxTerminalMarker> used for finding source and target cells.\n */\nmxConnectionHandler.prototype.marker = null;\n\n/**\n * Variable: constraintHandler\n * \n * Holds the <mxConstraintHandler> used for drawing and highlighting\n * constraints.\n */\nmxConnectionHandler.prototype.constraintHandler = null;\n\n/**\n * Variable: error\n * \n * Holds the current validation error while connections are being created.\n */\nmxConnectionHandler.prototype.error = null;\n\n/**\n * Variable: waypointsEnabled\n * \n * Specifies if single clicks should add waypoints on the new edge. Default is\n * false.\n */\nmxConnectionHandler.prototype.waypointsEnabled = false;\n\n/**\n * Variable: ignoreMouseDown\n * \n * Specifies if the connection handler should ignore the state of the mouse\n * button when highlighting the source. Default is false, that is, the\n * handler only highlights the source if no button is being pressed.\n */\nmxConnectionHandler.prototype.ignoreMouseDown = false;\n\n/**\n * Variable: first\n * \n * Holds the <mxPoint> where the mouseDown took place while the handler is\n * active.\n */\nmxConnectionHandler.prototype.first = null;\n\n/**\n * Variable: connectIconOffset\n * \n * Holds the offset for connect icons during connection preview.\n * Default is mxPoint(0, <mxConstants.TOOLTIP_VERTICAL_OFFSET>).\n * Note that placing the icon under the mouse pointer with an\n * offset of (0,0) will affect hit detection.\n */\nmxConnectionHandler.prototype.connectIconOffset = new mxPoint(0, mxConstants.TOOLTIP_VERTICAL_OFFSET);\n\n/**\n * Variable: edgeState\n * \n * Optional <mxCellState> that represents the preview edge while the\n * handler is active. This is created in <createEdgeState>.\n */\nmxConnectionHandler.prototype.edgeState = null;\n\n/**\n * Variable: changeHandler\n * \n * Holds the change event listener for later removal.\n */\nmxConnectionHandler.prototype.changeHandler = null;\n\n/**\n * Variable: drillHandler\n * \n * Holds the drill event listener for later removal.\n */\nmxConnectionHandler.prototype.drillHandler = null;\n\n/**\n * Variable: mouseDownCounter\n * \n * Counts the number of mouseDown events since the start. The initial mouse\n * down event counts as 1.\n */\nmxConnectionHandler.prototype.mouseDownCounter = 0;\n\n/**\n * Variable: movePreviewAway\n * \n * Switch to enable moving the preview away from the mousepointer. This is required in browsers\n * where the preview cannot be made transparent to events and if the built-in hit detection on\n * the HTML elements in the page should be used. Default is the value of <mxClient.IS_VML>.\n */\nmxConnectionHandler.prototype.movePreviewAway = mxClient.IS_VML;\n\n/**\n * Variable: outlineConnect\n * \n * Specifies if connections to the outline of a highlighted target should be\n * enabled. This will allow to place the connection point along the outline of\n * the highlighted target. Default is false.\n */\nmxConnectionHandler.prototype.outlineConnect = false;\n\n/**\n * Variable: livePreview\n * \n * Specifies if the actual shape of the edge state should be used for the preview.\n * Default is false. (Ignored if no edge state is created in <createEdgeState>.)\n */\nmxConnectionHandler.prototype.livePreview = false;\n\n/**\n * Variable: cursor\n * \n * Specifies the cursor to be used while the handler is active. Default is null.\n */\nmxConnectionHandler.prototype.cursor = null;\n\n/**\n * Variable: insertBeforeSource\n * \n * Specifies if new edges should be inserted before the source vertex in the\n * cell hierarchy. Default is false for backwards compatibility.\n */\nmxConnectionHandler.prototype.insertBeforeSource = false;\n\n/**\n * Function: isEnabled\n * \n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxConnectionHandler.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\t\n/**\n * Function: setEnabled\n * \n * Enables or disables event handling. This implementation\n * updates <enabled>.\n * \n * Parameters:\n * \n * enabled - Boolean that specifies the new enabled state.\n */\nmxConnectionHandler.prototype.setEnabled = function(enabled)\n{\n\tthis.enabled = enabled;\n};\n\n/**\n * Function: isInsertBefore\n * \n * Returns <insertBeforeSource> for non-loops and false for loops.\n *\n * Parameters:\n * \n * edge - <mxCell> that represents the edge to be inserted.\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n * evt - Mousedown event of the connect gesture.\n * dropTarget - <mxCell> that represents the cell under the mouse when it was\n * released.\n */\nmxConnectionHandler.prototype.isInsertBefore = function(edge, source, target, evt, dropTarget)\n{\n\treturn this.insertBeforeSource && source != target;\n};\n\n/**\n * Function: isCreateTarget\n * \n * Returns <createTarget>.\n *\n * Parameters:\n *\n * evt - Current active native pointer event.\n */\nmxConnectionHandler.prototype.isCreateTarget = function(evt)\n{\n\treturn this.createTarget;\n};\n\n/**\n * Function: setCreateTarget\n * \n * Sets <createTarget>.\n */\nmxConnectionHandler.prototype.setCreateTarget = function(value)\n{\n\tthis.createTarget = value;\n};\n\n/**\n * Function: createShape\n * \n * Creates the preview shape for new connections.\n */\nmxConnectionHandler.prototype.createShape = function()\n{\n\t// Creates the edge preview\n\tvar shape = (this.livePreview && this.edgeState != null) ?\n\t\tthis.graph.cellRenderer.createShape(this.edgeState) :\n\t\tnew mxPolyline([], mxConstants.INVALID_COLOR);\n\tshape.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\tmxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;\n\tshape.scale = this.graph.view.scale;\n\tshape.pointerEvents = false;\n\tshape.isDashed = true;\n\tshape.init(this.graph.getView().getOverlayPane());\n\tmxEvent.redirectMouseEvents(shape.node, this.graph, null);\n\n\treturn shape;\n};\n\n/**\n * Function: init\n * \n * Initializes the shapes required for this connection handler. This should\n * be invoked if <mxGraph.container> is assigned after the connection\n * handler has been created.\n */\nmxConnectionHandler.prototype.init = function()\n{\n\tthis.graph.addMouseListener(this);\n\tthis.marker = this.createMarker();\n\tthis.constraintHandler = new mxConstraintHandler(this.graph);\n\n\t// Redraws the icons if the graph changes\n\tthis.changeHandler = mxUtils.bind(this, function(sender)\n\t{\n\t\tif (this.iconState != null)\n\t\t{\n\t\t\tthis.iconState = this.graph.getView().getState(this.iconState.cell);\n\t\t}\n\t\t\n\t\tif (this.iconState != null)\n\t\t{\n\t\t\tthis.redrawIcons(this.icons, this.iconState);\n\t\t\tthis.constraintHandler.reset();\n\t\t}\n\t\telse if (this.previous != null && this.graph.view.getState(this.previous.cell) == null)\n\t\t{\n\t\t\tthis.reset();\n\t\t}\n\t});\n\t\n\tthis.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);\n\tthis.graph.getView().addListener(mxEvent.SCALE, this.changeHandler);\n\tthis.graph.getView().addListener(mxEvent.TRANSLATE, this.changeHandler);\n\tthis.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.changeHandler);\n\t\n\t// Removes the icon if we step into/up or start editing\n\tthis.drillHandler = mxUtils.bind(this, function(sender)\n\t{\n\t\tthis.reset();\n\t});\n\t\n\tthis.graph.addListener(mxEvent.START_EDITING, this.drillHandler);\n\tthis.graph.getView().addListener(mxEvent.DOWN, this.drillHandler);\n\tthis.graph.getView().addListener(mxEvent.UP, this.drillHandler);\n};\n\n/**\n * Function: isConnectableCell\n * \n * Returns true if the given cell is connectable. This is a hook to\n * disable floating connections. This implementation returns true.\n */\nmxConnectionHandler.prototype.isConnectableCell = function(cell)\n{\n\treturn true;\n};\n\n/**\n * Function: createMarker\n * \n * Creates and returns the <mxCellMarker> used in <marker>.\n */\nmxConnectionHandler.prototype.createMarker = function()\n{\n\tvar marker = new mxCellMarker(this.graph);\n\tmarker.hotspotEnabled = true;\n\n\t// Overrides to return cell at location only if valid (so that\n\t// there is no highlight for invalid cells)\n\tmarker.getCell = mxUtils.bind(this, function(me)\n\t{\n\t\tvar cell = mxCellMarker.prototype.getCell.apply(marker, arguments);\n\t\tthis.error = null;\n\t\t\n\t\t// Checks for cell at preview point (with grid)\n\t\tif (cell == null && this.currentPoint != null)\n\t\t{\n\t\t\tcell = this.graph.getCellAt(this.currentPoint.x, this.currentPoint.y);\n\t\t}\n\t\t\n\t\t// Uses connectable parent vertex if one exists\n\t\tif (cell != null && !this.graph.isCellConnectable(cell))\n\t\t{\n\t\t\tvar parent = this.graph.getModel().getParent(cell);\n\t\t\t\n\t\t\tif (this.graph.getModel().isVertex(parent) && this.graph.isCellConnectable(parent))\n\t\t\t{\n\t\t\t\tcell = parent;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ((this.graph.isSwimlane(cell) && this.currentPoint != null &&\n\t\t\tthis.graph.hitsSwimlaneContent(cell, this.currentPoint.x, this.currentPoint.y)) ||\n\t\t\t!this.isConnectableCell(cell))\n\t\t{\n\t\t\tcell = null;\n\t\t}\n\t\t\n\t\tif (cell != null)\n\t\t{\n\t\t\tif (this.isConnecting())\n\t\t\t{\n\t\t\t\tif (this.previous != null)\n\t\t\t\t{\n\t\t\t\t\tthis.error = this.validateConnection(this.previous.cell, cell);\n\t\t\t\t\t\n\t\t\t\t\tif (this.error != null && this.error.length == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcell = null;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Enables create target inside groups\n\t\t\t\t\t\tif (this.isCreateTarget(me.getEvent()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.error = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!this.isValidSource(cell, me))\n\t\t\t{\n\t\t\t\tcell = null;\n\t\t\t}\n\t\t}\n\t\telse if (this.isConnecting() && !this.isCreateTarget(me.getEvent()) &&\n\t\t\t\t!this.graph.allowDanglingEdges)\n\t\t{\n\t\t\tthis.error = '';\n\t\t}\n\n\t\treturn cell;\n\t});\n\n\t// Sets the highlight color according to validateConnection\n\tmarker.isValidState = mxUtils.bind(this, function(state)\n\t{\n\t\tif (this.isConnecting())\n\t\t{\n\t\t\treturn this.error == null;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn mxCellMarker.prototype.isValidState.apply(marker, arguments);\n\t\t}\n\t});\n\n\t// Overrides to use marker color only in highlight mode or for\n\t// target selection\n\tmarker.getMarkerColor = mxUtils.bind(this, function(evt, state, isValid)\n\t{\n\t\treturn (this.connectImage == null || this.isConnecting()) ?\n\t\t\tmxCellMarker.prototype.getMarkerColor.apply(marker, arguments) :\n\t\t\tnull;\n\t});\n\n\t// Overrides to use hotspot only for source selection otherwise\n\t// intersects always returns true when over a cell\n\tmarker.intersects = mxUtils.bind(this, function(state, evt)\n\t{\n\t\tif (this.connectImage != null || this.isConnecting())\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn mxCellMarker.prototype.intersects.apply(marker, arguments);\n\t});\n\n\treturn marker;\n};\n\n/**\n * Function: start\n * \n * Starts a new connection for the given state and coordinates.\n */\nmxConnectionHandler.prototype.start = function(state, x, y, edgeState)\n{\n\tthis.previous = state;\n\tthis.first = new mxPoint(x, y);\n\tthis.edgeState = (edgeState != null) ? edgeState : this.createEdgeState(null);\n\t\n\t// Marks the source state\n\tthis.marker.currentColor = this.marker.validColor;\n\tthis.marker.markedState = state;\n\tthis.marker.mark();\n\n\tthis.fireEvent(new mxEventObject(mxEvent.START, 'state', this.previous));\n};\n\n/**\n * Function: isConnecting\n * \n * Returns true if the source terminal has been clicked and a new\n * connection is currently being previewed.\n */\nmxConnectionHandler.prototype.isConnecting = function()\n{\n\treturn this.first != null && this.shape != null;\n};\n\n/**\n * Function: isValidSource\n * \n * Returns <mxGraph.isValidSource> for the given source terminal.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the source terminal.\n * me - <mxMouseEvent> that is associated with this call.\n */\nmxConnectionHandler.prototype.isValidSource = function(cell, me)\n{\n\treturn this.graph.isValidSource(cell);\n};\n\n/**\n * Function: isValidTarget\n * \n * Returns true. The call to <mxGraph.isValidTarget> is implicit by calling\n * <mxGraph.getEdgeValidationError> in <validateConnection>. This is an\n * additional hook for disabling certain targets in this specific handler.\n * \n * Parameters:\n * \n * cell - <mxCell> that represents the target terminal.\n */\nmxConnectionHandler.prototype.isValidTarget = function(cell)\n{\n\treturn true;\n};\n\n/**\n * Function: validateConnection\n * \n * Returns the error message or an empty string if the connection for the\n * given source target pair is not valid. Otherwise it returns null. This\n * implementation uses <mxGraph.getEdgeValidationError>.\n * \n * Parameters:\n * \n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n */\nmxConnectionHandler.prototype.validateConnection = function(source, target)\n{\n\tif (!this.isValidTarget(target))\n\t{\n\t\treturn '';\n\t}\n\t\n\treturn this.graph.getEdgeValidationError(null, source, target);\n};\n\n/**\n * Function: getConnectImage\n * \n * Hook to return the <mxImage> used for the connection icon of the given\n * <mxCellState>. This implementation returns <connectImage>.\n * \n * Parameters:\n * \n * state - <mxCellState> whose connect image should be returned.\n */\nmxConnectionHandler.prototype.getConnectImage = function(state)\n{\n\treturn this.connectImage;\n};\n\n/**\n * Function: isMoveIconToFrontForState\n * \n * Returns true if the state has a HTML label in the graph's container, otherwise\n * it returns <moveIconFront>.\n * \n * Parameters:\n * \n * state - <mxCellState> whose connect icons should be returned.\n */\nmxConnectionHandler.prototype.isMoveIconToFrontForState = function(state)\n{\n\tif (state.text != null && state.text.node.parentNode == this.graph.container)\n\t{\n\t\treturn true;\n\t}\n\t\n\treturn this.moveIconFront;\n};\n\n/**\n * Function: createIcons\n * \n * Creates the array <mxImageShapes> that represent the connect icons for\n * the given <mxCellState>.\n * \n * Parameters:\n * \n * state - <mxCellState> whose connect icons should be returned.\n */\nmxConnectionHandler.prototype.createIcons = function(state)\n{\n\tvar image = this.getConnectImage(state);\n\t\n\tif (image != null && state != null)\n\t{\n\t\tthis.iconState = state;\n\t\tvar icons = [];\n\n\t\t// Cannot use HTML for the connect icons because the icon receives all\n\t\t// mouse move events in IE, must use VML and SVG instead even if the\n\t\t// connect-icon appears behind the selection border and the selection\n\t\t// border consumes the events before the icon gets a chance\n\t\tvar bounds = new mxRectangle(0, 0, image.width, image.height);\n\t\tvar icon = new mxImageShape(bounds, image.src, null, null, 0);\n\t\ticon.preserveImageAspect = false;\n\t\t\n\t\tif (this.isMoveIconToFrontForState(state))\n\t\t{\n\t\t\ticon.dialect = mxConstants.DIALECT_STRICTHTML;\n\t\t\ticon.init(this.graph.container);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ticon.dialect = (this.graph.dialect == mxConstants.DIALECT_SVG) ?\n\t\t\t\tmxConstants.DIALECT_SVG : mxConstants.DIALECT_VML;\n\t\t\ticon.init(this.graph.getView().getOverlayPane());\n\n\t\t\t// Move the icon back in the overlay pane\n\t\t\tif (this.moveIconBack && icon.node.previousSibling != null)\n\t\t\t{\n\t\t\t\ticon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);\n\t\t\t}\n\t\t}\n\n\t\ticon.node.style.cursor = mxConstants.CURSOR_CONNECT;\n\n\t\t// Events transparency\n\t\tvar getState = mxUtils.bind(this, function()\n\t\t{\n\t\t\treturn (this.currentState != null) ? this.currentState : state;\n\t\t});\n\t\t\n\t\t// Updates the local icon before firing the mouse down event.\n\t\tvar mouseDown = mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tif (!mxEvent.isConsumed(evt))\n\t\t\t{\n\t\t\t\tthis.icon = icon;\n\t\t\t\tthis.graph.fireMouseEvent(mxEvent.MOUSE_DOWN,\n\t\t\t\t\tnew mxMouseEvent(evt, getState()));\n\t\t\t}\n\t\t});\n\n\t\tmxEvent.redirectMouseEvents(icon.node, this.graph, getState, mouseDown);\n\t\t\n\t\ticons.push(icon);\n\t\tthis.redrawIcons(icons, this.iconState);\n\t\t\n\t\treturn icons;\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: redrawIcons\n * \n * Redraws the given array of <mxImageShapes>.\n * \n * Parameters:\n * \n * icons - Optional array of <mxImageShapes> to be redrawn.\n */\nmxConnectionHandler.prototype.redrawIcons = function(icons, state)\n{\n\tif (icons != null && icons[0] != null && state != null)\n\t{\n\t\tvar pos = this.getIconPosition(icons[0], state);\n\t\ticons[0].bounds.x = pos.x;\n\t\ticons[0].bounds.y = pos.y;\n\t\ticons[0].redraw();\n\t}\n};\n\n/**\n * Function: getIconPosition\n * \n * Returns the center position of the given icon.\n * \n * Parameters:\n * \n * icon - The connect icon of <mxImageShape> with the mouse.\n * state - <mxCellState> under the mouse.\n */\nmxConnectionHandler.prototype.getIconPosition = function(icon, state)\n{\n\tvar scale = this.graph.getView().scale;\n\tvar cx = state.getCenterX();\n\tvar cy = state.getCenterY();\n\t\n\tif (this.graph.isSwimlane(state.cell))\n\t{\n\t\tvar size = this.graph.getStartSize(state.cell);\n\t\t\n\t\tcx = (size.width != 0) ? state.x + size.width * scale / 2 : cx;\n\t\tcy = (size.height != 0) ? state.y + size.height * scale / 2 : cy;\n\t\t\n\t\tvar alpha = mxUtils.toRadians(mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION) || 0);\n\t\t\n\t\tif (alpha != 0)\n\t\t{\n\t\t\tvar cos = Math.cos(alpha);\n\t\t\tvar sin = Math.sin(alpha);\n\t\t\tvar ct = new mxPoint(state.getCenterX(), state.getCenterY());\n\t\t\tvar pt = mxUtils.getRotatedPoint(new mxPoint(cx, cy), cos, sin, ct);\n\t\t\tcx = pt.x;\n\t\t\tcy = pt.y;\n\t\t}\n\t}\n\n\treturn new mxPoint(cx - icon.bounds.width / 2,\n\t\t\tcy - icon.bounds.height / 2);\n};\n\n/**\n * Function: destroyIcons\n * \n * Destroys the connect icons and resets the respective state.\n */\nmxConnectionHandler.prototype.destroyIcons = function()\n{\n\tif (this.icons != null)\n\t{\n\t\tfor (var i = 0; i < this.icons.length; i++)\n\t\t{\n\t\t\tthis.icons[i].destroy();\n\t\t}\n\t\t\n\t\tthis.icons = null;\n\t\tthis.icon = null;\n\t\tthis.selectedIcon = null;\n\t\tthis.iconState = null;\n\t}\n};\n\n/**\n * Function: isStartEvent\n * \n * Returns true if the given mouse down event should start this handler. The\n * This implementation returns true if the event does not force marquee\n * selection, and the currentConstraint and currentFocus of the\n * <constraintHandler> are not null, or <previous> and <error> are not null and\n * <icons> is null or <icons> and <icon> are not null.\n */\nmxConnectionHandler.prototype.isStartEvent = function(me)\n{\n\treturn ((this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null) ||\n\t\t(this.previous != null && this.error == null && (this.icons == null || (this.icons != null &&\n\t\tthis.icon != null))));\n};\n\n/**\n * Function: mouseDown\n * \n * Handles the event by initiating a new connection.\n */\nmxConnectionHandler.prototype.mouseDown = function(sender, me)\n{\n\tthis.mouseDownCounter++;\n\t\n\tif (this.isEnabled() && this.graph.isEnabled() && !me.isConsumed() &&\n\t\t!this.isConnecting() && this.isStartEvent(me))\n\t{\n\t\tif (this.constraintHandler.currentConstraint != null &&\n\t\t\tthis.constraintHandler.currentFocus != null &&\n\t\t\tthis.constraintHandler.currentPoint != null)\n\t\t{\n\t\t\tthis.sourceConstraint = this.constraintHandler.currentConstraint;\n\t\t\tthis.previous = this.constraintHandler.currentFocus;\n\t\t\tthis.first = this.constraintHandler.currentPoint.clone();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Stores the location of the initial mousedown\n\t\t\tthis.first = new mxPoint(me.getGraphX(), me.getGraphY());\n\t\t}\n\t\n\t\tthis.edgeState = this.createEdgeState(me);\n\t\tthis.mouseDownCounter = 1;\n\t\t\n\t\tif (this.waypointsEnabled && this.shape == null)\n\t\t{\n\t\t\tthis.waypoints = null;\n\t\t\tthis.shape = this.createShape();\n\t\t\t\n\t\t\tif (this.edgeState != null)\n\t\t\t{\n\t\t\t\tthis.shape.apply(this.edgeState);\n\t\t\t}\n\t\t}\n\n\t\t// Stores the starting point in the geometry of the preview\n\t\tif (this.previous == null && this.edgeState != null)\n\t\t{\n\t\t\tvar pt = this.graph.getPointForEvent(me.getEvent());\n\t\t\tthis.edgeState.cell.geometry.setTerminalPoint(pt, true);\n\t\t}\n\t\t\n\t\tthis.fireEvent(new mxEventObject(mxEvent.START, 'state', this.previous));\n\n\t\tme.consume();\n\t}\n\n\tthis.selectedIcon = this.icon;\n\tthis.icon = null;\n};\n\n/**\n * Function: isImmediateConnectSource\n * \n * Returns true if a tap on the given source state should immediately start\n * connecting. This implementation returns true if the state is not movable\n * in the graph. \n */\nmxConnectionHandler.prototype.isImmediateConnectSource = function(state)\n{\n\treturn !this.graph.isCellMovable(state.cell);\n};\n\n/**\n * Function: createEdgeState\n * \n * Hook to return an <mxCellState> which may be used during the preview.\n * This implementation returns null.\n * \n * Use the following code to create a preview for an existing edge style:\n * \n * (code)\n * graph.connectionHandler.createEdgeState = function(me)\n * {\n *   var edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=elbowEdgeStyle');\n *   \n *   return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));\n * };\n * (end)\n */\nmxConnectionHandler.prototype.createEdgeState = function(me)\n{\n\treturn null;\n};\n\n/**\n * Function: isOutlineConnectEvent\n * \n * Returns true if <outlineConnect> is true and the source of the event is the outline shape\n * or shift is pressed.\n */\nmxConnectionHandler.prototype.isOutlineConnectEvent = function(me)\n{\n\tvar offset = mxUtils.getOffset(this.graph.container);\n\tvar evt = me.getEvent();\n\t\n\tvar clientX = mxEvent.getClientX(evt);\n\tvar clientY = mxEvent.getClientY(evt);\n\t\n\tvar doc = document.documentElement;\n\tvar left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n\tvar top = (window.pageYOffset || doc.scrollTop)  - (doc.clientTop || 0);\n\t\n\tvar gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;\n\tvar gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;\n\n\treturn this.outlineConnect && !mxEvent.isShiftDown(me.getEvent()) &&\n\t\t(me.isSource(this.marker.highlight.shape) ||\n\t\t(mxEvent.isAltDown(me.getEvent()) && me.getState() != null) ||\n\t\tthis.marker.highlight.isHighlightAt(clientX, clientY) ||\n\t\t((gridX != clientX || gridY != clientY) && me.getState() == null &&\n\t\tthis.marker.highlight.isHighlightAt(gridX, gridY)));\n};\n\n/**\n * Function: updateCurrentState\n * \n * Updates the current state for a given mouse move event by using\n * the <marker>.\n */\nmxConnectionHandler.prototype.updateCurrentState = function(me, point)\n{\n\tthis.constraintHandler.update(me, this.first == null, false, (this.first == null ||\n\t\tme.isSource(this.marker.highlight.shape)) ? null : point);\n\t\n\tif (this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null)\n\t{\n\t\t// Handles special case where grid is large and connection point is at actual point in which\n\t\t// case the outline is not followed as long as we're < gridSize / 2 away from that point\n\t\tif (this.marker.highlight != null && this.marker.highlight.state != null &&\n\t\t\tthis.marker.highlight.state.cell == this.constraintHandler.currentFocus.cell)\n\t\t{\n\t\t\t// Direct repaint needed if cell already highlighted\n\t\t\tif (this.marker.highlight.shape.stroke != 'transparent')\n\t\t\t{\n\t\t\t\tthis.marker.highlight.shape.stroke = 'transparent';\n\t\t\t\tthis.marker.highlight.repaint();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent');\n\t\t}\n\n\t\t// Updates validation state\n\t\tif (this.previous != null)\n\t\t{\n\t\t\tthis.error = this.validateConnection(this.previous.cell, this.constraintHandler.currentFocus.cell);\n\t\t\t\n\t\t\tif (this.error == null)\n\t\t\t{\n\t\t\t\tthis.currentState = this.constraintHandler.currentFocus;\n\t\t\t}\n\t\t\t\t\t\n\t\t\tif (this.error != null || (this.currentState != null &&\n\t\t\t\t!this.isCellEnabled(this.currentState.cell)))\n\t\t\t{\n\t\t\t\tthis.constraintHandler.reset();\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (this.graph.isIgnoreTerminalEvent(me.getEvent()))\n\t\t{\n\t\t\tthis.marker.reset();\n\t\t\tthis.currentState = null;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.marker.process(me);\n\t\t\tthis.currentState = this.marker.getValidState();\n\t\t}\n\t\t\t\n\t\tif (this.currentState != null && !this.isCellEnabled(this.currentState.cell))\n\t\t{\n\t\t\tthis.constraintHandler.reset();\n\t\t\tthis.marker.reset();\n\t\t\tthis.currentState = null;\n\t\t}\n\n\t\tvar outline = this.isOutlineConnectEvent(me);\n\t\t\n\t\tif (this.currentState != null && outline)\n\t\t{\n\t\t\t// Handles special case where mouse is on outline away from actual end point\n\t\t\t// in which case the grid is ignored and mouse point is used instead\n\t\t\tif (me.isSource(this.marker.highlight.shape))\n\t\t\t{\n\t\t\t\tpoint = new mxPoint(me.getGraphX(), me.getGraphY());\n\t\t\t}\n\t\t\t\n\t\t\tvar constraint = this.graph.getOutlineConstraint(point, this.currentState, me);\n\t\t\tthis.constraintHandler.setFocus(me, this.currentState, false);\n\t\t\tthis.constraintHandler.currentConstraint = constraint;\n\t\t\tthis.constraintHandler.currentPoint = point;\n\t\t}\n\n\t\tif (this.outlineConnect)\n\t\t{\n\t\t\tif (this.marker.highlight != null && this.marker.highlight.shape != null)\n\t\t\t{\n\t\t\t\tvar s = this.graph.view.scale;\n\t\t\t\t\n\t\t\t\tif (this.constraintHandler.currentConstraint != null &&\n\t\t\t\t\tthis.constraintHandler.currentFocus != null)\n\t\t\t\t{\n\t\t\t\t\tthis.marker.highlight.shape.stroke = mxConstants.OUTLINE_HIGHLIGHT_COLOR;\n\t\t\t\t\tthis.marker.highlight.shape.strokewidth = mxConstants.OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;\n\t\t\t\t\tthis.marker.highlight.repaint();\n\t\t\t\t} \n\t\t\t\telse if (this.marker.hasValidState())\n\t\t\t\t{\n\t\t\t\t\t// Handles special case where actual end point of edge and current mouse point\n\t\t\t\t\t// are not equal (due to grid snapping) and there is no hit on shape or highlight\n\t\t\t\t\t// but ignores cases where parent is used for non-connectable child cells\n\t\t\t\t\tif (this.graph.isCellConnectable(me.getCell()) &&\n\t\t\t\t\t\tthis.marker.getValidState() != me.getState())\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.marker.highlight.shape.stroke = 'transparent';\n\t\t\t\t\t\tthis.currentState = null;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.marker.highlight.shape.stroke = mxConstants.DEFAULT_VALID_COLOR;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.marker.highlight.shape.strokewidth = mxConstants.HIGHLIGHT_STROKEWIDTH / s / s;\n\t\t\t\t\tthis.marker.highlight.repaint();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: isCellEnabled\n * \n * Returns true if the given cell allows new connections to be created. This implementation\n * always returns true.\n */\nmxConnectionHandler.prototype.isCellEnabled = function(cell)\n{\n\treturn true;\n};\n\n/**\n * Function: convertWaypoint\n * \n * Converts the given point from screen coordinates to model coordinates.\n */\nmxConnectionHandler.prototype.convertWaypoint = function(point)\n{\n\tvar scale = this.graph.getView().getScale();\n\tvar tr = this.graph.getView().getTranslate();\n\t\n\tpoint.x = point.x / scale - tr.x;\n\tpoint.y = point.y / scale - tr.y;\n};\n\n/**\n * Function: snapToPreview\n * \n * Called to snap the given point to the current preview. This snaps to the\n * first point of the preview if alt is not pressed.\n */\nmxConnectionHandler.prototype.snapToPreview = function(me, point)\n{\n\tif (!mxEvent.isAltDown(me.getEvent()) && this.previous != null)\n\t{\n\t\tvar tol = this.graph.gridSize * this.graph.view.scale / 2;\t\n\t\tvar tmp = (this.sourceConstraint != null) ? this.first :\n\t\t\tnew mxPoint(this.previous.getCenterX(), this.previous.getCenterY());\n\n\t\tif (Math.abs(tmp.x - me.getGraphX()) < tol)\n\t\t{\n\t\t\tpoint.x = tmp.x;\n\t\t}\n\t\t\n\t\tif (Math.abs(tmp.y - me.getGraphY()) < tol)\n\t\t{\n\t\t\tpoint.y = tmp.y;\n\t\t}\n\t}\t\n};\n\n/**\n * Function: mouseMove\n * \n * Handles the event by updating the preview edge or by highlighting\n * a possible source or target terminal.\n */\nmxConnectionHandler.prototype.mouseMove = function(sender, me)\n{\n\tif (!me.isConsumed() && (this.ignoreMouseDown || this.first != null || !this.graph.isMouseDown))\n\t{\n\t\t// Handles special case when handler is disabled during highlight\n\t\tif (!this.isEnabled() && this.currentState != null)\n\t\t{\n\t\t\tthis.destroyIcons();\n\t\t\tthis.currentState = null;\n\t\t}\n\n\t\tvar view = this.graph.getView();\n\t\tvar scale = view.scale;\n\t\tvar tr = view.translate;\n\t\tvar point = new mxPoint(me.getGraphX(), me.getGraphY());\n\t\tthis.error = null;\n\n\t\tif (this.graph.isGridEnabledEvent(me.getEvent()))\n\t\t{\n\t\t\tpoint = new mxPoint((this.graph.snap(point.x / scale - tr.x) + tr.x) * scale,\n\t\t\t\t(this.graph.snap(point.y / scale - tr.y) + tr.y) * scale);\n\t\t}\n\t\t\n\t\tthis.snapToPreview(me, point);\n\t\tthis.currentPoint = point;\n\t\t\n\t\tif ((this.first != null || (this.isEnabled() && this.graph.isEnabled())) &&\n\t\t\t(this.shape != null || this.first == null ||\n\t\t\tMath.abs(me.getGraphX() - this.first.x) > this.graph.tolerance ||\n\t\t\tMath.abs(me.getGraphY() - this.first.y) > this.graph.tolerance))\n\t\t{\n\t\t\tthis.updateCurrentState(me, point);\n\t\t}\n\n\t\tif (this.first != null)\n\t\t{\n\t\t\tvar constraint = null;\n\t\t\tvar current = point;\n\t\t\t\n\t\t\t// Uses the current point from the constraint handler if available\n\t\t\tif (this.constraintHandler.currentConstraint != null &&\n\t\t\t\tthis.constraintHandler.currentFocus != null &&\n\t\t\t\tthis.constraintHandler.currentPoint != null)\n\t\t\t{\n\t\t\t\tconstraint = this.constraintHandler.currentConstraint;\n\t\t\t\tcurrent = this.constraintHandler.currentPoint.clone();\n\t\t\t}\n\t\t\telse if (this.previous != null && !this.graph.isIgnoreTerminalEvent(me.getEvent()) &&\n\t\t\t\tmxEvent.isShiftDown(me.getEvent()))\n\t\t\t{\n\t\t\t\tif (Math.abs(this.previous.getCenterX() - point.x) <\n\t\t\t\t\tMath.abs(this.previous.getCenterY() - point.y))\n\t\t\t\t{\n\t\t\t\t\tpoint.x = this.previous.getCenterX();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpoint.y = this.previous.getCenterY();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar pt2 = this.first;\n\t\t\t\n\t\t\t// Moves the connect icon with the mouse\n\t\t\tif (this.selectedIcon != null)\n\t\t\t{\n\t\t\t\tvar w = this.selectedIcon.bounds.width;\n\t\t\t\tvar h = this.selectedIcon.bounds.height;\n\t\t\t\t\n\t\t\t\tif (this.currentState != null && this.targetConnectImage)\n\t\t\t\t{\n\t\t\t\t\tvar pos = this.getIconPosition(this.selectedIcon, this.currentState);\n\t\t\t\t\tthis.selectedIcon.bounds.x = pos.x;\n\t\t\t\t\tthis.selectedIcon.bounds.y = pos.y;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar bounds = new mxRectangle(me.getGraphX() + this.connectIconOffset.x,\n\t\t\t\t\t\tme.getGraphY() + this.connectIconOffset.y, w, h);\n\t\t\t\t\tthis.selectedIcon.bounds = bounds;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.selectedIcon.redraw();\n\t\t\t}\n\n\t\t\t// Uses edge state to compute the terminal points\n\t\t\tif (this.edgeState != null)\n\t\t\t{\n\t\t\t\tthis.updateEdgeState(current, constraint);\n\t\t\t\tcurrent = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 1];\n\t\t\t\tpt2 = this.edgeState.absolutePoints[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (this.currentState != null)\n\t\t\t\t{\n\t\t\t\t\tif (this.constraintHandler.currentConstraint == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar tmp = this.getTargetPerimeterPoint(this.currentState, me);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (tmp != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurrent = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Computes the source perimeter point\n\t\t\t\tif (this.sourceConstraint == null && this.previous != null)\n\t\t\t\t{\n\t\t\t\t\tvar next = (this.waypoints != null && this.waypoints.length > 0) ?\n\t\t\t\t\t\t\tthis.waypoints[0] : current;\n\t\t\t\t\tvar tmp = this.getSourcePerimeterPoint(this.previous, next, me);\n\t\t\t\t\t\n\t\t\t\t\tif (tmp != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tpt2 = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Makes sure the cell under the mousepointer can be detected\n\t\t\t// by moving the preview shape away from the mouse. This\n\t\t\t// makes sure the preview shape does not prevent the detection\n\t\t\t// of the cell under the mousepointer even for slow gestures.\n\t\t\tif (this.currentState == null && this.movePreviewAway)\n\t\t\t{\n\t\t\t\tvar tmp = pt2; \n\t\t\t\t\n\t\t\t\tif (this.edgeState != null && this.edgeState.absolutePoints.length >= 2)\n\t\t\t\t{\n\t\t\t\t\tvar tmp2 = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 2];\n\t\t\t\t\t\n\t\t\t\t\tif (tmp2 != null)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp = tmp2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar dx = current.x - tmp.x;\n\t\t\t\tvar dy = current.y - tmp.y;\n\t\t\t\t\n\t\t\t\tvar len = Math.sqrt(dx * dx + dy * dy);\n\t\t\t\t\n\t\t\t\tif (len == 0)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Stores old point to reuse when creating edge\n\t\t\t\tthis.originalPoint = current.clone();\n\t\t\t\tcurrent.x -= dx * 4 / len;\n\t\t\t\tcurrent.y -= dy * 4 / len;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.originalPoint = null;\n\t\t\t}\n\t\t\t\n\t\t\t// Creates the preview shape (lazy)\n\t\t\tif (this.shape == null)\n\t\t\t{\n\t\t\t\tvar dx = Math.abs(me.getGraphX() - this.first.x);\n\t\t\t\tvar dy = Math.abs(me.getGraphY() - this.first.y);\n\n\t\t\t\tif (dx > this.graph.tolerance || dy > this.graph.tolerance)\n\t\t\t\t{\n\t\t\t\t\tthis.shape = this.createShape();\n\n\t\t\t\t\tif (this.edgeState != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.shape.apply(this.edgeState);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Revalidates current connection\n\t\t\t\t\tthis.updateCurrentState(me, point);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Updates the points in the preview edge\n\t\t\tif (this.shape != null)\n\t\t\t{\n\t\t\t\tif (this.edgeState != null)\n\t\t\t\t{\n\t\t\t\t\tthis.shape.points = this.edgeState.absolutePoints;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar pts = [pt2];\n\t\t\t\t\t\n\t\t\t\t\tif (this.waypoints != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tpts = pts.concat(this.waypoints);\n\t\t\t\t\t}\n\n\t\t\t\t\tpts.push(current);\n\t\t\t\t\tthis.shape.points = pts;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.drawPreview();\n\t\t\t}\n\t\t\t\n\t\t\t// Makes sure endpoint of edge is visible during connect\n\t\t\tif (this.cursor != null)\n\t\t\t{\n\t\t\t\tthis.graph.container.style.cursor = this.cursor;\n\t\t\t}\n\t\t\t\n\t\t\tmxEvent.consume(me.getEvent());\n\t\t\tme.consume();\n\t\t}\n\t\telse if (!this.isEnabled() || !this.graph.isEnabled())\n\t\t{\n\t\t\tthis.constraintHandler.reset();\n\t\t}\n\t\telse if (this.previous != this.currentState && this.edgeState == null)\n\t\t{\n\t\t\tthis.destroyIcons();\n\t\t\t\n\t\t\t// Sets the cursor on the current shape\t\t\t\t\n\t\t\tif (this.currentState != null && this.error == null && this.constraintHandler.currentConstraint == null)\n\t\t\t{\n\t\t\t\tthis.icons = this.createIcons(this.currentState);\n\n\t\t\t\tif (this.icons == null)\n\t\t\t\t{\n\t\t\t\t\tthis.currentState.setCursor(mxConstants.CURSOR_CONNECT);\n\t\t\t\t\tme.consume();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.previous = this.currentState;\n\t\t}\n\t\telse if (this.previous == this.currentState && this.currentState != null && this.icons == null &&\n\t\t\t!this.graph.isMouseDown)\n\t\t{\n\t\t\t// Makes sure that no cursors are changed\n\t\t\tme.consume();\n\t\t}\n\n\t\tif (!this.graph.isMouseDown && this.currentState != null && this.icons != null)\n\t\t{\n\t\t\tvar hitsIcon = false;\n\t\t\tvar target = me.getSource();\n\t\t\t\n\t\t\tfor (var i = 0; i < this.icons.length && !hitsIcon; i++)\n\t\t\t{\n\t\t\t\thitsIcon = target == this.icons[i].node || target.parentNode == this.icons[i].node;\n\t\t\t}\n\n\t\t\tif (!hitsIcon)\n\t\t\t{\n\t\t\t\tthis.updateIcons(this.currentState, this.icons, me);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tthis.constraintHandler.reset();\n\t}\n};\n\n/**\n * Function: updateEdgeState\n * \n * Updates <edgeState>.\n */\nmxConnectionHandler.prototype.updateEdgeState = function(current, constraint)\n{\n\t// TODO: Use generic method for writing constraint to style\n\tif (this.sourceConstraint != null && this.sourceConstraint.point != null)\n\t{\n\t\tthis.edgeState.style[mxConstants.STYLE_EXIT_X] = this.sourceConstraint.point.x;\n\t\tthis.edgeState.style[mxConstants.STYLE_EXIT_Y] = this.sourceConstraint.point.y;\n\t}\n\n\tif (constraint != null && constraint.point != null)\n\t{\n\t\tthis.edgeState.style[mxConstants.STYLE_ENTRY_X] = constraint.point.x;\n\t\tthis.edgeState.style[mxConstants.STYLE_ENTRY_Y] = constraint.point.y;\n\t}\n\telse\n\t{\n\t\tdelete this.edgeState.style[mxConstants.STYLE_ENTRY_X];\n\t\tdelete this.edgeState.style[mxConstants.STYLE_ENTRY_Y];\n\t}\n\t\n\tthis.edgeState.absolutePoints = [null, (this.currentState != null) ? null : current];\n\tthis.graph.view.updateFixedTerminalPoint(this.edgeState, this.previous, true, this.sourceConstraint);\n\t\n\tif (this.currentState != null)\n\t{\n\t\tif (constraint == null)\n\t\t{\n\t\t\tconstraint = this.graph.getConnectionConstraint(this.edgeState, this.previous, false);\n\t\t}\n\t\t\n\t\tthis.edgeState.setAbsoluteTerminalPoint(null, false);\n\t\tthis.graph.view.updateFixedTerminalPoint(this.edgeState, this.currentState, false, constraint);\n\t}\n\t\n\t// Scales and translates the waypoints to the model\n\tvar realPoints = null;\n\t\n\tif (this.waypoints != null)\n\t{\n\t\trealPoints = [];\n\t\t\n\t\tfor (var i = 0; i < this.waypoints.length; i++)\n\t\t{\n\t\t\tvar pt = this.waypoints[i].clone();\n\t\t\tthis.convertWaypoint(pt);\n\t\t\trealPoints[i] = pt;\n\t\t}\n\t}\n\t\n\tthis.graph.view.updatePoints(this.edgeState, realPoints, this.previous, this.currentState);\n\tthis.graph.view.updateFloatingTerminalPoints(this.edgeState, this.previous, this.currentState);\n};\n\n/**\n * Function: getTargetPerimeterPoint\n * \n * Returns the perimeter point for the given target state.\n * \n * Parameters:\n * \n * state - <mxCellState> that represents the target cell state.\n * me - <mxMouseEvent> that represents the mouse move.\n */\nmxConnectionHandler.prototype.getTargetPerimeterPoint = function(state, me)\n{\n\tvar result = null;\n\tvar view = state.view;\n\tvar targetPerimeter = view.getPerimeterFunction(state);\n\t\n\tif (targetPerimeter != null)\n\t{\n\t\tvar next = (this.waypoints != null && this.waypoints.length > 0) ?\n\t\t\t\tthis.waypoints[this.waypoints.length - 1] :\n\t\t\t\tnew mxPoint(this.previous.getCenterX(), this.previous.getCenterY());\n\t\tvar tmp = targetPerimeter(view.getPerimeterBounds(state),\n\t\t\tthis.edgeState, next, false);\n\t\t\t\n\t\tif (tmp != null)\n\t\t{\n\t\t\tresult = tmp;\n\t\t}\n\t}\n\telse\n\t{\n\t\tresult = new mxPoint(state.getCenterX(), state.getCenterY());\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getSourcePerimeterPoint\n * \n * Hook to update the icon position(s) based on a mouseOver event. This is\n * an empty implementation.\n * \n * Parameters:\n * \n * state - <mxCellState> that represents the target cell state.\n * next - <mxPoint> that represents the next point along the previewed edge.\n * me - <mxMouseEvent> that represents the mouse move.\n */\nmxConnectionHandler.prototype.getSourcePerimeterPoint = function(state, next, me)\n{\n\tvar result = null;\n\tvar view = state.view;\n\tvar sourcePerimeter = view.getPerimeterFunction(state);\n\tvar c = new mxPoint(state.getCenterX(), state.getCenterY());\n\t\n\tif (sourcePerimeter != null)\n\t{\n\t\tvar theta = mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION, 0);\n\t\tvar rad = -theta * (Math.PI / 180);\n\t\t\n\t\tif (theta != 0)\n\t\t{\n\t\t\tnext = mxUtils.getRotatedPoint(new mxPoint(next.x, next.y), Math.cos(rad), Math.sin(rad), c);\n\t\t}\n\t\t\n\t\tvar tmp = sourcePerimeter(view.getPerimeterBounds(state), state, next, false);\n\t\t\t\n\t\tif (tmp != null)\n\t\t{\n\t\t\tif (theta != 0)\n\t\t\t{\n\t\t\t\ttmp = mxUtils.getRotatedPoint(new mxPoint(tmp.x, tmp.y), Math.cos(-rad), Math.sin(-rad), c);\n\t\t\t}\n\t\t\t\n\t\t\tresult = tmp;\n\t\t}\n\t}\n\telse\n\t{\n\t\tresult = c;\n\t}\n\t\n\treturn result;\n};\n\n\n/**\n * Function: updateIcons\n * \n * Hook to update the icon position(s) based on a mouseOver event. This is\n * an empty implementation.\n * \n * Parameters:\n * \n * state - <mxCellState> under the mouse.\n * icons - Array of currently displayed icons.\n * me - <mxMouseEvent> that contains the mouse event.\n */\nmxConnectionHandler.prototype.updateIcons = function(state, icons, me)\n{\n\t// empty\n};\n\n/**\n * Function: isStopEvent\n * \n * Returns true if the given mouse up event should stop this handler. The\n * connection will be created if <error> is null. Note that this is only\n * called if <waypointsEnabled> is true. This implemtation returns true\n * if there is a cell state in the given event.\n */\nmxConnectionHandler.prototype.isStopEvent = function(me)\n{\n\treturn me.getState() != null;\n};\n\n/**\n * Function: addWaypoint\n * \n * Adds the waypoint for the given event to <waypoints>.\n */\nmxConnectionHandler.prototype.addWaypointForEvent = function(me)\n{\n\tvar point = mxUtils.convertPoint(this.graph.container, me.getX(), me.getY());\n\tvar dx = Math.abs(point.x - this.first.x);\n\tvar dy = Math.abs(point.y - this.first.y);\n\tvar addPoint = this.waypoints != null || (this.mouseDownCounter > 1 &&\n\t\t\t(dx > this.graph.tolerance || dy > this.graph.tolerance));\n\n\tif (addPoint)\n\t{\n\t\tif (this.waypoints == null)\n\t\t{\n\t\t\tthis.waypoints = [];\n\t\t}\n\t\t\n\t\tvar scale = this.graph.view.scale;\n\t\tvar point = new mxPoint(this.graph.snap(me.getGraphX() / scale) * scale,\n\t\t\t\tthis.graph.snap(me.getGraphY() / scale) * scale);\n\t\tthis.waypoints.push(point);\n\t}\n};\n\n/**\n * Function: checkConstraints\n * \n * Returns true if the connection for the given constraints is valid. This\n * implementation returns true if the constraints are not pointing to the\n * same fixed connection point.\n */\nmxConnectionHandler.prototype.checkConstraints = function(c1, c2)\n{\n\treturn (c1 == null || c2 == null || c1.point == null || c2.point == null ||\n\t\t!c1.point.equals(c2.point) || c1.dx != c2.dx || c1.dy != c2.dy ||\n\t\tc1.perimeter != c2.perimeter);\n};\n\n/**\n * Function: mouseUp\n * \n * Handles the event by inserting the new connection.\n */\nmxConnectionHandler.prototype.mouseUp = function(sender, me)\n{\n\tif (!me.isConsumed() && this.isConnecting())\n\t{\n\t\tif (this.waypointsEnabled && !this.isStopEvent(me))\n\t\t{\n\t\t\tthis.addWaypointForEvent(me);\n\t\t\tme.consume();\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar c1 = this.sourceConstraint;\n\t\tvar c2 = this.constraintHandler.currentConstraint;\n\n\t\tvar source = (this.previous != null) ? this.previous.cell : null;\n\t\tvar target = null;\n\t\t\n\t\tif (this.constraintHandler.currentConstraint != null &&\n\t\t\tthis.constraintHandler.currentFocus != null)\n\t\t{\n\t\t\ttarget = this.constraintHandler.currentFocus.cell;\n\t\t}\n\t\t\n\t\tif (target == null && this.currentState != null)\n\t\t{\n\t\t\ttarget = this.currentState.cell;\n\t\t}\n\t\t\n\t\t// Inserts the edge if no validation error exists and if constraints differ\n\t\tif (this.error == null && (source == null || target == null ||\n\t\t\tsource != target || this.checkConstraints(c1, c2)))\n\t\t{\n\t\t\tthis.connect(source, target, me.getEvent(), me.getCell());\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Selects the source terminal for self-references\n\t\t\tif (this.previous != null && this.marker.validState != null &&\n\t\t\t\tthis.previous.cell == this.marker.validState.cell)\n\t\t\t{\n\t\t\t\tthis.graph.selectCellForEvent(this.marker.source, me.getEvent());\n\t\t\t}\n\t\t\t\n\t\t\t// Displays the error message if it is not an empty string,\n\t\t\t// for empty error messages, the event is silently dropped\n\t\t\tif (this.error != null && this.error.length > 0)\n\t\t\t{\n\t\t\t\tthis.graph.validationAlert(this.error);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Redraws the connect icons and resets the handler state\n\t\tthis.destroyIcons();\n\t\tme.consume();\n\t}\n\n\tif (this.first != null)\n\t{\n\t\tthis.reset();\n\t}\n};\n\n/**\n * Function: reset\n * \n * Resets the state of this handler.\n */\nmxConnectionHandler.prototype.reset = function()\n{\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.destroy();\n\t\tthis.shape = null;\n\t}\n\t\n\t// Resets the cursor on the container\n\tif (this.cursor != null && this.graph.container != null)\n\t{\n\t\tthis.graph.container.style.cursor = '';\n\t}\n\t\n\tthis.destroyIcons();\n\tthis.marker.reset();\n\tthis.constraintHandler.reset();\n\tthis.originalPoint = null;\n\tthis.currentPoint = null;\n\tthis.edgeState = null;\n\tthis.previous = null;\n\tthis.error = null;\n\tthis.sourceConstraint = null;\n\tthis.mouseDownCounter = 0;\n\tthis.first = null;\n\n\tthis.fireEvent(new mxEventObject(mxEvent.RESET));\n};\n\n/**\n * Function: drawPreview\n * \n * Redraws the preview edge using the color and width returned by\n * <getEdgeColor> and <getEdgeWidth>.\n */\nmxConnectionHandler.prototype.drawPreview = function()\n{\n\tthis.updatePreview(this.error == null);\n\tthis.shape.redraw();\n};\n\n/**\n * Function: getEdgeColor\n * \n * Returns the color used to draw the preview edge. This returns green if\n * there is no edge validation error and red otherwise.\n * \n * Parameters:\n * \n * valid - Boolean indicating if the color for a valid edge should be\n * returned.\n */\nmxConnectionHandler.prototype.updatePreview = function(valid)\n{\n\tthis.shape.strokewidth = this.getEdgeWidth(valid);\n\tthis.shape.stroke = this.getEdgeColor(valid);\n};\n\n/**\n * Function: getEdgeColor\n * \n * Returns the color used to draw the preview edge. This returns green if\n * there is no edge validation error and red otherwise.\n * \n * Parameters:\n * \n * valid - Boolean indicating if the color for a valid edge should be\n * returned.\n */\nmxConnectionHandler.prototype.getEdgeColor = function(valid)\n{\n\treturn (valid) ? mxConstants.VALID_COLOR : mxConstants.INVALID_COLOR;\n};\n\t\n/**\n * Function: getEdgeWidth\n * \n * Returns the width used to draw the preview edge. This returns 3 if\n * there is no edge validation error and 1 otherwise.\n * \n * Parameters:\n * \n * valid - Boolean indicating if the width for a valid edge should be\n * returned.\n */\nmxConnectionHandler.prototype.getEdgeWidth = function(valid)\n{\n\treturn (valid) ? 3 : 1;\n};\n\n/**\n * Function: connect\n * \n * Connects the given source and target using a new edge. This\n * implementation uses <createEdge> to create the edge.\n * \n * Parameters:\n * \n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n * evt - Mousedown event of the connect gesture.\n * dropTarget - <mxCell> that represents the cell under the mouse when it was\n * released.\n */\nmxConnectionHandler.prototype.connect = function(source, target, evt, dropTarget)\n{\n\tif (target != null || this.isCreateTarget(evt) || this.graph.allowDanglingEdges)\n\t{\n\t\t// Uses the common parent of source and target or\n\t\t// the default parent to insert the edge\n\t\tvar model = this.graph.getModel();\n\t\tvar terminalInserted = false;\n\t\tvar edge = null;\n\n\t\tmodel.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tif (source != null && target == null && !this.graph.isIgnoreTerminalEvent(evt) && this.isCreateTarget(evt))\n\t\t\t{\n\t\t\t\ttarget = this.createTargetVertex(evt, source);\n\t\t\t\t\n\t\t\t\tif (target != null)\n\t\t\t\t{\n\t\t\t\t\tdropTarget = this.graph.getDropTarget([target], evt, dropTarget);\n\t\t\t\t\tterminalInserted = true;\n\t\t\t\t\t\n\t\t\t\t\t// Disables edges as drop targets if the target cell was created\n\t\t\t\t\t// FIXME: Should not shift if vertex was aligned (same in Java)\n\t\t\t\t\tif (dropTarget == null || !this.graph.getModel().isEdge(dropTarget))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar pstate = this.graph.getView().getState(dropTarget);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (pstate != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar tmp = model.getGeometry(target);\n\t\t\t\t\t\t\ttmp.x -= pstate.origin.x;\n\t\t\t\t\t\t\ttmp.y -= pstate.origin.y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdropTarget = this.graph.getDefaultParent();\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tthis.graph.addCell(target, dropTarget);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar parent = this.graph.getDefaultParent();\n\n\t\t\tif (source != null && target != null &&\n\t\t\t\tmodel.getParent(source) == model.getParent(target) &&\n\t\t\t\tmodel.getParent(model.getParent(source)) != model.getRoot())\n\t\t\t{\n\t\t\t\tparent = model.getParent(source);\n\n\t\t\t\tif ((source.geometry != null && source.geometry.relative) &&\n\t\t\t\t\t(target.geometry != null && target.geometry.relative))\n\t\t\t\t{\n\t\t\t\t\tparent = model.getParent(parent);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Uses the value of the preview edge state for inserting\n\t\t\t// the new edge into the graph\n\t\t\tvar value = null;\n\t\t\tvar style = null;\n\t\t\t\n\t\t\tif (this.edgeState != null)\n\t\t\t{\n\t\t\t\tvalue = this.edgeState.cell.value;\n\t\t\t\tstyle = this.edgeState.cell.style;\n\t\t\t}\n\n\t\t\tedge = this.insertEdge(parent, null, value, source, target, style);\n\t\t\t\n\t\t\tif (edge != null)\n\t\t\t{\n\t\t\t\t// Updates the connection constraints\n\t\t\t\tthis.graph.setConnectionConstraint(edge, source, true, this.sourceConstraint);\n\t\t\t\tthis.graph.setConnectionConstraint(edge, target, false, this.constraintHandler.currentConstraint);\n\t\t\t\t\n\t\t\t\t// Uses geometry of the preview edge state\n\t\t\t\tif (this.edgeState != null)\n\t\t\t\t{\n\t\t\t\t\tmodel.setGeometry(edge, this.edgeState.cell.geometry);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar parent = model.getParent(source);\n\t\t\t\t\n\t\t\t\t// Inserts edge before source\n\t\t\t\tif (this.isInsertBefore(edge, source, target, evt, dropTarget))\n\t\t\t\t{\n\t\t\t\t\tvar index = null;\n\t\t\t\t\tvar tmp = source;\n\n\t\t\t\t\twhile (tmp.parent != null && tmp.geometry != null &&\n\t\t\t\t\t\ttmp.geometry.relative && tmp.parent != edge.parent)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp = this.graph.model.getParent(tmp);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tmp != null && tmp.parent != null && tmp.parent == edge.parent)\n\t\t\t\t\t{\n\t\t\t\t\t\tmodel.add(parent, edge, tmp.parent.getIndex(tmp));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Makes sure the edge has a non-null, relative geometry\n\t\t\t\tvar geo = model.getGeometry(edge);\n\n\t\t\t\tif (geo == null)\n\t\t\t\t{\n\t\t\t\t\tgeo = new mxGeometry();\n\t\t\t\t\tgeo.relative = true;\n\t\t\t\t\t\n\t\t\t\t\tmodel.setGeometry(edge, geo);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Uses scaled waypoints in geometry\n\t\t\t\tif (this.waypoints != null && this.waypoints.length > 0)\n\t\t\t\t{\n\t\t\t\t\tvar s = this.graph.view.scale;\n\t\t\t\t\tvar tr = this.graph.view.translate;\n\t\t\t\t\tgeo.points = [];\n\t\t\t\t\t\n\t\t\t\t\tfor (var i = 0; i < this.waypoints.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar pt = this.waypoints[i];\n\t\t\t\t\t\tgeo.points.push(new mxPoint(pt.x / s - tr.x, pt.y / s - tr.y));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (target == null)\n\t\t\t\t{\n\t\t\t\t\tvar t = this.graph.view.translate;\n\t\t\t\t\tvar s = this.graph.view.scale;\n\t\t\t\t\tvar pt = (this.originalPoint != null) ?\n\t\t\t\t\t\t\tnew mxPoint(this.originalPoint.x / s - t.x, this.originalPoint.y / s - t.y) :\n\t\t\t\t\t\tnew mxPoint(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);\n\t\t\t\t\tpt.x -= this.graph.panDx / this.graph.view.scale;\n\t\t\t\t\tpt.y -= this.graph.panDy / this.graph.view.scale;\n\t\t\t\t\tgeo.setTerminalPoint(pt, false);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CONNECT, 'cell', edge, 'terminal', target,\n\t\t\t\t\t'event', evt, 'target', dropTarget, 'terminalInserted', terminalInserted));\n\t\t\t}\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\tmxLog.show();\n\t\t\tmxLog.debug(e.message);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tmodel.endUpdate();\n\t\t}\n\t\t\n\t\tif (this.select)\n\t\t{\n\t\t\tthis.selectCells(edge, (terminalInserted) ? target : null);\n\t\t}\n\t}\n};\n\n/**\n * Function: selectCells\n * \n * Selects the given edge after adding a new connection. The target argument\n * contains the target vertex if one has been inserted.\n */\nmxConnectionHandler.prototype.selectCells = function(edge, target)\n{\n\tthis.graph.setSelectionCell(edge);\n};\n\n/**\n * Function: insertEdge\n * \n * Creates, inserts and returns the new edge for the given parameters. This\n * implementation does only use <createEdge> if <factoryMethod> is defined,\n * otherwise <mxGraph.insertEdge> will be used.\n */\nmxConnectionHandler.prototype.insertEdge = function(parent, id, value, source, target, style)\n{\n\tif (this.factoryMethod == null)\n\t{\n\t\treturn this.graph.insertEdge(parent, id, value, source, target, style);\n\t}\n\telse\n\t{\n\t\tvar edge = this.createEdge(value, source, target, style);\n\t\tedge = this.graph.addEdge(edge, parent, source, target);\n\t\t\n\t\treturn edge;\n\t}\n};\n\n/**\n * Function: createTargetVertex\n * \n * Hook method for creating new vertices on the fly if no target was\n * under the mouse. This is only called if <createTarget> is true and\n * returns null.\n * \n * Parameters:\n * \n * evt - Mousedown event of the connect gesture.\n * source - <mxCell> that represents the source terminal.\n */\nmxConnectionHandler.prototype.createTargetVertex = function(evt, source)\n{\n\t// Uses the first non-relative source\n\tvar geo = this.graph.getCellGeometry(source);\n\t\n\twhile (geo != null && geo.relative)\n\t{\n\t\tsource = this.graph.getModel().getParent(source);\n\t\tgeo = this.graph.getCellGeometry(source);\n\t}\n\t\n\tvar clone = this.graph.cloneCell(source);\n\tvar geo = this.graph.getModel().getGeometry(clone);\n\t\n\tif (geo != null)\n\t{\n\t\tvar t = this.graph.view.translate;\n\t\tvar s = this.graph.view.scale;\n\t\tvar point = new mxPoint(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);\n\t\tgeo.x = Math.round(point.x - geo.width / 2 - this.graph.panDx / s);\n\t\tgeo.y = Math.round(point.y - geo.height / 2 - this.graph.panDy / s);\n\n\t\t// Aligns with source if within certain tolerance\n\t\tvar tol = this.getAlignmentTolerance();\n\t\t\n\t\tif (tol > 0)\n\t\t{\n\t\t\tvar sourceState = this.graph.view.getState(source);\n\t\t\t\n\t\t\tif (sourceState != null)\n\t\t\t{\n\t\t\t\tvar x = sourceState.x / s - t.x;\n\t\t\t\tvar y = sourceState.y / s - t.y;\n\t\t\t\t\n\t\t\t\tif (Math.abs(x - geo.x) <= tol)\n\t\t\t\t{\n\t\t\t\t\tgeo.x = Math.round(x);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (Math.abs(y - geo.y) <= tol)\n\t\t\t\t{\n\t\t\t\t\tgeo.y = Math.round(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn clone;\t\t\n};\n\n/**\n * Function: getAlignmentTolerance\n * \n * Returns the tolerance for aligning new targets to sources. This returns the grid size / 2.\n */\nmxConnectionHandler.prototype.getAlignmentTolerance = function(evt)\n{\n\treturn (this.graph.isGridEnabled()) ? this.graph.gridSize / 2 : this.graph.tolerance;\n};\n\n/**\n * Function: createEdge\n * \n * Creates and returns a new edge using <factoryMethod> if one exists. If\n * no factory method is defined, then a new default edge is returned. The\n * source and target arguments are informal, the actual connection is\n * setup later by the caller of this function.\n * \n * Parameters:\n * \n * value - Value to be used for creating the edge.\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n * style - Optional style from the preview edge.\n */\nmxConnectionHandler.prototype.createEdge = function(value, source, target, style)\n{\n\tvar edge = null;\n\t\n\t// Creates a new edge using the factoryMethod\n\tif (this.factoryMethod != null)\n\t{\n\t\tedge = this.factoryMethod(source, target, style);\n\t}\n\t\n\tif (edge == null)\n\t{\n\t\tedge = new mxCell(value || '');\n\t\tedge.setEdge(true);\n\t\tedge.setStyle(style);\n\t\t\n\t\tvar geo = new mxGeometry();\n\t\tgeo.relative = true;\n\t\tedge.setGeometry(geo);\n\t}\n\n\treturn edge;\n};\n\n/**\n * Function: destroy\n * \n * Destroys the handler and all its resources and DOM nodes. This should be\n * called on all instances. It is called automatically for the built-in\n * instance created for each <mxGraph>.\n */\nmxConnectionHandler.prototype.destroy = function()\n{\n\tthis.graph.removeMouseListener(this);\n\t\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.destroy();\n\t\tthis.shape = null;\n\t}\n\t\n\tif (this.marker != null)\n\t{\n\t\tthis.marker.destroy();\n\t\tthis.marker = null;\n\t}\n\n\tif (this.constraintHandler != null)\n\t{\n\t\tthis.constraintHandler.destroy();\n\t\tthis.constraintHandler = null;\n\t}\n\n\tif (this.changeHandler != null)\n\t{\n\t\tthis.graph.getModel().removeListener(this.changeHandler);\n\t\tthis.graph.getView().removeListener(this.changeHandler);\n\t\tthis.changeHandler = null;\n\t}\n\t\n\tif (this.drillHandler != null)\n\t{\n\t\tthis.graph.removeListener(this.drillHandler);\n\t\tthis.graph.getView().removeListener(this.drillHandler);\n\t\tthis.drillHandler = null;\n\t}\n\t\n\tif (this.escapeHandler != null)\n\t{\n\t\tthis.graph.removeListener(this.escapeHandler);\n\t\tthis.escapeHandler = null;\n\t}\n};\n\n__mxOutput.mxConnectionHandler = typeof mxConnectionHandler !== 'undefined' ? mxConnectionHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxConstraintHandler\n *\n * Handles constraints on connection targets. This class is in charge of\n * showing fixed points when the mouse is over a vertex and handles constraints\n * to establish new connections.\n *\n * Constructor: mxConstraintHandler\n *\n * Constructs an new constraint handler.\n * \n * Parameters:\n * \n * graph - Reference to the enclosing <mxGraph>.\n * factoryMethod - Optional function to create the edge. The function takes\n * the source and target <mxCell> as the first and second argument and\n * returns the <mxCell> that represents the new edge.\n */\nfunction mxConstraintHandler(graph)\n{\n\tthis.graph = graph;\n\t\n\t// Adds a graph model listener to update the current focus on changes\n\tthis.resetHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tif (this.currentFocus != null && this.graph.view.getState(this.currentFocus.cell) == null)\n\t\t{\n\t\t\tthis.reset();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.redraw();\n\t\t}\n\t});\n\t\n\tthis.graph.model.addListener(mxEvent.CHANGE, this.resetHandler);\n\tthis.graph.view.addListener(mxEvent.SCALE_AND_TRANSLATE, this.resetHandler);\n\tthis.graph.view.addListener(mxEvent.TRANSLATE, this.resetHandler);\n\tthis.graph.view.addListener(mxEvent.SCALE, this.resetHandler);\n\tthis.graph.addListener(mxEvent.ROOT, this.resetHandler);\n};\n\n/**\n * Variable: pointImage\n * \n * <mxImage> to be used as the image for fixed connection points.\n */\nmxConstraintHandler.prototype.pointImage = new mxImage(mxClient.imageBasePath + '/point.gif', 5, 5);\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxConstraintHandler.prototype.graph = null;\n\n/**\n * Variable: enabled\n * \n * Specifies if events are handled. Default is true.\n */\nmxConstraintHandler.prototype.enabled = true;\n\n/**\n * Variable: highlightColor\n * \n * Specifies the color for the highlight. Default is <mxConstants.DEFAULT_VALID_COLOR>.\n */\nmxConstraintHandler.prototype.highlightColor = mxConstants.DEFAULT_VALID_COLOR;\n\n/**\n * Function: isEnabled\n * \n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxConstraintHandler.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\t\n/**\n * Function: setEnabled\n * \n * Enables or disables event handling. This implementation\n * updates <enabled>.\n * \n * Parameters:\n * \n * enabled - Boolean that specifies the new enabled state.\n */\nmxConstraintHandler.prototype.setEnabled = function(enabled)\n{\n\tthis.enabled = enabled;\n};\n\n/**\n * Function: reset\n * \n * Resets the state of this handler.\n */\nmxConstraintHandler.prototype.reset = function()\n{\n\tif (this.focusIcons != null)\n\t{\n\t\tfor (var i = 0; i < this.focusIcons.length; i++)\n\t\t{\n\t\t\tthis.focusIcons[i].destroy();\n\t\t}\n\t\t\n\t\tthis.focusIcons = null;\n\t}\n\t\n\tif (this.focusHighlight != null)\n\t{\n\t\tthis.focusHighlight.destroy();\n\t\tthis.focusHighlight = null;\n\t}\n\t\n\tthis.currentConstraint = null;\n\tthis.currentFocusArea = null;\n\tthis.currentPoint = null;\n\tthis.currentFocus = null;\n\tthis.focusPoints = null;\n};\n\n/**\n * Function: getTolerance\n * \n * Returns the tolerance to be used for intersecting connection points. This\n * implementation returns <mxGraph.tolerance>.\n * \n * Parameters:\n * \n * me - <mxMouseEvent> whose tolerance should be returned.\n */\nmxConstraintHandler.prototype.getTolerance = function(me)\n{\n\treturn this.graph.getTolerance();\n};\n\n/**\n * Function: getImageForConstraint\n * \n * Returns the tolerance to be used for intersecting connection points.\n */\nmxConstraintHandler.prototype.getImageForConstraint = function(state, constraint, point)\n{\n\treturn this.pointImage;\n};\n\n/**\n * Function: isEventIgnored\n * \n * Returns true if the given <mxMouseEvent> should be ignored in <update>. This\n * implementation always returns false.\n */\nmxConstraintHandler.prototype.isEventIgnored = function(me, source)\n{\n\treturn false;\n};\n\n/**\n * Function: isStateIgnored\n * \n * Returns true if the given state should be ignored. This always returns false.\n */\nmxConstraintHandler.prototype.isStateIgnored = function(state, source)\n{\n\treturn false;\n};\n\n/**\n * Function: destroyIcons\n * \n * Destroys the <focusIcons> if they exist.\n */\nmxConstraintHandler.prototype.destroyIcons = function()\n{\n\tif (this.focusIcons != null)\n\t{\n\t\tfor (var i = 0; i < this.focusIcons.length; i++)\n\t\t{\n\t\t\tthis.focusIcons[i].destroy();\n\t\t}\n\t\t\n\t\tthis.focusIcons = null;\n\t\tthis.focusPoints = null;\n\t}\n};\n\n/**\n * Function: destroyFocusHighlight\n * \n * Destroys the <focusHighlight> if one exists.\n */\nmxConstraintHandler.prototype.destroyFocusHighlight = function()\n{\n\tif (this.focusHighlight != null)\n\t{\n\t\tthis.focusHighlight.destroy();\n\t\tthis.focusHighlight = null;\n\t}\n};\n\n/**\n * Function: isKeepFocusEvent\n * \n * Returns true if the current focused state should not be changed for the given event.\n * This returns true if shift and alt are pressed.\n */\nmxConstraintHandler.prototype.isKeepFocusEvent = function(me)\n{\n\treturn mxEvent.isShiftDown(me.getEvent());\n};\n\n/**\n * Function: getCellForEvent\n * \n * Returns the cell for the given event.\n */\nmxConstraintHandler.prototype.getCellForEvent = function(me, point)\n{\n\tvar cell = me.getCell();\n\t\n\t// Gets cell under actual point if different from event location\n\tif (cell == null && point != null && (me.getGraphX() != point.x || me.getGraphY() != point.y))\n\t{\n\t\tcell = this.graph.getCellAt(point.x, point.y);\n\t}\n\t\n\t// Uses connectable parent vertex if one exists\n\tif (cell != null && !this.graph.isCellConnectable(cell))\n\t{\n\t\tvar parent = this.graph.getModel().getParent(cell);\n\t\t\n\t\tif (this.graph.getModel().isVertex(parent) && this.graph.isCellConnectable(parent))\n\t\t{\n\t\t\tcell = parent;\n\t\t}\n\t}\n\t\n\treturn (this.graph.isCellLocked(cell)) ? null : cell;\n};\n\n/**\n * Function: update\n * \n * Updates the state of this handler based on the given <mxMouseEvent>.\n * Source is a boolean indicating if the cell is a source or target.\n */\nmxConstraintHandler.prototype.update = function(me, source, existingEdge, point)\n{\n\tif (this.isEnabled() && !this.isEventIgnored(me))\n\t{\n\t\t// Lazy installation of mouseleave handler\n\t\tif (this.mouseleaveHandler == null && this.graph.container != null)\n\t\t{\n\t\t\tthis.mouseleaveHandler = mxUtils.bind(this, function()\n\t\t\t{\n\t\t\t\tthis.reset();\n\t\t\t});\n\n\t\t\tmxEvent.addListener(this.graph.container, 'mouseleave', this.resetHandler);\t\n\t\t}\n\t\t\n\t\tvar tol = this.getTolerance(me);\n\t\tvar x = (point != null) ? point.x : me.getGraphX();\n\t\tvar y = (point != null) ? point.y : me.getGraphY();\n\t\tvar grid = new mxRectangle(x - tol, y - tol, 2 * tol, 2 * tol);\n\t\tvar mouse = new mxRectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol);\n\t\tvar state = this.graph.view.getState(this.getCellForEvent(me, point));\n\n\t\t// Keeps focus icons visible while over vertex bounds and no other cell under mouse or shift is pressed\n\t\tif (!this.isKeepFocusEvent(me) && (this.currentFocusArea == null || this.currentFocus == null ||\n\t\t\t(state != null) || !this.graph.getModel().isVertex(this.currentFocus.cell) ||\n\t\t\t!mxUtils.intersects(this.currentFocusArea, mouse)) && (state != this.currentFocus))\n\t\t{\n\t\t\tthis.currentFocusArea = null;\n\t\t\tthis.currentFocus = null;\n\t\t\tthis.setFocus(me, state, source);\n\t\t}\n\n\t\tthis.currentConstraint = null;\n\t\tthis.currentPoint = null;\n\t\tvar minDistSq = null;\n\t\t\n\t\tif (this.focusIcons != null && this.constraints != null &&\n\t\t\t(state == null || this.currentFocus == state))\n\t\t{\n\t\t\tvar cx = mouse.getCenterX();\n\t\t\tvar cy = mouse.getCenterY();\n\t\t\t\n\t\t\tfor (var i = 0; i < this.focusIcons.length; i++)\n\t\t\t{\n\t\t\t\tvar dx = cx - this.focusIcons[i].bounds.getCenterX();\n\t\t\t\tvar dy = cy - this.focusIcons[i].bounds.getCenterY();\n\t\t\t\tvar tmp = dx * dx + dy * dy;\n\t\t\t\t\n\t\t\t\tif ((this.intersects(this.focusIcons[i], mouse, source, existingEdge) || (point != null &&\n\t\t\t\t\tthis.intersects(this.focusIcons[i], grid, source, existingEdge))) &&\n\t\t\t\t\t(minDistSq == null || tmp < minDistSq))\n\t\t\t\t{\n\t\t\t\t\tthis.currentConstraint = this.constraints[i];\n\t\t\t\t\tthis.currentPoint = this.focusPoints[i];\n\t\t\t\t\tminDistSq = tmp;\n\t\t\t\t\t\n\t\t\t\t\tvar tmp = this.focusIcons[i].bounds.clone();\n\t\t\t\t\ttmp.grow(mxConstants.HIGHLIGHT_SIZE + 1);\n\t\t\t\t\ttmp.width -= 1;\n\t\t\t\t\ttmp.height -= 1;\n\t\t\t\t\t\n\t\t\t\t\tif (this.focusHighlight == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar hl = this.createHighlightShape();\n\t\t\t\t\t\thl.dialect = (this.graph.dialect == mxConstants.DIALECT_SVG) ?\n\t\t\t\t\t\t\t\tmxConstants.DIALECT_SVG : mxConstants.DIALECT_VML;\n\t\t\t\t\t\thl.pointerEvents = false;\n\n\t\t\t\t\t\thl.init(this.graph.getView().getOverlayPane());\n\t\t\t\t\t\tthis.focusHighlight = hl;\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar getState = mxUtils.bind(this, function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn (this.currentFocus != null) ? this.currentFocus : state;\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\t\tmxEvent.redirectMouseEvents(hl.node, this.graph, getState);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.focusHighlight.bounds = tmp;\n\t\t\t\t\tthis.focusHighlight.redraw();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (this.currentConstraint == null)\n\t\t{\n\t\t\tthis.destroyFocusHighlight();\n\t\t}\n\t}\n\telse\n\t{\n\t\tthis.currentConstraint = null;\n\t\tthis.currentFocus = null;\n\t\tthis.currentPoint = null;\n\t}\n};\n\n/**\n * Function: redraw\n * \n * Transfers the focus to the given state as a source or target terminal. If\n * the handler is not enabled then the outline is painted, but the constraints\n * are ignored.\n */\nmxConstraintHandler.prototype.redraw = function()\n{\n\tif (this.currentFocus != null && this.constraints != null && this.focusIcons != null)\n\t{\n\t\tvar state = this.graph.view.getState(this.currentFocus.cell);\n\t\tthis.currentFocus = state;\n\t\tthis.currentFocusArea = new mxRectangle(state.x, state.y, state.width, state.height);\n\t\t\n\t\tfor (var i = 0; i < this.constraints.length; i++)\n\t\t{\n\t\t\tvar cp = this.graph.getConnectionPoint(state, this.constraints[i]);\n\t\t\tvar img = this.getImageForConstraint(state, this.constraints[i], cp);\n\n\t\t\tvar bounds = new mxRectangle(Math.round(cp.x - img.width / 2),\n\t\t\t\tMath.round(cp.y - img.height / 2), img.width, img.height);\n\t\t\tthis.focusIcons[i].bounds = bounds;\n\t\t\tthis.focusIcons[i].redraw();\n\t\t\tthis.currentFocusArea.add(this.focusIcons[i].bounds);\n\t\t\tthis.focusPoints[i] = cp;\n\t\t}\n\t}\t\n};\n\n/**\n * Function: setFocus\n * \n * Transfers the focus to the given state as a source or target terminal. If\n * the handler is not enabled then the outline is painted, but the constraints\n * are ignored.\n */\nmxConstraintHandler.prototype.setFocus = function(me, state, source)\n{\n\tthis.constraints = (state != null && !this.isStateIgnored(state, source) &&\n\t\tthis.graph.isCellConnectable(state.cell)) ? ((this.isEnabled()) ?\n\t\t(this.graph.getAllConnectionConstraints(state, source) || []) : []) : null;\n\n\t// Only uses cells which have constraints\n\tif (this.constraints != null)\n\t{\n\t\tthis.currentFocus = state;\n\t\tthis.currentFocusArea = new mxRectangle(state.x, state.y, state.width, state.height);\n\t\t\n\t\tif (this.focusIcons != null)\n\t\t{\n\t\t\tfor (var i = 0; i < this.focusIcons.length; i++)\n\t\t\t{\n\t\t\t\tthis.focusIcons[i].destroy();\n\t\t\t}\n\t\t\t\n\t\t\tthis.focusIcons = null;\n\t\t\tthis.focusPoints = null;\n\t\t}\n\t\t\n\t\tthis.focusPoints = [];\n\t\tthis.focusIcons = [];\n\t\t\n\t\tfor (var i = 0; i < this.constraints.length; i++)\n\t\t{\n\t\t\tvar cp = this.graph.getConnectionPoint(state, this.constraints[i]);\n\t\t\tvar img = this.getImageForConstraint(state, this.constraints[i], cp);\n\n\t\t\tvar src = img.src;\n\t\t\tvar bounds = new mxRectangle(Math.round(cp.x - img.width / 2),\n\t\t\t\tMath.round(cp.y - img.height / 2), img.width, img.height);\n\t\t\tvar icon = new mxImageShape(bounds, src);\n\t\t\ticon.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\t\t\t\tmxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;\n\t\t\ticon.preserveImageAspect = false;\n\t\t\ticon.init(this.graph.getView().getDecoratorPane());\n\t\t\t\n\t\t\t// Fixes lost event tracking for images in quirks / IE8 standards\n\t\t\tif (mxClient.IS_QUIRKS || document.documentMode == 8)\n\t\t\t{\n\t\t\t\tmxEvent.addListener(icon.node, 'dragstart', function(evt)\n\t\t\t\t{\n\t\t\t\t\tmxEvent.consume(evt);\n\t\t\t\t\t\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\t// Move the icon behind all other overlays\n\t\t\tif (icon.node.previousSibling != null)\n\t\t\t{\n\t\t\t\ticon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);\n\t\t\t}\n\n\t\t\tvar getState = mxUtils.bind(this, function()\n\t\t\t{\n\t\t\t\treturn (this.currentFocus != null) ? this.currentFocus : state;\n\t\t\t});\n\t\t\t\n\t\t\ticon.redraw();\n\n\t\t\tmxEvent.redirectMouseEvents(icon.node, this.graph, getState);\n\t\t\tthis.currentFocusArea.add(icon.bounds);\n\t\t\tthis.focusIcons.push(icon);\n\t\t\tthis.focusPoints.push(cp);\n\t\t}\n\t\t\n\t\tthis.currentFocusArea.grow(this.getTolerance(me));\n\t}\n\telse\n\t{\n\t\tthis.destroyIcons();\n\t\tthis.destroyFocusHighlight();\n\t}\n};\n\n/**\n * Function: createHighlightShape\n * \n * Create the shape used to paint the highlight.\n * \n * Returns true if the given icon intersects the given point.\n */\nmxConstraintHandler.prototype.createHighlightShape = function()\n{\n\tvar hl = new mxRectangleShape(null, this.highlightColor, this.highlightColor, mxConstants.HIGHLIGHT_STROKEWIDTH);\n\thl.opacity = mxConstants.HIGHLIGHT_OPACITY;\n\t\n\treturn hl;\n};\n\n/**\n * Function: intersects\n * \n * Returns true if the given icon intersects the given rectangle.\n */\nmxConstraintHandler.prototype.intersects = function(icon, mouse, source, existingEdge)\n{\n\treturn mxUtils.intersects(icon.bounds, mouse);\n};\n\n/**\n * Function: destroy\n * \n * Destroy this handler.\n */\nmxConstraintHandler.prototype.destroy = function()\n{\n\tthis.reset();\n\t\n\tif (this.resetHandler != null)\n\t{\n\t\tthis.graph.model.removeListener(this.resetHandler);\n\t\tthis.graph.view.removeListener(this.resetHandler);\n\t\tthis.graph.removeListener(this.resetHandler);\n\t\tthis.resetHandler = null;\n\t}\n\t\n\tif (this.mouseleaveHandler != null && this.graph.container != null)\n\t{\n\t\tmxEvent.removeListener(this.graph.container, 'mouseleave', this.mouseleaveHandler);\n\t\tthis.mouseleaveHandler = null;\n\t}\n};\n\n__mxOutput.mxConstraintHandler = typeof mxConstraintHandler !== 'undefined' ? mxConstraintHandler : undefined;\n\n/**\n * Copyright (c) 2006-2016, JGraph Ltd\n * Copyright (c) 2006-2016, Gaudenz Alder\n */\n/**\n * Class: mxRubberband\n * \n * Event handler that selects rectangular regions. This is not built-into\n * <mxGraph>. To enable rubberband selection in a graph, use the following code.\n * \n * Example:\n * \n * (code)\n * var rubberband = new mxRubberband(graph);\n * (end)\n * \n * Constructor: mxRubberband\n * \n * Constructs an event handler that selects rectangular regions in the graph\n * using rubberband selection.\n */\nfunction mxRubberband(graph)\n{\n\tif (graph != null)\n\t{\n\t\tthis.graph = graph;\n\t\tthis.graph.addMouseListener(this);\n\n\t\t// Handles force rubberband event\n\t\tthis.forceRubberbandHandler = mxUtils.bind(this, function(sender, evt)\n\t\t{\n\t\t\tvar evtName = evt.getProperty('eventName');\n\t\t\tvar me = evt.getProperty('event');\n\t\t\t\n\t\t\tif (evtName == mxEvent.MOUSE_DOWN && this.isForceRubberbandEvent(me))\n\t\t\t{\n\t\t\t\tvar offset = mxUtils.getOffset(this.graph.container);\n\t\t\t\tvar origin = mxUtils.getScrollOrigin(this.graph.container);\n\t\t\t\torigin.x -= offset.x;\n\t\t\t\torigin.y -= offset.y;\n\t\t\t\tthis.start(me.getX() + origin.x, me.getY() + origin.y);\n\t\t\t\tme.consume(false);\n\t\t\t}\n\t\t});\n\t\t\n\t\tthis.graph.addListener(mxEvent.FIRE_MOUSE_EVENT, this.forceRubberbandHandler);\n\t\t\n\t\t// Repaints the marquee after autoscroll\n\t\tthis.panHandler = mxUtils.bind(this, function()\n\t\t{\n\t\t\tthis.repaint();\n\t\t});\n\t\t\n\t\tthis.graph.addListener(mxEvent.PAN, this.panHandler);\n\t\t\n\t\t// Does not show menu if any touch gestures take place after the trigger\n\t\tthis.gestureHandler = mxUtils.bind(this, function(sender, eo)\n\t\t{\n\t\t\tif (this.first != null)\n\t\t\t{\n\t\t\t\tthis.reset();\n\t\t\t}\n\t\t});\n\t\t\n\t\tthis.graph.addListener(mxEvent.GESTURE, this.gestureHandler);\n\t\t\n\t\t// Automatic deallocation of memory\n\t\tif (mxClient.IS_IE)\n\t\t{\n\t\t\tmxEvent.addListener(window, 'unload',\n\t\t\t\tmxUtils.bind(this, function()\n\t\t\t\t{\n\t\t\t\t\tthis.destroy();\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t}\n};\n\n/**\n * Variable: defaultOpacity\n * \n * Specifies the default opacity to be used for the rubberband div. Default\n * is 20.\n */\nmxRubberband.prototype.defaultOpacity = 20;\n\n/**\n * Variable: enabled\n * \n * Specifies if events are handled. Default is true.\n */\nmxRubberband.prototype.enabled = true;\n\n/**\n * Variable: div\n * \n * Holds the DIV element which is currently visible.\n */\nmxRubberband.prototype.div = null;\n\n/**\n * Variable: sharedDiv\n * \n * Holds the DIV element which is used to display the rubberband.\n */\nmxRubberband.prototype.sharedDiv = null;\n\n/**\n * Variable: currentX\n * \n * Holds the value of the x argument in the last call to <update>.\n */\nmxRubberband.prototype.currentX = 0;\n\n/**\n * Variable: currentY\n * \n * Holds the value of the y argument in the last call to <update>.\n */\nmxRubberband.prototype.currentY = 0;\n\n/**\n * Variable: fadeOut\n * \n * Optional fade out effect. Default is false.\n */\nmxRubberband.prototype.fadeOut = false;\n\n/**\n * Function: isEnabled\n * \n * Returns true if events are handled. This implementation returns\n * <enabled>.\n */\nmxRubberband.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\t\t\n/**\n * Function: setEnabled\n * \n * Enables or disables event handling. This implementation updates\n * <enabled>.\n */\nmxRubberband.prototype.setEnabled = function(enabled)\n{\n\tthis.enabled = enabled;\n};\n\n/**\n * Function: isForceRubberbandEvent\n * \n * Returns true if the given <mxMouseEvent> should start rubberband selection.\n * This implementation returns true if the alt key is pressed.\n */\nmxRubberband.prototype.isForceRubberbandEvent = function(me)\n{\n\treturn mxEvent.isAltDown(me.getEvent());\n};\n\n/**\n * Function: mouseDown\n * \n * Handles the event by initiating a rubberband selection. By consuming the\n * event all subsequent events of the gesture are redirected to this\n * handler.\n */\nmxRubberband.prototype.mouseDown = function(sender, me)\n{\n\tif (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() &&\n\t\tme.getState() == null && !mxEvent.isMultiTouchEvent(me.getEvent()))\n\t{\n\t\tvar offset = mxUtils.getOffset(this.graph.container);\n\t\tvar origin = mxUtils.getScrollOrigin(this.graph.container);\n\t\torigin.x -= offset.x;\n\t\torigin.y -= offset.y;\n\t\tthis.start(me.getX() + origin.x, me.getY() + origin.y);\n\n\t\t// Does not prevent the default for this event so that the\n\t\t// event processing chain is still executed even if we start\n\t\t// rubberbanding. This is required eg. in ExtJs to hide the\n\t\t// current context menu. In mouseMove we'll make sure we're\n\t\t// not selecting anything while we're rubberbanding.\n\t\tme.consume(false);\n\t}\n};\n\n/**\n * Function: start\n * \n * Sets the start point for the rubberband selection.\n */\nmxRubberband.prototype.start = function(x, y)\n{\n\tthis.first = new mxPoint(x, y);\n\n\tvar container = this.graph.container;\n\t\n\tfunction createMouseEvent(evt)\n\t{\n\t\tvar me = new mxMouseEvent(evt);\n\t\tvar pt = mxUtils.convertPoint(container, me.getX(), me.getY());\n\t\t\n\t\tme.graphX = pt.x;\n\t\tme.graphY = pt.y;\n\t\t\n\t\treturn me;\n\t};\n\n\tthis.dragHandler = mxUtils.bind(this, function(evt)\n\t{\n\t\tthis.mouseMove(this.graph, createMouseEvent(evt));\n\t});\n\n\tthis.dropHandler = mxUtils.bind(this, function(evt)\n\t{\n\t\tthis.mouseUp(this.graph, createMouseEvent(evt));\n\t});\n\n\t// Workaround for rubberband stopping if the mouse leaves the container in Firefox\n\tif (mxClient.IS_FF)\n\t{\n\t\tmxEvent.addGestureListeners(document, null, this.dragHandler, this.dropHandler);\n\t}\n};\n\n/**\n * Function: mouseMove\n * \n * Handles the event by updating therubberband selection.\n */\nmxRubberband.prototype.mouseMove = function(sender, me)\n{\n\tif (!me.isConsumed() && this.first != null)\n\t{\n\t\tvar origin = mxUtils.getScrollOrigin(this.graph.container);\n\t\tvar offset = mxUtils.getOffset(this.graph.container);\n\t\torigin.x -= offset.x;\n\t\torigin.y -= offset.y;\n\t\tvar x = me.getX() + origin.x;\n\t\tvar y = me.getY() + origin.y;\n\t\tvar dx = this.first.x - x;\n\t\tvar dy = this.first.y - y;\n\t\tvar tol = this.graph.tolerance;\n\t\t\n\t\tif (this.div != null || Math.abs(dx) > tol ||  Math.abs(dy) > tol)\n\t\t{\n\t\t\tif (this.div == null)\n\t\t\t{\n\t\t\t\tthis.div = this.createShape();\n\t\t\t}\n\t\t\t\n\t\t\t// Clears selection while rubberbanding. This is required because\n\t\t\t// the event is not consumed in mouseDown.\n\t\t\tmxUtils.clearSelection();\n\t\t\t\n\t\t\tthis.update(x, y);\n\t\t\tme.consume();\n\t\t}\n\t}\n};\n\n/**\n * Function: createShape\n * \n * Creates the rubberband selection shape.\n */\nmxRubberband.prototype.createShape = function()\n{\n\tif (this.sharedDiv == null)\n\t{\n\t\tthis.sharedDiv = document.createElement('div');\n\t\tthis.sharedDiv.className = 'mxRubberband';\n\t\tmxUtils.setOpacity(this.sharedDiv, this.defaultOpacity);\n\t}\n\n\tthis.graph.container.appendChild(this.sharedDiv);\n\tvar result = this.sharedDiv;\n\t\n\tif (mxClient.IS_SVG && (!mxClient.IS_IE || document.documentMode >= 10) && this.fadeOut)\n\t{\n\t\tthis.sharedDiv = null;\n\t}\n\t\t\n\treturn result;\n};\n\n/**\n * Function: isActive\n * \n * Returns true if this handler is active.\n */\nmxRubberband.prototype.isActive = function(sender, me)\n{\n\treturn this.div != null && this.div.style.display != 'none';\n};\n\n/**\n * Function: mouseUp\n * \n * Handles the event by selecting the region of the rubberband using\n * <mxGraph.selectRegion>.\n */\nmxRubberband.prototype.mouseUp = function(sender, me)\n{\n\tvar active = this.isActive();\n\tthis.reset();\n\t\n\tif (active)\n\t{\n\t\tthis.execute(me.getEvent());\n\t\tme.consume();\n\t}\n};\n\n/**\n * Function: execute\n * \n * Resets the state of this handler and selects the current region\n * for the given event.\n */\nmxRubberband.prototype.execute = function(evt)\n{\n\tvar rect = new mxRectangle(this.x, this.y, this.width, this.height);\n\tthis.graph.selectRegion(rect, evt);\n};\n\n/**\n * Function: reset\n * \n * Resets the state of the rubberband selection.\n */\nmxRubberband.prototype.reset = function()\n{\n\tif (this.div != null)\n\t{\n\t\tif (mxClient.IS_SVG && (!mxClient.IS_IE || document.documentMode >= 10) && this.fadeOut)\n\t\t{\n\t\t\tvar temp = this.div;\n\t\t\tmxUtils.setPrefixedStyle(temp.style, 'transition', 'all 0.2s linear');\n\t\t\ttemp.style.pointerEvents = 'none';\n\t\t\ttemp.style.opacity = 0;\n\t\t    \n\t\t    window.setTimeout(function()\n\t\t    \t{\n\t\t    \t\ttemp.parentNode.removeChild(temp);\n\t\t    \t}, 200);\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.div.parentNode.removeChild(this.div);\n\t\t}\n\t}\n\n\tmxEvent.removeGestureListeners(document, null, this.dragHandler, this.dropHandler);\n\tthis.dragHandler = null;\n\tthis.dropHandler = null;\n\t\n\tthis.currentX = 0;\n\tthis.currentY = 0;\n\tthis.first = null;\n\tthis.div = null;\n};\n\n/**\n * Function: update\n * \n * Sets <currentX> and <currentY> and calls <repaint>.\n */\nmxRubberband.prototype.update = function(x, y)\n{\n\tthis.currentX = x;\n\tthis.currentY = y;\n\t\n\tthis.repaint();\n};\n\n/**\n * Function: repaint\n * \n * Computes the bounding box and updates the style of the <div>.\n */\nmxRubberband.prototype.repaint = function()\n{\n\tif (this.div != null)\n\t{\n\t\tvar x = this.currentX - this.graph.panDx;\n\t\tvar y = this.currentY - this.graph.panDy;\n\t\t\n\t\tthis.x = Math.min(this.first.x, x);\n\t\tthis.y = Math.min(this.first.y, y);\n\t\tthis.width = Math.max(this.first.x, x) - this.x;\n\t\tthis.height =  Math.max(this.first.y, y) - this.y;\n\n\t\tvar dx = (mxClient.IS_VML) ? this.graph.panDx : 0;\n\t\tvar dy = (mxClient.IS_VML) ? this.graph.panDy : 0;\n\t\t\n\t\tthis.div.style.left = (this.x + dx) + 'px';\n\t\tthis.div.style.top = (this.y + dy) + 'px';\n\t\tthis.div.style.width = Math.max(1, this.width) + 'px';\n\t\tthis.div.style.height = Math.max(1, this.height) + 'px';\n\t}\n};\n\n/**\n * Function: destroy\n * \n * Destroys the handler and all its resources and DOM nodes. This does\n * normally not need to be called, it is called automatically when the\n * window unloads.\n */\nmxRubberband.prototype.destroy = function()\n{\n\tif (!this.destroyed)\n\t{\n\t\tthis.destroyed = true;\n\t\tthis.graph.removeMouseListener(this);\n\t\tthis.graph.removeListener(this.forceRubberbandHandler);\n\t\tthis.graph.removeListener(this.panHandler);\n\t\tthis.reset();\n\t\t\n\t\tif (this.sharedDiv != null)\n\t\t{\n\t\t\tthis.sharedDiv = null;\n\t\t}\n\t}\n};\n\n__mxOutput.mxRubberband = typeof mxRubberband !== 'undefined' ? mxRubberband : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxHandle\n * \n * Implements a single custom handle for vertices.\n * \n * Constructor: mxHandle\n * \n * Constructs a new handle for the given state.\n * \n * Parameters:\n * \n * state - <mxCellState> of the cell to be handled.\n */\nfunction mxHandle(state, cursor, image, shape)\n{\n\tthis.graph = state.view.graph;\n\tthis.state = state;\n\tthis.cursor = (cursor != null) ? cursor : this.cursor;\n\tthis.image = (image != null) ? image : this.image;\n\tthis.shape = (shape != null) ? shape : null;\n\tthis.init();\n};\n\n/**\n * Variable: cursor\n * \n * Specifies the cursor to be used for this handle. Default is 'default'.\n */\nmxHandle.prototype.cursor = 'default';\n\n/**\n * Variable: image\n * \n * Specifies the <mxImage> to be used to render the handle. Default is null.\n */\nmxHandle.prototype.image = null;\n\n/**\n * Variable: ignoreGrid\n * \n * Default is false.\n */\nmxHandle.prototype.ignoreGrid = false;\n\n/**\n * Function: getPosition\n * \n * Hook for subclassers to return the current position of the handle.\n */\nmxHandle.prototype.getPosition = function(bounds) { };\n\n/**\n * Function: setPosition\n * \n * Hooks for subclassers to update the style in the <state>.\n */\nmxHandle.prototype.setPosition = function(bounds, pt, me) { };\n\n/**\n * Function: execute\n * \n * Hook for subclassers to execute the handle.\n */\nmxHandle.prototype.execute = function(me) { };\n\n/**\n * Function: copyStyle\n * \n * Sets the cell style with the given name to the corresponding value in <state>.\n */\nmxHandle.prototype.copyStyle = function(key)\n{\n\tthis.graph.setCellStyles(key, this.state.style[key], [this.state.cell]);\n};\n\n/**\n * Function: processEvent\n * \n * Processes the given <mxMouseEvent> and invokes <setPosition>.\n */\nmxHandle.prototype.processEvent = function(me)\n{\n\tvar scale = this.graph.view.scale;\n\tvar tr = this.graph.view.translate;\n\tvar pt = new mxPoint(me.getGraphX() / scale - tr.x, me.getGraphY() / scale - tr.y);\n\t\n\t// Center shape on mouse cursor\n\tif (this.shape != null && this.shape.bounds != null)\n\t{\n\t\tpt.x -= this.shape.bounds.width / scale / 4;\n\t\tpt.y -= this.shape.bounds.height / scale / 4;\n\t}\n\n\t// Snaps to grid for the rotated position then applies the rotation for the direction after that\n\tvar alpha1 = -mxUtils.toRadians(this.getRotation());\n\tvar alpha2 = -mxUtils.toRadians(this.getTotalRotation()) - alpha1;\n\tpt = this.flipPoint(this.rotatePoint(this.snapPoint(this.rotatePoint(pt, alpha1),\n\t\t\tthis.ignoreGrid || !this.graph.isGridEnabledEvent(me.getEvent())), alpha2));\n\tthis.setPosition(this.state.getPaintBounds(), pt, me);\n\tthis.redraw();\n};\n\n/**\n * Function: positionChanged\n * \n * Should be called after <setPosition> in <processEvent>.\n * This repaints the state using <mxCellRenderer>.\n */\nmxHandle.prototype.positionChanged = function()\n{\n\tif (this.state.text != null)\n\t{\n\t\tthis.state.text.apply(this.state);\n\t}\n\t\n\tif (this.state.shape != null)\n\t{\n\t\tthis.state.shape.apply(this.state);\n\t}\n\t\n\tthis.graph.cellRenderer.redraw(this.state, true);\n};\n\n/**\n * Function: getRotation\n * \n * Returns the rotation defined in the style of the cell.\n */\nmxHandle.prototype.getRotation = function()\n{\n\tif (this.state.shape != null)\n\t{\n\t\treturn this.state.shape.getRotation();\n\t}\n\t\n\treturn 0;\n};\n\n/**\n * Function: getTotalRotation\n * \n * Returns the rotation from the style and the rotation from the direction of\n * the cell.\n */\nmxHandle.prototype.getTotalRotation = function()\n{\n\tif (this.state.shape != null)\n\t{\n\t\treturn this.state.shape.getShapeRotation();\n\t}\n\t\n\treturn 0;\n};\n\n/**\n * Function: init\n * \n * Creates and initializes the shapes required for this handle.\n */\nmxHandle.prototype.init = function()\n{\n\tvar html = this.isHtmlRequired();\n\t\n\tif (this.image != null)\n\t{\n\t\tthis.shape = new mxImageShape(new mxRectangle(0, 0, this.image.width, this.image.height), this.image.src);\n\t\tthis.shape.preserveImageAspect = false;\n\t}\n\telse if (this.shape == null)\n\t{\n\t\tthis.shape = this.createShape(html);\n\t}\n\t\n\tthis.initShape(html);\n};\n\n/**\n * Function: createShape\n * \n * Creates and returns the shape for this handle.\n */\nmxHandle.prototype.createShape = function(html)\n{\n\tvar bounds = new mxRectangle(0, 0, mxConstants.HANDLE_SIZE, mxConstants.HANDLE_SIZE);\n\t\n\treturn new mxRectangleShape(bounds, mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);\n};\n\n/**\n * Function: initShape\n * \n * Initializes <shape> and sets its cursor.\n */\nmxHandle.prototype.initShape = function(html)\n{\n\tif (html && this.shape.isHtmlAllowed())\n\t{\n\t\tthis.shape.dialect = mxConstants.DIALECT_STRICTHTML;\n\t\tthis.shape.init(this.graph.container);\n\t}\n\telse\n\t{\n\t\tthis.shape.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\t\tmxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;\n\t\t\n\t\tif (this.cursor != null)\n\t\t{\n\t\t\tthis.shape.init(this.graph.getView().getOverlayPane());\n\t\t}\n\t}\n\n\tmxEvent.redirectMouseEvents(this.shape.node, this.graph, this.state);\n\tthis.shape.node.style.cursor = this.cursor;\n};\n\n/**\n * Function: redraw\n * \n * Renders the shape for this handle.\n */\nmxHandle.prototype.redraw = function()\n{\n\tif (this.shape != null && this.state.shape != null)\n\t{\n\t\tvar pt = this.getPosition(this.state.getPaintBounds());\n\t\t\n\t\tif (pt != null)\n\t\t{\n\t\t\tvar alpha = mxUtils.toRadians(this.getTotalRotation());\n\t\t\tpt = this.rotatePoint(this.flipPoint(pt), alpha);\n\t\n\t\t\tvar scale = this.graph.view.scale;\n\t\t\tvar tr = this.graph.view.translate;\n\t\t\tthis.shape.bounds.x = Math.floor((pt.x + tr.x) * scale - this.shape.bounds.width / 2);\n\t\t\tthis.shape.bounds.y = Math.floor((pt.y + tr.y) * scale - this.shape.bounds.height / 2);\n\t\t\t\n\t\t\t// Needed to force update of text bounds\n\t\t\tthis.shape.redraw();\n\t\t}\n\t}\n};\n\n/**\n * Function: isHtmlRequired\n * \n * Returns true if this handle should be rendered in HTML. This returns true if\n * the text node is in the graph container.\n */\nmxHandle.prototype.isHtmlRequired = function()\n{\n\treturn this.state.text != null && this.state.text.node.parentNode == this.graph.container;\n};\n\n/**\n * Function: rotatePoint\n * \n * Rotates the point by the given angle.\n */\nmxHandle.prototype.rotatePoint = function(pt, alpha)\n{\n\tvar bounds = this.state.getCellBounds();\n\tvar cx = new mxPoint(bounds.getCenterX(), bounds.getCenterY());\n\tvar cos = Math.cos(alpha);\n\tvar sin = Math.sin(alpha); \n\n\treturn mxUtils.getRotatedPoint(pt, cos, sin, cx);\n};\n\n/**\n * Function: flipPoint\n * \n * Flips the given point vertically and/or horizontally.\n */\nmxHandle.prototype.flipPoint = function(pt)\n{\n\tif (this.state.shape != null)\n\t{\n\t\tvar bounds = this.state.getCellBounds();\n\t\t\n\t\tif (this.state.shape.flipH)\n\t\t{\n\t\t\tpt.x = 2 * bounds.x + bounds.width - pt.x;\n\t\t}\n\t\t\n\t\tif (this.state.shape.flipV)\n\t\t{\n\t\t\tpt.y = 2 * bounds.y + bounds.height - pt.y;\n\t\t}\n\t}\n\t\n\treturn pt;\n};\n\n/**\n * Function: snapPoint\n * \n * Snaps the given point to the grid if ignore is false. This modifies\n * the given point in-place and also returns it.\n */\nmxHandle.prototype.snapPoint = function(pt, ignore)\n{\n\tif (!ignore)\n\t{\n\t\tpt.x = this.graph.snap(pt.x);\n\t\tpt.y = this.graph.snap(pt.y);\n\t}\n\t\n\treturn pt;\n};\n\n/**\n * Function: setVisible\n * \n * Shows or hides this handle.\n */\nmxHandle.prototype.setVisible = function(visible)\n{\n\tif (this.shape != null && this.shape.node != null)\n\t{\n\t\tthis.shape.node.style.display = (visible) ? '' : 'none';\n\t}\n};\n\n/**\n * Function: reset\n * \n * Resets the state of this handle by setting its visibility to true.\n */\nmxHandle.prototype.reset = function()\n{\n\tthis.setVisible(true);\n\tthis.state.style = this.graph.getCellStyle(this.state.cell);\n\tthis.positionChanged();\n};\n\n/**\n * Function: destroy\n * \n * Destroys this handle.\n */\nmxHandle.prototype.destroy = function()\n{\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.destroy();\n\t\tthis.shape = null;\n\t}\n};\n\n__mxOutput.mxHandle = typeof mxHandle !== 'undefined' ? mxHandle : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxVertexHandler\n * \n * Event handler for resizing cells. This handler is automatically created in\n * <mxGraph.createHandler>.\n * \n * Constructor: mxVertexHandler\n * \n * Constructs an event handler that allows to resize vertices\n * and groups.\n * \n * Parameters:\n * \n * state - <mxCellState> of the cell to be resized.\n */\nfunction mxVertexHandler(state)\n{\n\tif (state != null)\n\t{\n\t\tthis.state = state;\n\t\tthis.init();\n\t\t\n\t\t// Handles escape keystrokes\n\t\tthis.escapeHandler = mxUtils.bind(this, function(sender, evt)\n\t\t{\n\t\t\tif (this.livePreview && this.index != null)\n\t\t\t{\n\t\t\t\t// Redraws the live preview\n\t\t\t\tthis.state.view.graph.cellRenderer.redraw(this.state, true);\n\t\t\t\t\n\t\t\t\t// Redraws connected edges\n\t\t\t\tthis.state.view.invalidate(this.state.cell);\n\t\t\t\tthis.state.invalid = false;\n\t\t\t\tthis.state.view.validate();\n\t\t\t}\n\t\t\t\n\t\t\tthis.reset();\n\t\t});\n\t\t\n\t\tthis.state.view.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);\n\t}\n};\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxVertexHandler.prototype.graph = null;\n\n/**\n * Variable: state\n * \n * Reference to the <mxCellState> being modified.\n */\nmxVertexHandler.prototype.state = null;\n\n/**\n * Variable: singleSizer\n * \n * Specifies if only one sizer handle at the bottom, right corner should be\n * used. Default is false.\n */\nmxVertexHandler.prototype.singleSizer = false;\n\n/**\n * Variable: index\n * \n * Holds the index of the current handle.\n */\nmxVertexHandler.prototype.index = null;\n\n/**\n * Variable: allowHandleBoundsCheck\n * \n * Specifies if the bounds of handles should be used for hit-detection in IE or\n * if <tolerance> > 0. Default is true.\n */\nmxVertexHandler.prototype.allowHandleBoundsCheck = true;\n\n/**\n * Variable: handleImage\n * \n * Optional <mxImage> to be used as handles. Default is null.\n */\nmxVertexHandler.prototype.handleImage = null;\n\n/**\n * Variable: handlesVisible\n * \n * If handles are currently visible.\n */\nmxVertexHandler.prototype.handlesVisible = true;\n\n/**\n * Variable: tolerance\n * \n * Optional tolerance for hit-detection in <getHandleForEvent>. Default is 0.\n */\nmxVertexHandler.prototype.tolerance = 0;\n\n/**\n * Variable: rotationEnabled\n * \n * Specifies if a rotation handle should be visible. Default is false.\n */\nmxVertexHandler.prototype.rotationEnabled = false;\n\n/**\n * Variable: parentHighlightEnabled\n * \n * Specifies if the parent should be highlighted if a child cell is selected.\n * Default is false.\n */\nmxVertexHandler.prototype.parentHighlightEnabled = false;\n\n/**\n * Variable: rotationRaster\n * \n * Specifies if rotation steps should be \"rasterized\" depening on the distance\n * to the handle. Default is true.\n */\nmxVertexHandler.prototype.rotationRaster = true;\n\n/**\n * Variable: rotationCursor\n * \n * Specifies the cursor for the rotation handle. Default is 'crosshair'.\n */\nmxVertexHandler.prototype.rotationCursor = 'crosshair';\n\n/**\n * Variable: livePreview\n * \n * Specifies if resize should change the cell in-place. This is an experimental\n * feature for non-touch devices. Default is false.\n */\nmxVertexHandler.prototype.livePreview = false;\n\n/**\n * Variable: movePreviewToFront\n * \n * Specifies if the live preview should be moved to the front.\n */\nmxVertexHandler.prototype.movePreviewToFront = false;\n\n/**\n * Variable: manageSizers\n * \n * Specifies if sizers should be hidden and spaced if the vertex is small.\n * Default is false.\n */\nmxVertexHandler.prototype.manageSizers = false;\n\n/**\n * Variable: constrainGroupByChildren\n * \n * Specifies if the size of groups should be constrained by the children.\n * Default is false.\n */\nmxVertexHandler.prototype.constrainGroupByChildren = false;\n\n/**\n * Variable: rotationHandleVSpacing\n * \n * Vertical spacing for rotation icon. Default is -16.\n */\nmxVertexHandler.prototype.rotationHandleVSpacing = -16;\n\n/**\n * Variable: horizontalOffset\n * \n * The horizontal offset for the handles. This is updated in <redrawHandles>\n * if <manageSizers> is true and the sizers are offset horizontally.\n */\nmxVertexHandler.prototype.horizontalOffset = 0;\n\n/**\n * Variable: verticalOffset\n * \n * The horizontal offset for the handles. This is updated in <redrawHandles>\n * if <manageSizers> is true and the sizers are offset vertically.\n */\nmxVertexHandler.prototype.verticalOffset = 0;\n\n/**\n * Function: init\n * \n * Initializes the shapes required for this vertex handler.\n */\nmxVertexHandler.prototype.init = function()\n{\n\tthis.graph = this.state.view.graph;\n\tthis.selectionBounds = this.getSelectionBounds(this.state);\n\tthis.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);\n\tthis.selectionBorder = this.createSelectionShape(this.bounds);\n\t// VML dialect required here for event transparency in IE\n\tthis.selectionBorder.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;\n\tthis.selectionBorder.pointerEvents = false;\n\tthis.selectionBorder.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || '0');\n\tthis.selectionBorder.init(this.graph.getView().getOverlayPane());\n\tmxEvent.redirectMouseEvents(this.selectionBorder.node, this.graph, this.state);\n\t\n\tif (this.graph.isCellMovable(this.state.cell))\n\t{\n\t\tthis.selectionBorder.setCursor(mxConstants.CURSOR_MOVABLE_VERTEX);\n\t}\n\n\t// Adds the sizer handles\n\tif (mxGraphHandler.prototype.maxCells <= 0 || this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells)\n\t{\n\t\tvar resizable = this.graph.isCellResizable(this.state.cell);\n\t\tthis.sizers = [];\n\n\t\tif (resizable || (this.graph.isLabelMovable(this.state.cell) &&\n\t\t\tthis.state.width >= 2 && this.state.height >= 2))\n\t\t{\n\t\t\tvar i = 0;\n\n\t\t\tif (resizable)\n\t\t\t{\n\t\t\t\tif (!this.singleSizer)\n\t\t\t\t{\n\t\t\t\t\tthis.sizers.push(this.createSizer('nw-resize', i++));\n\t\t\t\t\tthis.sizers.push(this.createSizer('n-resize', i++));\n\t\t\t\t\tthis.sizers.push(this.createSizer('ne-resize', i++));\n\t\t\t\t\tthis.sizers.push(this.createSizer('w-resize', i++));\n\t\t\t\t\tthis.sizers.push(this.createSizer('e-resize', i++));\n\t\t\t\t\tthis.sizers.push(this.createSizer('sw-resize', i++));\n\t\t\t\t\tthis.sizers.push(this.createSizer('s-resize', i++));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.sizers.push(this.createSizer('se-resize', i++));\n\t\t\t}\n\t\t\t\n\t\t\tvar geo = this.graph.model.getGeometry(this.state.cell);\n\t\t\t\n\t\t\tif (geo != null && !geo.relative && !this.graph.isSwimlane(this.state.cell) &&\n\t\t\t\tthis.graph.isLabelMovable(this.state.cell))\n\t\t\t{\n\t\t\t\t// Marks this as the label handle for getHandleForEvent\n\t\t\t\tthis.labelShape = this.createSizer(mxConstants.CURSOR_LABEL_HANDLE, mxEvent.LABEL_HANDLE,\n\t\t\t\t\tmxConstants.LABEL_HANDLE_SIZE, mxConstants.LABEL_HANDLE_FILLCOLOR);\n\t\t\t\tthis.sizers.push(this.labelShape);\n\t\t\t}\n\t\t}\n\t\telse if (this.graph.isCellMovable(this.state.cell) && !this.graph.isCellResizable(this.state.cell) &&\n\t\t\tthis.state.width < 2 && this.state.height < 2)\n\t\t{\n\t\t\tthis.labelShape = this.createSizer(mxConstants.CURSOR_MOVABLE_VERTEX,\n\t\t\t\tmxEvent.LABEL_HANDLE, null, mxConstants.LABEL_HANDLE_FILLCOLOR);\n\t\t\tthis.sizers.push(this.labelShape);\n\t\t}\n\t}\n\t\n\t// Adds the rotation handler\n\tif (this.isRotationHandleVisible())\n\t{\n\t\tthis.rotationShape = this.createSizer(this.rotationCursor, mxEvent.ROTATION_HANDLE,\n\t\t\tmxConstants.HANDLE_SIZE + 3, mxConstants.HANDLE_FILLCOLOR);\n\t\tthis.sizers.push(this.rotationShape);\n\t}\n\n\tthis.customHandles = this.createCustomHandles();\n\tthis.redraw();\n\t\n\tif (this.constrainGroupByChildren)\n\t{\n\t\tthis.updateMinBounds();\n\t}\n};\n\n/**\n * Function: isRotationHandleVisible\n * \n * Returns true if the rotation handle should be showing.\n */\nmxVertexHandler.prototype.isRotationHandleVisible = function()\n{\n\treturn this.graph.isEnabled() && this.rotationEnabled && this.graph.isCellRotatable(this.state.cell) &&\n\t\t(mxGraphHandler.prototype.maxCells <= 0 || this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells);\n};\n\n/**\n * Function: isConstrainedEvent\n * \n * Returns true if the aspect ratio if the cell should be maintained.\n */\nmxVertexHandler.prototype.isConstrainedEvent = function(me)\n{\n\treturn mxEvent.isShiftDown(me.getEvent()) || this.state.style[mxConstants.STYLE_ASPECT] == 'fixed';\n};\n\n/**\n * Function: isCenteredEvent\n * \n * Returns true if the center of the vertex should be maintained during the resize.\n */\nmxVertexHandler.prototype.isCenteredEvent = function(state, me)\n{\n\treturn false;\n};\n\n/**\n * Function: createCustomHandles\n * \n * Returns an array of custom handles. This implementation returns null.\n */\nmxVertexHandler.prototype.createCustomHandles = function()\n{\n\treturn null;\n};\n\n/**\n * Function: updateMinBounds\n * \n * Initializes the shapes required for this vertex handler.\n */\nmxVertexHandler.prototype.updateMinBounds = function()\n{\n\tvar children = this.graph.getChildCells(this.state.cell);\n\t\n\tif (children.length > 0)\n\t{\n\t\tthis.minBounds = this.graph.view.getBounds(children);\n\t\t\n\t\tif (this.minBounds != null)\n\t\t{\n\t\t\tvar s = this.state.view.scale;\n\t\t\tvar t = this.state.view.translate;\n\n\t\t\tthis.minBounds.x -= this.state.x;\n\t\t\tthis.minBounds.y -= this.state.y;\n\t\t\tthis.minBounds.x /= s;\n\t\t\tthis.minBounds.y /= s;\n\t\t\tthis.minBounds.width /= s;\n\t\t\tthis.minBounds.height /= s;\n\t\t\tthis.x0 = this.state.x / s - t.x;\n\t\t\tthis.y0 = this.state.y / s - t.y;\n\t\t}\n\t}\n};\n\n/**\n * Function: getSelectionBounds\n * \n * Returns the mxRectangle that defines the bounds of the selection\n * border.\n */\nmxVertexHandler.prototype.getSelectionBounds = function(state)\n{\n\treturn new mxRectangle(Math.round(state.x), Math.round(state.y), Math.round(state.width), Math.round(state.height));\n};\n\n/**\n * Function: createParentHighlightShape\n * \n * Creates the shape used to draw the selection border.\n */\nmxVertexHandler.prototype.createParentHighlightShape = function(bounds)\n{\n\treturn this.createSelectionShape(bounds);\n};\n\n/**\n * Function: createSelectionShape\n * \n * Creates the shape used to draw the selection border.\n */\nmxVertexHandler.prototype.createSelectionShape = function(bounds)\n{\n\tvar shape = new mxRectangleShape(\n\t\tmxRectangle.fromRectangle(bounds),\n\t\tnull, this.getSelectionColor());\n\tshape.strokewidth = this.getSelectionStrokeWidth();\n\tshape.isDashed = this.isSelectionDashed();\n\t\n\treturn shape;\n};\n\n/**\n * Function: getSelectionColor\n * \n * Returns <mxConstants.VERTEX_SELECTION_COLOR>.\n */\nmxVertexHandler.prototype.getSelectionColor = function()\n{\n\treturn mxConstants.VERTEX_SELECTION_COLOR;\n};\n\n/**\n * Function: getSelectionStrokeWidth\n * \n * Returns <mxConstants.VERTEX_SELECTION_STROKEWIDTH>.\n */\nmxVertexHandler.prototype.getSelectionStrokeWidth = function()\n{\n\treturn mxConstants.VERTEX_SELECTION_STROKEWIDTH;\n};\n\n/**\n * Function: isSelectionDashed\n * \n * Returns <mxConstants.VERTEX_SELECTION_DASHED>.\n */\nmxVertexHandler.prototype.isSelectionDashed = function()\n{\n\treturn mxConstants.VERTEX_SELECTION_DASHED;\n};\n\n/**\n * Function: createSizer\n * \n * Creates a sizer handle for the specified cursor and index and returns\n * the new <mxRectangleShape> that represents the handle.\n */\nmxVertexHandler.prototype.createSizer = function(cursor, index, size, fillColor)\n{\n\tsize = size || mxConstants.HANDLE_SIZE;\n\t\n\tvar bounds = new mxRectangle(0, 0, size, size);\n\tvar sizer = this.createSizerShape(bounds, index, fillColor);\n\n\tif (sizer.isHtmlAllowed() && this.state.text != null && this.state.text.node.parentNode == this.graph.container)\n\t{\n\t\tsizer.bounds.height -= 1;\n\t\tsizer.bounds.width -= 1;\n\t\tsizer.dialect = mxConstants.DIALECT_STRICTHTML;\n\t\tsizer.init(this.graph.container);\n\t}\n\telse\n\t{\n\t\tsizer.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\t\t\tmxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;\n\t\tsizer.init(this.graph.getView().getOverlayPane());\n\t}\n\n\tmxEvent.redirectMouseEvents(sizer.node, this.graph, this.state);\n\t\n\tif (this.graph.isEnabled())\n\t{\n\t\tsizer.setCursor(cursor);\n\t}\n\t\n\tif (!this.isSizerVisible(index))\n\t{\n\t\tsizer.visible = false;\n\t}\n\t\n\treturn sizer;\n};\n\n/**\n * Function: isSizerVisible\n * \n * Returns true if the sizer for the given index is visible.\n * This returns true for all given indices.\n */\nmxVertexHandler.prototype.isSizerVisible = function(index)\n{\n\treturn true;\n};\n\n/**\n * Function: createSizerShape\n * \n * Creates the shape used for the sizer handle for the specified bounds an\n * index. Only images and rectangles should be returned if support for HTML\n * labels with not foreign objects is required.\n */\nmxVertexHandler.prototype.createSizerShape = function(bounds, index, fillColor)\n{\n\tif (this.handleImage != null)\n\t{\n\t\tbounds = new mxRectangle(bounds.x, bounds.y, this.handleImage.width, this.handleImage.height);\n\t\tvar shape = new mxImageShape(bounds, this.handleImage.src);\n\t\t\n\t\t// Allows HTML rendering of the images\n\t\tshape.preserveImageAspect = false;\n\n\t\treturn shape;\n\t}\n\telse if (index == mxEvent.ROTATION_HANDLE)\n\t{\n\t\treturn new mxEllipse(bounds, fillColor || mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);\n\t}\n\telse\n\t{\n\t\treturn new mxRectangleShape(bounds, fillColor || mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);\n\t}\n};\n\n/**\n * Function: createBounds\n * \n * Helper method to create an <mxRectangle> around the given centerpoint\n * with a width and height of 2*s or 6, if no s is given.\n */\nmxVertexHandler.prototype.moveSizerTo = function(shape, x, y)\n{\n\tif (shape != null)\n\t{\n\t\tshape.bounds.x = Math.floor(x - shape.bounds.width / 2);\n\t\tshape.bounds.y = Math.floor(y - shape.bounds.height / 2);\n\t\t\n\t\t// Fixes visible inactive handles in VML\n\t\tif (shape.node != null && shape.node.style.display != 'none')\n\t\t{\n\t\t\tshape.redraw();\n\t\t}\n\t}\n};\n\n/**\n * Function: getHandleForEvent\n * \n * Returns the index of the handle for the given event. This returns the index\n * of the sizer from where the event originated or <mxEvent.LABEL_INDEX>.\n */\nmxVertexHandler.prototype.getHandleForEvent = function(me)\n{\n\t// Connection highlight may consume events before they reach sizer handle\n\tvar tol = (!mxEvent.isMouseEvent(me.getEvent())) ? this.tolerance : 1;\n\tvar hit = (this.allowHandleBoundsCheck && (mxClient.IS_IE || tol > 0)) ?\n\t\tnew mxRectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;\n\n\tvar checkShape = mxUtils.bind(this, function(shape)\n\t{\n\t\tvar st = (shape != null && shape.constructor != mxImageShape &&\n\t\t\tthis.allowHandleBoundsCheck) ? shape.strokewidth + shape.svgStrokeTolerance : null;\n\t\tvar real = (st != null) ? new mxRectangle(me.getGraphX() - Math.floor(st / 2),\n\t\t\tme.getGraphY() - Math.floor(st / 2), st, st) : hit;\n\n\t\treturn shape != null && (me.isSource(shape) || (real != null && mxUtils.intersects(shape.bounds, real) &&\n\t\t\tshape.node.style.display != 'none' && shape.node.style.visibility != 'hidden'));\n\t});\n\t\n\tif (checkShape(this.rotationShape))\n\t{\n\t\treturn mxEvent.ROTATION_HANDLE;\n\t}\n\telse if (checkShape(this.labelShape))\n\t{\n\t\treturn mxEvent.LABEL_HANDLE;\n\t}\n\n\tif (this.sizers != null)\n\t{\n\t\tfor (var i = 0; i < this.sizers.length; i++)\n\t\t{\n\t\t\tif (checkShape(this.sizers[i]))\n\t\t\t{\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (this.customHandles != null && this.isCustomHandleEvent(me))\n\t{\n\t\t// Inverse loop order to match display order\n\t\tfor (var i = this.customHandles.length - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (checkShape(this.customHandles[i].shape))\n\t\t\t{\n\t\t\t\t// LATER: Return reference to active shape\n\t\t\t\treturn mxEvent.CUSTOM_HANDLE - i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: isCustomHandleEvent\n * \n * Returns true if the given event allows custom handles to be changed. This\n * implementation returns true.\n */\nmxVertexHandler.prototype.isCustomHandleEvent = function(me)\n{\n\treturn true;\n};\n\n/**\n * Function: mouseDown\n * \n * Handles the event if a handle has been clicked. By consuming the\n * event all subsequent events of the gesture are redirected to this\n * handler.\n */\nmxVertexHandler.prototype.mouseDown = function(sender, me)\n{\n\tif (!me.isConsumed() && this.graph.isEnabled())\n\t{\n\t\tvar handle = this.getHandleForEvent(me);\n\n\t\tif (handle != null)\n\t\t{\n\t\t\tthis.start(me.getGraphX(), me.getGraphY(), handle);\n\t\t\tme.consume();\n\t\t}\n\t}\n};\n\n/**\n * Function: isLivePreviewBorder\n * \n * Called if <livePreview> is enabled to check if a border should be painted.\n * This implementation returns true if the shape is transparent.\n */\nmxVertexHandler.prototype.isLivePreviewBorder = function()\n{\n\treturn this.state.shape != null && this.state.shape.fill == null && this.state.shape.stroke == null;\n};\n\n/**\n * Function: start\n * \n * Starts the handling of the mouse gesture.\n */\nmxVertexHandler.prototype.start = function(x, y, index)\n{\n\tif (this.selectionBorder != null)\n\t{\n\t\tthis.livePreviewActive = this.livePreview && this.graph.model.getChildCount(this.state.cell) == 0;\n\t\tthis.inTolerance = true;\n\t\tthis.childOffsetX = 0;\n\t\tthis.childOffsetY = 0;\n\t\tthis.index = index;\n\t\tthis.startX = x;\n\t\tthis.startY = y;\n\t\t\n\t\tif (this.index <= mxEvent.CUSTOM_HANDLE && this.isGhostPreview())\n\t\t{\n\t\t\tthis.ghostPreview = this.createGhostPreview();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Saves reference to parent state\n\t\t\tvar model = this.state.view.graph.model;\n\t\t\tvar parent = model.getParent(this.state.cell);\n\t\t\t\n\t\t\tif (this.state.view.currentRoot != parent && (model.isVertex(parent) || model.isEdge(parent)))\n\t\t\t{\n\t\t\t\tthis.parentState = this.state.view.graph.view.getState(parent);\n\t\t\t}\n\t\t\t\n\t\t\t// Creates a preview that can be on top of any HTML label\n\t\t\tthis.selectionBorder.node.style.display = (index == mxEvent.ROTATION_HANDLE) ? 'inline' : 'none';\n\t\t\t\n\t\t\t// Creates the border that represents the new bounds\n\t\t\tif (!this.livePreviewActive || this.isLivePreviewBorder())\n\t\t\t{\n\t\t\t\tthis.preview = this.createSelectionShape(this.bounds);\n\t\t\t\t\n\t\t\t\tif (!(mxClient.IS_SVG && Number(this.state.style[mxConstants.STYLE_ROTATION] || '0') != 0) &&\n\t\t\t\t\tthis.state.text != null && this.state.text.node.parentNode == this.graph.container)\n\t\t\t\t{\n\t\t\t\t\tthis.preview.dialect = mxConstants.DIALECT_STRICTHTML;\n\t\t\t\t\tthis.preview.init(this.graph.container);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.preview.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\t\t\t\t\t\tmxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;\n\t\t\t\t\tthis.preview.init(this.graph.view.getOverlayPane());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (index == mxEvent.ROTATION_HANDLE)\n\t\t\t{\n\t\t\t\t// With the rotation handle in a corner, need the angle and distance\n\t\t\t\tvar pos = this.getRotationHandlePosition();\n\t\t\t\t\n\t\t\t\tvar dx = pos.x - this.state.getCenterX();\n\t\t\t\tvar dy = pos.y - this.state.getCenterY();\n\t\t\t\t\n\t\t\t\tthis.startAngle = (dx != 0) ? Math.atan(dy / dx) * 180 / Math.PI + 90 : 0;\n\t\t\t\tthis.startDist = Math.sqrt(dx * dx + dy * dy);\n\t\t\t}\n\t\n\t\t\t// Prepares the handles for live preview\n\t\t\tif (this.livePreviewActive)\n\t\t\t{\n\t\t\t\tthis.hideSizers();\n\t\t\t\t\n\t\t\t\tif (index == mxEvent.ROTATION_HANDLE)\n\t\t\t\t{\n\t\t\t\t\tthis.rotationShape.node.style.display = '';\n\t\t\t\t}\n\t\t\t\telse if (index == mxEvent.LABEL_HANDLE)\n\t\t\t\t{\n\t\t\t\t\tthis.labelShape.node.style.display = '';\n\t\t\t\t}\n\t\t\t\telse if (this.sizers != null && this.sizers[index] != null)\n\t\t\t\t{\n\t\t\t\t\tthis.sizers[index].node.style.display = '';\n\t\t\t\t}\n\t\t\t\telse if (index <= mxEvent.CUSTOM_HANDLE && this.customHandles != null)\n\t\t\t\t{\n\t\t\t\t\tthis.customHandles[mxEvent.CUSTOM_HANDLE - index].setVisible(true);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Gets the array of connected edge handlers for redrawing\n\t\t\t\tvar edges = this.graph.getEdges(this.state.cell);\n\t\t\t\tthis.edgeHandlers = [];\n\t\t\t\t\n\t\t\t\tfor (var i = 0; i < edges.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar handler = this.graph.selectionCellsHandler.getHandler(edges[i]);\n\t\t\t\t\t\n\t\t\t\t\tif (handler != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.edgeHandlers.push(handler);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: createGhostPreview\n * \n * Starts the handling of the mouse gesture.\n */\nmxVertexHandler.prototype.createGhostPreview = function()\n{\n\tvar shape = this.graph.cellRenderer.createShape(this.state);\n\tshape.init(this.graph.view.getOverlayPane());\n\tshape.scale = this.state.view.scale;\n\tshape.bounds = this.bounds;\n\tshape.outline = true;\n\t\n\treturn shape;\n};\n\n/**\n * Function: hideHandles\n * \n * Shortcut to <hideSizers>.\n */\nmxVertexHandler.prototype.setHandlesVisible = function(visible)\n{\n\tthis.handlesVisible = visible;\n\t\n\tif (this.sizers != null)\n\t{\n\t\tfor (var i = 0; i < this.sizers.length; i++)\n\t\t{\n\t\t\tthis.sizers[i].node.style.display = (visible) ? '' : 'none';\n\t\t}\n\t}\n\n\tif (this.customHandles != null)\n\t{\n\t\tfor (var i = 0; i < this.customHandles.length; i++)\n\t\t{\n\t\t\tthis.customHandles[i].setVisible(visible);\n\t\t}\n\t}\n};\n\n/**\n * Function: hideSizers\n * \n * Hides all sizers except.\n * \n * Starts the handling of the mouse gesture.\n */\nmxVertexHandler.prototype.hideSizers = function()\n{\n\tthis.setHandlesVisible(false);\n};\n\n/**\n * Function: checkTolerance\n * \n * Checks if the coordinates for the given event are within the\n * <mxGraph.tolerance>. If the event is a mouse event then the tolerance is\n * ignored.\n */\nmxVertexHandler.prototype.checkTolerance = function(me)\n{\n\tif (this.inTolerance && this.startX != null && this.startY != null)\n\t{\n\t\tif (mxEvent.isMouseEvent(me.getEvent()) ||\n\t\t\tMath.abs(me.getGraphX() - this.startX) > this.graph.tolerance ||\n\t\t\tMath.abs(me.getGraphY() - this.startY) > this.graph.tolerance)\n\t\t{\n\t\t\tthis.inTolerance = false;\n\t\t}\n\t}\n};\n\n/**\n * Function: updateHint\n * \n * Hook for subclassers do show details while the handler is active.\n */\nmxVertexHandler.prototype.updateHint = function(me) { };\n\n/**\n * Function: removeHint\n * \n * Hooks for subclassers to hide details when the handler gets inactive.\n */\nmxVertexHandler.prototype.removeHint = function() { };\n\n/**\n * Function: roundAngle\n * \n * Hook for rounding the angle. This uses Math.round.\n */\nmxVertexHandler.prototype.roundAngle = function(angle)\n{\n\treturn Math.round(angle * 10) / 10;\n};\n\n/**\n * Function: roundLength\n * \n * Hook for rounding the unscaled width or height. This uses Math.round.\n */\nmxVertexHandler.prototype.roundLength = function(length)\n{\n\treturn Math.round(length * 100) / 100;\n};\n\n/**\n * Function: mouseMove\n * \n * Handles the event by updating the preview.\n */\nmxVertexHandler.prototype.mouseMove = function(sender, me)\n{\n\tif (!me.isConsumed() && this.index != null)\n\t{\n\t\t// Checks tolerance for ignoring single clicks\n\t\tthis.checkTolerance(me);\n\n\t\tif (!this.inTolerance)\n\t\t{\n\t\t\tif (this.index <= mxEvent.CUSTOM_HANDLE)\n\t\t\t{\n\t\t\t\tif (this.customHandles != null)\n\t\t\t\t{\n\t\t\t\t\tthis.customHandles[mxEvent.CUSTOM_HANDLE - this.index].processEvent(me);\n\t\t\t\t\tthis.customHandles[mxEvent.CUSTOM_HANDLE - this.index].active = true;\n\t\t\t\t\t\n\t\t\t\t\tif (this.ghostPreview != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.ghostPreview.apply(this.state);\n\t\t\t\t\t\tthis.ghostPreview.strokewidth = this.getSelectionStrokeWidth() /\n\t\t\t\t\t\t\tthis.ghostPreview.scale / this.ghostPreview.scale;\n\t\t\t\t\t\tthis.ghostPreview.isDashed = this.isSelectionDashed();\n\t\t\t\t\t\tthis.ghostPreview.stroke = this.getSelectionColor();\n\t\t\t\t\t\tthis.ghostPreview.redraw();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (this.selectionBounds != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.selectionBorder.node.style.display = 'none';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.movePreviewToFront)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.moveToFront();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.customHandles[mxEvent.CUSTOM_HANDLE - this.index].positionChanged();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (this.index == mxEvent.LABEL_HANDLE)\n\t\t\t{\n\t\t\t\tthis.moveLabel(me);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (this.index == mxEvent.ROTATION_HANDLE)\n\t\t\t\t{\n\t\t\t\t\tthis.rotateVertex(me);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.resizeVertex(me);\n\t\t\t\t}\n\n\t\t\t\tthis.updateHint(me);\n\t\t\t}\n\t\t}\n\t\t\n\t\tme.consume();\n\t}\n\t// Workaround for disabling the connect highlight when over handle\n\telse if (!this.graph.isMouseDown && this.getHandleForEvent(me) != null)\n\t{\n\t\tme.consume(false);\n\t}\n};\n\n/**\n * Function: isGhostPreview\n * \n * Returns true if a ghost preview should be used for custom handles.\n */\nmxVertexHandler.prototype.isGhostPreview = function()\n{\n\treturn this.state.view.graph.model.getChildCount(this.state.cell) > 0;\n};\n\n/**\n * Function: moveLabel\n * \n * Moves the label.\n */\nmxVertexHandler.prototype.moveLabel = function(me)\n{\n\tvar point = new mxPoint(me.getGraphX(), me.getGraphY());\n\tvar tr = this.graph.view.translate;\n\tvar scale = this.graph.view.scale;\n\t\n\tif (this.graph.isGridEnabledEvent(me.getEvent()))\n\t{\n\t\tpoint.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;\n\t\tpoint.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;\n\t}\n\n\tvar index = (this.rotationShape != null) ? this.sizers.length - 2 : this.sizers.length - 1;\n\tthis.moveSizerTo(this.sizers[index], point.x, point.y);\n};\n\n/**\n * Function: rotateVertex\n * \n * Rotates the vertex.\n */\nmxVertexHandler.prototype.rotateVertex = function(me)\n{\n\tvar point = new mxPoint(me.getGraphX(), me.getGraphY());\n\tvar dx = this.state.x + this.state.width / 2 - point.x;\n\tvar dy = this.state.y + this.state.height / 2 - point.y;\n\tthis.currentAlpha = (dx != 0) ? Math.atan(dy / dx) * 180 / Math.PI + 90 : ((dy < 0) ? 180 : 0);\n\t\n\tif (dx > 0)\n\t{\n\t\tthis.currentAlpha -= 180;\n\t}\n\t\n\tthis.currentAlpha -= this.startAngle;\n\t\n\t// Rotation raster\n\tif (this.rotationRaster && this.graph.isGridEnabledEvent(me.getEvent()))\n\t{\n\t\tvar dx = point.x - this.state.getCenterX();\n\t\tvar dy = point.y - this.state.getCenterY();\n\t\tvar dist = Math.sqrt(dx * dx + dy * dy);\n\t\t\n\t\tif (dist - this.startDist < 2)\n\t\t{\n\t\t\traster = 15;\n\t\t}\n\t\telse if (dist - this.startDist < 25)\n\t\t{\n\t\t\traster = 5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\traster = 1;\n\t\t}\n\t\t\n\t\tthis.currentAlpha = Math.round(this.currentAlpha / raster) * raster;\n\t}\n\telse\n\t{\n\t\tthis.currentAlpha = this.roundAngle(this.currentAlpha);\n\t}\n\n\tthis.selectionBorder.rotation = this.currentAlpha;\n\tthis.selectionBorder.redraw();\n\t\t\t\t\t\n\tif (this.livePreviewActive)\n\t{\n\t\tthis.redrawHandles();\n\t}\n};\n\n/**\n * Function: resizeVertex\n * \n * Risizes the vertex.\n */\nmxVertexHandler.prototype.resizeVertex = function(me)\n{\n\tvar ct = new mxPoint(this.state.getCenterX(), this.state.getCenterY());\n\tvar alpha = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || '0');\n\tvar point = new mxPoint(me.getGraphX(), me.getGraphY());\n\tvar tr = this.graph.view.translate;\n\tvar scale = this.graph.view.scale;\n\tvar cos = Math.cos(-alpha);\n\tvar sin = Math.sin(-alpha);\n\t\n\tvar dx = point.x - this.startX;\n\tvar dy = point.y - this.startY;\n\n\t// Rotates vector for mouse gesture\n\tvar tx = cos * dx - sin * dy;\n\tvar ty = sin * dx + cos * dy;\n\t\n\tdx = tx;\n\tdy = ty;\n\n\tvar geo = this.graph.getCellGeometry(this.state.cell);\n\tthis.unscaledBounds = this.union(geo, dx / scale, dy / scale, this.index,\n\t\tthis.graph.isGridEnabledEvent(me.getEvent()), 1,\n\t\tnew mxPoint(0, 0), this.isConstrainedEvent(me),\n\t\tthis.isCenteredEvent(this.state, me));\n\t\n\t// Keeps vertex within maximum graph or parent bounds\n\tif (!geo.relative)\n\t{\n\t\tvar max = this.graph.getMaximumGraphBounds();\n\t\t\n\t\t// Handles child cells\n\t\tif (max != null && this.parentState != null)\n\t\t{\n\t\t\tmax = mxRectangle.fromRectangle(max);\n\t\t\t\n\t\t\tmax.x -= (this.parentState.x - tr.x * scale) / scale;\n\t\t\tmax.y -= (this.parentState.y - tr.y * scale) / scale;\n\t\t}\n\t\t\n\t\tif (this.graph.isConstrainChild(this.state.cell))\n\t\t{\n\t\t\tvar tmp = this.graph.getCellContainmentArea(this.state.cell);\n\t\t\t\n\t\t\tif (tmp != null)\n\t\t\t{\n\t\t\t\tvar overlap = this.graph.getOverlap(this.state.cell);\n\t\t\t\t\n\t\t\t\tif (overlap > 0)\n\t\t\t\t{\n\t\t\t\t\ttmp = mxRectangle.fromRectangle(tmp);\n\t\t\t\t\t\n\t\t\t\t\ttmp.x -= tmp.width * overlap;\n\t\t\t\t\ttmp.y -= tmp.height * overlap;\n\t\t\t\t\ttmp.width += 2 * tmp.width * overlap;\n\t\t\t\t\ttmp.height += 2 * tmp.height * overlap;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (max == null)\n\t\t\t\t{\n\t\t\t\t\tmax = tmp;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmax = mxRectangle.fromRectangle(max);\n\t\t\t\t\tmax.intersect(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tif (max != null)\n\t\t{\n\t\t\tif (this.unscaledBounds.x < max.x)\n\t\t\t{\n\t\t\t\tthis.unscaledBounds.width -= max.x - this.unscaledBounds.x;\n\t\t\t\tthis.unscaledBounds.x = max.x;\n\t\t\t}\n\t\t\t\n\t\t\tif (this.unscaledBounds.y < max.y)\n\t\t\t{\n\t\t\t\tthis.unscaledBounds.height -= max.y - this.unscaledBounds.y;\n\t\t\t\tthis.unscaledBounds.y = max.y;\n\t\t\t}\n\t\t\t\n\t\t\tif (this.unscaledBounds.x + this.unscaledBounds.width > max.x + max.width)\n\t\t\t{\n\t\t\t\tthis.unscaledBounds.width -= this.unscaledBounds.x +\n\t\t\t\t\tthis.unscaledBounds.width - max.x - max.width;\n\t\t\t}\n\t\t\t\n\t\t\tif (this.unscaledBounds.y + this.unscaledBounds.height > max.y + max.height)\n\t\t\t{\n\t\t\t\tthis.unscaledBounds.height -= this.unscaledBounds.y +\n\t\t\t\t\tthis.unscaledBounds.height - max.y - max.height;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvar old = this.bounds;\n\tthis.bounds = new mxRectangle(((this.parentState != null) ? this.parentState.x : tr.x * scale) +\n\t\t(this.unscaledBounds.x) * scale, ((this.parentState != null) ? this.parentState.y : tr.y * scale) +\n\t\t(this.unscaledBounds.y) * scale, this.unscaledBounds.width * scale, this.unscaledBounds.height * scale);\n\n\tif (geo.relative && this.parentState != null)\n\t{\n\t\tthis.bounds.x += this.state.x - this.parentState.x;\n\t\tthis.bounds.y += this.state.y - this.parentState.y;\n\t}\n\n\tcos = Math.cos(alpha);\n\tsin = Math.sin(alpha);\n\t\n\tvar c2 = new mxPoint(this.bounds.getCenterX(), this.bounds.getCenterY());\n\n\tvar dx = c2.x - ct.x;\n\tvar dy = c2.y - ct.y;\n\t\n\tvar dx2 = cos * dx - sin * dy;\n\tvar dy2 = sin * dx + cos * dy;\n\t\n\tvar dx3 = dx2 - dx;\n\tvar dy3 = dy2 - dy;\n\t\n\tvar dx4 = this.bounds.x - this.state.x;\n\tvar dy4 = this.bounds.y - this.state.y;\n\t\n\tvar dx5 = cos * dx4 - sin * dy4;\n\tvar dy5 = sin * dx4 + cos * dy4;\n\t\n\tthis.bounds.x += dx3;\n\tthis.bounds.y += dy3;\n\t\n\t// Rounds unscaled bounds to int\n\tthis.unscaledBounds.x = this.roundLength(this.unscaledBounds.x + dx3 / scale);\n\tthis.unscaledBounds.y = this.roundLength(this.unscaledBounds.y + dy3 / scale);\n\tthis.unscaledBounds.width = this.roundLength(this.unscaledBounds.width);\n\tthis.unscaledBounds.height = this.roundLength(this.unscaledBounds.height);\n\t\n\t// Shifts the children according to parent offset\n\tif (!this.graph.isCellCollapsed(this.state.cell) && (dx3 != 0 || dy3 != 0))\n\t{\n\t\tthis.childOffsetX = this.state.x - this.bounds.x + dx5;\n\t\tthis.childOffsetY = this.state.y - this.bounds.y + dy5;\n\t}\n\telse\n\t{\n\t\tthis.childOffsetX = 0;\n\t\tthis.childOffsetY = 0;\n\t}\n\t\t\t\n\tif (!old.equals(this.bounds))\n\t{\t\n\t\tif (this.livePreviewActive)\n\t\t{\n\t\t\tthis.updateLivePreview(me);\n\t\t}\n\t\t\n\t\tif (this.preview != null)\n\t\t{\n\t\t\tthis.drawPreview();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.updateParentHighlight();\n\t\t}\n\t}\n};\n\n/**\n * Function: updateLivePreview\n * \n * Repaints the live preview.\n */\nmxVertexHandler.prototype.updateLivePreview = function(me)\n{\n\t// TODO: Apply child offset to children in live preview\n\tvar scale = this.graph.view.scale;\n\tvar tr = this.graph.view.translate;\n\t\n\t// Saves current state\n\tvar tempState = this.state.clone();\n\n\t// Temporarily changes size and origin\n\tthis.state.x = this.bounds.x;\n\tthis.state.y = this.bounds.y;\n\tthis.state.origin = new mxPoint(this.state.x / scale - tr.x, this.state.y / scale - tr.y);\n\tthis.state.width = this.bounds.width;\n\tthis.state.height = this.bounds.height;\n\t\n\t// Redraws cell and handles\n\tvar off = this.state.absoluteOffset;\n\toff = new mxPoint(off.x, off.y);\n\n\t// Required to store and reset absolute offset for updating label position\n\tthis.state.absoluteOffset.x = 0;\n\tthis.state.absoluteOffset.y = 0;\n\tvar geo = this.graph.getCellGeometry(this.state.cell);\t\t\t\t\n\n\tif (geo != null)\n\t{\n\t\tvar offset = geo.offset || this.EMPTY_POINT;\n\n\t\tif (offset != null && !geo.relative)\n\t\t{\n\t\t\tthis.state.absoluteOffset.x = this.state.view.scale * offset.x;\n\t\t\tthis.state.absoluteOffset.y = this.state.view.scale * offset.y;\n\t\t}\n\t\t\n\t\tthis.state.view.updateVertexLabelOffset(this.state);\n\t}\n\t\n\t// Draws the live preview\n\tthis.state.view.graph.cellRenderer.redraw(this.state, true);\n\t\n\t// Redraws connected edges TODO: Include child edges\n\tthis.state.view.invalidate(this.state.cell);\n\tthis.state.invalid = false;\n\tthis.state.view.validate();\n\tthis.redrawHandles();\n\t\n\t// Moves live preview to front\n\tif (this.movePreviewToFront)\n\t{\n\t\tthis.moveToFront();\n\t}\n\t\n\t// Hides folding icon\n\tif (this.state.control != null && this.state.control.node != null)\n\t{\n\t\tthis.state.control.node.style.visibility = 'hidden';\n\t}\n\t\n\t// Restores current state\n\tthis.state.setState(tempState);\n};\n\n/**\n * Function: moveToFront\n * \n * Handles the event by applying the changes to the geometry.\n */\nmxVertexHandler.prototype.moveToFront = function()\n{\n\tif ((this.state.text != null && this.state.text.node != null &&\n\t\tthis.state.text.node.nextSibling != null) ||\n\t\t(this.state.shape != null && this.state.shape.node != null &&\n\t\tthis.state.shape.node.nextSibling != null && (this.state.text == null ||\n\t\tthis.state.shape.node.nextSibling != this.state.text.node)))\n\t{\n\t\tif (this.state.shape != null && this.state.shape.node != null)\n\t\t{\n\t\t\tthis.state.shape.node.parentNode.appendChild(this.state.shape.node);\n\t\t}\n\t\t\n\t\tif (this.state.text != null && this.state.text.node != null)\n\t\t{\n\t\t\tthis.state.text.node.parentNode.appendChild(this.state.text.node);\n\t\t}\n\t}\n};\n\n/**\n * Function: mouseUp\n * \n * Handles the event by applying the changes to the geometry.\n */\nmxVertexHandler.prototype.mouseUp = function(sender, me)\n{\n\tif (this.index != null && this.state != null)\n\t{\n\t\tvar point = new mxPoint(me.getGraphX(), me.getGraphY());\n\t\tvar index = this.index;\n\t\tthis.index = null;\n\t\n\t\tif (this.ghostPreview == null)\n\t\t{\n\t\t\t// Required to restore order in case of no change\n\t\t\tthis.state.view.invalidate(this.state.cell, false, false);\n\t\t\tthis.state.view.validate();\n\t\t}\n\t\t\n\t\tthis.graph.getModel().beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tif (index <= mxEvent.CUSTOM_HANDLE)\n\t\t\t{\n\t\t\t\tif (this.customHandles != null)\n\t\t\t\t{\n\t\t\t\t\t// Creates style before changing cell state\n\t\t\t\t\tvar style = this.state.view.graph.getCellStyle(this.state.cell);\n\t\t\t\t\t\n\t\t\t\t\tthis.customHandles[mxEvent.CUSTOM_HANDLE - index].active = false;\n\t\t\t\t\tthis.customHandles[mxEvent.CUSTOM_HANDLE - index].execute(me);\n\t\t\t\t\t\n\t\t\t\t\t// Sets style and apply on shape to force repaint and\n\t\t\t\t\t// check if execute has removed custom handles\n\t\t\t\t\tif (this.customHandles != null &&\n\t\t\t\t\t\tthis.customHandles[mxEvent.CUSTOM_HANDLE - index] != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.state.style = style;\n\t\t\t\t\t\tthis.customHandles[mxEvent.CUSTOM_HANDLE - index].positionChanged();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (index == mxEvent.ROTATION_HANDLE)\n\t\t\t{\n\t\t\t\tif (this.currentAlpha != null)\n\t\t\t\t{\n\t\t\t\t\tvar delta = this.currentAlpha - (this.state.style[mxConstants.STYLE_ROTATION] || 0);\n\t\t\t\t\t\n\t\t\t\t\tif (delta != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.rotateCell(this.state.cell, delta);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.rotateClick();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar gridEnabled = this.graph.isGridEnabledEvent(me.getEvent());\n\t\t\t\tvar alpha = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || '0');\n\t\t\t\tvar cos = Math.cos(-alpha);\n\t\t\t\tvar sin = Math.sin(-alpha);\n\t\t\t\t\n\t\t\t\tvar dx = point.x - this.startX;\n\t\t\t\tvar dy = point.y - this.startY;\n\t\t\t\t\n\t\t\t\t// Rotates vector for mouse gesture\n\t\t\t\tvar tx = cos * dx - sin * dy;\n\t\t\t\tvar ty = sin * dx + cos * dy;\n\t\t\t\t\n\t\t\t\tdx = tx;\n\t\t\t\tdy = ty;\n\t\t\t\t\n\t\t\t\tvar s = this.graph.view.scale;\n\t\t\t\tvar recurse = this.isRecursiveResize(this.state, me);\n\t\t\t\tthis.resizeCell(this.state.cell, this.roundLength(dx / s), this.roundLength(dy / s),\n\t\t\t\t\tindex, gridEnabled, this.isConstrainedEvent(me), recurse);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.graph.getModel().endUpdate();\n\t\t}\n\n\t\tme.consume();\n\t\tthis.reset();\n\t\tthis.redrawHandles();\n\t}\n};\n\n/**\n * Function: isRecursiveResize\n * \n * Returns the recursiveResize of the give state.\n * \n * Parameters:\n * \n * state - the given <mxCellState>. This implementation takes \n * the value of this state.\n * me - the mouse event.\n */\nmxVertexHandler.prototype.isRecursiveResize = function(state, me)\n{\n\treturn this.graph.isRecursiveResize(this.state);\n};\n\n/**\n * Function: rotateClick\n * \n * Hook for subclassers to implement a single click on the rotation handle.\n * This code is executed as part of the model transaction. This implementation\n * is empty.\n */\nmxVertexHandler.prototype.rotateClick = function() { };\n\n/**\n * Function: rotateCell\n * \n * Rotates the given cell and its children by the given angle in degrees.\n * \n * Parameters:\n * \n * cell - <mxCell> to be rotated.\n * angle - Angle in degrees.\n */\nmxVertexHandler.prototype.rotateCell = function(cell, angle, parent)\n{\n\tif (angle != 0)\n\t{\n\t\tvar model = this.graph.getModel();\n\n\t\tif (model.isVertex(cell) || model.isEdge(cell))\n\t\t{\n\t\t\tif (!model.isEdge(cell))\n\t\t\t{\n\t\t\t\tvar style = this.graph.getCurrentCellStyle(cell);\n\t\t\t\tvar total = (style[mxConstants.STYLE_ROTATION] || 0) + angle;\n\t\t\t\tthis.graph.setCellStyles(mxConstants.STYLE_ROTATION, total, [cell]);\n\t\t\t}\n\t\t\t\n\t\t\tvar geo = this.graph.getCellGeometry(cell);\n\t\t\t\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tvar pgeo = this.graph.getCellGeometry(parent);\n\t\t\t\t\n\t\t\t\tif (pgeo != null && !model.isEdge(parent))\n\t\t\t\t{\n\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\tgeo.rotate(angle, new mxPoint(pgeo.width / 2, pgeo.height / 2));\n\t\t\t\t\tmodel.setGeometry(cell, geo);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ((model.isVertex(cell) && !geo.relative) || model.isEdge(cell))\n\t\t\t\t{\n\t\t\t\t\t// Recursive rotation\n\t\t\t\t\tvar childCount = model.getChildCount(cell);\n\t\t\t\t\t\n\t\t\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.rotateCell(model.getChildAt(cell, i), angle, cell);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: reset\n * \n * Resets the state of this handler.\n */\nmxVertexHandler.prototype.reset = function()\n{\n\tif (this.sizers != null && this.index != null && this.sizers[this.index] != null &&\n\t\tthis.sizers[this.index].node.style.display == 'none')\n\t{\n\t\tthis.sizers[this.index].node.style.display = '';\n\t}\n\n\tthis.currentAlpha = null;\n\tthis.inTolerance = null;\n\tthis.index = null;\n\n\t// TODO: Reset and redraw cell states for live preview\n\tif (this.preview != null)\n\t{\n\t\tthis.preview.destroy();\n\t\tthis.preview = null;\n\t}\n\t\n\tif (this.ghostPreview != null)\n\t{\n\t\tthis.ghostPreview.destroy();\n\t\tthis.ghostPreview = null;\n\t}\n\n\tif (this.livePreviewActive && this.sizers != null)\n\t{\n\t\tfor (var i = 0; i < this.sizers.length; i++)\n\t\t{\n\t\t\tif (this.sizers[i] != null)\n\t\t\t{\n\t\t\t\tthis.sizers[i].node.style.display = '';\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Shows folding icon\n\t\tif (this.state.control != null && this.state.control.node != null)\n\t\t{\n\t\t\tthis.state.control.node.style.visibility = '';\n\t\t}\n\t}\n\n\tif (this.customHandles != null)\n\t{\n\t\tfor (var i = 0; i < this.customHandles.length; i++)\n\t\t{\n\t\t\tif (this.customHandles[i].active)\n\t\t\t{\n\t\t\t\tthis.customHandles[i].active = false;\n\t\t\t\tthis.customHandles[i].reset();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.customHandles[i].setVisible(true);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Checks if handler has been destroyed\n\tif (this.selectionBorder != null)\n\t{\n\t\tthis.selectionBorder.node.style.display = 'inline';\n\t\tthis.selectionBounds = this.getSelectionBounds(this.state);\n\t\tthis.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y,\n\t\t\tthis.selectionBounds.width, this.selectionBounds.height);\n\t\tthis.drawPreview();\n\t}\n\n\tthis.removeHint();\n\tthis.redrawHandles();\n\tthis.edgeHandlers = null;\n\tthis.handlesVisible = true;\n\tthis.unscaledBounds = null;\n\tthis.livePreviewActive = null;\n};\n\n/**\n * Function: resizeCell\n * \n * Uses the given vector to change the bounds of the given cell\n * in the graph using <mxGraph.resizeCell>.\n */\nmxVertexHandler.prototype.resizeCell = function(cell, dx, dy, index, gridEnabled, constrained, recurse)\n{\n\tvar geo = this.graph.model.getGeometry(cell);\n\t\n\tif (geo != null)\n\t{\n\t\tif (index == mxEvent.LABEL_HANDLE)\n\t\t{\n\t\t\tvar alpha = -mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || '0');\n\t\t\tvar cos = Math.cos(alpha);\n\t\t\tvar sin = Math.sin(alpha);\n\t\t\tvar scale = this.graph.view.scale;\n\t\t\tvar pt = mxUtils.getRotatedPoint(new mxPoint(\n\t\t\t\tMath.round((this.labelShape.bounds.getCenterX() - this.startX) / scale),\n\t\t\t\tMath.round((this.labelShape.bounds.getCenterY() - this.startY) / scale)),\n\t\t\t\tcos, sin);\n\n\t\t\tgeo = geo.clone();\n\t\t\t\n\t\t\tif (geo.offset == null)\n\t\t\t{\n\t\t\t\tgeo.offset = pt;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgeo.offset.x += pt.x;\n\t\t\t\tgeo.offset.y += pt.y;\n\t\t\t}\n\t\t\t\n\t\t\tthis.graph.model.setGeometry(cell, geo);\n\t\t}\n\t\telse if (this.unscaledBounds != null)\n\t\t{\n\t\t\tvar scale = this.graph.view.scale;\n\n\t\t\tif (this.childOffsetX != 0 || this.childOffsetY != 0)\n\t\t\t{\n\t\t\t\tthis.moveChildren(cell, Math.round(this.childOffsetX / scale), Math.round(this.childOffsetY / scale));\n\t\t\t}\n\n\t\t\tthis.graph.resizeCell(cell, this.unscaledBounds, recurse);\n\t\t}\n\t}\n};\n\n/**\n * Function: moveChildren\n * \n * Moves the children of the given cell by the given vector.\n */\nmxVertexHandler.prototype.moveChildren = function(cell, dx, dy)\n{\n\tvar model = this.graph.getModel();\n\tvar childCount = model.getChildCount(cell);\n\t\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = model.getChildAt(cell, i);\n\t\tvar geo = this.graph.getCellGeometry(child);\n\t\t\n\t\tif (geo != null)\n\t\t{\n\t\t\tgeo = geo.clone();\n\t\t\tgeo.translate(dx, dy);\n\t\t\tmodel.setGeometry(child, geo);\n\t\t}\n\t}\n};\n/**\n * Function: union\n * \n * Returns the union of the given bounds and location for the specified\n * handle index.\n * \n * To override this to limit the size of vertex via a minWidth/-Height style,\n * the following code can be used.\n * \n * (code)\n * var vertexHandlerUnion = mxVertexHandler.prototype.union;\n * mxVertexHandler.prototype.union = function(bounds, dx, dy, index, gridEnabled, scale, tr, constrained)\n * {\n *   var result = vertexHandlerUnion.apply(this, arguments);\n *   \n *   result.width = Math.max(result.width, mxUtils.getNumber(this.state.style, 'minWidth', 0));\n *   result.height = Math.max(result.height, mxUtils.getNumber(this.state.style, 'minHeight', 0));\n *   \n *   return result;\n * };\n * (end)\n * \n * The minWidth/-Height style can then be used as follows:\n * \n * (code)\n * graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30, 'minWidth=100;minHeight=100;');\n * (end)\n * \n * To override this to update the height for a wrapped text if the width of a vertex is\n * changed, the following can be used.\n * \n * (code)\n * var mxVertexHandlerUnion = mxVertexHandler.prototype.union;\n * mxVertexHandler.prototype.union = function(bounds, dx, dy, index, gridEnabled, scale, tr, constrained)\n * {\n *   var result = mxVertexHandlerUnion.apply(this, arguments);\n *   var s = this.state;\n *   \n *   if (this.graph.isHtmlLabel(s.cell) && (index == 3 || index == 4) &&\n *       s.text != null && s.style[mxConstants.STYLE_WHITE_SPACE] == 'wrap')\n *   {\n *     var label = this.graph.getLabel(s.cell);\n *     var fontSize = mxUtils.getNumber(s.style, mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE);\n *     var ww = result.width / s.view.scale - s.text.spacingRight - s.text.spacingLeft\n *     \n *     result.height = mxUtils.getSizeForString(label, fontSize, s.style[mxConstants.STYLE_FONTFAMILY], ww).height;\n *   }\n *   \n *   return result;\n * };\n * (end)\n */\nmxVertexHandler.prototype.union = function(bounds, dx, dy, index, gridEnabled, scale, tr, constrained, centered)\n{\n\tgridEnabled = (gridEnabled != null) ? gridEnabled && this.graph.gridEnabled : this.graph.gridEnabled;\n\t\n\tif (this.singleSizer)\n\t{\n\t\tvar x = bounds.x + bounds.width + dx;\n\t\tvar y = bounds.y + bounds.height + dy;\n\t\t\n\t\tif (gridEnabled)\n\t\t{\n\t\t\tx = this.graph.snap(x / scale) * scale;\n\t\t\ty = this.graph.snap(y / scale) * scale;\n\t\t}\n\t\t\n\t\tvar rect = new mxRectangle(bounds.x, bounds.y, 0, 0);\n\t\trect.add(new mxRectangle(x, y, 0, 0));\n\t\t\n\t\treturn rect;\n\t}\n\telse\n\t{\n\t\tvar w0 = bounds.width;\n\t\tvar h0 = bounds.height;\n\t\tvar left = bounds.x - tr.x * scale;\n\t\tvar right = left + w0;\n\t\tvar top = bounds.y - tr.y * scale;\n\t\tvar bottom = top + h0;\n\t\t\n\t\tvar cx = left + w0 / 2;\n\t\tvar cy = top + h0 / 2;\n\t\t\n\t\tif (index > 4 /* Bottom Row */)\n\t\t{\n\t\t\tbottom = bottom + dy;\n\t\t\t\n\t\t\tif (gridEnabled)\n\t\t\t{\n\t\t\t\tbottom = this.graph.snap(bottom / scale) * scale;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbottom = Math.round(bottom / scale) * scale;\n\t\t\t}\n\t\t}\n\t\telse if (index < 3 /* Top Row */)\n\t\t{\n\t\t\ttop = top + dy;\n\t\t\t\n\t\t\tif (gridEnabled)\n\t\t\t{\n\t\t\t\ttop = this.graph.snap(top / scale) * scale;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttop = Math.round(top / scale) * scale;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (index == 0 || index == 3 || index == 5 /* Left */)\n\t\t{\n\t\t\tleft += dx;\n\t\t\t\n\t\t\tif (gridEnabled)\n\t\t\t{\n\t\t\t\tleft = this.graph.snap(left / scale) * scale;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tleft = Math.round(left / scale) * scale;\n\t\t\t}\n\t\t}\n\t\telse if (index == 2 || index == 4 || index == 7 /* Right */)\n\t\t{\n\t\t\tright += dx;\n\t\t\t\n\t\t\tif (gridEnabled)\n\t\t\t{\n\t\t\t\tright = this.graph.snap(right / scale) * scale;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tright = Math.round(right / scale) * scale;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar width = right - left;\n\t\tvar height = bottom - top;\n\n\t\tif (constrained)\n\t\t{\n\t\t\tvar geo = this.graph.getCellGeometry(this.state.cell);\n\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tvar aspect = geo.width / geo.height;\n\t\t\t\t\n\t\t\t\tif (index== 1 || index== 2 || index == 7 || index == 6)\n\t\t\t\t{\n\t\t\t\t\twidth = height * aspect;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theight = width / aspect;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (index == 0)\n\t\t\t\t{\n\t\t\t\t\tleft = right - width;\n\t\t\t\t\ttop = bottom - height;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (centered)\n\t\t{\n\t\t\twidth += (width - w0);\n\t\t\theight += (height - h0);\n\t\t\t\n\t\t\tvar cdx = cx - (left + width / 2);\n\t\t\tvar cdy = cy - (top + height / 2);\n\n\t\t\tleft += cdx;\n\t\t\ttop += cdy;\n\t\t\tright += cdx;\n\t\t\tbottom += cdy;\n\t\t}\n\n\t\t// Flips over left side\n\t\tif (width < 0)\n\t\t{\n\t\t\tleft += width;\n\t\t\twidth = Math.abs(width);\n\t\t}\n\t\t\n\t\t// Flips over top side\n\t\tif (height < 0)\n\t\t{\n\t\t\ttop += height;\n\t\t\theight = Math.abs(height);\n\t\t}\n\n\t\tvar result = new mxRectangle(left + tr.x * scale, top + tr.y * scale, width, height);\n\t\t\n\t\tif (this.minBounds != null)\n\t\t{\n\t\t\tresult.width = Math.max(result.width, this.minBounds.x * scale + this.minBounds.width * scale +\n\t\t\t\tMath.max(0, this.x0 * scale - result.x));\n\t\t\tresult.height = Math.max(result.height, this.minBounds.y * scale + this.minBounds.height * scale +\n\t\t\t\tMath.max(0, this.y0 * scale - result.y));\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n};\n\n/**\n * Function: redraw\n * \n * Redraws the handles and the preview.\n */\nmxVertexHandler.prototype.redraw = function(ignoreHandles)\n{\n\tthis.selectionBounds = this.getSelectionBounds(this.state);\n\tthis.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y,\n\t\tthis.selectionBounds.width, this.selectionBounds.height);\n\tthis.drawPreview();\n\n\tif (!ignoreHandles)\n\t{\n\t\tthis.redrawHandles();\n\t}\n};\n\n/**\n * Returns the padding to be used for drawing handles for the current <bounds>.\n */\nmxVertexHandler.prototype.getHandlePadding = function()\n{\n\t// KNOWN: Tolerance depends on event type (eg. 0 for mouse events)\n\tvar result = new mxPoint(0, 0);\n\tvar tol = this.tolerance;\n\n\tif (this.sizers != null && this.sizers.length > 0 && this.sizers[0] != null &&\n\t\t(this.bounds.width < 2 * this.sizers[0].bounds.width + 2 * tol ||\n\t\tthis.bounds.height < 2 * this.sizers[0].bounds.height + 2 * tol))\n\t{\n\t\ttol /= 2;\n\t\t\n\t\tresult.x = this.sizers[0].bounds.width + tol;\n\t\tresult.y = this.sizers[0].bounds.height + tol;\n\t}\n\t\n\treturn result;\n};\n\n/**\n * Function: getSizerBounds\n * \n * Returns the bounds used to paint the resize handles.\n */\nmxVertexHandler.prototype.getSizerBounds = function()\n{\n\treturn this.bounds;\n};\n\n/**\n * Function: redrawHandles\n * \n * Redraws the handles. To hide certain handles the following code can be used.\n * \n * (code)\n * mxVertexHandler.prototype.redrawHandles = function()\n * {\n *   mxVertexHandlerRedrawHandles.apply(this, arguments);\n *   \n *   if (this.sizers != null && this.sizers.length > 7)\n *   {\n *     this.sizers[1].node.style.display = 'none';\n *     this.sizers[6].node.style.display = 'none';\n *   }\n * };\n * (end)\n */\nmxVertexHandler.prototype.redrawHandles = function()\n{\n\tvar s = this.getSizerBounds();\n\tvar tol = this.tolerance;\n\tthis.horizontalOffset = 0;\n\tthis.verticalOffset = 0;\n\t\n\tif (this.customHandles != null)\n\t{\n\t\tfor (var i = 0; i < this.customHandles.length; i++)\n\t\t{\n\t\t\tvar temp = this.customHandles[i].shape.node.style.display;\n\t\t\tthis.customHandles[i].redraw();\n\t\t\tthis.customHandles[i].shape.node.style.display = temp;\n\n\t\t\t// Hides custom handles during text editing\n\t\t\tthis.customHandles[i].shape.node.style.visibility =\n\t\t\t\t(this.handlesVisible && this.isCustomHandleVisible(\n\t\t\t\t\tthis.customHandles[i])) ? '' : 'hidden';\n\t\t}\n\t}\n\n\tif (this.sizers != null && this.sizers.length > 0 && this.sizers[0] != null)\n\t{\n\t\tif (this.index == null && this.manageSizers && this.sizers.length >= 8)\n\t\t{\n\t\t\t// KNOWN: Tolerance depends on event type (eg. 0 for mouse events)\n\t\t\tvar padding = this.getHandlePadding();\n\t\t\tthis.horizontalOffset = padding.x;\n\t\t\tthis.verticalOffset = padding.y;\n\t\t\t\n\t\t\tif (this.horizontalOffset != 0 || this.verticalOffset != 0)\n\t\t\t{\n\t\t\t\ts = new mxRectangle(s.x, s.y, s.width, s.height);\n\n\t\t\t\ts.x -= this.horizontalOffset / 2;\n\t\t\t\ts.width += this.horizontalOffset;\n\t\t\t\ts.y -= this.verticalOffset / 2;\n\t\t\t\ts.height += this.verticalOffset;\n\t\t\t}\n\t\t\t\n\t\t\tif (this.sizers.length >= 8)\n\t\t\t{\n\t\t\t\tif ((s.width < 2 * this.sizers[0].bounds.width + 2 * tol) ||\n\t\t\t\t\t(s.height < 2 * this.sizers[0].bounds.height + 2 * tol))\n\t\t\t\t{\n\t\t\t\t\tthis.sizers[0].node.style.display = 'none';\n\t\t\t\t\tthis.sizers[2].node.style.display = 'none';\n\t\t\t\t\tthis.sizers[5].node.style.display = 'none';\n\t\t\t\t\tthis.sizers[7].node.style.display = 'none';\n\t\t\t\t}\n\t\t\t\telse if (this.handlesVisible)\n\t\t\t\t{\n\t\t\t\t\tthis.sizers[0].node.style.display = '';\n\t\t\t\t\tthis.sizers[2].node.style.display = '';\n\t\t\t\t\tthis.sizers[5].node.style.display = '';\n\t\t\t\t\tthis.sizers[7].node.style.display = '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar r = s.x + s.width;\n\t\tvar b = s.y + s.height;\n\t\t\n\t\tif (this.singleSizer)\n\t\t{\n\t\t\tthis.moveSizerTo(this.sizers[0], r, b);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar cx = s.x + s.width / 2;\n\t\t\tvar cy = s.y + s.height / 2;\n\t\t\t\n\t\t\tif (this.sizers.length >= 8)\n\t\t\t{\n\t\t\t\tvar crs = ['nw-resize', 'n-resize', 'ne-resize', 'e-resize', 'se-resize', 's-resize', 'sw-resize', 'w-resize'];\n\t\t\t\t\n\t\t\t\tvar alpha = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || '0');\n\t\t\t\tvar cos = Math.cos(alpha);\n\t\t\t\tvar sin = Math.sin(alpha);\n\t\t\t\t\n\t\t\t\tvar da = Math.round(alpha * 4 / Math.PI);\n\t\t\t\t\n\t\t\t\tvar ct = new mxPoint(s.getCenterX(), s.getCenterY());\n\t\t\t\tvar pt = mxUtils.getRotatedPoint(new mxPoint(s.x, s.y), cos, sin, ct);\n\t\t\t\t\n\t\t\t\tthis.moveSizerTo(this.sizers[0], pt.x, pt.y);\n\t\t\t\tthis.sizers[0].setCursor(crs[mxUtils.mod(0 + da, crs.length)]);\n\t\t\t\t\n\t\t\t\tpt.x = cx;\n\t\t\t\tpt.y = s.y;\n\t\t\t\tpt = mxUtils.getRotatedPoint(pt, cos, sin, ct);\n\t\t\t\t\n\t\t\t\tthis.moveSizerTo(this.sizers[1], pt.x, pt.y);\n\t\t\t\tthis.sizers[1].setCursor(crs[mxUtils.mod(1 + da, crs.length)]);\n\t\t\t\t\n\t\t\t\tpt.x = r;\n\t\t\t\tpt.y = s.y;\n\t\t\t\tpt = mxUtils.getRotatedPoint(pt, cos, sin, ct);\n\t\t\t\t\n\t\t\t\tthis.moveSizerTo(this.sizers[2], pt.x, pt.y);\n\t\t\t\tthis.sizers[2].setCursor(crs[mxUtils.mod(2 + da, crs.length)]);\n\t\t\t\t\n\t\t\t\tpt.x = s.x;\n\t\t\t\tpt.y = cy;\n\t\t\t\tpt = mxUtils.getRotatedPoint(pt, cos, sin, ct);\n\t\t\t\t\n\t\t\t\tthis.moveSizerTo(this.sizers[3], pt.x, pt.y);\n\t\t\t\tthis.sizers[3].setCursor(crs[mxUtils.mod(7 + da, crs.length)]);\n\n\t\t\t\tpt.x = r;\n\t\t\t\tpt.y = cy;\n\t\t\t\tpt = mxUtils.getRotatedPoint(pt, cos, sin, ct);\n\t\t\t\t\n\t\t\t\tthis.moveSizerTo(this.sizers[4], pt.x, pt.y);\n\t\t\t\tthis.sizers[4].setCursor(crs[mxUtils.mod(3 + da, crs.length)]);\n\n\t\t\t\tpt.x = s.x;\n\t\t\t\tpt.y = b;\n\t\t\t\tpt = mxUtils.getRotatedPoint(pt, cos, sin, ct);\n\t\t\t\t\n\t\t\t\tthis.moveSizerTo(this.sizers[5], pt.x, pt.y);\n\t\t\t\tthis.sizers[5].setCursor(crs[mxUtils.mod(6 + da, crs.length)]);\n\n\t\t\t\tpt.x = cx;\n\t\t\t\tpt.y = b;\n\t\t\t\tpt = mxUtils.getRotatedPoint(pt, cos, sin, ct);\n\t\t\t\t\n\t\t\t\tthis.moveSizerTo(this.sizers[6], pt.x, pt.y);\n\t\t\t\tthis.sizers[6].setCursor(crs[mxUtils.mod(5 + da, crs.length)]);\n\n\t\t\t\tpt.x = r;\n\t\t\t\tpt.y = b;\n\t\t\t\tpt = mxUtils.getRotatedPoint(pt, cos, sin, ct);\n\t\t\t\t\n\t\t\t\tthis.moveSizerTo(this.sizers[7], pt.x, pt.y);\n\t\t\t\tthis.sizers[7].setCursor(crs[mxUtils.mod(4 + da, crs.length)]);\n\t\t\t\t\n\t\t\t\tpt.x = cx + this.state.absoluteOffset.x;\n\t\t\t\tpt.y = cy + this.state.absoluteOffset.y;\n\t\t\t\tpt = mxUtils.getRotatedPoint(pt, cos, sin, ct);\n\t\t\t\tthis.moveSizerTo(this.sizers[8], pt.x, pt.y);\n\t\t\t}\n\t\t\telse if (this.state.width >= 2 && this.state.height >= 2)\n\t\t\t{\n\t\t\t\tthis.moveSizerTo(this.sizers[0], cx + this.state.absoluteOffset.x, cy + this.state.absoluteOffset.y);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.moveSizerTo(this.sizers[0], this.state.x, this.state.y);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (this.rotationShape != null)\n\t{\n\t\tvar alpha = mxUtils.toRadians((this.currentAlpha != null) ? this.currentAlpha : this.state.style[mxConstants.STYLE_ROTATION] || '0');\n\t\tvar cos = Math.cos(alpha);\n\t\tvar sin = Math.sin(alpha);\n\t\t\n\t\tvar ct = new mxPoint(this.state.getCenterX(), this.state.getCenterY());\n\t\tvar pt = mxUtils.getRotatedPoint(this.getRotationHandlePosition(), cos, sin, ct);\n\n\t\tif (this.rotationShape.node != null)\n\t\t{\n\t\t\tthis.moveSizerTo(this.rotationShape, pt.x, pt.y);\n\n\t\t\t// Hides rotation handle during text editing\n\t\t\tthis.rotationShape.node.style.visibility = (this.state.view.graph.isEditing() ||\n\t\t\t\t!this.handlesVisible) ? 'hidden' : '';\n\t\t}\n\t}\n\t\n\tif (this.selectionBorder != null)\n\t{\n\t\tthis.selectionBorder.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || '0');\n\t}\n\t\n\tif (this.edgeHandlers != null)\n\t{\t\t\n\t\tfor (var i = 0; i < this.edgeHandlers.length; i++)\n\t\t{\n\t\t\tthis.edgeHandlers[i].redraw();\n\t\t}\n\t}\n};\n\n/**\n * Function: isCustomHandleVisible\n * \n * Returns true if the given custom handle is visible.\n */\nmxVertexHandler.prototype.isCustomHandleVisible = function(handle)\n{\n\treturn !this.graph.isEditing() && this.state.view.graph.getSelectionCount() == 1;\n};\n\n/**\n * Function: getRotationHandlePosition\n * \n * Returns an <mxPoint> that defines the rotation handle position.\n */\nmxVertexHandler.prototype.getRotationHandlePosition = function()\n{\n\treturn new mxPoint(this.bounds.x + this.bounds.width / 2, this.bounds.y + this.rotationHandleVSpacing)\n};\n\n/**\n * Function: isParentHighlightVisible\n * \n * Returns true if the parent highlight should be visible. This implementation\n * always returns true.\n */\nmxVertexHandler.prototype.isParentHighlightVisible = function()\n{\n\treturn !this.graph.isCellSelected(this.graph.model.getParent(this.state.cell));\n};\n\n/**\n * Function: updateParentHighlight\n * \n * Updates the highlight of the parent if <parentHighlightEnabled> is true.\n */\nmxVertexHandler.prototype.updateParentHighlight = function()\n{\n\tif (!this.isDestroyed())\n\t{\n\t\tvar visible = this.isParentHighlightVisible();\n\t\tvar parent = this.graph.model.getParent(this.state.cell);\n\t\tvar pstate = this.graph.view.getState(parent);\n\n\t\tif (this.parentHighlight != null)\n\t\t{\n\t\t\tif (this.graph.model.isVertex(parent) && visible)\n\t\t\t{\n\t\t\t\tvar b = this.parentHighlight.bounds;\n\t\t\t\t\n\t\t\t\tif (pstate != null && (b.x != pstate.x || b.y != pstate.y ||\n\t\t\t\t\tb.width != pstate.width || b.height != pstate.height))\n\t\t\t\t{\n\t\t\t\t\tthis.parentHighlight.bounds = mxRectangle.fromRectangle(pstate);\n\t\t\t\t\tthis.parentHighlight.redraw();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (pstate != null && pstate.parentHighlight == this.parentHighlight)\n\t\t\t\t{\n\t\t\t\t\tpstate.parentHighlight = null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.parentHighlight.destroy();\n\t\t\t\tthis.parentHighlight = null;\n\t\t\t}\n\t\t}\n\t\telse if (this.parentHighlightEnabled && visible)\n\t\t{\n\t\t\tif (this.graph.model.isVertex(parent) && pstate != null &&\n\t\t\t\tpstate.parentHighlight == null)\n\t\t\t{\n\t\t\t\tthis.parentHighlight = this.createParentHighlightShape(pstate);\n\t\t\t\t// VML dialect required here for event transparency in IE\n\t\t\t\tthis.parentHighlight.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;\n\t\t\t\tthis.parentHighlight.pointerEvents = false;\n\t\t\t\tthis.parentHighlight.rotation = Number(pstate.style[mxConstants.STYLE_ROTATION] || '0');\n\t\t\t\tthis.parentHighlight.init(this.graph.getView().getOverlayPane());\n\t\t\t\tthis.parentHighlight.redraw();\n\t\t\t\t\n\t\t\t\t// Shows highlight once per parent\n\t\t\t\tpstate.parentHighlight = this.parentHighlight;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: drawPreview\n * \n * Redraws the preview.\n */\nmxVertexHandler.prototype.drawPreview = function()\n{\n\tif (this.preview != null)\n\t{\n\t\tthis.preview.bounds = this.bounds;\n\t\t\n\t\tif (this.preview.node.parentNode == this.graph.container)\n\t\t{\n\t\t\tthis.preview.bounds.width = Math.max(0, this.preview.bounds.width - 1);\n\t\t\tthis.preview.bounds.height = Math.max(0, this.preview.bounds.height - 1);\n\t\t}\n\t\n\t\tthis.preview.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || '0');\n\t\tthis.preview.redraw();\n\t}\n\t\n\tthis.selectionBorder.bounds = this.getSelectionBorderBounds();\n\tthis.selectionBorder.redraw();\n\tthis.updateParentHighlight();\n};\n\n/**\n * Function: getSelectionBorderBounds\n * \n * Returns the bounds for the selection border.\n */\nmxVertexHandler.prototype.getSelectionBorderBounds = function()\n{\n\treturn this.bounds;\n};\n\n/**\n * Function: isDestroyed\n * \n * Returns true if this handler was destroyed or not initialized.\n */\nmxVertexHandler.prototype.isDestroyed = function()\n{\n\treturn this.selectionBorder == null;\n};\n\n/**\n * Function: destroy\n * \n * Destroys the handler and all its resources and DOM nodes.\n */\nmxVertexHandler.prototype.destroy = function()\n{\n\tif (this.escapeHandler != null)\n\t{\n\t\tthis.state.view.graph.removeListener(this.escapeHandler);\n\t\tthis.escapeHandler = null;\n\t}\n\t\n\tif (this.preview != null)\n\t{\n\t\tthis.preview.destroy();\n\t\tthis.preview = null;\n\t}\n\t\n\tif (this.parentHighlight != null)\n\t{\n\t\tvar parent = this.graph.model.getParent(this.state.cell);\n\t\tvar pstate = this.graph.view.getState(parent);\n\n\t\tif (pstate != null && pstate.parentHighlight == this.parentHighlight)\n\t\t{\n\t\t\tpstate.parentHighlight = null;\n\t\t}\n\t\t\n\t\tthis.parentHighlight.destroy();\n\t\tthis.parentHighlight = null;\n\t}\n\t\n\tif (this.ghostPreview != null)\n\t{\n\t\tthis.ghostPreview.destroy();\n\t\tthis.ghostPreview = null;\n\t}\n\n\tif (this.selectionBorder != null)\n\t{\n\t\tthis.selectionBorder.destroy();\n\t\tthis.selectionBorder = null;\n\t}\n\t\n\tthis.labelShape = null;\n\tthis.removeHint();\n\n\tif (this.sizers != null)\n\t{\n\t\tfor (var i = 0; i < this.sizers.length; i++)\n\t\t{\n\t\t\tthis.sizers[i].destroy();\n\t\t}\n\t\t\n\t\tthis.sizers = null;\n\t}\n\n\tif (this.customHandles != null)\n\t{\n\t\tfor (var i = 0; i < this.customHandles.length; i++)\n\t\t{\n\t\t\tthis.customHandles[i].destroy();\n\t\t}\n\t\t\n\t\tthis.customHandles = null;\n\t}\n};\n\n__mxOutput.mxVertexHandler = typeof mxVertexHandler !== 'undefined' ? mxVertexHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxEdgeHandler\n *\n * Graph event handler that reconnects edges and modifies control points and\n * the edge label location. Uses <mxTerminalMarker> for finding and\n * highlighting new source and target vertices. This handler is automatically\n * created in <mxGraph.createHandler> for each selected edge.\n * \n * To enable adding/removing control points, the following code can be used:\n * \n * (code)\n * mxEdgeHandler.prototype.addEnabled = true;\n * mxEdgeHandler.prototype.removeEnabled = true;\n * (end)\n * \n * Note: This experimental feature is not recommended for production use.\n * \n * Constructor: mxEdgeHandler\n *\n * Constructs an edge handler for the specified <mxCellState>.\n * \n * Parameters:\n * \n * state - <mxCellState> of the cell to be handled.\n */\nfunction mxEdgeHandler(state)\n{\n\tif (state != null && state.shape != null)\n\t{\n\t\tthis.state = state;\n\t\tthis.init();\n\t\t\n\t\t// Handles escape keystrokes\n\t\tthis.escapeHandler = mxUtils.bind(this, function(sender, evt)\n\t\t{\n\t\t\tvar dirty = this.index != null;\n\t\t\tthis.reset();\n\t\t\t\n\t\t\tif (dirty)\n\t\t\t{\n\t\t\t\tthis.graph.cellRenderer.redraw(this.state, false, state.view.isRendering());\n\t\t\t}\n\t\t});\n\t\t\n\t\tthis.state.view.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);\n\t}\n};\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxEdgeHandler.prototype.graph = null;\n\n/**\n * Variable: state\n * \n * Reference to the <mxCellState> being modified.\n */\nmxEdgeHandler.prototype.state = null;\n\n/**\n * Variable: marker\n * \n * Holds the <mxTerminalMarker> which is used for highlighting terminals.\n */\nmxEdgeHandler.prototype.marker = null;\n\n/**\n * Variable: constraintHandler\n * \n * Holds the <mxConstraintHandler> used for drawing and highlighting\n * constraints.\n */\nmxEdgeHandler.prototype.constraintHandler = null;\n\n/**\n * Variable: error\n * \n * Holds the current validation error while a connection is being changed.\n */\nmxEdgeHandler.prototype.error = null;\n\n/**\n * Variable: shape\n * \n * Holds the <mxShape> that represents the preview edge.\n */\nmxEdgeHandler.prototype.shape = null;\n\n/**\n * Variable: bends\n * \n * Holds the <mxShapes> that represent the points.\n */\nmxEdgeHandler.prototype.bends = null;\n\n/**\n * Variable: labelShape\n * \n * Holds the <mxShape> that represents the label position.\n */\nmxEdgeHandler.prototype.labelShape = null;\n\n/**\n * Variable: cloneEnabled\n * \n * Specifies if cloning by control-drag is enabled. Default is true.\n */\nmxEdgeHandler.prototype.cloneEnabled = true;\n\n/**\n * Variable: addEnabled\n * \n * Specifies if adding bends by shift-click is enabled. Default is false.\n * Note: This experimental feature is not recommended for production use.\n */\nmxEdgeHandler.prototype.addEnabled = false;\n\n/**\n * Variable: removeEnabled\n * \n * Specifies if removing bends by shift-click is enabled. Default is false.\n * Note: This experimental feature is not recommended for production use.\n */\nmxEdgeHandler.prototype.removeEnabled = false;\n\n/**\n * Variable: dblClickRemoveEnabled\n * \n * Specifies if removing bends by double click is enabled. Default is false.\n */\nmxEdgeHandler.prototype.dblClickRemoveEnabled = false;\n\n/**\n * Variable: mergeRemoveEnabled\n * \n * Specifies if removing bends by dropping them on other bends is enabled.\n * Default is false.\n */\nmxEdgeHandler.prototype.mergeRemoveEnabled = false;\n\n/**\n * Variable: straightRemoveEnabled\n * \n * Specifies if removing bends by creating straight segments should be enabled.\n * If enabled, this can be overridden by holding down the alt key while moving.\n * Default is false.\n */\nmxEdgeHandler.prototype.straightRemoveEnabled = false;\n\n/**\n * Variable: virtualBendsEnabled\n * \n * Specifies if virtual bends should be added in the center of each\n * segments. These bends can then be used to add new waypoints.\n * Default is false.\n */\nmxEdgeHandler.prototype.virtualBendsEnabled = false;\n\n/**\n * Variable: virtualBendOpacity\n * \n * Opacity to be used for virtual bends (see <virtualBendsEnabled>).\n * Default is 20.\n */\nmxEdgeHandler.prototype.virtualBendOpacity = 20;\n\n/**\n * Variable: parentHighlightEnabled\n * \n * Specifies if the parent should be highlighted if a child cell is selected.\n * Default is false.\n */\nmxEdgeHandler.prototype.parentHighlightEnabled = false;\n\n/**\n * Variable: preferHtml\n * \n * Specifies if bends should be added to the graph container. This is updated\n * in <init> based on whether the edge or one of its terminals has an HTML\n * label in the container.\n */\nmxEdgeHandler.prototype.preferHtml = false;\n\n/**\n * Variable: allowHandleBoundsCheck\n * \n * Specifies if the bounds of handles should be used for hit-detection in IE\n * Default is true.\n */\nmxEdgeHandler.prototype.allowHandleBoundsCheck = true;\n\n/**\n * Variable: snapToTerminals\n * \n * Specifies if waypoints should snap to the routing centers of terminals.\n * Default is false.\n */\nmxEdgeHandler.prototype.snapToTerminals = false;\n\n/**\n * Variable: handleImage\n * \n * Optional <mxImage> to be used as handles. Default is null.\n */\nmxEdgeHandler.prototype.handleImage = null;\n\n/**\n * Variable: tolerance\n * \n * Optional tolerance for hit-detection in <getHandleForEvent>. Default is 0.\n */\nmxEdgeHandler.prototype.tolerance = 0;\n\n/**\n * Variable: outlineConnect\n * \n * Specifies if connections to the outline of a highlighted target should be\n * enabled. This will allow to place the connection point along the outline of\n * the highlighted target. Default is false.\n */\nmxEdgeHandler.prototype.outlineConnect = false;\n\n/**\n * Variable: manageLabelHandle\n * \n * Specifies if the label handle should be moved if it intersects with another\n * handle. Uses <checkLabelHandle> for checking and moving. Default is false.\n */\nmxEdgeHandler.prototype.manageLabelHandle = false;\n\n/**\n * Function: init\n * \n * Initializes the shapes required for this edge handler.\n */\nmxEdgeHandler.prototype.init = function()\n{\n\tthis.graph = this.state.view.graph;\n\tthis.marker = this.createMarker();\n\tthis.constraintHandler = new mxConstraintHandler(this.graph);\n\t\n\t// Clones the original points from the cell\n\t// and makes sure at least one point exists\n\tthis.points = [];\n\t\n\t// Uses the absolute points of the state\n\t// for the initial configuration and preview\n\tthis.abspoints = this.getSelectionPoints(this.state);\n\tthis.shape = this.createSelectionShape(this.abspoints);\n\tthis.shape.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\tmxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;\n\tthis.shape.init(this.graph.getView().getOverlayPane());\n\tthis.shape.pointerEvents = false;\n\tthis.shape.setCursor(mxConstants.CURSOR_MOVABLE_EDGE);\n\tmxEvent.redirectMouseEvents(this.shape.node, this.graph, this.state);\n\n\t// Updates preferHtml\n\tthis.preferHtml = this.state.text != null &&\n\t\tthis.state.text.node.parentNode == this.graph.container;\n\t\n\tif (!this.preferHtml)\n\t{\n\t\t// Checks source terminal\n\t\tvar sourceState = this.state.getVisibleTerminalState(true);\n\t\t\n\t\tif (sourceState != null)\n\t\t{\n\t\t\tthis.preferHtml = sourceState.text != null &&\n\t\t\t\tsourceState.text.node.parentNode == this.graph.container;\n\t\t}\n\t\t\n\t\tif (!this.preferHtml)\n\t\t{\n\t\t\t// Checks target terminal\n\t\t\tvar targetState = this.state.getVisibleTerminalState(false);\n\t\t\t\n\t\t\tif (targetState != null)\n\t\t\t{\n\t\t\t\tthis.preferHtml = targetState.text != null &&\n\t\t\t\ttargetState.text.node.parentNode == this.graph.container;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Creates bends for the non-routed absolute points\n\t// or bends that don't correspond to points\n\tif (this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells ||\n\t\tmxGraphHandler.prototype.maxCells <= 0)\n\t{\n\t\tthis.bends = this.createBends();\n\n\t\tif (this.isVirtualBendsEnabled())\n\t\t{\n\t\t\tthis.virtualBends = this.createVirtualBends();\n\t\t}\n\t}\n\n\t// Adds a rectangular handle for the label position\n\tthis.label = new mxPoint(this.state.absoluteOffset.x, this.state.absoluteOffset.y);\n\tthis.labelShape = this.createLabelHandleShape();\n\tthis.initBend(this.labelShape);\n\tthis.labelShape.setCursor(mxConstants.CURSOR_LABEL_HANDLE);\n\t\n\tthis.customHandles = this.createCustomHandles();\n\t\n\tthis.updateParentHighlight();\n\tthis.redraw();\n};\n\n\n/**\n * Function: isParentHighlightVisible\n * \n * Returns true if the parent highlight should be visible. This implementation\n * always returns true.\n */\nmxEdgeHandler.prototype.isParentHighlightVisible = mxVertexHandler.prototype.isParentHighlightVisible;\n\n/**\n * Function: updateParentHighlight\n * \n * Updates the highlight of the parent if <parentHighlightEnabled> is true.\n */\nmxEdgeHandler.prototype.updateParentHighlight = mxVertexHandler.prototype.updateParentHighlight;\n\n/**\n * Function: createCustomHandles\n * \n * Returns an array of custom handles. This implementation returns null.\n */\nmxEdgeHandler.prototype.createCustomHandles = function()\n{\n\treturn null;\n};\n\n/**\n * Function: isVirtualBendsEnabled\n * \n * Returns true if virtual bends should be added. This returns true if\n * <virtualBendsEnabled> is true and the current style allows and\n * renders custom waypoints.\n */\nmxEdgeHandler.prototype.isVirtualBendsEnabled = function(evt)\n{\n\treturn this.virtualBendsEnabled && (this.state.style[mxConstants.STYLE_EDGE] == null ||\n\t\t\tthis.state.style[mxConstants.STYLE_EDGE] == mxConstants.NONE ||\n\t\t\tthis.state.style[mxConstants.STYLE_NOEDGESTYLE] == 1)  &&\n\t\t\tmxUtils.getValue(this.state.style, mxConstants.STYLE_SHAPE, null) != 'arrow';\n};\n\n/**\n * Function: isCellEnabled\n * \n * Returns true if the given cell allows new connections to be created. This implementation\n * always returns true.\n */\nmxEdgeHandler.prototype.isCellEnabled = function(cell)\n{\n\treturn true;\n};\n\n/**\n * Function: isAddPointEvent\n * \n * Returns true if the given event is a trigger to add a new point. This\n * implementation returns true if shift is pressed.\n */\nmxEdgeHandler.prototype.isAddPointEvent = function(evt)\n{\n\treturn mxEvent.isShiftDown(evt);\n};\n\n/**\n * Function: isRemovePointEvent\n * \n * Returns true if the given event is a trigger to remove a point. This\n * implementation returns true if shift is pressed.\n */\nmxEdgeHandler.prototype.isRemovePointEvent = function(evt)\n{\n\treturn mxEvent.isShiftDown(evt);\n};\n\n/**\n * Function: getSelectionPoints\n * \n * Returns the list of points that defines the selection stroke.\n */\nmxEdgeHandler.prototype.getSelectionPoints = function(state)\n{\n\treturn state.absolutePoints;\n};\n\n/**\n * Function: createParentHighlightShape\n * \n * Creates the shape used to draw the selection border.\n */\nmxEdgeHandler.prototype.createParentHighlightShape = function(bounds)\n{\n\tvar shape = new mxRectangleShape(mxRectangle.fromRectangle(bounds),\n\t\tnull, this.getSelectionColor());\n\tshape.strokewidth = this.getSelectionStrokeWidth();\n\tshape.isDashed = this.isSelectionDashed();\n\t\n\treturn shape;\n};\n\n/**\n * Function: createSelectionShape\n * \n * Creates the shape used to draw the selection border.\n */\nmxEdgeHandler.prototype.createSelectionShape = function(points)\n{\n\tvar shape = new this.state.shape.constructor();\n\tshape.outline = true;\n\tshape.apply(this.state);\n\t\n\tshape.isDashed = this.isSelectionDashed();\n\tshape.stroke = this.getSelectionColor();\n\tshape.isShadow = false;\n\t\n\treturn shape;\n};\n\n/**\n * Function: getSelectionColor\n * \n * Returns <mxConstants.EDGE_SELECTION_COLOR>.\n */\nmxEdgeHandler.prototype.getSelectionColor = function()\n{\n\treturn mxConstants.EDGE_SELECTION_COLOR;\n};\n\n/**\n * Function: getSelectionStrokeWidth\n * \n * Returns <mxConstants.EDGE_SELECTION_STROKEWIDTH>.\n */\nmxEdgeHandler.prototype.getSelectionStrokeWidth = function()\n{\n\treturn mxConstants.EDGE_SELECTION_STROKEWIDTH;\n};\n\n/**\n * Function: isSelectionDashed\n * \n * Returns <mxConstants.EDGE_SELECTION_DASHED>.\n */\nmxEdgeHandler.prototype.isSelectionDashed = function()\n{\n\treturn mxConstants.EDGE_SELECTION_DASHED;\n};\n\n/**\n * Function: isConnectableCell\n * \n * Returns true if the given cell is connectable. This is a hook to\n * disable floating connections. This implementation returns true.\n */\nmxEdgeHandler.prototype.isConnectableCell = function(cell)\n{\n\treturn true;\n};\n\n/**\n * Function: getCellAt\n * \n * Creates and returns the <mxCellMarker> used in <marker>.\n */\nmxEdgeHandler.prototype.getCellAt = function(x, y)\n{\n\treturn (!this.outlineConnect) ? this.graph.getCellAt(x, y) : null;\n};\n\n/**\n * Function: createMarker\n * \n * Creates and returns the <mxCellMarker> used in <marker>.\n */\nmxEdgeHandler.prototype.createMarker = function()\n{\n\tvar marker = new mxCellMarker(this.graph);\n\tvar self = this; // closure\n\n\t// Only returns edges if they are connectable and never returns\n\t// the edge that is currently being modified\n\tmarker.getCell = function(me)\n\t{\n\t\tvar cell = mxCellMarker.prototype.getCell.apply(this, arguments);\n\n\t\t// Checks for cell at preview point (with grid)\n\t\tif ((cell == self.state.cell || cell == null) && self.currentPoint != null)\n\t\t{\n\t\t\tcell = self.graph.getCellAt(self.currentPoint.x, self.currentPoint.y);\n\t\t}\n\t\t\n\t\t// Uses connectable parent vertex if one exists\n\t\tif (cell != null && !this.graph.isCellConnectable(cell))\n\t\t{\n\t\t\tvar parent = this.graph.getModel().getParent(cell);\n\t\t\t\n\t\t\tif (this.graph.getModel().isVertex(parent) && this.graph.isCellConnectable(parent))\n\t\t\t{\n\t\t\t\tcell = parent;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar model = self.graph.getModel();\n\t\t\n\t\tif ((this.graph.isSwimlane(cell) && self.currentPoint != null &&\n\t\t\tthis.graph.hitsSwimlaneContent(cell, self.currentPoint.x, self.currentPoint.y)) ||\n\t\t\t(!self.isConnectableCell(cell)) || (cell == self.state.cell ||\n\t\t\t(cell != null && !self.graph.connectableEdges && model.isEdge(cell))) ||\n\t\t\tmodel.isAncestor(self.state.cell, cell))\n\t\t{\n\t\t\tcell = null;\n\t\t}\n\t\t\n\t\tif (!this.graph.isCellConnectable(cell))\n\t\t{\n\t\t\tcell = null;\n\t\t}\n\t\t\n\t\treturn cell;\n\t};\n\n\t// Sets the highlight color according to validateConnection\n\tmarker.isValidState = function(state)\n\t{\n\t\tvar model = self.graph.getModel();\n\t\tvar other = self.graph.view.getTerminalPort(state,\n\t\t\tself.graph.view.getState(model.getTerminal(self.state.cell,\n\t\t\t!self.isSource)), !self.isSource);\n\t\tvar otherCell = (other != null) ? other.cell : null;\n\t\tvar source = (self.isSource) ? state.cell : otherCell;\n\t\tvar target = (self.isSource) ? otherCell : state.cell;\n\t\t\n\t\t// Updates the error message of the handler\n\t\tself.error = self.validateConnection(source, target);\n\n\t\treturn self.error == null;\n\t};\n\t\n\treturn marker;\n};\n\n/**\n * Function: validateConnection\n * \n * Returns the error message or an empty string if the connection for the\n * given source, target pair is not valid. Otherwise it returns null. This\n * implementation uses <mxGraph.getEdgeValidationError>.\n * \n * Parameters:\n * \n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n */\nmxEdgeHandler.prototype.validateConnection = function(source, target)\n{\n\treturn this.graph.getEdgeValidationError(this.state.cell, source, target);\n};\n\n/**\n * Function: createBends\n * \n * Creates and returns the bends used for modifying the edge. This is\n * typically an array of <mxRectangleShapes>.\n */\n mxEdgeHandler.prototype.createBends = function()\n {\n\tvar cell = this.state.cell;\n\tvar bends = [];\n\n\tfor (var i = 0; i < this.abspoints.length; i++)\n\t{\n\t\tif (this.isHandleVisible(i))\n\t\t{\n\t\t\tvar source = i == 0;\n\t\t\tvar target = i == this.abspoints.length - 1;\n\t\t\tvar terminal = source || target;\n\n\t\t\tif (terminal || this.graph.isCellBendable(cell))\n\t\t\t{\n\t\t\t\t(mxUtils.bind(this, function(index)\n\t\t\t\t{\n\t\t\t\t\tvar bend = this.createHandleShape(index);\n\t\t\t\t\tthis.initBend(bend, mxUtils.bind(this, mxUtils.bind(this, function()\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.dblClickRemoveEnabled)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.removePoint(this.state, index);\n\t\t\t\t\t\t}\n\t\t\t\t\t})));\n\t\n\t\t\t\t\tif (this.isHandleEnabled(i))\n\t\t\t\t\t{\n\t\t\t\t\t\tbend.setCursor((terminal) ? mxConstants.CURSOR_TERMINAL_HANDLE : mxConstants.CURSOR_BEND_HANDLE);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbends.push(bend);\n\t\t\t\t\n\t\t\t\t\tif (!terminal)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.points.push(new mxPoint(0,0));\n\t\t\t\t\t\tbend.node.style.visibility = 'hidden';\n\t\t\t\t\t}\n\t\t\t\t}))(i);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn bends;\n};\n\n/**\n * Function: createVirtualBends\n * \n * Creates and returns the bends used for modifying the edge. This is\n * typically an array of <mxRectangleShapes>.\n */\n mxEdgeHandler.prototype.createVirtualBends = function()\n {\n\tvar cell = this.state.cell;\n\tvar last = this.abspoints[0];\n\tvar bends = [];\n\n\tif (this.graph.isCellBendable(cell))\n\t{\n\t\tfor (var i = 1; i < this.abspoints.length; i++)\n\t\t{\n\t\t\t(mxUtils.bind(this, function(bend)\n\t\t\t{\n\t\t\t\tthis.initBend(bend);\n\t\t\t\tbend.setCursor(mxConstants.CURSOR_VIRTUAL_BEND_HANDLE);\n\t\t\t\tbends.push(bend);\n\t\t\t}))(this.createHandleShape());\n\t\t}\n\t}\n\n\treturn bends;\n};\n\n/**\n * Function: isHandleEnabled\n * \n * Creates the shape used to display the given bend.\n */\nmxEdgeHandler.prototype.isHandleEnabled = function(index)\n{\n\treturn true;\n};\n\n/**\n * Function: isHandleVisible\n * \n * Returns true if the handle at the given index is visible.\n */\nmxEdgeHandler.prototype.isHandleVisible = function(index)\n{\n\tvar source = this.state.getVisibleTerminalState(true);\n\tvar target = this.state.getVisibleTerminalState(false);\n\tvar geo = this.graph.getCellGeometry(this.state.cell);\n\tvar edgeStyle = (geo != null) ? this.graph.view.getEdgeStyle(this.state, geo.points, source, target) : null;\n\n\treturn edgeStyle != mxEdgeStyle.EntityRelation || index == 0 || index == this.abspoints.length - 1;\n};\n\n/**\n * Function: createHandleShape\n * \n * Creates the shape used to display the given bend. Note that the index may be\n * null for special cases, such as when called from\n * <mxElbowEdgeHandler.createVirtualBend>. Only images and rectangles should be\n * returned if support for HTML labels with not foreign objects is required.\n * Index if null for virtual handles.\n */\nmxEdgeHandler.prototype.createHandleShape = function(index)\n{\n\tif (this.handleImage != null)\n\t{\n\t\tvar shape = new mxImageShape(new mxRectangle(0, 0, this.handleImage.width, this.handleImage.height), this.handleImage.src);\n\t\t\n\t\t// Allows HTML rendering of the images\n\t\tshape.preserveImageAspect = false;\n\n\t\treturn shape;\n\t}\n\telse\n\t{\n\t\tvar s = mxConstants.HANDLE_SIZE;\n\t\t\n\t\tif (this.preferHtml)\n\t\t{\n\t\t\ts -= 1;\n\t\t}\n\t\t\n\t\treturn new mxRectangleShape(new mxRectangle(0, 0, s, s), mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);\n\t}\n};\n\n/**\n * Function: createLabelHandleShape\n * \n * Creates the shape used to display the the label handle.\n */\nmxEdgeHandler.prototype.createLabelHandleShape = function()\n{\n\tif (this.labelHandleImage != null)\n\t{\n\t\tvar shape = new mxImageShape(new mxRectangle(0, 0, this.labelHandleImage.width, this.labelHandleImage.height), this.labelHandleImage.src);\n\t\t\n\t\t// Allows HTML rendering of the images\n\t\tshape.preserveImageAspect = false;\n\n\t\treturn shape;\n\t}\n\telse\n\t{\n\t\tvar s = mxConstants.LABEL_HANDLE_SIZE;\n\t\treturn new mxRectangleShape(new mxRectangle(0, 0, s, s), mxConstants.LABEL_HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);\n\t}\n};\n\n/**\n * Function: initBend\n * \n * Helper method to initialize the given bend.\n * \n * Parameters:\n * \n * bend - <mxShape> that represents the bend to be initialized.\n */\nmxEdgeHandler.prototype.initBend = function(bend, dblClick)\n{\n\tif (this.preferHtml)\n\t{\n\t\tbend.dialect = mxConstants.DIALECT_STRICTHTML;\n\t\tbend.init(this.graph.container);\n\t}\n\telse\n\t{\n\t\tbend.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\t\tmxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;\n\t\tbend.init(this.graph.getView().getOverlayPane());\n\t}\n\n\tmxEvent.redirectMouseEvents(bend.node, this.graph, this.state,\n\t\t\tnull, null, null, dblClick);\n\t\n\t// Fixes lost event tracking for images in quirks / IE8 standards\n\tif (mxClient.IS_QUIRKS || document.documentMode == 8)\n\t{\n\t\tmxEvent.addListener(bend.node, 'dragstart', function(evt)\n\t\t{\n\t\t\tmxEvent.consume(evt);\n\t\t\t\n\t\t\treturn false;\n\t\t});\n\t}\n\t\n\tif (mxClient.IS_TOUCH)\n\t{\n\t\tbend.node.setAttribute('pointer-events', 'none');\n\t}\n};\n\n/**\n * Function: getHandleForEvent\n * \n * Returns the index of the handle for the given event.\n */\nmxEdgeHandler.prototype.getHandleForEvent = function(me)\n{\n\tvar result = null;\n\t\n\tif (this.state != null)\n\t{\n\t\t// Connection highlight may consume events before they reach sizer handle\n\t\tvar tol = (!mxEvent.isMouseEvent(me.getEvent())) ? this.tolerance : 1;\n\t\tvar hit = (this.allowHandleBoundsCheck && (mxClient.IS_IE || tol > 0)) ?\n\t\t\tnew mxRectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;\n\t\tvar minDistSq = null;\n\t\n\t\tfunction checkShape(shape)\n\t\t{\n\t\t\tif (shape != null && shape.node != null && shape.node.style.display != 'none' &&\n\t\t\t\tshape.node.style.visibility != 'hidden' &&\n\t\t\t\t(me.isSource(shape) || (hit != null && mxUtils.intersects(shape.bounds, hit))))\n\t\t\t{\n\t\t\t\tvar dx = me.getGraphX() - shape.bounds.getCenterX();\n\t\t\t\tvar dy = me.getGraphY() - shape.bounds.getCenterY();\n\t\t\t\tvar tmp = dx * dx + dy * dy;\n\t\t\t\t\n\t\t\t\tif (minDistSq == null || tmp <= minDistSq)\n\t\t\t\t{\n\t\t\t\t\tminDistSq = tmp;\n\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (this.customHandles != null && this.isCustomHandleEvent(me))\n\t\t{\n\t\t\t// Inverse loop order to match display order\n\t\t\tfor (var i = this.customHandles.length - 1; i >= 0; i--)\n\t\t\t{\n\t\t\t\tif (checkShape(this.customHandles[i].shape))\n\t\t\t\t{\n\t\t\t\t\t// LATER: Return reference to active shape\n\t\t\t\t\treturn mxEvent.CUSTOM_HANDLE - i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tif (me.isSource(this.state.text) || checkShape(this.labelShape))\n\t\t{\n\t\t\tresult = mxEvent.LABEL_HANDLE;\n\t\t}\n\t\t\n\t\tif (this.bends != null)\n\t\t{\n\t\t\tfor (var i = 0; i < this.bends.length; i++)\n\t\t\t{\n\t\t\t\tif (checkShape(this.bends[i]))\n\t\t\t\t{\n\t\t\t\t\tresult = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (this.virtualBends != null && this.isAddVirtualBendEvent(me))\n\t\t{\n\t\t\tfor (var i = 0; i < this.virtualBends.length; i++)\n\t\t\t{\n\t\t\t\tif (checkShape(this.virtualBends[i]))\n\t\t\t\t{\n\t\t\t\t\tresult = mxEvent.VIRTUAL_HANDLE - i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: isAddVirtualBendEvent\n * \n * Returns true if the given event allows virtual bends to be added. This\n * implementation returns true.\n */\nmxEdgeHandler.prototype.isAddVirtualBendEvent = function(me)\n{\n\treturn true;\n};\n\n/**\n * Function: isCustomHandleEvent\n * \n * Returns true if the given event allows custom handles to be changed. This\n * implementation returns true.\n */\nmxEdgeHandler.prototype.isCustomHandleEvent = function(me)\n{\n\treturn true;\n};\n\n/**\n * Function: mouseDown\n * \n * Handles the event by checking if a special element of the handler\n * was clicked, in which case the index parameter is non-null. The\n * indices may be one of <LABEL_HANDLE> or the number of the respective\n * control point. The source and target points are used for reconnecting\n * the edge.\n */\nmxEdgeHandler.prototype.mouseDown = function(sender, me)\n{\n\tvar handle = this.getHandleForEvent(me);\n\t\n\tif (this.bends != null && this.bends[handle] != null)\n\t{\n\t\tvar b = this.bends[handle].bounds;\n\t\tthis.snapPoint = new mxPoint(b.getCenterX(), b.getCenterY());\n\t}\n\t\n\tif (this.addEnabled && handle == null && this.isAddPointEvent(me.getEvent()))\n\t{\n\t\tthis.addPoint(this.state, me.getEvent());\n\t\tme.consume();\n\t}\n\telse if (handle != null && !me.isConsumed() && this.graph.isEnabled())\n\t{\n\t\tif (this.removeEnabled && this.isRemovePointEvent(me.getEvent()))\n\t\t{\n\t\t\tthis.removePoint(this.state, handle);\n\t\t}\n\t\telse if (handle != mxEvent.LABEL_HANDLE || this.graph.isLabelMovable(me.getCell()))\n\t\t{\n\t\t\tif (handle <= mxEvent.VIRTUAL_HANDLE)\n\t\t\t{\n\t\t\t\tmxUtils.setOpacity(this.virtualBends[mxEvent.VIRTUAL_HANDLE - handle].node, 100);\n\t\t\t}\n\t\t\t\n\t\t\tthis.start(me.getX(), me.getY(), handle);\n\t\t}\n\t\t\n\t\tme.consume();\n\t}\n};\n\n/**\n * Function: start\n * \n * Starts the handling of the mouse gesture.\n */\nmxEdgeHandler.prototype.start = function(x, y, index)\n{\n\tthis.startX = x;\n\tthis.startY = y;\n\n\tthis.isSource = (this.bends == null) ? false : index == 0;\n\tthis.isTarget = (this.bends == null) ? false : index == this.bends.length - 1;\n\tthis.isLabel = index == mxEvent.LABEL_HANDLE;\n\n\tif (this.isSource || this.isTarget)\n\t{\n\t\tvar cell = this.state.cell;\n\t\tvar terminal = this.graph.model.getTerminal(cell, this.isSource);\n\n\t\tif ((terminal == null && this.graph.isTerminalPointMovable(cell, this.isSource)) ||\n\t\t\t(terminal != null && this.graph.isCellDisconnectable(cell, terminal, this.isSource)))\n\t\t{\n\t\t\tthis.index = index;\n\t\t}\n\t}\n\telse\n\t{\n\t\tthis.index = index;\n\t}\n\t\n\t// Hides other custom handles\n\tif (this.index <= mxEvent.CUSTOM_HANDLE && this.index > mxEvent.VIRTUAL_HANDLE)\n\t{\n\t\tif (this.customHandles != null)\n\t\t{\n\t\t\tfor (var i = 0; i < this.customHandles.length; i++)\n\t\t\t{\n\t\t\t\tif (i != mxEvent.CUSTOM_HANDLE - this.index)\n\t\t\t\t{\n\t\t\t\t\tthis.customHandles[i].setVisible(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: clonePreviewState\n * \n * Returns a clone of the current preview state for the given point and terminal.\n */\nmxEdgeHandler.prototype.clonePreviewState = function(point, terminal)\n{\n\treturn this.state.clone();\n};\n\n/**\n * Function: getSnapToTerminalTolerance\n * \n * Returns the tolerance for the guides. Default value is\n * gridSize * scale / 2.\n */\nmxEdgeHandler.prototype.getSnapToTerminalTolerance = function()\n{\n\treturn this.graph.gridSize * this.graph.view.scale / 2;\n};\n\n/**\n * Function: updateHint\n * \n * Hook for subclassers do show details while the handler is active.\n */\nmxEdgeHandler.prototype.updateHint = function(me, point) { };\n\n/**\n * Function: removeHint\n * \n * Hooks for subclassers to hide details when the handler gets inactive.\n */\nmxEdgeHandler.prototype.removeHint = function() { };\n\n/**\n * Function: roundLength\n * \n * Hook for rounding the unscaled width or height. This uses Math.round.\n */\nmxEdgeHandler.prototype.roundLength = function(length)\n{\n\treturn Math.round(length);\n};\n\n/**\n * Function: isSnapToTerminalsEvent\n * \n * Returns true if <snapToTerminals> is true and if alt is not pressed.\n */\nmxEdgeHandler.prototype.isSnapToTerminalsEvent = function(me)\n{\n\treturn this.snapToTerminals && !mxEvent.isAltDown(me.getEvent());\n};\n\n/**\n * Function: getPointForEvent\n * \n * Returns the point for the given event.\n */\nmxEdgeHandler.prototype.getPointForEvent = function(me)\n{\n\tvar view = this.graph.getView();\n\tvar scale = view.scale;\n\tvar point = new mxPoint(this.roundLength(me.getGraphX() / scale) * scale,\n\t\tthis.roundLength(me.getGraphY() / scale) * scale);\n\t\n\tvar tt = this.getSnapToTerminalTolerance();\n\tvar overrideX = false;\n\tvar overrideY = false;\t\t\n\t\n\tif (tt > 0 && this.isSnapToTerminalsEvent(me))\n\t{\n\t\tfunction snapToPoint(pt)\n\t\t{\n\t\t\tif (pt != null)\n\t\t\t{\n\t\t\t\tvar x = pt.x;\n\n\t\t\t\tif (Math.abs(point.x - x) < tt)\n\t\t\t\t{\n\t\t\t\t\tpoint.x = x;\n\t\t\t\t\toverrideX = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar y = pt.y;\n\n\t\t\t\tif (Math.abs(point.y - y) < tt)\n\t\t\t\t{\n\t\t\t\t\tpoint.y = y;\n\t\t\t\t\toverrideY = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Temporary function\n\t\tfunction snapToTerminal(terminal)\n\t\t{\n\t\t\tif (terminal != null)\n\t\t\t{\n\t\t\t\tsnapToPoint.call(this, new mxPoint(view.getRoutingCenterX(terminal),\n\t\t\t\t\t\tview.getRoutingCenterY(terminal)));\n\t\t\t}\n\t\t};\n\n\t\tsnapToTerminal.call(this, this.state.getVisibleTerminalState(true));\n\t\tsnapToTerminal.call(this, this.state.getVisibleTerminalState(false));\n\n\t\tif (this.state.absolutePoints != null)\n\t\t{\n\t\t\tfor (var i = 0; i < this.state.absolutePoints.length; i++)\n\t\t\t{\n\t\t\t\tsnapToPoint.call(this, this.state.absolutePoints[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (this.graph.isGridEnabledEvent(me.getEvent()))\n\t{\n\t\tvar tr = view.translate;\n\t\t\n\t\tif (!overrideX)\n\t\t{\n\t\t\tpoint.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;\n\t\t}\n\t\t\n\t\tif (!overrideY)\n\t\t{\n\t\t\tpoint.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;\n\t\t}\n\t}\n\t\n\treturn point;\n};\n\n/**\n * Function: getPreviewTerminalState\n * \n * Updates the given preview state taking into account the state of the constraint handler.\n */\nmxEdgeHandler.prototype.getPreviewTerminalState = function(me)\n{\n\tthis.constraintHandler.update(me, this.isSource, true, me.isSource(this.marker.highlight.shape) ? null : this.currentPoint);\n\t\n\tif (this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null)\n\t{\n\t\t// Handles special case where grid is large and connection point is at actual point in which\n\t\t// case the outline is not followed as long as we're < gridSize / 2 away from that point\n\t\tif (this.marker.highlight != null && this.marker.highlight.state != null &&\n\t\t\tthis.marker.highlight.state.cell == this.constraintHandler.currentFocus.cell)\n\t\t{\n\t\t\t// Direct repaint needed if cell already highlighted\n\t\t\tif (this.marker.highlight.shape.stroke != 'transparent')\n\t\t\t{\n\t\t\t\tthis.marker.highlight.shape.stroke = 'transparent';\n\t\t\t\tthis.marker.highlight.repaint();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent');\n\t\t}\n\t\t\n\t\tvar model = this.graph.getModel();\n\t\tvar other = this.graph.view.getTerminalPort(this.state,\n\t\t\t\tthis.graph.view.getState(model.getTerminal(this.state.cell,\n\t\t\t!this.isSource)), !this.isSource);\n\t\tvar otherCell = (other != null) ? other.cell : null;\n\t\tvar source = (this.isSource) ? this.constraintHandler.currentFocus.cell : otherCell;\n\t\tvar target = (this.isSource) ? otherCell : this.constraintHandler.currentFocus.cell;\n\t\t\n\t\t// Updates the error message of the handler\n\t\tthis.error = this.validateConnection(source, target);\n\t\tvar result = null;\n\t\t\n\t\tif (this.error == null)\n\t\t{\n\t\t\tresult = this.constraintHandler.currentFocus;\n\t\t}\n\t\t\n\t\tif (this.error != null || (result != null &&\n\t\t\t!this.isCellEnabled(result.cell)))\n\t\t{\n\t\t\tthis.constraintHandler.reset();\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\telse if (!this.graph.isIgnoreTerminalEvent(me.getEvent()))\n\t{\n\t\tthis.marker.process(me);\n\t\tvar state = this.marker.getValidState();\n\t\t\n\t\tif (state != null && !this.isCellEnabled(state.cell))\n\t\t{\n\t\t\tthis.constraintHandler.reset();\n\t\t\tthis.marker.reset();\n\t\t}\n\t\t\n\t\treturn this.marker.getValidState();\n\t}\n\telse\n\t{\n\t\tthis.marker.reset();\n\t\t\n\t\treturn null;\n\t}\n};\n\n/**\n * Function: getPreviewPoints\n * \n * Updates the given preview state taking into account the state of the constraint handler.\n * \n * Parameters:\n * \n * pt - <mxPoint> that contains the current pointer position.\n * me - Optional <mxMouseEvent> that contains the current event.\n */\nmxEdgeHandler.prototype.getPreviewPoints = function(pt, me)\n{\n\tvar geometry = this.graph.getCellGeometry(this.state.cell);\n\tvar points = (geometry.points != null) ? geometry.points.slice() : null;\n\tvar point = new mxPoint(pt.x, pt.y);\n\tvar result = null;\n\t\n\tif (!this.isSource && !this.isTarget)\n\t{\n\t\tthis.convertPoint(point, false);\n\t\t\n\t\tif (points == null)\n\t\t{\n\t\t\tpoints = [point];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Adds point from virtual bend\n\t\t\tif (this.index <= mxEvent.VIRTUAL_HANDLE)\n\t\t\t{\n\t\t\t\tpoints.splice(mxEvent.VIRTUAL_HANDLE - this.index, 0, point);\n\t\t\t}\n\n\t\t\t// Removes point if dragged on terminal point\n\t\t\tif (!this.isSource && !this.isTarget)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < this.bends.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (i != this.index)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar bend = this.bends[i];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (bend != null && mxUtils.contains(bend.bounds, pt.x, pt.y))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (this.index <= mxEvent.VIRTUAL_HANDLE)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpoints.splice(mxEvent.VIRTUAL_HANDLE - this.index, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpoints.splice(this.index - 1, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tresult = points;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Removes point if user tries to straighten a segment\n\t\t\t\tif (result == null && this.straightRemoveEnabled && (me == null || !mxEvent.isAltDown(me.getEvent())))\n\t\t\t\t{\n\t\t\t\t\tvar tol = this.graph.tolerance * this.graph.tolerance;\n\t\t\t\t\tvar abs = this.state.absolutePoints.slice();\n\t\t\t\t\tabs[this.index] = pt;\n\t\t\t\t\t\n\t\t\t\t\t// Handes special case where removing waypoint affects tolerance (flickering)\n\t\t\t\t\tvar src = this.state.getVisibleTerminalState(true);\n\t\t\t\t\t\n\t\t\t\t\tif (src != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar c = this.graph.getConnectionConstraint(this.state, src, true);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Checks if point is not fixed\n\t\t\t\t\t\tif (c == null || this.graph.getConnectionPoint(src, c) == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tabs[0] = new mxPoint(src.view.getRoutingCenterX(src), src.view.getRoutingCenterY(src));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar trg = this.state.getVisibleTerminalState(false);\n\t\t\t\t\t\n\t\t\t\t\tif (trg != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar c = this.graph.getConnectionConstraint(this.state, trg, false);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Checks if point is not fixed\n\t\t\t\t\t\tif (c == null || this.graph.getConnectionPoint(trg, c) == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tabs[abs.length - 1] = new mxPoint(trg.view.getRoutingCenterX(trg), trg.view.getRoutingCenterY(trg));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction checkRemove(idx, tmp)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (idx > 0 && idx < abs.length - 1 &&\n\t\t\t\t\t\t\tmxUtils.ptSegDistSq(abs[idx - 1].x, abs[idx - 1].y,\n\t\t\t\t\t\t\t\tabs[idx + 1].x, abs[idx + 1].y, tmp.x, tmp.y) < tol)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpoints.splice(idx - 1, 1);\n\t\t\t\t\t\t\tresult = points;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\t// LATER: Check if other points can be removed if a segment is made straight\n\t\t\t\t\tcheckRemove(this.index, pt);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Updates existing point\n\t\t\tif (result == null && this.index > mxEvent.VIRTUAL_HANDLE)\n\t\t\t{\n\t\t\t\tpoints[this.index - 1] = point;\n\t\t\t}\n\t\t}\n\t}\n\telse if (this.graph.resetEdgesOnConnect)\n\t{\n\t\tpoints = null;\n\t}\n\t\n\treturn (result != null) ? result : points;\n};\n\n/**\n * Function: isOutlineConnectEvent\n * \n * Returns true if <outlineConnect> is true and the source of the event is the outline shape\n * or shift is pressed.\n */\nmxEdgeHandler.prototype.isOutlineConnectEvent = function(me)\n{\n\tvar offset = mxUtils.getOffset(this.graph.container);\n\tvar evt = me.getEvent();\n\t\n\tvar clientX = mxEvent.getClientX(evt);\n\tvar clientY = mxEvent.getClientY(evt);\n\t\n\tvar doc = document.documentElement;\n\tvar left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n\tvar top = (window.pageYOffset || doc.scrollTop)  - (doc.clientTop || 0);\n\t\n\tvar gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;\n\tvar gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;\n\n\treturn this.outlineConnect && !mxEvent.isShiftDown(me.getEvent()) &&\n\t\t(me.isSource(this.marker.highlight.shape) ||\n\t\t(mxEvent.isAltDown(me.getEvent()) && me.getState() != null) ||\n\t\tthis.marker.highlight.isHighlightAt(clientX, clientY) ||\n\t\t((gridX != clientX || gridY != clientY) && me.getState() == null &&\n\t\tthis.marker.highlight.isHighlightAt(gridX, gridY)));\n};\n\n/**\n * Function: updatePreviewState\n * \n * Updates the given preview state taking into account the state of the constraint handler.\n */\nmxEdgeHandler.prototype.updatePreviewState = function(edge, point, terminalState, me, outline)\n{\n\t// Computes the points for the edge style and terminals\n\tvar sourceState = (this.isSource) ? terminalState : this.state.getVisibleTerminalState(true);\n\tvar targetState = (this.isTarget) ? terminalState : this.state.getVisibleTerminalState(false);\n\t\n\tvar sourceConstraint = this.graph.getConnectionConstraint(edge, sourceState, true);\n\tvar targetConstraint = this.graph.getConnectionConstraint(edge, targetState, false);\n\n\tvar constraint = this.constraintHandler.currentConstraint;\n\n\tif (constraint == null && outline)\n\t{\n\t\tif (terminalState != null)\n\t\t{\n\t\t\t// Handles special case where mouse is on outline away from actual end point\n\t\t\t// in which case the grid is ignored and mouse point is used instead\n\t\t\tif (me.isSource(this.marker.highlight.shape))\n\t\t\t{\n\t\t\t\tpoint = new mxPoint(me.getGraphX(), me.getGraphY());\n\t\t\t}\n\t\t\t\n\t\t\tconstraint = this.graph.getOutlineConstraint(point, terminalState, me);\n\t\t\tthis.constraintHandler.setFocus(me, terminalState, this.isSource);\n\t\t\tthis.constraintHandler.currentConstraint = constraint;\n\t\t\tthis.constraintHandler.currentPoint = point;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconstraint = new mxConnectionConstraint();\n\t\t}\n\t}\n\t\n\tif (this.outlineConnect && this.marker.highlight != null && this.marker.highlight.shape != null)\n\t{\n\t\tvar s = this.graph.view.scale;\n\t\t\n\t\tif (this.constraintHandler.currentConstraint != null &&\n\t\t\tthis.constraintHandler.currentFocus != null)\n\t\t{\n\t\t\tthis.marker.highlight.shape.stroke = (outline) ? mxConstants.OUTLINE_HIGHLIGHT_COLOR : 'transparent';\n\t\t\tthis.marker.highlight.shape.strokewidth = mxConstants.OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;\n\t\t\tthis.marker.highlight.repaint();\n\t\t}\n\t\telse if (this.marker.hasValidState())\n\t\t{\n\t\t\tthis.marker.highlight.shape.stroke = (this.graph.isCellConnectable(me.getCell()) &&\n\t\t\t\tthis.marker.getValidState() != me.getState()) ?\n\t\t\t\t'transparent' : mxConstants.DEFAULT_VALID_COLOR;\n\t\t\tthis.marker.highlight.shape.strokewidth = mxConstants.HIGHLIGHT_STROKEWIDTH / s / s;\n\t\t\tthis.marker.highlight.repaint();\n\t\t}\n\t}\n\t\n\tif (this.isSource)\n\t{\n\t\tsourceConstraint = constraint;\n\t}\n\telse if (this.isTarget)\n\t{\n\t\ttargetConstraint = constraint;\n\t}\n\t\n\tif (this.isSource || this.isTarget)\n\t{\n\t\tif (constraint != null && constraint.point != null)\n\t\t{\n\t\t\tedge.style[(this.isSource) ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X] = constraint.point.x;\n\t\t\tedge.style[(this.isSource) ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y] = constraint.point.y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdelete edge.style[(this.isSource) ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X];\n\t\t\tdelete edge.style[(this.isSource) ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y];\n\t\t}\n\t}\n\t\n\tedge.setVisibleTerminalState(sourceState, true);\n\tedge.setVisibleTerminalState(targetState, false);\n\t\n\tif (!this.isSource || sourceState != null)\n\t{\n\t\tedge.view.updateFixedTerminalPoint(edge, sourceState, true, sourceConstraint);\n\t}\n\t\n\tif (!this.isTarget || targetState != null)\n\t{\n\t\tedge.view.updateFixedTerminalPoint(edge, targetState, false, targetConstraint);\n\t}\n\t\n\tif ((this.isSource || this.isTarget) && terminalState == null)\n\t{\n\t\tedge.setAbsoluteTerminalPoint(point, this.isSource);\n\n\t\tif (this.marker.getMarkedState() == null)\n\t\t{\n\t\t\tthis.error = (this.graph.allowDanglingEdges) ? null : '';\n\t\t}\n\t}\n\t\n\tedge.view.updatePoints(edge, this.points, sourceState, targetState);\n\tedge.view.updateFloatingTerminalPoints(edge, sourceState, targetState);\n};\n\n/**\n * Function: mouseMove\n * \n * Handles the event by updating the preview.\n */\nmxEdgeHandler.prototype.mouseMove = function(sender, me)\n{\n\tif (this.index != null && this.marker != null)\n\t{\n\t\tthis.currentPoint = this.getPointForEvent(me);\n\t\tthis.error = null;\n\t\t\n\t\t// Uses the current point from the constraint handler if available\n\t\tif (!this.graph.isIgnoreTerminalEvent(me.getEvent()) && mxEvent.isShiftDown(me.getEvent()) && this.snapPoint != null)\n\t\t{\n\t\t\tif (Math.abs(this.snapPoint.x - this.currentPoint.x) < Math.abs(this.snapPoint.y - this.currentPoint.y))\n\t\t\t{\n\t\t\t\tthis.currentPoint.x = this.snapPoint.x;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.currentPoint.y = this.snapPoint.y;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (this.index <= mxEvent.CUSTOM_HANDLE && this.index > mxEvent.VIRTUAL_HANDLE)\n\t\t{\n\t\t\tif (this.customHandles != null)\n\t\t\t{\n\t\t\t\tthis.customHandles[mxEvent.CUSTOM_HANDLE - this.index].processEvent(me);\n\t\t\t\tthis.customHandles[mxEvent.CUSTOM_HANDLE - this.index].positionChanged();\n\t\t\t\t\n\t\t\t\tif (this.shape != null && this.shape.node != null)\n\t\t\t\t{\n\t\t\t\t\tthis.shape.node.style.display = 'none';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (this.isLabel)\n\t\t{\n\t\t\tthis.label.x = this.currentPoint.x;\n\t\t\tthis.label.y = this.currentPoint.y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.points = this.getPreviewPoints(this.currentPoint, me);\n\t\t\tvar terminalState = (this.isSource || this.isTarget) ? this.getPreviewTerminalState(me) : null;\n\t\t\t\n\t\t\tif (this.constraintHandler.currentConstraint != null &&\n\t\t\t\tthis.constraintHandler.currentFocus != null &&\n\t\t\t\tthis.constraintHandler.currentPoint != null)\n\t\t\t{\n\t\t\t\tthis.currentPoint = this.constraintHandler.currentPoint.clone();\n\t\t\t}\n\t\t\telse if (this.outlineConnect)\n\t\t\t{\n\t\t\t\t// Need to check outline before cloning terminal state\n\t\t\t\tvar outline = (this.isSource || this.isTarget) ? this.isOutlineConnectEvent(me) : false\n\t\t\t\t\t\t\n\t\t\t\tif (outline)\n\t\t\t\t{\n\t\t\t\t\tterminalState = this.marker.highlight.state;\n\t\t\t\t}\n\t\t\t\telse if (terminalState != null && terminalState != me.getState() &&\n\t\t\t\t\tthis.graph.isCellConnectable(me.getCell()) &&\n\t\t\t\t\tthis.marker.highlight.shape != null)\n\t\t\t\t{\n\t\t\t\t\tthis.marker.highlight.shape.stroke = 'transparent';\n\t\t\t\t\tthis.marker.highlight.repaint();\n\t\t\t\t\tterminalState = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (terminalState != null && !this.isCellEnabled(terminalState.cell))\n\t\t\t{\n\t\t\t\tterminalState = null;\n\t\t\t\tthis.marker.reset();\n\t\t\t}\n\t\t\t\n\t\t\tvar clone = this.clonePreviewState(this.currentPoint, (terminalState != null) ? terminalState.cell : null);\n\t\t\tthis.updatePreviewState(clone, this.currentPoint, terminalState, me, outline);\n\n\t\t\t// Sets the color of the preview to valid or invalid, updates the\n\t\t\t// points of the preview and redraws\n\t\t\tvar color = (this.error == null) ? this.marker.validColor : this.marker.invalidColor;\n\t\t\tthis.setPreviewColor(color);\n\t\t\tthis.abspoints = clone.absolutePoints;\n\t\t\tthis.active = true;\n\t\t\tthis.updateHint(me, this.currentPoint);\n\t\t}\n\n\t\t// This should go before calling isOutlineConnectEvent above. As a workaround\n\t\t// we add an offset of gridSize to the hint to avoid problem with hit detection\n\t\t// in highlight.isHighlightAt (which uses comonentFromPoint)\n\t\tthis.drawPreview();\n\t\tmxEvent.consume(me.getEvent());\n\t\tme.consume();\n\t}\n\t// Workaround for disabling the connect highlight when over handle\n\telse if (mxClient.IS_IE && this.getHandleForEvent(me) != null)\n\t{\n\t\tme.consume(false);\n\t}\n};\n\n/**\n * Function: mouseUp\n * \n * Handles the event to applying the previewed changes on the edge by\n * using <moveLabel>, <connect> or <changePoints>.\n */\nmxEdgeHandler.prototype.mouseUp = function(sender, me)\n{\n\t// Workaround for wrong event source in Webkit\n\tif (this.index != null && this.marker != null)\n\t{\n\t\tif (this.shape != null && this.shape.node != null)\n\t\t{\n\t\t\tthis.shape.node.style.display = '';\n\t\t}\n\t\t\n\t\tvar edge = this.state.cell;\n\t\tvar index = this.index;\n\t\tthis.index = null;\n\n\t\t// Ignores event if mouse has not been moved\n\t\tif (me.getX() != this.startX || me.getY() != this.startY)\n\t\t{\n\t\t\tvar clone = !this.graph.isIgnoreTerminalEvent(me.getEvent()) && this.graph.isCloneEvent(me.getEvent()) &&\n\t\t\t\tthis.cloneEnabled && this.graph.isCellsCloneable();\n\t\t\t\n\t\t\t// Displays the reason for not carriying out the change\n\t\t\t// if there is an error message with non-zero length\n\t\t\tif (this.error != null)\n\t\t\t{\n\t\t\t\tif (this.error.length > 0)\n\t\t\t\t{\n\t\t\t\t\tthis.graph.validationAlert(this.error);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (index <= mxEvent.CUSTOM_HANDLE && index > mxEvent.VIRTUAL_HANDLE)\n\t\t\t{\n\t\t\t\tif (this.customHandles != null)\n\t\t\t\t{\n\t\t\t\t\tvar model = this.graph.getModel();\n\t\t\t\t\t\n\t\t\t\t\tmodel.beginUpdate();\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.customHandles[mxEvent.CUSTOM_HANDLE - index].execute(me);\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tif (this.shape != null && this.shape.node != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.shape.apply(this.state);\n\t\t\t\t\t\t\tthis.shape.redraw();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinally\n\t\t\t\t\t{\n\t\t\t\t\t\tmodel.endUpdate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (this.isLabel)\n\t\t\t{\n\t\t\t\tthis.moveLabel(this.state, this.label.x, this.label.y);\n\t\t\t}\n\t\t\telse if (this.isSource || this.isTarget)\n\t\t\t{\n\t\t\t\tvar terminal = null;\n\t\t\t\t\n\t\t\t\tif (this.constraintHandler.currentConstraint != null &&\n\t\t\t\t\tthis.constraintHandler.currentFocus != null)\n\t\t\t\t{\n\t\t\t\t\tterminal = this.constraintHandler.currentFocus.cell;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (terminal == null && this.marker.hasValidState() && this.marker.highlight != null &&\n\t\t\t\t\tthis.marker.highlight.shape != null &&\n\t\t\t\t\tthis.marker.highlight.shape.stroke != 'transparent' &&\n\t\t\t\t\tthis.marker.highlight.shape.stroke != 'white')\n\t\t\t\t{\n\t\t\t\t\tterminal = this.marker.validState.cell;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (terminal != null)\n\t\t\t\t{\n\t\t\t\t\tvar model = this.graph.getModel();\n\t\t\t\t\tvar parent = model.getParent(edge);\n\t\t\t\t\t\n\t\t\t\t\tmodel.beginUpdate();\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\t// Clones and adds the cell\n\t\t\t\t\t\tif (clone)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar geo = model.getGeometry(edge);\n\t\t\t\t\t\t\tvar clone = this.graph.cloneCell(edge);\n\t\t\t\t\t\t\tmodel.add(parent, clone, model.getChildCount(parent));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (geo != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\t\t\tmodel.setGeometry(clone, geo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar other = model.getTerminal(edge, !this.isSource);\n\t\t\t\t\t\t\tthis.graph.connectCell(clone, other, !this.isSource);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tedge = clone;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tedge = this.connect(edge, terminal, this.isSource, clone, me);\n\t\t\t\t\t}\n\t\t\t\t\tfinally\n\t\t\t\t\t{\n\t\t\t\t\t\tmodel.endUpdate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (this.graph.isAllowDanglingEdges())\n\t\t\t\t{\n\t\t\t\t\tvar pt = this.abspoints[(this.isSource) ? 0 : this.abspoints.length - 1];\n\t\t\t\t\tpt.x = this.roundLength(pt.x / this.graph.view.scale - this.graph.view.translate.x);\n\t\t\t\t\tpt.y = this.roundLength(pt.y / this.graph.view.scale - this.graph.view.translate.y);\n\n\t\t\t\t\tvar pstate = this.graph.getView().getState(\n\t\t\t\t\t\t\tthis.graph.getModel().getParent(edge));\n\t\t\t\t\t\t\t\n\t\t\t\t\tif (pstate != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tpt.x -= pstate.origin.x;\n\t\t\t\t\t\tpt.y -= pstate.origin.y;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpt.x -= this.graph.panDx / this.graph.view.scale;\n\t\t\t\t\tpt.y -= this.graph.panDy / this.graph.view.scale;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t// Destroys and recreates this handler\n\t\t\t\t\tedge = this.changeTerminalPoint(edge, pt, this.isSource, clone);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (this.active)\n\t\t\t{\n\t\t\t\tedge = this.changePoints(edge, this.points, clone);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.graph.getView().invalidate(this.state.cell);\n\t\t\t\tthis.graph.getView().validate(this.state.cell);\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t\telse if (this.graph.isToggleEvent(me.getEvent()))\n\t\t{\n\t\t\tthis.graph.selectCellForEvent(this.state.cell, me.getEvent());\n\t\t}\n\n\t\t// Resets the preview color the state of the handler if this\n\t\t// handler has not been recreated\n\t\tif (this.marker != null)\n\t\t{\n\t\t\tthis.reset();\n\n\t\t\t// Updates the selection if the edge has been cloned\n\t\t\tif (edge != this.state.cell)\n\t\t\t{\n\t\t\t\tthis.graph.setSelectionCell(edge);\n\t\t\t}\n\t\t}\n\n\t\tme.consume();\n\t}\n};\n\n/**\n * Function: reset\n * \n * Resets the state of this handler.\n */\nmxEdgeHandler.prototype.reset = function()\n{\n\tif (this.active)\n\t{\n\t\tthis.refresh();\n\t}\n\t\n\tthis.error = null;\n\tthis.index = null;\n\tthis.label = null;\n\tthis.points = null;\n\tthis.snapPoint = null;\n\tthis.isLabel = false;\n\tthis.isSource = false;\n\tthis.isTarget = false;\n\tthis.active = false;\n\t\n\tif (this.livePreview && this.sizers != null)\n\t{\n\t\tfor (var i = 0; i < this.sizers.length; i++)\n\t\t{\n\t\t\tif (this.sizers[i] != null)\n\t\t\t{\n\t\t\t\tthis.sizers[i].node.style.display = '';\n\t\t\t}\n\t\t}\n\t}\n\n\tif (this.marker != null)\n\t{\n\t\tthis.marker.reset();\n\t}\n\t\n\tif (this.constraintHandler != null)\n\t{\n\t\tthis.constraintHandler.reset();\n\t}\n\t\n\tif (this.customHandles != null)\n\t{\n\t\tfor (var i = 0; i < this.customHandles.length; i++)\n\t\t{\n\t\t\tthis.customHandles[i].reset();\n\t\t}\n\t}\n\n\tthis.setPreviewColor(mxConstants.EDGE_SELECTION_COLOR);\n\tthis.removeHint();\n\tthis.redraw();\n};\n\n/**\n * Function: setPreviewColor\n * \n * Sets the color of the preview to the given value.\n */\nmxEdgeHandler.prototype.setPreviewColor = function(color)\n{\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.stroke = color;\n\t}\n};\n\n\n/**\n * Function: convertPoint\n * \n * Converts the given point in-place from screen to unscaled, untranslated\n * graph coordinates and applies the grid. Returns the given, modified\n * point instance.\n * \n * Parameters:\n * \n * point - <mxPoint> to be converted.\n * gridEnabled - Boolean that specifies if the grid should be applied.\n */\nmxEdgeHandler.prototype.convertPoint = function(point, gridEnabled)\n{\n\tvar scale = this.graph.getView().getScale();\n\tvar tr = this.graph.getView().getTranslate();\n\t\t\n\tif (gridEnabled)\n\t{\n\t\tpoint.x = this.graph.snap(point.x);\n\t\tpoint.y = this.graph.snap(point.y);\n\t}\n\t\n\tpoint.x = Math.round(point.x / scale - tr.x);\n\tpoint.y = Math.round(point.y / scale - tr.y);\n\n\tvar pstate = this.graph.getView().getState(\n\t\tthis.graph.getModel().getParent(this.state.cell));\n\n\tif (pstate != null)\n\t{\n\t\tpoint.x -= pstate.origin.x;\n\t\tpoint.y -= pstate.origin.y;\n\t}\n\n\treturn point;\n};\n\n/**\n * Function: moveLabel\n * \n * Changes the coordinates for the label of the given edge.\n * \n * Parameters:\n * \n * edge - <mxCell> that represents the edge.\n * x - Integer that specifies the x-coordinate of the new location.\n * y - Integer that specifies the y-coordinate of the new location.\n */\nmxEdgeHandler.prototype.moveLabel = function(edgeState, x, y)\n{\n\tvar model = this.graph.getModel();\n\tvar geometry = model.getGeometry(edgeState.cell);\n\t\n\tif (geometry != null)\n\t{\n\t\tvar scale = this.graph.getView().scale;\n\t\tgeometry = geometry.clone();\n\t\t\n\t\tif (geometry.relative)\n\t\t{\n\t\t\t// Resets the relative location stored inside the geometry\n\t\t\tvar pt = this.graph.getView().getRelativePoint(edgeState, x, y);\n\t\t\tgeometry.x = Math.round(pt.x * 10000) / 10000;\n\t\t\tgeometry.y = Math.round(pt.y);\n\t\t\t\n\t\t\t// Resets the offset inside the geometry to find the offset\n\t\t\t// from the resulting point\n\t\t\tgeometry.offset = new mxPoint(0, 0);\n\t\t\tvar pt = this.graph.view.getPoint(edgeState, geometry);\n\t\t\tgeometry.offset = new mxPoint(Math.round((x - pt.x) / scale), Math.round((y - pt.y) / scale));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar points = edgeState.absolutePoints;\n\t\t\tvar p0 = points[0];\n\t\t\tvar pe = points[points.length - 1];\n\t\t\t\n\t\t\tif (p0 != null && pe != null)\n\t\t\t{\n\t\t\t\tvar cx = p0.x + (pe.x - p0.x) / 2;\n\t\t\t\tvar cy = p0.y + (pe.y - p0.y) / 2;\n\t\t\t\t\n\t\t\t\tgeometry.offset = new mxPoint(Math.round((x - cx) / scale), Math.round((y - cy) / scale));\n\t\t\t\tgeometry.x = 0;\n\t\t\t\tgeometry.y = 0;\n\t\t\t}\n\t\t}\n\n\t\tmodel.setGeometry(edgeState.cell, geometry);\n\t}\n};\n\n/**\n * Function: connect\n * \n * Changes the terminal or terminal point of the given edge in the graph\n * model.\n * \n * Parameters:\n * \n * edge - <mxCell> that represents the edge to be reconnected.\n * terminal - <mxCell> that represents the new terminal.\n * isSource - Boolean indicating if the new terminal is the source or\n * target terminal.\n * isClone - Boolean indicating if the new connection should be a clone of\n * the old edge.\n * me - <mxMouseEvent> that contains the mouse up event.\n */\nmxEdgeHandler.prototype.connect = function(edge, terminal, isSource, isClone, me)\n{\n\tvar model = this.graph.getModel();\n\tvar parent = model.getParent(edge);\n\t\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tvar constraint = this.constraintHandler.currentConstraint;\n\t\t\n\t\tif (constraint == null)\n\t\t{\n\t\t\tconstraint = new mxConnectionConstraint();\n\t\t}\n\n\t\tthis.graph.connectCell(edge, terminal, isSource, constraint);\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n\t\n\treturn edge;\n};\n\n/**\n * Function: changeTerminalPoint\n * \n * Changes the terminal point of the given edge.\n */\nmxEdgeHandler.prototype.changeTerminalPoint = function(edge, point, isSource, clone)\n{\n\tvar model = this.graph.getModel();\n\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tif (clone)\n\t\t{\n\t\t\tvar parent = model.getParent(edge);\n\t\t\tvar terminal = model.getTerminal(edge, !isSource);\n\t\t\tedge = this.graph.cloneCell(edge);\n\t\t\tmodel.add(parent, edge, model.getChildCount(parent));\n\t\t\tmodel.setTerminal(edge, terminal, !isSource);\n\t\t}\n\n\t\tvar geo = model.getGeometry(edge);\n\t\t\n\t\tif (geo != null)\n\t\t{\n\t\t\tgeo = geo.clone();\n\t\t\tgeo.setTerminalPoint(point, isSource);\n\t\t\tmodel.setGeometry(edge, geo);\n\t\t\tthis.graph.connectCell(edge, null, isSource, new mxConnectionConstraint());\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n\t\n\treturn edge;\n};\n\n/**\n * Function: changePoints\n * \n * Changes the control points of the given edge in the graph model.\n */\nmxEdgeHandler.prototype.changePoints = function(edge, points, clone)\n{\n\tvar model = this.graph.getModel();\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tif (clone)\n\t\t{\n\t\t\tvar parent = model.getParent(edge);\n\t\t\tvar source = model.getTerminal(edge, true);\n\t\t\tvar target = model.getTerminal(edge, false);\n\t\t\tedge = this.graph.cloneCell(edge);\n\t\t\tmodel.add(parent, edge, model.getChildCount(parent));\n\t\t\tmodel.setTerminal(edge, source, true);\n\t\t\tmodel.setTerminal(edge, target, false);\n\t\t}\n\t\t\n\t\tvar geo = model.getGeometry(edge);\n\t\t\n\t\tif (geo != null)\n\t\t{\n\t\t\tgeo = geo.clone();\n\t\t\tgeo.points = points;\n\t\t\t\n\t\t\tmodel.setGeometry(edge, geo);\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n\t\n\treturn edge;\n};\n\n/**\n * Function: addPoint\n * \n * Adds a control point for the given state and event.\n */\nmxEdgeHandler.prototype.addPoint = function(state, evt)\n{\n\tvar pt = mxUtils.convertPoint(this.graph.container, mxEvent.getClientX(evt),\n\t\t\tmxEvent.getClientY(evt));\n\tvar gridEnabled = this.graph.isGridEnabledEvent(evt);\n\tthis.convertPoint(pt, gridEnabled);\n\tthis.addPointAt(state, pt.x, pt.y);\n\tmxEvent.consume(evt);\n};\n\n/**\n * Function: addPointAt\n * \n * Adds a control point at the given point.\n */\nmxEdgeHandler.prototype.addPointAt = function(state, x, y)\n{\n\tvar geo = this.graph.getCellGeometry(state.cell);\n\tvar pt = new mxPoint(x, y);\n\t\n\tif (geo != null)\n\t{\n\t\tgeo = geo.clone();\n\t\tvar t = this.graph.view.translate;\n\t\tvar s = this.graph.view.scale;\n\t\tvar offset = new mxPoint(t.x * s, t.y * s);\n\t\t\n\t\tvar parent = this.graph.model.getParent(this.state.cell);\n\t\t\n\t\tif (this.graph.model.isVertex(parent))\n\t\t{\n\t\t\tvar pState = this.graph.view.getState(parent);\n\t\t\toffset = new mxPoint(pState.x, pState.y);\n\t\t}\n\t\t\n\t\tvar index = mxUtils.findNearestSegment(state, pt.x * s + offset.x, pt.y * s + offset.y);\n\n\t\tif (geo.points == null)\n\t\t{\n\t\t\tgeo.points = [pt];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgeo.points.splice(index, 0, pt);\n\t\t}\n\t\t\n\t\tthis.graph.getModel().setGeometry(state.cell, geo);\n\t\tthis.refresh();\t\n\t\tthis.redraw();\n\t}\n};\n\n/**\n * Function: removePoint\n * \n * Removes the control point at the given index from the given state.\n */\nmxEdgeHandler.prototype.removePoint = function(state, index)\n{\n\tif (index > 0 && index < this.abspoints.length - 1)\n\t{\n\t\tvar geo = this.graph.getCellGeometry(this.state.cell);\n\t\t\n\t\tif (geo != null && geo.points != null)\n\t\t{\n\t\t\tgeo = geo.clone();\n\t\t\tgeo.points.splice(index - 1, 1);\n\t\t\tthis.graph.getModel().setGeometry(state.cell, geo);\n\t\t\tthis.refresh();\n\t\t\tthis.redraw();\n\t\t}\n\t}\n};\n\n/**\n * Function: getHandleFillColor\n * \n * Returns the fillcolor for the handle at the given index.\n */\nmxEdgeHandler.prototype.getHandleFillColor = function(index)\n{\n\tvar isSource = index == 0;\n\tvar cell = this.state.cell;\n\tvar terminal = this.graph.getModel().getTerminal(cell, isSource);\n\tvar color = mxConstants.HANDLE_FILLCOLOR;\n\t\n\tif ((terminal != null && !this.graph.isCellDisconnectable(cell, terminal, isSource)) ||\n\t\t(terminal == null && !this.graph.isTerminalPointMovable(cell, isSource)))\n\t{\n\t\tcolor = mxConstants.LOCKED_HANDLE_FILLCOLOR;\n\t}\n\telse if (terminal != null && this.graph.isCellDisconnectable(cell, terminal, isSource))\n\t{\n\t\tcolor = mxConstants.CONNECT_HANDLE_FILLCOLOR;\n\t}\n\t\n\treturn color;\n};\n\n/**\n * Function: redraw\n * \n * Redraws the preview, and the bends- and label control points.\n */\nmxEdgeHandler.prototype.redraw = function(ignoreHandles)\n{\n\tif (this.state != null)\n\t{\n\t\tthis.abspoints = this.state.absolutePoints.slice();\n\t\tvar g = this.graph.getModel().getGeometry(this.state.cell);\n\t\t\n\t\tif (g != null)\n\t\t{\n\t\t\tvar pts = g.points;\n\t\t\n\t\t\tif (this.bends != null && this.bends.length > 0)\n\t\t\t{\n\t\t\t\tif (pts != null)\n\t\t\t\t{\n\t\t\t\t\tif (this.points == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.points = [];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (var i = 1; i < this.bends.length - 1; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.bends[i] != null && this.abspoints[i] != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.points[i - 1] = pts[i - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.drawPreview();\n\t\t\n\t\tif (!ignoreHandles)\n\t\t{\n\t\t\tthis.redrawHandles();\n\t\t}\n\t}\n};\n\n/**\n * Function: redrawHandles\n * \n * Redraws the handles.\n */\nmxEdgeHandler.prototype.redrawHandles = function()\n{\n\tvar cell = this.state.cell;\n\n\t// Updates the handle for the label position\n\tvar b = this.labelShape.bounds;\n\tthis.label = new mxPoint(this.state.absoluteOffset.x, this.state.absoluteOffset.y);\n\tthis.labelShape.bounds = new mxRectangle(Math.round(this.label.x - b.width / 2),\n\t\tMath.round(this.label.y - b.height / 2), b.width, b.height);\n\n\t// Shows or hides the label handle depending on the label\n\tvar lab = this.graph.getLabel(cell);\n\tthis.labelShape.visible = (lab != null && lab.length > 0 && this.graph.isLabelMovable(cell));\n\t\n\tif (this.bends != null && this.bends.length > 0)\n\t{\n\t\tvar n = this.abspoints.length - 1;\n\t\t\n\t\tvar p0 = this.abspoints[0];\n\t\tvar x0 = p0.x;\n\t\tvar y0 = p0.y;\n\t\t\n\t\tb = this.bends[0].bounds;\n\t\tthis.bends[0].bounds = new mxRectangle(Math.floor(x0 - b.width / 2),\n\t\t\t\tMath.floor(y0 - b.height / 2), b.width, b.height);\n\t\tthis.bends[0].fill = this.getHandleFillColor(0);\n\t\tthis.bends[0].redraw();\n\t\t\n\t\tif (this.manageLabelHandle)\n\t\t{\n\t\t\tthis.checkLabelHandle(this.bends[0].bounds);\n\t\t}\n\t\t\t\t\n\t\tvar pe = this.abspoints[n];\n\t\tvar xn = pe.x;\n\t\tvar yn = pe.y;\n\t\t\n\t\tvar bn = this.bends.length - 1;\n\t\tb = this.bends[bn].bounds;\n\t\tthis.bends[bn].bounds = new mxRectangle(Math.floor(xn - b.width / 2),\n\t\t\t\tMath.floor(yn - b.height / 2), b.width, b.height);\n\t\tthis.bends[bn].fill = this.getHandleFillColor(bn);\n\t\tthis.bends[bn].redraw();\n\t\t\t\t\n\t\tif (this.manageLabelHandle)\n\t\t{\n\t\t\tthis.checkLabelHandle(this.bends[bn].bounds);\n\t\t}\n\t\t\n\t\tthis.redrawInnerBends(p0, pe);\n\t}\n\n\tif (this.abspoints != null && this.virtualBends != null && this.virtualBends.length > 0)\n\t{\n\t\tvar last = this.abspoints[0];\n\t\t\n\t\tfor (var i = 0; i < this.virtualBends.length; i++)\n\t\t{\n\t\t\tif (this.virtualBends[i] != null && this.abspoints[i + 1] != null)\n\t\t\t{\n\t\t\t\tvar pt = this.abspoints[i + 1];\n\t\t\t\tvar b = this.virtualBends[i];\n\t\t\t\tvar x = last.x + (pt.x - last.x) / 2;\n\t\t\t\tvar y = last.y + (pt.y - last.y) / 2;\n\t\t\t\tb.bounds = new mxRectangle(Math.floor(x - b.bounds.width / 2),\n\t\t\t\t\t\tMath.floor(y - b.bounds.height / 2), b.bounds.width, b.bounds.height);\n\t\t\t\tb.redraw();\n\t\t\t\tmxUtils.setOpacity(b.node, this.virtualBendOpacity);\n\t\t\t\tlast = pt;\n\t\t\t\t\n\t\t\t\tif (this.manageLabelHandle)\n\t\t\t\t{\n\t\t\t\t\tthis.checkLabelHandle(b.bounds);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (this.labelShape != null)\n\t{\n\t\tthis.labelShape.redraw();\n\t}\n\t\n\tif (this.customHandles != null)\n\t{\n\t\tfor (var i = 0; i < this.customHandles.length; i++)\n\t\t{\n\t\t\tvar temp = this.customHandles[i].shape.node.style.display;\n\t\t\tthis.customHandles[i].redraw();\n\t\t\tthis.customHandles[i].shape.node.style.display = temp;\n\n\t\t\t// Hides custom handles during text editing\n\t\t\tthis.customHandles[i].shape.node.style.visibility =\n\t\t\t\t(this.isCustomHandleVisible(this.customHandles[i])) ?\n\t\t\t\t'' : 'hidden';\n\t\t}\n\t}\n};\n\n/**\n * Function: isCustomHandleVisible\n * \n * Returns true if the given custom handle is visible.\n */\nmxEdgeHandler.prototype.isCustomHandleVisible = function(handle)\n{\n\treturn !this.graph.isEditing() && this.state.view.graph.getSelectionCount() == 1;\n};\n\n/**\n * Function: hideHandles\n * \n * Shortcut to <hideSizers>.\n */\nmxEdgeHandler.prototype.setHandlesVisible = function(visible)\n{\n\tif (this.bends != null)\n\t{\n\t\tfor (var i = 0; i < this.bends.length; i++)\n\t\t{\n\t\t\tthis.bends[i].node.style.display = (visible) ? '' : 'none';\n\t\t}\n\t}\n\t\n\tif (this.virtualBends != null)\n\t{\n\t\tfor (var i = 0; i < this.virtualBends.length; i++)\n\t\t{\n\t\t\tthis.virtualBends[i].node.style.display = (visible) ? '' : 'none';\n\t\t}\n\t}\n\n\tif (this.labelShape != null)\n\t{\n\t\tthis.labelShape.node.style.display = (visible) ? '' : 'none';\n\t}\n\t\n\tif (this.customHandles != null)\n\t{\n\t\tfor (var i = 0; i < this.customHandles.length; i++)\n\t\t{\n\t\t\tthis.customHandles[i].setVisible(visible);\n\t\t}\n\t}\n};\n\n/**\n * Function: redrawInnerBends\n * \n * Updates and redraws the inner bends.\n * \n * Parameters:\n * \n * p0 - <mxPoint> that represents the location of the first point.\n * pe - <mxPoint> that represents the location of the last point.\n */\nmxEdgeHandler.prototype.redrawInnerBends = function(p0, pe)\n{\n\tfor (var i = 1; i < this.bends.length - 1; i++)\n\t{\n\t\tif (this.bends[i] != null)\n\t\t{\n\t\t\tif (this.abspoints[i] != null)\n\t\t\t{\n\t\t\t\tvar x = this.abspoints[i].x;\n\t\t\t\tvar y = this.abspoints[i].y;\n\t\t\t\t\n\t\t\t\tvar b = this.bends[i].bounds;\n\t\t\t\tthis.bends[i].node.style.visibility = 'visible';\n\t\t\t\tthis.bends[i].bounds = new mxRectangle(Math.round(x - b.width / 2),\n\t\t\t\t\t\tMath.round(y - b.height / 2), b.width, b.height);\n\t\t\t\t\n\t\t\t\tif (this.manageLabelHandle)\n\t\t\t\t{\n\t\t\t\t\tthis.checkLabelHandle(this.bends[i].bounds);\n\t\t\t\t}\n\t\t\t\telse if (this.handleImage == null && this.labelShape.visible && mxUtils.intersects(this.bends[i].bounds, this.labelShape.bounds))\n\t\t\t\t{\n\t\t\t\t\tw = mxConstants.HANDLE_SIZE + 3;\n\t\t\t\t\th = mxConstants.HANDLE_SIZE + 3;\n\t\t\t\t\tthis.bends[i].bounds = new mxRectangle(Math.round(x - w / 2), Math.round(y - h / 2), w, h);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.bends[i].redraw();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.bends[i].destroy();\n\t\t\t\tthis.bends[i] = null;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: checkLabelHandle\n * \n * Checks if the label handle intersects the given bounds and moves it if it\n * intersects.\n */\nmxEdgeHandler.prototype.checkLabelHandle = function(b)\n{\n\tif (this.labelShape != null)\n\t{\n\t\tvar b2 = this.labelShape.bounds;\n\t\t\n\t\tif (mxUtils.intersects(b, b2))\n\t\t{\n\t\t\tif (b.getCenterY() < b2.getCenterY())\n\t\t\t{\n\t\t\t\tb2.y = b.y + b.height;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb2.y = b.y - b2.height;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: drawPreview\n * \n * Redraws the preview.\n */\nmxEdgeHandler.prototype.drawPreview = function()\n{\n\ttry\n\t{\n\t\tif (this.isLabel)\n\t\t{\n\t\t\tvar b = this.labelShape.bounds;\n\t\t\tvar bounds = new mxRectangle(Math.round(this.label.x - b.width / 2),\n\t\t\t\tMath.round(this.label.y - b.height / 2), b.width, b.height);\n\t\t\t\n\t\t\tif (!this.labelShape.bounds.equals(bounds))\n\t\t\t{\n\t\t\t\tthis.labelShape.bounds = bounds;\n\t\t\t\tthis.labelShape.redraw();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (this.shape != null && !mxUtils.equalPoints(this.shape.points, this.abspoints))\n\t\t{\n\t\t\tthis.shape.apply(this.state);\n\t\t\tthis.shape.points = this.abspoints.slice();\n\t\t\tthis.shape.scale = this.state.view.scale;\n\t\t\tthis.shape.isDashed = this.isSelectionDashed();\n\t\t\tthis.shape.stroke = this.getSelectionColor();\n\t\t\tthis.shape.strokewidth = this.getSelectionStrokeWidth() / this.shape.scale / this.shape.scale;\n\t\t\tthis.shape.isShadow = false;\n\t\t\tthis.shape.redraw();\n\t\t}\n\t\t\n\t\tthis.updateParentHighlight();\n\t}\n\tcatch (e)\n\t{\n\t\t// ignore\n\t}\n};\n\n/**\n * Function: refresh\n * \n * Refreshes the bends of this handler.\n */\nmxEdgeHandler.prototype.refresh = function()\n{\n\tif (this.state != null)\n\t{\n\t\tthis.abspoints = this.getSelectionPoints(this.state);\n\t\tthis.points = [];\n\t\n\t\tif (this.bends != null)\n\t\t{\n\t\t\tthis.destroyBends(this.bends);\n\t\t\tthis.bends = this.createBends();\n\t\t}\n\t\t\n\t\tif (this.virtualBends != null)\n\t\t{\n\t\t\tthis.destroyBends(this.virtualBends);\n\t\t\tthis.virtualBends = this.createVirtualBends();\n\t\t}\n\t\t\n\t\tif (this.customHandles != null)\n\t\t{\n\t\t\tthis.destroyBends(this.customHandles);\n\t\t\tthis.customHandles = this.createCustomHandles();\n\t\t}\n\t\t\n\t\t// Puts label node on top of bends\n\t\tif (this.labelShape != null && this.labelShape.node != null && this.labelShape.node.parentNode != null)\n\t\t{\n\t\t\tthis.labelShape.node.parentNode.appendChild(this.labelShape.node);\n\t\t}\n\t}\n};\n\n/**\n * Function: isDestroyed\n * \n * Returns true if <destroy> was called.\n */\nmxEdgeHandler.prototype.isDestroyed = function()\n{\n\treturn this.shape == null;\n};\n\n/**\n * Function: destroyBends\n * \n * Destroys all elements in <bends>.\n */\nmxEdgeHandler.prototype.destroyBends = function(bends)\n{\n\tif (bends != null)\n\t{\n\t\tfor (var i = 0; i < bends.length; i++)\n\t\t{\n\t\t\tif (bends[i] != null)\n\t\t\t{\n\t\t\t\tbends[i].destroy();\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: destroy\n * \n * Destroys the handler and all its resources and DOM nodes. This does\n * normally not need to be called as handlers are destroyed automatically\n * when the corresponding cell is deselected.\n */\nmxEdgeHandler.prototype.destroy = function()\n{\n\tif (this.escapeHandler != null)\n\t{\n\t\tthis.state.view.graph.removeListener(this.escapeHandler);\n\t\tthis.escapeHandler = null;\n\t}\n\t\n\tif (this.marker != null)\n\t{\n\t\tthis.marker.destroy();\n\t\tthis.marker = null;\n\t}\n\t\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.destroy();\n\t\tthis.shape = null;\n\t}\n\t\n\tif (this.parentHighlight != null)\n\t{\n\t\tvar parent = this.graph.model.getParent(this.state.cell);\n\t\tvar pstate = this.graph.view.getState(parent);\n\n\t\tif (pstate != null && pstate.parentHighlight == this.parentHighlight)\n\t\t{\n\t\t\tpstate.parentHighlight = null;\n\t\t}\n\t\t\n\t\tthis.parentHighlight.destroy();\n\t\tthis.parentHighlight = null;\n\t}\n\t\n\tif (this.labelShape != null)\n\t{\n\t\tthis.labelShape.destroy();\n\t\tthis.labelShape = null;\n\t}\n\n\tif (this.constraintHandler != null)\n\t{\n\t\tthis.constraintHandler.destroy();\n\t\tthis.constraintHandler = null;\n\t}\n\t\n\tthis.destroyBends(this.virtualBends);\n\tthis.virtualBends = null;\n\t\n\tthis.destroyBends(this.customHandles);\n\tthis.customHandles = null;\n\n\tthis.destroyBends(this.bends);\n\tthis.bends = null;\n\t\n\tthis.removeHint();\n};\n\n__mxOutput.mxEdgeHandler = typeof mxEdgeHandler !== 'undefined' ? mxEdgeHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxElbowEdgeHandler\n *\n * Graph event handler that reconnects edges and modifies control points and\n * the edge label location. Uses <mxTerminalMarker> for finding and\n * highlighting new source and target vertices. This handler is automatically\n * created in <mxGraph.createHandler>. It extends <mxEdgeHandler>.\n * \n * Constructor: mxEdgeHandler\n *\n * Constructs an edge handler for the specified <mxCellState>.\n * \n * Parameters:\n * \n * state - <mxCellState> of the cell to be modified.\n */\nfunction mxElbowEdgeHandler(state)\n{\n\tmxEdgeHandler.call(this, state);\n};\n\n/**\n * Extends mxEdgeHandler.\n */\nmxUtils.extend(mxElbowEdgeHandler, mxEdgeHandler);\n\n/**\n * Specifies if a double click on the middle handle should call\n * <mxGraph.flipEdge>. Default is true.\n */\nmxElbowEdgeHandler.prototype.flipEnabled = true;\n\n/**\n * Variable: doubleClickOrientationResource\n * \n * Specifies the resource key for the tooltip to be displayed on the single\n * control point for routed edges. If the resource for this key does not\n * exist then the value is used as the error message. Default is\n * 'doubleClickOrientation'.\n */\nmxElbowEdgeHandler.prototype.doubleClickOrientationResource =\n\t(mxClient.language != 'none') ? 'doubleClickOrientation' : '';\n\n/**\n * Function: createBends\n * \n * Overrides <mxEdgeHandler.createBends> to create custom bends.\n */\n mxElbowEdgeHandler.prototype.createBends = function()\n {\n\tvar bends = [];\n\t\n\t// Source\n\tvar bend = this.createHandleShape(0);\n\tthis.initBend(bend);\n\tbend.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);\n\tbends.push(bend);\n\n\t// Virtual\n\tbends.push(this.createVirtualBend(mxUtils.bind(this, function(evt)\n\t{\n\t\tif (!mxEvent.isConsumed(evt) && this.flipEnabled)\n\t\t{\n\t\t\tthis.graph.flipEdge(this.state.cell, evt);\n\t\t\tmxEvent.consume(evt);\n\t\t}\n\t})));\n\t\n\tthis.points.push(new mxPoint(0,0));\n\n\t// Target\n\tbend = this.createHandleShape(2);\n\tthis.initBend(bend);\n\tbend.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);\n\tbends.push(bend);\n\t\n\treturn bends;\n };\n\n/**\n * Function: createVirtualBend\n * \n * Creates a virtual bend that supports double clicking and calls\n * <mxGraph.flipEdge>.\n */\nmxElbowEdgeHandler.prototype.createVirtualBend = function(dblClickHandler)\n{\n\tvar bend = this.createHandleShape();\n\tthis.initBend(bend, dblClickHandler);\n\n\tbend.setCursor(this.getCursorForBend());\n\n\tif (!this.graph.isCellBendable(this.state.cell))\n\t{\n\t\tbend.node.style.display = 'none';\n\t}\n\n\treturn bend;\n};\n\n/**\n * Function: getCursorForBend\n * \n * Returns the cursor to be used for the bend.\n */\nmxElbowEdgeHandler.prototype.getCursorForBend = function()\n{\n\treturn (this.state.style[mxConstants.STYLE_EDGE] == mxEdgeStyle.TopToBottom ||\n\t\tthis.state.style[mxConstants.STYLE_EDGE] == mxConstants.EDGESTYLE_TOPTOBOTTOM ||\n\t\t((this.state.style[mxConstants.STYLE_EDGE] == mxEdgeStyle.ElbowConnector ||\n\t\tthis.state.style[mxConstants.STYLE_EDGE] == mxConstants.EDGESTYLE_ELBOW)&&\n\t\tthis.state.style[mxConstants.STYLE_ELBOW] == mxConstants.ELBOW_VERTICAL)) ? \n\t\t'row-resize' : 'col-resize';\n};\n\n/**\n * Function: getTooltipForNode\n * \n * Returns the tooltip for the given node.\n */\nmxElbowEdgeHandler.prototype.getTooltipForNode = function(node)\n{\n\tvar tip = null;\n\t\n\tif (this.bends != null && this.bends[1] != null && (node == this.bends[1].node ||\n\t\tnode.parentNode == this.bends[1].node))\n\t{\n\t\ttip = this.doubleClickOrientationResource;\n\t\ttip = mxResources.get(tip) || tip; // translate\n\t}\n\n\treturn tip;\n};\n\n/**\n * Function: convertPoint\n * \n * Converts the given point in-place from screen to unscaled, untranslated\n * graph coordinates and applies the grid.\n * \n * Parameters:\n * \n * point - <mxPoint> to be converted.\n * gridEnabled - Boolean that specifies if the grid should be applied.\n */\nmxElbowEdgeHandler.prototype.convertPoint = function(point, gridEnabled)\n{\n\tvar scale = this.graph.getView().getScale();\n\tvar tr = this.graph.getView().getTranslate();\n\tvar origin = this.state.origin;\n\t\n\tif (gridEnabled)\n\t{\n\t\tpoint.x = this.graph.snap(point.x);\n\t\tpoint.y = this.graph.snap(point.y);\n\t}\n\t\n\tpoint.x = Math.round(point.x / scale - tr.x - origin.x);\n\tpoint.y = Math.round(point.y / scale - tr.y - origin.y);\n\t\n\treturn point;\n};\n\n/**\n * Function: redrawInnerBends\n * \n * Updates and redraws the inner bends.\n * \n * Parameters:\n * \n * p0 - <mxPoint> that represents the location of the first point.\n * pe - <mxPoint> that represents the location of the last point.\n */\nmxElbowEdgeHandler.prototype.redrawInnerBends = function(p0, pe)\n{\n\tvar g = this.graph.getModel().getGeometry(this.state.cell);\n\tvar pts = this.state.absolutePoints;\n\tvar pt = null;\n\n\t// Keeps the virtual bend on the edge shape\n\tif (pts.length > 1)\n\t{\n\t\tp0 = pts[1];\n\t\tpe = pts[pts.length - 2];\n\t}\n\telse if (g.points != null && g.points.length > 0)\n\t{\n\t\tpt = pts[0];\n\t}\n\t\n\tif (pt == null)\n\t{\n\t\tpt = new mxPoint(p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);\n\t}\n\telse\n\t{\n\t\tpt = new mxPoint(this.graph.getView().scale * (pt.x + this.graph.getView().translate.x + this.state.origin.x),\n\t\t\t\tthis.graph.getView().scale * (pt.y + this.graph.getView().translate.y + this.state.origin.y));\n\t}\n\n\t// Makes handle slightly bigger if the yellow  label handle\n\t// exists and intersects this green handle\n\tvar b = this.bends[1].bounds;\n\tvar w = b.width;\n\tvar h = b.height;\n\tvar bounds = new mxRectangle(Math.round(pt.x - w / 2), Math.round(pt.y - h / 2), w, h);\n\n\tif (this.manageLabelHandle)\n\t{\n\t\tthis.checkLabelHandle(bounds);\n\t}\n\telse if (this.handleImage == null && this.labelShape.visible && mxUtils.intersects(bounds, this.labelShape.bounds))\n\t{\n\t\tw = mxConstants.HANDLE_SIZE + 3;\n\t\th = mxConstants.HANDLE_SIZE + 3;\n\t\tbounds = new mxRectangle(Math.floor(pt.x - w / 2), Math.floor(pt.y - h / 2), w, h);\n\t}\n\n\tthis.bends[1].bounds = bounds;\n\tthis.bends[1].redraw();\n\t\n\tif (this.manageLabelHandle)\n\t{\n\t\tthis.checkLabelHandle(this.bends[1].bounds);\n\t}\n};\n\n__mxOutput.mxElbowEdgeHandler = typeof mxElbowEdgeHandler !== 'undefined' ? mxElbowEdgeHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nfunction mxEdgeSegmentHandler(state)\n{\n\tmxEdgeHandler.call(this, state);\n};\n\n/**\n * Extends mxEdgeHandler.\n */\nmxUtils.extend(mxEdgeSegmentHandler, mxElbowEdgeHandler);\n\n/**\n * Function: getCurrentPoints\n * \n * Returns the current absolute points.\n */\nmxEdgeSegmentHandler.prototype.getCurrentPoints = function()\n{\n\tvar pts = this.state.absolutePoints;\n\t\n\tif (pts != null)\n\t{\n\t\t// Special case for straight edges where we add a virtual middle handle for moving the edge\n\t\tvar tol = Math.max(1, this.graph.view.scale);\n\t\t\n\t\tif (pts.length == 2 || (pts.length == 3 &&\n\t\t\t(Math.abs(pts[0].x - pts[1].x) < tol && Math.abs(pts[1].x - pts[2].x) < tol ||\n\t\t\tMath.abs(pts[0].y - pts[1].y) < tol && Math.abs(pts[1].y - pts[2].y) < tol)))\n\t\t{\n\t\t\tvar cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;\n\t\t\tvar cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;\n\t\t\t\n\t\t\tpts = [pts[0], new mxPoint(cx, cy), new mxPoint(cx, cy), pts[pts.length - 1]];\t\n\t\t}\n\t}\n\n\treturn pts;\n};\n\n/**\n * Function: getPreviewPoints\n * \n * Updates the given preview state taking into account the state of the constraint handler.\n */\nmxEdgeSegmentHandler.prototype.getPreviewPoints = function(point)\n{\n\tif (this.isSource || this.isTarget)\n\t{\n\t\treturn mxElbowEdgeHandler.prototype.getPreviewPoints.apply(this, arguments);\n\t}\n\telse\n\t{\n\t\tvar pts = this.getCurrentPoints();\n\t\tvar last = this.convertPoint(pts[0].clone(), false);\n\t\tpoint = this.convertPoint(point.clone(), false);\n\t\tvar result = [];\n\n\t\tfor (var i = 1; i < pts.length; i++)\n\t\t{\n\t\t\tvar pt = this.convertPoint(pts[i].clone(), false);\n\t\t\t\n\t\t\tif (i == this.index)\n\t\t\t{\n\t\t\t\tif (Math.round(last.x - pt.x) == 0)\n\t\t \t\t{\n\t\t\t\t\tlast.x = point.x;\n\t\t\t\t\tpt.x = point.x;\n\t\t \t\t}\n\t\t \t\t\n\t\t\t\tif (Math.round(last.y - pt.y) == 0)\n\t\t \t\t{\n\t\t \t\t\tlast.y = point.y;\n\t\t \t\t\tpt.y = point.y;\n\t\t \t\t}\n\t\t\t}\n\n\t\t\tif (i < pts.length - 1)\n\t\t\t{\n\t\t\t\tresult.push(pt);\n\t\t\t}\n\n\t\t\tlast = pt;\n\t\t}\n\t\t\n\t\t// Replaces single point that intersects with source or target\n\t\tif (result.length == 1)\n\t\t{\n\t\t\tvar source = this.state.getVisibleTerminalState(true);\n\t\t\tvar target = this.state.getVisibleTerminalState(false);\n\t\t\tvar scale = this.state.view.getScale();\n\t\t\tvar tr = this.state.view.getTranslate();\n\t\t\t\n\t\t\tvar x = result[0].x * scale + tr.x;\n\t\t\tvar y = result[0].y * scale + tr.y;\n\t\t\t\n\t\t\tif ((source != null && mxUtils.contains(source, x, y)) ||\n\t\t\t\t(target != null && mxUtils.contains(target, x, y)))\n\t\t\t{\n\t\t\t\tresult = [point, point];\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n};\n\n/**\n * Function: updatePreviewState\n * \n * Overridden to perform optimization of the edge style result.\n */\nmxEdgeSegmentHandler.prototype.updatePreviewState = function(edge, point, terminalState, me)\n{\n\tmxEdgeHandler.prototype.updatePreviewState.apply(this, arguments);\n\n\t// Checks and corrects preview by running edge style again\n\tif (!this.isSource && !this.isTarget)\n\t{\n\t\tpoint = this.convertPoint(point.clone(), false);\n\t\tvar pts = edge.absolutePoints;\n\t\tvar pt0 = pts[0];\n\t\tvar pt1 = pts[1];\n\n\t\tvar result = [];\n\t\t\n\t\tfor (var i = 2; i < pts.length; i++)\n\t\t{\n\t\t\tvar pt2 = pts[i];\n\t\t\n\t\t\t// Merges adjacent segments only if more than 2 to allow for straight edges\n\t\t\tif ((Math.round(pt0.x - pt1.x) != 0 || Math.round(pt1.x - pt2.x) != 0) &&\n\t\t\t\t(Math.round(pt0.y - pt1.y) != 0 || Math.round(pt1.y - pt2.y) != 0))\n\t\t\t{\n\t\t\t\tresult.push(this.convertPoint(pt1.clone(), false));\n\t\t\t}\n\n\t\t\tpt0 = pt1;\n\t\t\tpt1 = pt2;\n\t\t}\n\t\t\n\t\tvar source = this.state.getVisibleTerminalState(true);\n\t\tvar target = this.state.getVisibleTerminalState(false);\n\t\tvar rpts = this.state.absolutePoints;\n\t\t\n\t\t// A straight line is represented by 3 handles\n\t\tif (result.length == 0 && (Math.round(pts[0].x - pts[pts.length - 1].x) == 0 ||\n\t\t\tMath.round(pts[0].y - pts[pts.length - 1].y) == 0))\n\t\t{\n\t\t\tresult = [point, point];\n\t\t}\n\t\t// Handles special case of transitions from straight vertical to routed\n\t\telse if (pts.length == 5 && result.length == 2 && source != null && target != null &&\n\t\t\t\trpts != null && Math.round(rpts[0].x - rpts[rpts.length - 1].x) == 0)\n\t\t{\n\t\t\tvar view = this.graph.getView();\n\t\t\tvar scale = view.getScale();\n\t\t\tvar tr = view.getTranslate();\n\t\t\t\n\t\t\tvar y0 = view.getRoutingCenterY(source) / scale - tr.y;\n\t\t\t\n\t\t\t// Use fixed connection point y-coordinate if one exists\n\t\t\tvar sc = this.graph.getConnectionConstraint(edge, source, true);\n\t\t\t\n\t\t\tif (sc != null)\n\t\t\t{\n\t\t\t\tvar pt = this.graph.getConnectionPoint(source, sc);\n\t\t\t\t\n\t\t\t\tif (pt != null)\n\t\t\t\t{\n\t\t\t\t\tthis.convertPoint(pt, false);\n\t\t\t\t\ty0 = pt.y;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar ye = view.getRoutingCenterY(target) / scale - tr.y;\n\t\t\t\n\t\t\t// Use fixed connection point y-coordinate if one exists\n\t\t\tvar tc = this.graph.getConnectionConstraint(edge, target, false);\n\t\t\t\n\t\t\tif (tc)\n\t\t\t{\n\t\t\t\tvar pt = this.graph.getConnectionPoint(target, tc);\n\t\t\t\t\n\t\t\t\tif (pt != null)\n\t\t\t\t{\n\t\t\t\t\tthis.convertPoint(pt, false);\n\t\t\t\t\tye = pt.y;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tresult = [new mxPoint(point.x, y0), new mxPoint(point.x, ye)];\n\t\t}\n\n\t\tthis.points = result;\n\n\t\t// LATER: Check if points and result are different\n\t\tedge.view.updateFixedTerminalPoints(edge, source, target);\n\t\tedge.view.updatePoints(edge, this.points, source, target);\n\t\tedge.view.updateFloatingTerminalPoints(edge, source, target);\n\t}\n};\n\n/**\n * Overriden to merge edge segments.\n */\nmxEdgeSegmentHandler.prototype.connect = function(edge, terminal, isSource, isClone, me)\n{\n\tvar model = this.graph.getModel();\n\tvar geo = model.getGeometry(edge);\n\tvar result = null;\n\t\n\t// Merges adjacent edge segments\n\tif (geo != null && geo.points != null && geo.points.length > 0)\n\t{\n\t\tvar pts = this.abspoints;\n\t\tvar pt0 = pts[0];\n\t\tvar pt1 = pts[1];\n\t\tresult = [];\n\t\t\n\t\tfor (var i = 2; i < pts.length; i++)\n\t\t{\n\t\t\tvar pt2 = pts[i];\n\t\t\n\t\t\t// Merges adjacent segments only if more than 2 to allow for straight edges\n\t\t\tif ((Math.round(pt0.x - pt1.x) != 0 || Math.round(pt1.x - pt2.x) != 0) &&\n\t\t\t\t(Math.round(pt0.y - pt1.y) != 0 || Math.round(pt1.y - pt2.y) != 0))\n\t\t\t{\n\t\t\t\tresult.push(this.convertPoint(pt1.clone(), false));\n\t\t\t}\n\t\n\t\t\tpt0 = pt1;\n\t\t\tpt1 = pt2;\n\t\t}\n\t}\n\t\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tif (result != null)\n\t\t{\n\t\t\tvar geo = model.getGeometry(edge);\n\t\t\t\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tgeo = geo.clone();\n\t\t\t\tgeo.points = result;\n\t\t\t\t\n\t\t\t\tmodel.setGeometry(edge, geo);\n\t\t\t}\n\t\t}\n\t\t\n\t\tedge = mxEdgeHandler.prototype.connect.apply(this, arguments);\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n\t\n\treturn edge;\n};\n\n/**\n * Function: getTooltipForNode\n * \n * Returns no tooltips.\n */\nmxEdgeSegmentHandler.prototype.getTooltipForNode = function(node)\n{\n\treturn null;\n};\n\n/**\n * Function: start\n * \n * Starts the handling of the mouse gesture.\n */\nmxEdgeSegmentHandler.prototype.start = function(x, y, index)\n{\n\tmxEdgeHandler.prototype.start.apply(this, arguments);\n\t\n\tif (this.bends != null && this.bends[index] != null &&\n\t\t!this.isSource && !this.isTarget)\n\t{\n\t\tmxUtils.setOpacity(this.bends[index].node, 100);\n\t}\n};\n\n/**\n * Function: createBends\n * \n * Adds custom bends for the center of each segment.\n */\nmxEdgeSegmentHandler.prototype.createBends = function()\n{\n\tvar bends = [];\n\t\n\t// Source\n\tvar bend = this.createHandleShape(0);\n\tthis.initBend(bend);\n\tbend.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);\n\tbends.push(bend);\n\n\tvar pts = this.getCurrentPoints();\n\n\t// Waypoints (segment handles)\n\tif (this.graph.isCellBendable(this.state.cell))\n\t{\n\t\tif (this.points == null)\n\t\t{\n\t\t\tthis.points = [];\n\t\t}\n\n\t\tfor (var i = 0; i < pts.length - 1; i++)\n\t\t{\n\t\t\tbend = this.createVirtualBend();\n\t\t\tbends.push(bend);\n\t\t\tvar horizontal = Math.round(pts[i].x - pts[i + 1].x) == 0;\n\t\t\t\n\t\t\t// Special case where dy is 0 as well\n\t\t\tif (Math.round(pts[i].y - pts[i + 1].y) == 0 && i < pts.length - 2)\n\t\t\t{\n\t\t\t\thorizontal = Math.round(pts[i].x - pts[i + 2].x) == 0;\n\t\t\t}\n\t\t\t\n\t\t\tbend.setCursor((horizontal) ? 'col-resize' : 'row-resize');\n\t\t\tthis.points.push(new mxPoint(0,0));\n\t\t}\n\t}\n\n\t// Target\n\tvar bend = this.createHandleShape(pts.length);\n\tthis.initBend(bend);\n\tbend.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);\n\tbends.push(bend);\n\n\treturn bends;\n};\n\n/**\n * Function: redraw\n * \n * Overridden to invoke <refresh> before the redraw.\n */\nmxEdgeSegmentHandler.prototype.redraw = function()\n{\n\tthis.refresh();\n\tmxEdgeHandler.prototype.redraw.apply(this, arguments);\n};\n\n/**\n * Function: redrawInnerBends\n * \n * Updates the position of the custom bends.\n */\nmxEdgeSegmentHandler.prototype.redrawInnerBends = function(p0, pe)\n{\n\tif (this.graph.isCellBendable(this.state.cell))\n\t{\n\t\tvar pts = this.getCurrentPoints();\n\t\t\n\t\tif (pts != null && pts.length > 1)\n\t\t{\n\t\t\tvar straight = false;\n\t\t\t\n\t\t\t// Puts handle in the center of straight edges\n\t\t\tif (pts.length == 4 && Math.round(pts[1].x - pts[2].x) == 0 && Math.round(pts[1].y - pts[2].y) == 0)\n\t\t\t{\n\t\t\t\tstraight = true;\n\t\t\t\t\n\t\t\t\tif (Math.round(pts[0].y - pts[pts.length - 1].y) == 0)\n\t\t\t\t{\n\t\t\t\t\tvar cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;\n\t\t\t\t\tpts[1] = new mxPoint(cx, pts[1].y);\n\t\t\t\t\tpts[2] = new mxPoint(cx, pts[2].y);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;\n\t\t\t\t\tpts[1] = new mxPoint(pts[1].x, cy);\n\t\t\t\t\tpts[2] = new mxPoint(pts[2].x, cy);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (var i = 0; i < pts.length - 1; i++)\n\t\t\t{\n\t\t\t\tif (this.bends[i + 1] != null)\n\t\t\t\t{\n\t\t \t\t\tvar p0 = pts[i];\n\t \t\t\t\tvar pe = pts[i + 1];\n\t\t\t \t\tvar pt = new mxPoint(p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);\n\t\t\t \t\tvar b = this.bends[i + 1].bounds;\n\t\t\t \t\tthis.bends[i + 1].bounds = new mxRectangle(Math.floor(pt.x - b.width / 2),\n\t\t\t \t\t\t\tMath.floor(pt.y - b.height / 2), b.width, b.height);\n\t\t\t\t \tthis.bends[i + 1].redraw();\n\t\t\t\t \t\n\t\t\t\t \tif (this.manageLabelHandle)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.checkLabelHandle(this.bends[i + 1].bounds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (straight)\n\t\t\t{\n\t\t\t\tmxUtils.setOpacity(this.bends[1].node, this.virtualBendOpacity);\n\t\t\t\tmxUtils.setOpacity(this.bends[3].node, this.virtualBendOpacity);\n\t\t\t}\n\t\t}\n\t}\n};\n\n__mxOutput.mxEdgeSegmentHandler = typeof mxEdgeSegmentHandler !== 'undefined' ? mxEdgeSegmentHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxKeyHandler\n *\n * Event handler that listens to keystroke events. This is not a singleton,\n * however, it is normally only required once if the target is the document\n * element (default).\n * \n * This handler installs a key event listener in the topmost DOM node and\n * processes all events that originate from descandants of <mxGraph.container>\n * or from the topmost DOM node. The latter means that all unhandled keystrokes\n * are handled by this object regardless of the focused state of the <graph>.\n * \n * Example:\n * \n * The following example creates a key handler that listens to the delete key\n * (46) and deletes the selection cells if the graph is enabled.\n * \n * (code)\n * var keyHandler = new mxKeyHandler(graph);\n * keyHandler.bindKey(46, function(evt)\n * {\n *   if (graph.isEnabled())\n *   {\n *     graph.removeCells();\n *   }\n * });\n * (end)\n * \n * Keycodes:\n * \n * See http://tinyurl.com/yp8jgl or http://tinyurl.com/229yqw for a list of\n * keycodes or install a key event listener into the document element and print\n * the key codes of the respective events to the console.\n * \n * To support the Command key and the Control key on the Mac, the following\n * code can be used.\n *\n * (code)\n * keyHandler.getFunction = function(evt)\n * {\n *   if (evt != null)\n *   {\n *     return (mxEvent.isControlDown(evt) || (mxClient.IS_MAC && evt.metaKey)) ? this.controlKeys[evt.keyCode] : this.normalKeys[evt.keyCode];\n *   }\n *   \n *   return null;\n * };\n * (end)\n * \n * Constructor: mxKeyHandler\n *\n * Constructs an event handler that executes functions bound to specific\n * keystrokes.\n * \n * Parameters:\n * \n * graph - Reference to the associated <mxGraph>.\n * target - Optional reference to the event target. If null, the document\n * element is used as the event target, that is, the object where the key\n * event listener is installed.\n */\nfunction mxKeyHandler(graph, target)\n{\n\tif (graph != null)\n\t{\n\t\tthis.graph = graph;\n\t\tthis.target = target || document.documentElement;\n\t\t\n\t\t// Creates the arrays to map from keycodes to functions\n\t\tthis.normalKeys = [];\n\t\tthis.shiftKeys = [];\n\t\tthis.controlKeys = [];\n\t\tthis.controlShiftKeys = [];\n\t\t\n\t\tthis.keydownHandler = mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tthis.keyDown(evt);\n\t\t});\n\n\t\t// Installs the keystroke listener in the target\n\t\tmxEvent.addListener(this.target, 'keydown', this.keydownHandler);\n\t\t\n\t\t// Automatically deallocates memory in IE\n\t\tif (mxClient.IS_IE)\n\t\t{\n\t\t\tmxEvent.addListener(window, 'unload',\n\t\t\t\tmxUtils.bind(this, function()\n\t\t\t\t{\n\t\t\t\t\tthis.destroy();\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t}\n};\n\n/**\n * Variable: graph\n * \n * Reference to the <mxGraph> associated with this handler.\n */\nmxKeyHandler.prototype.graph = null;\n\n/**\n * Variable: target\n * \n * Reference to the target DOM, that is, the DOM node where the key event\n * listeners are installed.\n */\nmxKeyHandler.prototype.target = null;\n\n/**\n * Variable: normalKeys\n * \n * Maps from keycodes to functions for non-pressed control keys.\n */\nmxKeyHandler.prototype.normalKeys = null;\n\n/**\n * Variable: shiftKeys\n * \n * Maps from keycodes to functions for pressed shift keys.\n */\nmxKeyHandler.prototype.shiftKeys = null;\n\n/**\n * Variable: controlKeys\n * \n * Maps from keycodes to functions for pressed control keys.\n */\nmxKeyHandler.prototype.controlKeys = null;\n\n/**\n * Variable: controlShiftKeys\n * \n * Maps from keycodes to functions for pressed control and shift keys.\n */\nmxKeyHandler.prototype.controlShiftKeys = null;\n\n/**\n * Variable: enabled\n * \n * Specifies if events are handled. Default is true.\n */\nmxKeyHandler.prototype.enabled = true;\n\n/**\n * Function: isEnabled\n * \n * Returns true if events are handled. This implementation returns\n * <enabled>.\n */\nmxKeyHandler.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n * \n * Enables or disables event handling by updating <enabled>.\n * \n * Parameters:\n * \n * enabled - Boolean that specifies the new enabled state.\n */\nmxKeyHandler.prototype.setEnabled = function(enabled)\n{\n\tthis.enabled = enabled;\n};\n\n/**\n * Function: bindKey\n * \n * Binds the specified keycode to the given function. This binding is used\n * if the control key is not pressed.\n * \n * Parameters:\n *\n * code - Integer that specifies the keycode.\n * funct - JavaScript function that takes the key event as an argument.\n */\nmxKeyHandler.prototype.bindKey = function(code, funct)\n{\n\tthis.normalKeys[code] = funct;\n};\n\n/**\n * Function: bindShiftKey\n * \n * Binds the specified keycode to the given function. This binding is used\n * if the shift key is pressed.\n * \n * Parameters:\n *\n * code - Integer that specifies the keycode.\n * funct - JavaScript function that takes the key event as an argument.\n */\nmxKeyHandler.prototype.bindShiftKey = function(code, funct)\n{\n\tthis.shiftKeys[code] = funct;\n};\n\n/**\n * Function: bindControlKey\n * \n * Binds the specified keycode to the given function. This binding is used\n * if the control key is pressed.\n * \n * Parameters:\n *\n * code - Integer that specifies the keycode.\n * funct - JavaScript function that takes the key event as an argument.\n */\nmxKeyHandler.prototype.bindControlKey = function(code, funct)\n{\n\tthis.controlKeys[code] = funct;\n};\n\n/**\n * Function: bindControlShiftKey\n * \n * Binds the specified keycode to the given function. This binding is used\n * if the control and shift key are pressed.\n * \n * Parameters:\n *\n * code - Integer that specifies the keycode.\n * funct - JavaScript function that takes the key event as an argument.\n */\nmxKeyHandler.prototype.bindControlShiftKey = function(code, funct)\n{\n\tthis.controlShiftKeys[code] = funct;\n};\n\n/**\n * Function: isControlDown\n * \n * Returns true if the control key is pressed. This uses <mxEvent.isControlDown>.\n * \n * Parameters:\n * \n * evt - Key event whose control key pressed state should be returned.\n */\nmxKeyHandler.prototype.isControlDown = function(evt)\n{\n\treturn mxEvent.isControlDown(evt);\n};\n\n/**\n * Function: getFunction\n * \n * Returns the function associated with the given key event or null if no\n * function is associated with the given event.\n * \n * Parameters:\n * \n * evt - Key event whose associated function should be returned.\n */\nmxKeyHandler.prototype.getFunction = function(evt)\n{\n\tif (evt != null && !mxEvent.isAltDown(evt))\n\t{\n\t\tif (this.isControlDown(evt))\n\t\t{\n\t\t\tif (mxEvent.isShiftDown(evt))\n\t\t\t{\n\t\t\t\treturn this.controlShiftKeys[evt.keyCode];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.controlKeys[evt.keyCode];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (mxEvent.isShiftDown(evt))\n\t\t\t{\n\t\t\t\treturn this.shiftKeys[evt.keyCode];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.normalKeys[evt.keyCode];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn null;\n};\n\t\n/**\n * Function: isGraphEvent\n * \n * Returns true if the event should be processed by this handler, that is,\n * if the event source is either the target, one of its direct children, a\n * descendant of the <mxGraph.container>, or the <mxGraph.cellEditor> of the\n * <graph>.\n * \n * Parameters:\n * \n * evt - Key event that represents the keystroke.\n */\nmxKeyHandler.prototype.isGraphEvent = function(evt)\n{\n\tvar source = mxEvent.getSource(evt);\n\t\n\t// Accepts events from the target object or\n\t// in-place editing inside graph\n\tif ((source == this.target || source.parentNode == this.target) ||\n\t\t(this.graph.cellEditor != null && this.graph.cellEditor.isEventSource(evt)))\n\t{\n\t\treturn true;\n\t}\n\t\n\t// Accepts events from inside the container\n\treturn mxUtils.isAncestorNode(this.graph.container, source);\n};\n\n/**\n * Function: keyDown\n * \n * Handles the event by invoking the function bound to the respective keystroke\n * if <isEnabledForEvent> returns true for the given event and if\n * <isEventIgnored> returns false, except for escape for which\n * <isEventIgnored> is not invoked.\n * \n * Parameters:\n * \n * evt - Key event that represents the keystroke.\n */\nmxKeyHandler.prototype.keyDown = function(evt)\n{\n\tif (this.isEnabledForEvent(evt))\n\t{\n\t\t// Cancels the editing if escape is pressed\n\t\tif (evt.keyCode == 27 /* Escape */)\n\t\t{\n\t\t\tthis.escape(evt);\n\t\t}\n\t\t\n\t\t// Invokes the function for the keystroke\n\t\telse if (!this.isEventIgnored(evt))\n\t\t{\n\t\t\tvar boundFunction = this.getFunction(evt);\n\t\t\t\n\t\t\tif (boundFunction != null)\n\t\t\t{\n\t\t\t\tboundFunction(evt);\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: isEnabledForEvent\n * \n * Returns true if the given event should be handled. <isEventIgnored> is\n * called later if the event is not an escape key stroke, in which case\n * <escape> is called. This implementation returns true if <isEnabled>\n * returns true for both, this handler and <graph>, if the event is not\n * consumed and if <isGraphEvent> returns true.\n * \n * Parameters:\n * \n * evt - Key event that represents the keystroke.\n */\nmxKeyHandler.prototype.isEnabledForEvent = function(evt)\n{\n\treturn (this.graph.isEnabled() && !mxEvent.isConsumed(evt) &&\n\t\tthis.isGraphEvent(evt) && this.isEnabled());\n};\n\n/**\n * Function: isEventIgnored\n * \n * Returns true if the given keystroke should be ignored. This returns\n * graph.isEditing().\n * \n * Parameters:\n * \n * evt - Key event that represents the keystroke.\n */\nmxKeyHandler.prototype.isEventIgnored = function(evt)\n{\n\treturn this.graph.isEditing();\n};\n\n/**\n * Function: escape\n * \n * Hook to process ESCAPE keystrokes. This implementation invokes\n * <mxGraph.stopEditing> to cancel the current editing, connecting\n * and/or other ongoing modifications.\n * \n * Parameters:\n * \n * evt - Key event that represents the keystroke. Possible keycode in this\n * case is 27 (ESCAPE).\n */\nmxKeyHandler.prototype.escape = function(evt)\n{\n\tif (this.graph.isEscapeEnabled())\n\t{\n\t\tthis.graph.escape(evt);\n\t}\n};\n\n/**\n * Function: destroy\n * \n * Destroys the handler and all its references into the DOM. This does\n * normally not need to be called, it is called automatically when the\n * window unloads (in IE).\n */\nmxKeyHandler.prototype.destroy = function()\n{\n\tif (this.target != null && this.keydownHandler != null)\n\t{\n\t\tmxEvent.removeListener(this.target, 'keydown', this.keydownHandler);\n\t\tthis.keydownHandler = null;\n\t}\n\t\n\tthis.target = null;\n};\n\n__mxOutput.mxKeyHandler = typeof mxKeyHandler !== 'undefined' ? mxKeyHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxTooltipHandler\n * \n * Graph event handler that displays tooltips. <mxGraph.getTooltip> is used to\n * get the tooltip for a cell or handle. This handler is built-into\n * <mxGraph.tooltipHandler> and enabled using <mxGraph.setTooltips>.\n *\n * Example:\n * \n * (code>\n * new mxTooltipHandler(graph);\n * (end)\n * \n * Constructor: mxTooltipHandler\n * \n * Constructs an event handler that displays tooltips with the specified\n * delay (in milliseconds). If no delay is specified then a default delay\n * of 500 ms (0.5 sec) is used.\n * \n * Parameters:\n * \n * graph - Reference to the enclosing <mxGraph>.\n * delay - Optional delay in milliseconds.\n */\nfunction mxTooltipHandler(graph, delay)\n{\n\tif (graph != null)\n\t{\n\t\tthis.graph = graph;\n\t\tthis.delay = delay || 500;\n\t\tthis.graph.addMouseListener(this);\n\t}\n};\n\n/**\n * Variable: zIndex\n * \n * Specifies the zIndex for the tooltip and its shadow. Default is 10005.\n */\nmxTooltipHandler.prototype.zIndex = 10005;\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxTooltipHandler.prototype.graph = null;\n\n/**\n * Variable: delay\n * \n * Delay to show the tooltip in milliseconds. Default is 500.\n */\nmxTooltipHandler.prototype.delay = null;\n\n/**\n * Variable: ignoreTouchEvents\n * \n * Specifies if touch and pen events should be ignored. Default is true.\n */\nmxTooltipHandler.prototype.ignoreTouchEvents = true;\n\n/**\n * Variable: hideOnHover\n * \n * Specifies if the tooltip should be hidden if the mouse is moved over the\n * current cell. Default is false.\n */\nmxTooltipHandler.prototype.hideOnHover = false;\n\n/**\n * Variable: destroyed\n * \n * True if this handler was destroyed using <destroy>.\n */\nmxTooltipHandler.prototype.destroyed = false;\n\n/**\n * Variable: enabled\n * \n * Specifies if events are handled. Default is true.\n */\nmxTooltipHandler.prototype.enabled = true;\n\n/**\n * Function: isEnabled\n * \n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxTooltipHandler.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n * \n * Enables or disables event handling. This implementation\n * updates <enabled>.\n */\nmxTooltipHandler.prototype.setEnabled = function(enabled)\n{\n\tthis.enabled = enabled;\n};\n\n/**\n * Function: isHideOnHover\n * \n * Returns <hideOnHover>.\n */\nmxTooltipHandler.prototype.isHideOnHover = function()\n{\n\treturn this.hideOnHover;\n};\n\n/**\n * Function: setHideOnHover\n * \n * Sets <hideOnHover>.\n */\nmxTooltipHandler.prototype.setHideOnHover = function(value)\n{\n\tthis.hideOnHover = value;\n};\n\n/**\n * Function: init\n * \n * Initializes the DOM nodes required for this tooltip handler.\n */\nmxTooltipHandler.prototype.init = function()\n{\n\tif (document.body != null)\n\t{\n\t\tthis.div = document.createElement('div');\n\t\tthis.div.className = 'mxTooltip';\n\t\tthis.div.style.visibility = 'hidden';\n\n\t\tdocument.body.appendChild(this.div);\n\n\t\tmxEvent.addGestureListeners(this.div, mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tvar source = mxEvent.getSource(evt);\n\t\t\t\n\t\t\tif (source.nodeName != 'A')\n\t\t\t{\n\t\t\t\tthis.hideTooltip();\n\t\t\t}\n\t\t}));\n\t}\n};\n\n/**\n * Function: getStateForEvent\n * \n * Returns the <mxCellState> to be used for showing a tooltip for this event.\n */\nmxTooltipHandler.prototype.getStateForEvent = function(me)\n{\n\treturn me.getState();\n};\n\n/**\n * Function: mouseDown\n * \n * Handles the event by initiating a rubberband selection. By consuming the\n * event all subsequent events of the gesture are redirected to this\n * handler.\n */\nmxTooltipHandler.prototype.mouseDown = function(sender, me)\n{\n\tthis.reset(me, false);\n\tthis.hideTooltip();\n};\n\n/**\n * Function: mouseMove\n * \n * Handles the event by updating the rubberband selection.\n */\nmxTooltipHandler.prototype.mouseMove = function(sender, me)\n{\n\tif (me.getX() != this.lastX || me.getY() != this.lastY)\n\t{\n\t\tthis.reset(me, true);\n\t\tvar state = this.getStateForEvent(me);\n\t\t\n\t\tif (this.isHideOnHover() || state != this.state || (me.getSource() != this.node &&\n\t\t\t(!this.stateSource || (state != null && this.stateSource ==\n\t\t\t(me.isSource(state.shape) || !me.isSource(state.text))))))\n\t\t{\n\t\t\tthis.hideTooltip();\n\t\t}\n\t}\n\t\n\tthis.lastX = me.getX();\n\tthis.lastY = me.getY();\n};\n\n/**\n * Function: mouseUp\n * \n * Handles the event by resetting the tooltip timer or hiding the existing\n * tooltip.\n */\nmxTooltipHandler.prototype.mouseUp = function(sender, me)\n{\n\tthis.reset(me, true);\n\tthis.hideTooltip();\n};\n\n\n/**\n * Function: resetTimer\n * \n * Resets the timer.\n */\nmxTooltipHandler.prototype.resetTimer = function()\n{\n\tif (this.thread != null)\n\t{\n\t\twindow.clearTimeout(this.thread);\n\t\tthis.thread = null;\n\t}\n};\n\n/**\n * Function: reset\n * \n * Resets and/or restarts the timer to trigger the display of the tooltip.\n */\nmxTooltipHandler.prototype.reset = function(me, restart, state)\n{\n\tif (!this.ignoreTouchEvents || mxEvent.isMouseEvent(me.getEvent()))\n\t{\n\t\tthis.resetTimer();\n\t\tstate = (state != null) ? state : this.getStateForEvent(me);\n\t\t\n\t\tif (restart && this.isEnabled() && state != null && (this.div == null ||\n\t\t\tthis.div.style.visibility == 'hidden'))\n\t\t{\n\t\t\tvar node = me.getSource();\n\t\t\tvar x = me.getX();\n\t\t\tvar y = me.getY();\n\t\t\tvar stateSource = me.isSource(state.shape) || me.isSource(state.text);\n\t\n\t\t\tthis.thread = window.setTimeout(mxUtils.bind(this, function()\n\t\t\t{\n\t\t\t\tif (!this.graph.isEditing() && !this.graph.popupMenuHandler.isMenuShowing() && !this.graph.isMouseDown)\n\t\t\t\t{\n\t\t\t\t\t// Uses information from inside event cause using the event at\n\t\t\t\t\t// this (delayed) point in time is not possible in IE as it no\n\t\t\t\t\t// longer contains the required information (member not found)\n\t\t\t\t\tvar tip = this.graph.getTooltip(state, node, x, y);\n\t\t\t\t\tthis.show(tip, x, y);\n\t\t\t\t\tthis.state = state;\n\t\t\t\t\tthis.node = node;\n\t\t\t\t\tthis.stateSource = stateSource;\n\t\t\t\t}\n\t\t\t}), this.delay);\n\t\t}\n\t}\n};\n\n/**\n * Function: hide\n * \n * Hides the tooltip and resets the timer.\n */\nmxTooltipHandler.prototype.hide = function()\n{\n\tthis.resetTimer();\n\tthis.hideTooltip();\n};\n\n/**\n * Function: hideTooltip\n * \n * Hides the tooltip.\n */\nmxTooltipHandler.prototype.hideTooltip = function()\n{\n\tif (this.div != null)\n\t{\n\t\tthis.div.style.visibility = 'hidden';\n\t\tthis.div.innerHTML = '';\n\t}\n};\n\n/**\n * Function: show\n * \n * Shows the tooltip for the specified cell and optional index at the\n * specified location (with a vertical offset of 10 pixels).\n */\nmxTooltipHandler.prototype.show = function(tip, x, y)\n{\n\tif (!this.destroyed && tip != null && tip.length > 0)\n\t{\n\t\t// Initializes the DOM nodes if required\n\t\tif (this.div == null)\n\t\t{\n\t\t\tthis.init();\n\t\t}\n\t\t\n\t\tvar origin = mxUtils.getScrollOrigin();\n\n\t\tthis.div.style.zIndex = this.zIndex;\n\t\tthis.div.style.left = (x + origin.x) + 'px';\n\t\tthis.div.style.top = (y + mxConstants.TOOLTIP_VERTICAL_OFFSET +\n\t\t\torigin.y) + 'px';\n\n\t\tif (!mxUtils.isNode(tip))\n\t\t{\t\n\t\t\tthis.div.innerHTML = tip.replace(/\\n/g, '<br>');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.div.innerHTML = '';\n\t\t\tthis.div.appendChild(tip);\n\t\t}\n\t\t\n\t\tthis.div.style.visibility = '';\n\t\tmxUtils.fit(this.div);\n\t}\n};\n\n/**\n * Function: destroy\n * \n * Destroys the handler and all its resources and DOM nodes.\n */\nmxTooltipHandler.prototype.destroy = function()\n{\n\tif (!this.destroyed)\n\t{\n\t\tthis.graph.removeMouseListener(this);\n\t\tmxEvent.release(this.div);\n\t\t\n\t\tif (this.div != null && this.div.parentNode != null)\n\t\t{\n\t\t\tthis.div.parentNode.removeChild(this.div);\n\t\t}\n\t\t\n\t\tthis.destroyed = true;\n\t\tthis.div = null;\n\t}\n};\n\n__mxOutput.mxTooltipHandler = typeof mxTooltipHandler !== 'undefined' ? mxTooltipHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCellTracker\n * \n * Event handler that highlights cells. Inherits from <mxCellMarker>.\n * \n * Example:\n * \n * (code)\n * new mxCellTracker(graph, '#00FF00');\n * (end)\n * \n * For detecting dragEnter, dragOver and dragLeave on cells, the following\n * code can be used:\n * \n * (code)\n * graph.addMouseListener(\n * {\n *   cell: null,\n *   mouseDown: function(sender, me) { },\n *   mouseMove: function(sender, me)\n *   {\n *     var tmp = me.getCell();\n *     \n *     if (tmp != this.cell)\n *     {\n *       if (this.cell != null)\n *       {\n *         this.dragLeave(me.getEvent(), this.cell);\n *       }\n *       \n *       this.cell = tmp;\n *       \n *       if (this.cell != null)\n *       {\n *         this.dragEnter(me.getEvent(), this.cell);\n *       }\n *     }\n *     \n *     if (this.cell != null)\n *     {\n *       this.dragOver(me.getEvent(), this.cell);\n *     }\n *   },\n *   mouseUp: function(sender, me) { },\n *   dragEnter: function(evt, cell)\n *   {\n *     mxLog.debug('dragEnter', cell.value);\n *   },\n *   dragOver: function(evt, cell)\n *   {\n *     mxLog.debug('dragOver', cell.value);\n *   },\n *   dragLeave: function(evt, cell)\n *   {\n *     mxLog.debug('dragLeave', cell.value);\n *   }\n * });\n * (end)\n * \n * Constructor: mxCellTracker\n * \n * Constructs an event handler that highlights cells.\n * \n * Parameters:\n * \n * graph - Reference to the enclosing <mxGraph>.\n * color - Color of the highlight. Default is blue.\n * funct - Optional JavaScript function that is used to override\n * <mxCellMarker.getCell>.\n */\nfunction mxCellTracker(graph, color, funct)\n{\n\tmxCellMarker.call(this, graph, color);\n\n\tthis.graph.addMouseListener(this);\n\t\n\tif (funct != null)\n\t{\n\t\tthis.getCell = funct;\n\t}\n\t\n\t// Automatic deallocation of memory\n\tif (mxClient.IS_IE)\n\t{\n\t\tmxEvent.addListener(window, 'unload', mxUtils.bind(this, function()\n\t\t{\n\t\t\tthis.destroy();\n\t\t}));\n\t}\n};\n\n/**\n * Extends mxCellMarker.\n */\nmxUtils.extend(mxCellTracker, mxCellMarker);\n\n/**\n * Function: mouseDown\n * \n * Ignores the event. The event is not consumed.\n */\nmxCellTracker.prototype.mouseDown = function(sender, me) { };\n\n/**\n * Function: mouseMove\n * \n * Handles the event by highlighting the cell under the mousepointer if it\n * is over the hotspot region of the cell.\n */\nmxCellTracker.prototype.mouseMove = function(sender, me)\n{\n\tif (this.isEnabled())\n\t{\n\t\tthis.process(me);\n\t}\n};\n\n/**\n * Function: mouseUp\n * \n * Handles the event by reseting the highlight.\n */\nmxCellTracker.prototype.mouseUp = function(sender, me) { };\n\n/**\n * Function: destroy\n * \n * Destroys the object and all its resources and DOM nodes. This doesn't\n * normally need to be called. It is called automatically when the window\n * unloads.\n */\nmxCellTracker.prototype.destroy = function()\n{\n\tif (!this.destroyed)\n\t{\n\t\tthis.destroyed = true;\n\n\t\tthis.graph.removeMouseListener(this);\n\t\tmxCellMarker.prototype.destroy.apply(this);\n\t}\n};\n\n__mxOutput.mxCellTracker = typeof mxCellTracker !== 'undefined' ? mxCellTracker : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCellHighlight\n * \n * A helper class to highlight cells. Here is an example for a given cell.\n * \n * (code)\n * var highlight = new mxCellHighlight(graph, '#ff0000', 2);\n * highlight.highlight(graph.view.getState(cell)));\n * (end)\n * \n * Constructor: mxCellHighlight\n * \n * Constructs a cell highlight.\n */\nfunction mxCellHighlight(graph, highlightColor, strokeWidth, dashed)\n{\n\tif (graph != null)\n\t{\n\t\tthis.graph = graph;\n\t\tthis.highlightColor = (highlightColor != null) ? highlightColor : mxConstants.DEFAULT_VALID_COLOR;\n\t\tthis.strokeWidth = (strokeWidth != null) ? strokeWidth : mxConstants.HIGHLIGHT_STROKEWIDTH;\n\t\tthis.dashed = (dashed != null) ? dashed : false;\n\t\tthis.opacity = mxConstants.HIGHLIGHT_OPACITY;\n\n\t\t// Updates the marker if the graph changes\n\t\tthis.repaintHandler = mxUtils.bind(this, function()\n\t\t{\n\t\t\t// Updates reference to state\n\t\t\tif (this.state != null)\n\t\t\t{\n\t\t\t\tvar tmp = this.graph.view.getState(this.state.cell);\n\t\t\t\t\n\t\t\t\tif (tmp == null)\n\t\t\t\t{\n\t\t\t\t\tthis.hide();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.state = tmp;\n\t\t\t\t\tthis.repaint();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tthis.graph.getView().addListener(mxEvent.SCALE, this.repaintHandler);\n\t\tthis.graph.getView().addListener(mxEvent.TRANSLATE, this.repaintHandler);\n\t\tthis.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.repaintHandler);\n\t\tthis.graph.getModel().addListener(mxEvent.CHANGE, this.repaintHandler);\n\t\t\n\t\t// Hides the marker if the current root changes\n\t\tthis.resetHandler = mxUtils.bind(this, function()\n\t\t{\n\t\t\tthis.hide();\n\t\t});\n\n\t\tthis.graph.getView().addListener(mxEvent.DOWN, this.resetHandler);\n\t\tthis.graph.getView().addListener(mxEvent.UP, this.resetHandler);\n\t}\n};\n\n/**\n * Variable: keepOnTop\n * \n * Specifies if the highlights should appear on top of everything\n * else in the overlay pane. Default is false.\n */\nmxCellHighlight.prototype.keepOnTop = false;\n\n/**\n * Variable: graph\n * \n * Reference to the enclosing <mxGraph>.\n */\nmxCellHighlight.prototype.graph = null;\n\n/**\n * Variable: state\n * \n * Reference to the <mxCellState>.\n */\nmxCellHighlight.prototype.state = null;\n\n/**\n * Variable: spacing\n * \n * Specifies the spacing between the highlight for vertices and the vertex.\n * Default is 2.\n */\nmxCellHighlight.prototype.spacing = 2;\n\n/**\n * Variable: resetHandler\n * \n * Holds the handler that automatically invokes reset if the highlight\n * should be hidden.\n */\nmxCellHighlight.prototype.resetHandler = null;\n\n/**\n * Function: setHighlightColor\n * \n * Sets the color of the rectangle used to highlight drop targets.\n * \n * Parameters:\n * \n * color - String that represents the new highlight color.\n */\nmxCellHighlight.prototype.setHighlightColor = function(color)\n{\n\tthis.highlightColor = color;\n\t\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.stroke = color;\n\t}\n};\n\n/**\n * Function: drawHighlight\n * \n * Creates and returns the highlight shape for the given state.\n */\nmxCellHighlight.prototype.drawHighlight = function()\n{\n\tthis.shape = this.createShape();\n\tthis.repaint();\n\n\tif (!this.keepOnTop && this.shape.node.parentNode.firstChild != this.shape.node)\n\t{\n\t\tthis.shape.node.parentNode.insertBefore(this.shape.node, this.shape.node.parentNode.firstChild);\n\t}\n};\n\n/**\n * Function: createShape\n * \n * Creates and returns the highlight shape for the given state.\n */\nmxCellHighlight.prototype.createShape = function()\n{\n\tvar shape = this.graph.cellRenderer.createShape(this.state);\n\t\n\tshape.svgStrokeTolerance = this.graph.tolerance;\n\tshape.points = this.state.absolutePoints;\n\tshape.apply(this.state);\n\tshape.stroke = this.highlightColor;\n\tshape.opacity = this.opacity;\n\tshape.isDashed = this.dashed;\n\tshape.isShadow = false;\n\t\n\tshape.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;\n\tshape.init(this.graph.getView().getOverlayPane());\n\tmxEvent.redirectMouseEvents(shape.node, this.graph, this.state);\n\t\n\tif (this.graph.dialect != mxConstants.DIALECT_SVG)\n\t{\n\t\tshape.pointerEvents = false;\n\t}\n\telse\n\t{\n\t\tshape.svgPointerEvents = 'stroke';\n\t}\n\t\n\treturn shape;\n};\n\n/**\n * Function: getStrokeWidth\n * \n * Returns the stroke width.\n */\nmxCellHighlight.prototype.getStrokeWidth = function(state)\n{\n\treturn this.strokeWidth;\n};\n\n/**\n * Function: repaint\n * \n * Updates the highlight after a change of the model or view.\n */\nmxCellHighlight.prototype.repaint = function()\n{\n\tif (this.state != null && this.shape != null)\n\t{\n\t\tthis.shape.scale = this.state.view.scale;\n\t\t\n\t\tif (this.graph.model.isEdge(this.state.cell))\n\t\t{\n\t\t\tthis.shape.strokewidth = this.getStrokeWidth();\n\t\t\tthis.shape.points = this.state.absolutePoints;\n\t\t\tthis.shape.outline = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.shape.bounds = new mxRectangle(this.state.x - this.spacing, this.state.y - this.spacing,\n\t\t\t\t\tthis.state.width + 2 * this.spacing, this.state.height + 2 * this.spacing);\n\t\t\tthis.shape.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || '0');\n\t\t\tthis.shape.strokewidth = this.getStrokeWidth() / this.state.view.scale;\n\t\t\tthis.shape.outline = true;\n\t\t}\n\n\t\t// Uses cursor from shape in highlight\n\t\tif (this.state.shape != null)\n\t\t{\n\t\t\tthis.shape.setCursor(this.state.shape.getCursor());\n\t\t}\n\t\t\n\t\t// Workaround for event transparency in VML with transparent color\n\t\t// is to use a non-transparent color with near zero opacity\n\t\tif (mxClient.IS_QUIRKS || document.documentMode == 8)\n\t\t{\n\t\t\tif (this.shape.stroke == 'transparent')\n\t\t\t{\n\t\t\t\t// KNOWN: Quirks mode does not seem to catch events if\n\t\t\t\t// we do not force an update of the DOM via a change such\n\t\t\t\t// as mxLog.debug. Since IE6 is EOL we do not add a fix.\n\t\t\t\tthis.shape.stroke = 'white';\n\t\t\t\tthis.shape.opacity = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.shape.opacity = this.opacity;\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.shape.redraw();\n\t}\n};\n\n/**\n * Function: hide\n * \n * Resets the state of the cell marker.\n */\nmxCellHighlight.prototype.hide = function()\n{\n\tthis.highlight(null);\n};\n\n/**\n * Function: mark\n * \n * Marks the <markedState> and fires a <mark> event.\n */\nmxCellHighlight.prototype.highlight = function(state)\n{\n\tif (this.state != state)\n\t{\n\t\tif (this.shape != null)\n\t\t{\n\t\t\tthis.shape.destroy();\n\t\t\tthis.shape = null;\n\t\t}\n\n\t\tthis.state = state;\n\t\t\n\t\tif (this.state != null)\n\t\t{\n\t\t\tthis.drawHighlight();\n\t\t}\n\t}\n};\n\n/**\n * Function: isHighlightAt\n * \n * Returns true if this highlight is at the given position.\n */\nmxCellHighlight.prototype.isHighlightAt = function(x, y)\n{\n\tvar hit = false;\n\t\n\t// Quirks mode is currently not supported as it used a different coordinate system\n\tif (this.shape != null && document.elementFromPoint != null && !mxClient.IS_QUIRKS)\n\t{\n\t\tvar elt = document.elementFromPoint(x, y);\n\n\t\twhile (elt != null)\n\t\t{\n\t\t\tif (elt == this.shape.node)\n\t\t\t{\n\t\t\t\thit = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\telt = elt.parentNode;\n\t\t}\n\t}\n\t\n\treturn hit;\n};\n\n/**\n * Function: destroy\n * \n * Destroys the handler and all its resources and DOM nodes.\n */\nmxCellHighlight.prototype.destroy = function()\n{\n\tthis.graph.getView().removeListener(this.resetHandler);\n\tthis.graph.getView().removeListener(this.repaintHandler);\n\tthis.graph.getModel().removeListener(this.repaintHandler);\n\t\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.destroy();\n\t\tthis.shape = null;\n\t}\n};\n\n__mxOutput.mxCellHighlight = typeof mxCellHighlight !== 'undefined' ? mxCellHighlight : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxDefaultKeyHandler\n *\n * Binds keycodes to actionnames in an editor. This aggregates an internal\n * <handler> and extends the implementation of <mxKeyHandler.escape> to not\n * only cancel the editing, but also hide the properties dialog and fire an\n * <mxEditor.escape> event via <editor>. An instance of this class is created\n * by <mxEditor> and stored in <mxEditor.keyHandler>.\n * \n * Example:\n * \n * Bind the delete key to the delete action in an existing editor.\n * \n * (code)\n * var keyHandler = new mxDefaultKeyHandler(editor);\n * keyHandler.bindAction(46, 'delete');\n * (end)\n *\n * Codec:\n * \n * This class uses the <mxDefaultKeyHandlerCodec> to read configuration\n * data into an existing instance. See <mxDefaultKeyHandlerCodec> for a\n * description of the configuration format.\n * \n * Keycodes:\n * \n * See <mxKeyHandler>.\n * \n * An <mxEvent.ESCAPE> event is fired via the editor if the escape key is\n * pressed.\n * \n * Constructor: mxDefaultKeyHandler\n *\n * Constructs a new default key handler for the <mxEditor.graph> in the\n * given <mxEditor>. (The editor may be null if a prototypical instance for\n * a <mxDefaultKeyHandlerCodec> is created.)\n * \n * Parameters:\n * \n * editor - Reference to the enclosing <mxEditor>.\n */\nfunction mxDefaultKeyHandler(editor)\n{\n\tif (editor != null)\n\t{\n\t\tthis.editor = editor;\n\t\tthis.handler = new mxKeyHandler(editor.graph);\n\t\t\n\t\t// Extends the escape function of the internal key\n\t\t// handle to hide the properties dialog and fire\n\t\t// the escape event via the editor instance\n\t\tvar old = this.handler.escape;\n\t\t\n\t\tthis.handler.escape = function(evt)\n\t\t{\n\t\t\told.apply(this, arguments);\n\t\t\teditor.hideProperties();\n\t\t\teditor.fireEvent(new mxEventObject(mxEvent.ESCAPE, 'event', evt));\n\t\t};\n\t}\n};\n\t\n/**\n * Variable: editor\n *\n * Reference to the enclosing <mxEditor>.\n */\nmxDefaultKeyHandler.prototype.editor = null;\n\n/**\n * Variable: handler\n *\n * Holds the <mxKeyHandler> for key event handling.\n */\nmxDefaultKeyHandler.prototype.handler = null;\n\n/**\n * Function: bindAction\n *\n * Binds the specified keycode to the given action in <editor>. The\n * optional control flag specifies if the control key must be pressed\n * to trigger the action.\n *\n * Parameters:\n *\n * code - Integer that specifies the keycode.\n * action - Name of the action to execute in <editor>.\n * control - Optional boolean that specifies if control must be pressed.\n * Default is false.\n */\nmxDefaultKeyHandler.prototype.bindAction = function (code, action, control)\n{\n\tvar keyHandler = mxUtils.bind(this, function()\n\t{\n\t\tthis.editor.execute(action);\n\t});\n\n\t// Binds the function to control-down keycode\n\tif (control)\n\t{\n\t\tthis.handler.bindControlKey(code, keyHandler);\n\t}\n\n\t// Binds the function to the normal keycode\n\telse\n\t{\n\t\tthis.handler.bindKey(code, keyHandler);\t\t\t\t\n\t}\n};\n\n/**\n * Function: destroy\n *\n * Destroys the <handler> associated with this object. This does normally\n * not need to be called, the <handler> is destroyed automatically when the\n * window unloads (in IE) by <mxEditor>.\n */\nmxDefaultKeyHandler.prototype.destroy = function ()\n{\n\tthis.handler.destroy();\n\tthis.handler = null;\n};\n\n__mxOutput.mxDefaultKeyHandler = typeof mxDefaultKeyHandler !== 'undefined' ? mxDefaultKeyHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxDefaultPopupMenu\n *\n * Creates popupmenus for mouse events. This object holds an XML node\n * which is a description of the popup menu to be created. In\n * <createMenu>, the configuration is applied to the context and\n * the resulting menu items are added to the menu dynamically. See\n * <createMenu> for a description of the configuration format.\n * \n * This class does not create the DOM nodes required for the popup menu, it\n * only parses an XML description to invoke the respective methods on an\n * <mxPopupMenu> each time the menu is displayed.\n *\n * Codec:\n * \n * This class uses the <mxDefaultPopupMenuCodec> to read configuration\n * data into an existing instance, however, the actual parsing is done\n * by this class during program execution, so the format is described\n * below.\n * \n * Constructor: mxDefaultPopupMenu\n *\n * Constructs a new popupmenu-factory based on given configuration.\n *\n * Paramaters:\n *\n * config - XML node that contains the configuration data.\n */\nfunction mxDefaultPopupMenu(config)\n{\n\tthis.config = config;\n};\n\n/**\n * Variable: imageBasePath\n *\n * Base path for all icon attributes in the config. Default is null.\n */\nmxDefaultPopupMenu.prototype.imageBasePath = null;\n\n/**\n * Variable: config\n *\n * XML node used as the description of new menu items. This node is\n * used in <createMenu> to dynamically create the menu items if their\n * respective conditions evaluate to true for the given arguments.\n */\nmxDefaultPopupMenu.prototype.config = null;\n\n/**\n * Function: createMenu\n *\n * This function is called from <mxEditor> to add items to the\n * given menu based on <config>. The config is a sequence of\n * the following nodes and attributes.\n *\n * Child Nodes: \n *\n * add - Adds a new menu item. See below for attributes.\n * separator - Adds a separator. No attributes.\n * condition - Adds a custom condition. Name attribute.\n * \n * The add-node may have a child node that defines a function to be invoked\n * before the action is executed (or instead of an action to be executed).\n *\n * Attributes:\n *\n * as - Resource key for the label (needs entry in property file).\n * action - Name of the action to execute in enclosing editor.\n * icon - Optional icon (relative/absolute URL).\n * iconCls - Optional CSS class for the icon.\n * if - Optional name of condition that must be true (see below).\n * enabled-if - Optional name of condition that specifies if the menu item\n * should be enabled.\n * name - Name of custom condition. Only for condition nodes.\n *\n * Conditions:\n *\n * nocell - No cell under the mouse.\n * ncells - More than one cell selected.\n * notRoot - Drilling position is other than home.\n * cell - Cell under the mouse.\n * notEmpty - Exactly one cell with children under mouse.\n * expandable - Exactly one expandable cell under mouse.\n * collapsable - Exactly one collapsable cell under mouse.\n * validRoot - Exactly one cell which is a possible root under mouse.\n * swimlane - Exactly one cell which is a swimlane under mouse.\n *\n * Example:\n *\n * To add a new item for a given action to the popupmenu:\n * \n * (code)\n * <mxDefaultPopupMenu as=\"popupHandler\">\n *   <add as=\"delete\" action=\"delete\" icon=\"images/delete.gif\" if=\"cell\"/>\n * </mxDefaultPopupMenu>\n * (end)\n * \n * To add a new item for a custom function:\n * \n * (code)\n * <mxDefaultPopupMenu as=\"popupHandler\">\n *   <add as=\"action1\"><![CDATA[\n *\t\tfunction (editor, cell, evt)\n *\t\t{\n *\t\t\teditor.execute('action1', cell, 'myArg');\n *\t\t}\n *   ]]></add>\n * </mxDefaultPopupMenu>\n * (end)\n * \n * The above example invokes action1 with an additional third argument via\n * the editor instance. The third argument is passed to the function that\n * defines action1. If the add-node has no action-attribute, then only the\n * function defined in the text content is executed, otherwise first the\n * function and then the action defined in the action-attribute is\n * executed. The function in the text content has 3 arguments, namely the\n * <mxEditor> instance, the <mxCell> instance under the mouse, and the\n * native mouse event.\n *\n * Custom Conditions:\n *\n * To add a new condition for popupmenu items:\n *  \n * (code)\n * <condition name=\"condition1\"><![CDATA[\n *   function (editor, cell, evt)\n *   {\n *     return cell != null;\n *   }\n * ]]></condition>\n * (end)\n * \n * The new condition can then be used in any item as follows:\n * \n * (code)\n * <add as=\"action1\" action=\"action1\" icon=\"action1.gif\" if=\"condition1\"/>\n * (end)\n * \n * The order in which the items and conditions appear is not significant as\n * all connditions are evaluated before any items are created.\n * \n * Parameters:\n *\n * editor - Enclosing <mxEditor> instance.\n * menu - <mxPopupMenu> that is used for adding items and separators.\n * cell - Optional <mxCell> which is under the mousepointer.\n * evt - Optional mouse event which triggered the menu. \n */\nmxDefaultPopupMenu.prototype.createMenu = function(editor, menu, cell, evt)\n{\n\tif (this.config != null)\n\t{\n\t\tvar conditions = this.createConditions(editor, cell, evt);\n\t\tvar item = this.config.firstChild;\n\n\t\tthis.addItems(editor, menu, cell, evt, conditions, item, null);\n\t}\n};\n\n/**\n * Function: addItems\n * \n * Recursively adds the given items and all of its children into the given menu.\n * \n * Parameters:\n *\n * editor - Enclosing <mxEditor> instance.\n * menu - <mxPopupMenu> that is used for adding items and separators.\n * cell - Optional <mxCell> which is under the mousepointer.\n * evt - Optional mouse event which triggered the menu.\n * conditions - Array of names boolean conditions.\n * item - XML node that represents the current menu item.\n * parent - DOM node that represents the parent menu item.\n */\nmxDefaultPopupMenu.prototype.addItems = function(editor, menu, cell, evt, conditions, item, parent)\n{\n\tvar addSeparator = false;\n\t\n\twhile (item != null)\n\t{\n\t\tif (item.nodeName == 'add')\n\t\t{\n\t\t\tvar condition = item.getAttribute('if');\n\t\t\t\n\t\t\tif (condition == null || conditions[condition])\n\t\t\t{\n\t\t\t\tvar as = item.getAttribute('as');\n\t\t\t\tas = mxResources.get(as) || as;\n\t\t\t\tvar funct = mxUtils.eval(mxUtils.getTextContent(item));\n\t\t\t\tvar action = item.getAttribute('action');\n\t\t\t\tvar icon = item.getAttribute('icon');\n\t\t\t\tvar iconCls = item.getAttribute('iconCls');\n\t\t\t\tvar enabledCond = item.getAttribute('enabled-if');\n\t\t\t\tvar enabled = enabledCond == null || conditions[enabledCond];\n\t\t\t\t\n\t\t\t\tif (addSeparator)\n\t\t\t\t{\n\t\t\t\t\tmenu.addSeparator(parent);\n\t\t\t\t\taddSeparator = false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (icon != null && this.imageBasePath)\n\t\t\t\t{\n\t\t\t\t\ticon = this.imageBasePath + icon;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar row = this.addAction(menu, editor, as, icon, funct, action, cell, parent, iconCls, enabled);\n\t\t\t\tthis.addItems(editor, menu, cell, evt, conditions, item.firstChild, row);\n\t\t\t}\n\t\t}\n\t\telse if (item.nodeName == 'separator')\n\t\t{\n\t\t\taddSeparator = true;\n\t\t}\n\t\t\n\t\titem = item.nextSibling;\n\t}\n};\n\n/**\n * Function: addAction\n *\n * Helper method to bind an action to a new menu item.\n * \n * Parameters:\n *\n * menu - <mxPopupMenu> that is used for adding items and separators.\n * editor - Enclosing <mxEditor> instance.\n * lab - String that represents the label of the menu item.\n * icon - Optional URL that represents the icon of the menu item.\n * action - Optional name of the action to execute in the given editor.\n * funct - Optional function to execute before the optional action. The\n * function takes an <mxEditor>, the <mxCell> under the mouse and the\n * mouse event that triggered the call.\n * cell - Optional <mxCell> to use as an argument for the action.\n * parent - DOM node that represents the parent menu item.\n * iconCls - Optional CSS class for the menu icon.\n * enabled - Optional boolean that specifies if the menu item is enabled.\n * Default is true.\n */\nmxDefaultPopupMenu.prototype.addAction = function(menu, editor, lab, icon, funct, action, cell, parent, iconCls, enabled)\n{\n\tvar clickHandler = function(evt)\n\t{\n\t\tif (typeof(funct) == 'function')\n\t\t{\n\t\t\tfunct.call(editor, editor, cell, evt);\n\t\t}\n\t\t\n\t\tif (action != null)\n\t\t{\n\t\t\teditor.execute(action, cell, evt);\n\t\t}\n\t};\n\t\n\treturn menu.addItem(lab, icon, clickHandler, parent, iconCls, enabled);\n};\n\n/**\n * Function: createConditions\n * \n * Evaluates the default conditions for the given context.\n */\nmxDefaultPopupMenu.prototype.createConditions = function(editor, cell, evt)\n{\n\t// Creates array with conditions\n\tvar model = editor.graph.getModel();\n\tvar childCount = model.getChildCount(cell);\n\t\n\t// Adds some frequently used conditions\n\tvar conditions = [];\n\tconditions['nocell'] = cell == null;\n\tconditions['ncells'] = editor.graph.getSelectionCount() > 1;\n\tconditions['notRoot'] = model.getRoot() !=\n\t\tmodel.getParent(editor.graph.getDefaultParent());\n\tconditions['cell'] = cell != null;\n\t\n\tvar isCell = cell != null && editor.graph.getSelectionCount() == 1;\n\tconditions['nonEmpty'] = isCell && childCount > 0;\n\tconditions['expandable'] = isCell && editor.graph.isCellFoldable(cell, false);\n\tconditions['collapsable'] = isCell && editor.graph.isCellFoldable(cell, true);\n\tconditions['validRoot'] = isCell && editor.graph.isValidRoot(cell);\n\tconditions['emptyValidRoot'] = conditions['validRoot'] && childCount == 0;\n\tconditions['swimlane'] = isCell && editor.graph.isSwimlane(cell);\n\n\t// Evaluates dynamic conditions from config file\n\tvar condNodes = this.config.getElementsByTagName('condition');\n\t\n\tfor (var i=0; i<condNodes.length; i++)\n\t{\n\t\tvar funct = mxUtils.eval(mxUtils.getTextContent(condNodes[i]));\n\t\tvar name = condNodes[i].getAttribute('name');\n\t\t\n\t\tif (name != null && typeof(funct) == 'function')\n\t\t{\n\t\t\tconditions[name] = funct(editor, cell, evt);\n\t\t}\n\t}\n\t\n\treturn conditions;\n};\n\n__mxOutput.mxDefaultPopupMenu = typeof mxDefaultPopupMenu !== 'undefined' ? mxDefaultPopupMenu : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxDefaultToolbar\n *\n * Toolbar for the editor. This modifies the state of the graph\n * or inserts new cells upon mouse clicks.\n * \n * Example:\n * \n * Create a toolbar with a button to copy the selection into the clipboard,\n * and a combo box with one action to paste the selection from the clipboard\n * into the graph.\n * \n * (code)\n * var toolbar = new mxDefaultToolbar(container, editor);\n * toolbar.addItem('Copy', null, 'copy');\n * \n * var combo = toolbar.addActionCombo('More actions...');\n * toolbar.addActionOption(combo, 'Paste', 'paste');\n * (end) \n *\n * Codec:\n * \n * This class uses the <mxDefaultToolbarCodec> to read configuration\n * data into an existing instance. See <mxDefaultToolbarCodec> for a\n * description of the configuration format.\n * \n * Constructor: mxDefaultToolbar\n *\n * Constructs a new toolbar for the given container and editor. The\n * container and editor may be null if a prototypical instance for a\n * <mxDefaultKeyHandlerCodec> is created.\n *\n * Parameters:\n *\n * container - DOM node that contains the toolbar.\n * editor - Reference to the enclosing <mxEditor>. \n */\nfunction mxDefaultToolbar(container, editor)\n{\n\tthis.editor = editor;\n\n\tif (container != null && editor != null)\n\t{\n\t\tthis.init(container);\n\t}\n};\n\t\n/**\n * Variable: editor\n *\n * Reference to the enclosing <mxEditor>.\n */\nmxDefaultToolbar.prototype.editor = null;\n\n/**\n * Variable: toolbar\n *\n * Holds the internal <mxToolbar>.\n */\nmxDefaultToolbar.prototype.toolbar = null;\n\n/**\n * Variable: resetHandler\n *\n * Reference to the function used to reset the <toolbar>.\n */\nmxDefaultToolbar.prototype.resetHandler = null;\n\n/**\n * Variable: spacing\n *\n * Defines the spacing between existing and new vertices in\n * gridSize units when a new vertex is dropped on an existing\n * cell. Default is 4 (40 pixels).\n */\nmxDefaultToolbar.prototype.spacing = 4;\n\n/**\n * Variable: connectOnDrop\n * \n * Specifies if elements should be connected if new cells are dropped onto\n * connectable elements. Default is false.\n */\nmxDefaultToolbar.prototype.connectOnDrop = false;\n\n/**\n * Function: init\n * \n * Constructs the <toolbar> for the given container and installs a listener\n * that updates the <mxEditor.insertFunction> on <editor> if an item is\n * selected in the toolbar. This assumes that <editor> is not null.\n *\n * Parameters:\n *\n * container - DOM node that contains the toolbar.\n */\nmxDefaultToolbar.prototype.init = function(container)\n{\n\tif (container != null)\n\t{\n\t\tthis.toolbar = new mxToolbar(container);\n\t\t\n\t\t// Installs the insert function in the editor if an item is\n\t\t// selected in the toolbar\n\t\tthis.toolbar.addListener(mxEvent.SELECT, mxUtils.bind(this, function(sender, evt)\n\t\t{\n\t\t\tvar funct = evt.getProperty('function');\n\t\t\t\n\t\t\tif (funct != null)\n\t\t\t{\n\t\t\t\tthis.editor.insertFunction = mxUtils.bind(this, function()\n\t\t\t\t{\n\t\t\t\t\tfunct.apply(this, arguments);\n\t\t\t\t\tthis.toolbar.resetMode();\n\t\t\t\t});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.editor.insertFunction = null;\n\t\t\t}\n\t\t}));\n\t\t\n\t\t// Resets the selected tool after a doubleclick or escape keystroke\n\t\tthis.resetHandler = mxUtils.bind(this, function()\n\t\t{\n\t\t\tif (this.toolbar != null)\n\t\t\t{\n\t\t\t\tthis.toolbar.resetMode(true);\n\t\t\t}\n\t\t});\n\n\t\tthis.editor.graph.addListener(mxEvent.DOUBLE_CLICK, this.resetHandler);\n\t\tthis.editor.addListener(mxEvent.ESCAPE, this.resetHandler);\n\t}\n};\n\n/**\n * Function: addItem\n *\n * Adds a new item that executes the given action in <editor>. The title,\n * icon and pressedIcon are used to display the toolbar item.\n * \n * Parameters:\n *\n * title - String that represents the title (tooltip) for the item.\n * icon - URL of the icon to be used for displaying the item.\n * action - Name of the action to execute when the item is clicked.\n * pressed - Optional URL of the icon for the pressed state.\n */\nmxDefaultToolbar.prototype.addItem = function(title, icon, action, pressed)\n{\n\tvar clickHandler = mxUtils.bind(this, function()\n\t{\n\t\tif (action != null && action.length > 0)\n\t\t{\n\t\t\tthis.editor.execute(action);\n\t\t}\n\t});\n\t\n\treturn this.toolbar.addItem(title, icon, clickHandler, pressed);\n};\n\n/**\n * Function: addSeparator\n *\n * Adds a vertical separator using the optional icon.\n * \n * Parameters:\n * \n * icon - Optional URL of the icon that represents the vertical separator.\n * Default is <mxClient.imageBasePath> + '/separator.gif'.\n */\nmxDefaultToolbar.prototype.addSeparator = function(icon)\n{\n\ticon = icon || mxClient.imageBasePath + '/separator.gif';\n\tthis.toolbar.addSeparator(icon);\n};\n\t\n/**\n * Function: addCombo\n *\n * Helper method to invoke <mxToolbar.addCombo> on <toolbar> and return the\n * resulting DOM node.\n */\nmxDefaultToolbar.prototype.addCombo = function()\n{\n\treturn this.toolbar.addCombo();\n};\n\t\t\n/**\n * Function: addActionCombo\n *\n * Helper method to invoke <mxToolbar.addActionCombo> on <toolbar> using\n * the given title and return the resulting DOM node.\n * \n * Parameters:\n * \n * title - String that represents the title of the combo.\n */\nmxDefaultToolbar.prototype.addActionCombo = function(title)\n{\n\treturn this.toolbar.addActionCombo(title);\n};\n\n/**\n * Function: addActionOption\n *\n * Binds the given action to a option with the specified label in the\n * given combo. Combo is an object returned from an earlier call to\n * <addCombo> or <addActionCombo>.\n * \n * Parameters:\n * \n * combo - DOM node that represents the combo box.\n * title - String that represents the title of the combo.\n * action - Name of the action to execute in <editor>.\n */\nmxDefaultToolbar.prototype.addActionOption = function(combo, title, action)\n{\n\tvar clickHandler = mxUtils.bind(this, function()\n\t{\n\t\tthis.editor.execute(action);\n\t});\n\t\n\tthis.addOption(combo, title, clickHandler);\n};\n\n/**\n * Function: addOption\n *\n * Helper method to invoke <mxToolbar.addOption> on <toolbar> and return\n * the resulting DOM node that represents the option.\n * \n * Parameters:\n * \n * combo - DOM node that represents the combo box.\n * title - String that represents the title of the combo.\n * value - Object that represents the value of the option.\n */\nmxDefaultToolbar.prototype.addOption = function(combo, title, value)\n{\n\treturn this.toolbar.addOption(combo, title, value);\n};\n\t\n/**\n * Function: addMode\n *\n * Creates an item for selecting the given mode in the <editor>'s graph.\n * Supported modenames are select, connect and pan.\n * \n * Parameters:\n * \n * title - String that represents the title of the item.\n * icon - URL of the icon that represents the item.\n * mode - String that represents the mode name to be used in\n * <mxEditor.setMode>.\n * pressed - Optional URL of the icon that represents the pressed state.\n * funct - Optional JavaScript function that takes the <mxEditor> as the\n * first and only argument that is executed after the mode has been\n * selected.\n */\nmxDefaultToolbar.prototype.addMode = function(title, icon, mode, pressed, funct)\n{\n\tvar clickHandler = mxUtils.bind(this, function()\n\t{\n\t\tthis.editor.setMode(mode);\n\t\t\n\t\tif (funct != null)\n\t\t{\n\t\t\tfunct(this.editor);\n\t\t}\n\t});\n\t\n\treturn this.toolbar.addSwitchMode(title, icon, clickHandler, pressed);\n};\n\n/**\n * Function: addPrototype\n *\n * Creates an item for inserting a clone of the specified prototype cell into\n * the <editor>'s graph. The ptype may either be a cell or a function that\n * returns a cell.\n * \n * Parameters:\n * \n * title - String that represents the title of the item.\n * icon - URL of the icon that represents the item.\n * ptype - Function or object that represents the prototype cell. If ptype\n * is a function then it is invoked with no arguments to create new\n * instances.\n * pressed - Optional URL of the icon that represents the pressed state.\n * insert - Optional JavaScript function that handles an insert of the new\n * cell. This function takes the <mxEditor>, new cell to be inserted, mouse\n * event and optional <mxCell> under the mouse pointer as arguments.\n * toggle - Optional boolean that specifies if the item can be toggled.\n * Default is true.\n */\nmxDefaultToolbar.prototype.addPrototype = function(title, icon, ptype, pressed, insert, toggle)\n{\n\t// Creates a wrapper function that is in charge of constructing\n\t// the new cell instance to be inserted into the graph\n\tvar factory = mxUtils.bind(this, function()\n\t{\n\t\tif (typeof(ptype) == 'function')\n\t\t{\n\t\t\treturn ptype();\n\t\t}\n\t\telse if (ptype != null)\n\t\t{\n\t\t\treturn this.editor.graph.cloneCell(ptype);\n\t\t}\n\t\t\n\t\treturn null;\n\t});\n\t\n\t// Defines the function for a click event on the graph\n\t// after this item has been selected in the toolbar\n\tvar clickHandler = mxUtils.bind(this, function(evt, cell)\n\t{\n\t\tif (typeof(insert) == 'function')\n\t\t{\n\t\t\tinsert(this.editor, factory(), evt, cell);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.drop(factory(), evt, cell);\n\t\t}\n\t\t\n\t\tthis.toolbar.resetMode();\n\t\tmxEvent.consume(evt);\n\t});\n\t\n\tvar img = this.toolbar.addMode(title, icon, clickHandler, pressed, null, toggle);\n\t\t\t\t\n\t// Creates a wrapper function that calls the click handler without\n\t// the graph argument\n\tvar dropHandler = function(graph, evt, cell)\n\t{\n\t\tclickHandler(evt, cell);\n\t};\n\t\n\tthis.installDropHandler(img, dropHandler);\n\t\n\treturn img;\n};\n\n/**\n * Function: drop\n * \n * Handles a drop from a toolbar item to the graph. The given vertex\n * represents the new cell to be inserted. This invokes <insert> or\n * <connect> depending on the given target cell.\n * \n * Parameters:\n * \n * vertex - <mxCell> to be inserted.\n * evt - Mouse event that represents the drop.\n * target - Optional <mxCell> that represents the drop target.\n */\nmxDefaultToolbar.prototype.drop = function(vertex, evt, target)\n{\n\tvar graph = this.editor.graph;\n\tvar model = graph.getModel();\n\t\n\tif (target == null ||\n\t\tmodel.isEdge(target) ||\n\t\t!this.connectOnDrop ||\n\t\t!graph.isCellConnectable(target))\n\t{\n\t\twhile (target != null &&\n\t\t\t!graph.isValidDropTarget(target, [vertex], evt))\n\t\t{\n\t\t\ttarget = model.getParent(target);\n\t\t}\n\t\t\n\t\tthis.insert(vertex, evt, target);\n\t}\n\telse\n\t{\n\t\tthis.connect(vertex, evt, target);\n\t}\n};\n\n/**\n * Function: insert\n *\n * Handles a drop by inserting the given vertex into the given parent cell\n * or the default parent if no parent is specified.\n * \n * Parameters:\n * \n * vertex - <mxCell> to be inserted.\n * evt - Mouse event that represents the drop.\n * parent - Optional <mxCell> that represents the parent.\n */\nmxDefaultToolbar.prototype.insert = function(vertex, evt, target)\n{\n\tvar graph = this.editor.graph;\n\t\n\tif (graph.canImportCell(vertex))\n\t{\n\t\tvar x = mxEvent.getClientX(evt);\n\t\tvar y = mxEvent.getClientY(evt);\n\t\tvar pt = mxUtils.convertPoint(graph.container, x, y);\n\t\t\n\t\t// Splits the target edge or inserts into target group\n\t\tif (graph.isSplitEnabled() &&\n\t\t\tgraph.isSplitTarget(target, [vertex], evt))\n\t\t{\n\t\t\treturn graph.splitEdge(target, [vertex], null, pt.x, pt.y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.editor.addVertex(target, vertex, pt.x, pt.y);\n\t\t}\n\t}\n\t\n\treturn null;\n};\n\n/**\n * Function: connect\n * \n * Handles a drop by connecting the given vertex to the given source cell.\n * \n * vertex - <mxCell> to be inserted.\n * evt - Mouse event that represents the drop.\n * source - Optional <mxCell> that represents the source terminal.\n */\nmxDefaultToolbar.prototype.connect = function(vertex, evt, source)\n{\n\tvar graph = this.editor.graph;\n\tvar model = graph.getModel();\n\t\n\tif (source != null &&\n\t\tgraph.isCellConnectable(vertex) &&\n\t\tgraph.isEdgeValid(null, source, vertex))\n\t{\n\t\tvar edge = null;\n\n\t\tmodel.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tvar geo = model.getGeometry(source);\n\t\t\tvar g = model.getGeometry(vertex).clone();\n\t\t\t\n\t\t\t// Moves the vertex away from the drop target that will\n\t\t\t// be used as the source for the new connection\n\t\t\tg.x = geo.x + (geo.width - g.width) / 2;\n\t\t\tg.y = geo.y + (geo.height - g.height) / 2;\n\t\t\t\n\t\t\tvar step = this.spacing * graph.gridSize;\n\t\t\tvar dist = model.getDirectedEdgeCount(source, true) * 20;\n\t\t\t\n\t\t\tif (this.editor.horizontalFlow)\n\t\t\t{\n\t\t\t\tg.x += (g.width + geo.width) / 2 + step + dist;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tg.y += (g.height + geo.height) / 2 + step + dist;\n\t\t\t}\n\t\t\t\n\t\t\tvertex.setGeometry(g);\n\t\t\t\n\t\t\t// Fires two add-events with the code below - should be fixed\n\t\t\t// to only fire one add event for both inserts\n\t\t\tvar parent = model.getParent(source);\n\t\t\tgraph.addCell(vertex, parent);\n\t\t\tgraph.constrainChild(vertex);\n\n\t\t\t// Creates the edge using the editor instance and calls\n\t\t\t// the second function that fires an add event\n\t\t\tedge = this.editor.createEdge(source, vertex);\n\t\t\t\n\t\t\tif (model.getGeometry(edge) == null)\n\t\t\t{\n\t\t\t\tvar edgeGeometry = new mxGeometry();\n\t\t\t\tedgeGeometry.relative = true;\n\t\t\t\t\n\t\t\t\tmodel.setGeometry(edge, edgeGeometry);\n\t\t\t}\n\t\t\t\n\t\t\tgraph.addEdge(edge, parent, source, vertex);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tmodel.endUpdate();\n\t\t}\n\t\t\n\t\tgraph.setSelectionCells([vertex, edge]);\n\t\tgraph.scrollCellToVisible(vertex);\n\t}\n};\n\n/**\n * Function: installDropHandler\n * \n * Makes the given img draggable using the given function for handling a\n * drop event.\n * \n * Parameters:\n * \n * img - DOM node that represents the image.\n * dropHandler - Function that handles a drop of the image.\n */\nmxDefaultToolbar.prototype.installDropHandler = function (img, dropHandler)\n{\n\tvar sprite = document.createElement('img');\n\tsprite.setAttribute('src', img.getAttribute('src'));\n\n\t// Handles delayed loading of the images\n\tvar loader = mxUtils.bind(this, function(evt)\n\t{\n\t\t// Preview uses the image node with double size. Later this can be\n\t\t// changed to use a separate preview and guides, but for this the\n\t\t// dropHandler must use the additional x- and y-arguments and the\n\t\t// dragsource which makeDraggable returns much be configured to\n\t\t// use guides via mxDragSource.isGuidesEnabled.\n\t\tsprite.style.width = (2 * img.offsetWidth) + 'px';\n\t\tsprite.style.height = (2 * img.offsetHeight) + 'px';\n\n\t\tmxUtils.makeDraggable(img, this.editor.graph, dropHandler,\n\t\t\tsprite);\n\t\tmxEvent.removeListener(sprite, 'load', loader);\n\t});\n\n\tif (mxClient.IS_IE)\n\t{\n\t\tloader();\n\t}\n\telse\n\t{\n\t\tmxEvent.addListener(sprite, 'load', loader);\n\t}\t\n};\n\n/**\n * Function: destroy\n * \n * Destroys the <toolbar> associated with this object and removes all\n * installed listeners. This does normally not need to be called, the\n * <toolbar> is destroyed automatically when the window unloads (in IE) by\n * <mxEditor>.\n */\nmxDefaultToolbar.prototype.destroy = function ()\n{\n\tif (this.resetHandler != null)\n\t{\n\t\tthis.editor.graph.removeListener('dblclick', this.resetHandler);\n\t\tthis.editor.removeListener('escape', this.resetHandler);\n\t\tthis.resetHandler = null;\n\t}\n\t\n\tif (this.toolbar != null)\n\t{\n\t\tthis.toolbar.destroy();\n\t\tthis.toolbar = null;\n\t}\n};\n\n__mxOutput.mxDefaultToolbar = typeof mxDefaultToolbar !== 'undefined' ? mxDefaultToolbar : undefined;\n\n/**\n * Copyright (c) 2006-2019, JGraph Ltd\n * Copyright (c) 2006-2019, draw.io AG\n */\n/**\n * Class: mxEditor\n *\n * Extends <mxEventSource> to implement an application wrapper for a graph that\n * adds <actions>, I/O using <mxCodec>, auto-layout using <mxLayoutManager>,\n * command history using <undoManager>, and standard dialogs and widgets, eg.\n * properties, help, outline, toolbar, and popupmenu. It also adds <templates>\n * to be used as cells in toolbars, auto-validation using the <validation>\n * flag, attribute cycling using <cycleAttributeValues>, higher-level events\n * such as <root>, and backend integration using <urlPost> and <urlImage>.\n *\n * Actions:\n *\n * Actions are functions stored in the <actions> array under their names. The\n * functions take the <mxEditor> as the first, and an optional <mxCell> as the\n * second argument and are invoked using <execute>. Any additional arguments\n * passed to execute are passed on to the action as-is.\n *\n * A list of built-in actions is available in the <addActions> description.\n *\n * Read/write Diagrams:\n *\n * To read a diagram from an XML string, for example from a textfield within the\n * page, the following code is used:\n *\n * (code)\n * var doc = mxUtils.parseXML(xmlString);\n * var node = doc.documentElement;\n * editor.readGraphModel(node);\n * (end)\n *\n * For reading a diagram from a remote location, use the <open> method.\n *\n * To save diagrams in XML on a server, you can set the <urlPost> variable.\n * This variable will be used in <getUrlPost> to construct a URL for the post\n * request that is issued in the <save> method. The post request contains the\n * XML representation of the diagram as returned by <writeGraphModel> in the\n * xml parameter.\n *\n * On the server side, the post request is processed using standard\n * technologies such as Java Servlets, CGI, .NET or ASP.\n *\n * Here are some examples of processing a post request in various languages.\n *\n * - Java: URLDecoder.decode(request.getParameter(\"xml\"), \"UTF-8\").replace(\"\\n\", \"&#xa;\")\n *\n * Note that the linefeeds should only be replaced if the XML is\n * processed in Java, for example when creating an image, but not\n * if the XML is passed back to the client-side.\n *\n * - .NET: HttpUtility.UrlDecode(context.Request.Params[\"xml\"])\n * - PHP: urldecode($_POST[\"xml\"])\n *\n * Creating images:\n *\n * A backend (Java, PHP or C#) is required for creating images. The\n * distribution contains an example for each backend (ImageHandler.java,\n * ImageHandler.cs and graph.php). More information about using a backend\n * to create images can be found in the readme.html files. Note that the\n * preview is implemented using VML/SVG in the browser and does not require\n * a backend. The backend is only required to creates images (bitmaps).\n *\n * Special characters:\n *\n * Note There are five characters that should always appear in XML content as\n * escapes, so that they do not interact with the syntax of the markup. These\n * are part of the language for all documents based on XML and for HTML.\n *\n * - &lt; (<)\n * - &gt; (>)\n * - &amp; (&)\n * - &quot; (\")\n * - &apos; (')\n *\n * Although it is part of the XML language, &apos; is not defined in HTML.\n * For this reason the XHTML specification recommends instead the use of\n * &#39; if text may be passed to a HTML user agent.\n *\n * If you are having problems with special characters on the server-side then\n * you may want to try the <escapePostData> flag.\n *\n * For converting decimal escape sequences inside strings, a user has provided\n * us with the following function:\n *\n * (code)\n * function html2js(text)\n * {\n *   var entitySearch = /&#[0-9]+;/;\n *   var entity;\n *\n *   while (entity = entitySearch.exec(text))\n *   {\n *     var charCode = entity[0].substring(2, entity[0].length -1);\n *     text = text.substring(0, entity.index)\n *            + String.fromCharCode(charCode)\n *            + text.substring(entity.index + entity[0].length);\n *   }\n *\n *   return text;\n * }\n * (end)\n *\n * Otherwise try using hex escape sequences and the built-in unescape function\n * for converting such strings.\n *\n * Local Files:\n *\n * For saving and opening local files, no standardized method exists that\n * works across all browsers. The recommended way of dealing with local files\n * is to create a backend that streams the XML data back to the browser (echo)\n * as an attachment so that a Save-dialog is displayed on the client-side and\n * the file can be saved to the local disk.\n *\n * For example, in PHP the code that does this looks as follows.\n *\n * (code)\n * $xml = stripslashes($_POST[\"xml\"]);\n * header(\"Content-Disposition: attachment; filename=\\\"diagram.xml\\\"\");\n * echo($xml);\n * (end)\n *\n * To open a local file, the file should be uploaded via a form in the browser\n * and then opened from the server in the editor.\n *\n * Cell Properties:\n *\n * The properties displayed in the properties dialog are the attributes and\n * values of the cell's user object, which is an XML node. The XML node is\n * defined in the templates section of the config file.\n *\n * The templates are stored in <mxEditor.templates> and contain cells which\n * are cloned at insertion time to create new vertices by use of drag and\n * drop from the toolbar. Each entry in the toolbar for adding a new vertex\n * must refer to an existing template.\n *\n * In the following example, the task node is a business object and only the\n * mxCell node and its mxGeometry child contain graph information:\n *\n * (code)\n * <Task label=\"Task\" description=\"\">\n *   <mxCell vertex=\"true\">\n *     <mxGeometry as=\"geometry\" width=\"72\" height=\"32\"/>\n *   </mxCell>\n * </Task>\n * (end)\n *\n * The idea is that the XML representation is inverse from the in-memory\n * representation: The outer XML node is the user object and the inner node is\n * the cell. This means the user object of the cell is the Task node with no\n * children for the above example:\n *\n * (code)\n * <Task label=\"Task\" description=\"\"/>\n * (end)\n *\n * The Task node can have any tag name, attributes and child nodes. The\n * <mxCodec> will use the XML hierarchy as the user object, while removing the\n * \"known annotations\", such as the mxCell node. At save-time the cell data\n * will be \"merged\" back into the user object. The user object is only modified\n * via the properties dialog during the lifecycle of the cell.\n *\n * In the default implementation of <createProperties>, the user object's\n * attributes are put into a form for editing. Attributes are changed using\n * the <mxCellAttributeChange> action in the model. The dialog can be replaced\n * by overriding the <createProperties> hook or by replacing the showProperties\n * action in <actions>. Alternatively, the entry in the config file's popupmenu\n * section can be modified to invoke a different action.\n *\n * If you want to displey the properties dialog on a doubleclick, you can set\n * <mxEditor.dblClickAction> to showProperties as follows:\n *\n * (code)\n * editor.dblClickAction = 'showProperties';\n * (end)\n *\n * Popupmenu and Toolbar:\n *\n * The toolbar and popupmenu are typically configured using the respective\n * sections in the config file, that is, the popupmenu is defined as follows:\n *\n * (code)\n * <mxEditor>\n *   <mxDefaultPopupMenu as=\"popupHandler\">\n * \t\t<add as=\"cut\" action=\"cut\" icon=\"images/cut.gif\"/>\n *      ...\n * (end)\n *\n * New entries can be added to the toolbar by inserting an add-node into the\n * above configuration. Existing entries may be removed and changed by\n * modifying or removing the respective entries in the configuration.\n * The configuration is read by the <mxDefaultPopupMenuCodec>, the format of the\n * configuration is explained in <mxDefaultPopupMenu.decode>.\n *\n * The toolbar is defined in the mxDefaultToolbar section. Items can be added\n * and removed in this section.\n *\n * (code)\n * <mxEditor>\n *   <mxDefaultToolbar>\n *     <add as=\"save\" action=\"save\" icon=\"images/save.gif\"/>\n *     <add as=\"Swimlane\" template=\"swimlane\" icon=\"images/swimlane.gif\"/>\n *     ...\n * (end)\n *\n * The format of the configuration is described in\n * <mxDefaultToolbarCodec.decode>.\n *\n * Ids:\n *\n * For the IDs, there is an implicit behaviour in <mxCodec>: It moves the Id\n * from the cell to the user object at encoding time and vice versa at decoding\n * time. For example, if the Task node from above has an id attribute, then\n * the <mxCell.id> of the corresponding cell will have this value. If there\n * is no Id collision in the model, then the cell may be retrieved using this\n * Id with the <mxGraphModel.getCell> function. If there is a collision, a new\n * Id will be created for the cell using <mxGraphModel.createId>. At encoding\n * time, this new Id will replace the value previously stored under the id\n * attribute in the Task node.\n *\n * See <mxEditorCodec>, <mxDefaultToolbarCodec> and <mxDefaultPopupMenuCodec>\n * for information about configuring the editor and user interface.\n *\n * Programmatically inserting cells:\n *\n * For inserting a new cell, say, by clicking a button in the document,\n * the following code can be used. This requires an reference to the editor.\n *\n * (code)\n * var userObject = new Object();\n * var parent = editor.graph.getDefaultParent();\n * var model = editor.graph.model;\n * model.beginUpdate();\n * try\n * {\n *   editor.graph.insertVertex(parent, null, userObject, 20, 20, 80, 30);\n * }\n * finally\n * {\n *   model.endUpdate();\n * }\n * (end)\n *\n * If a template cell from the config file should be inserted, then a clone\n * of the template can be created as follows. The clone is then inserted using\n * the add function instead of addVertex.\n *\n * (code)\n * var template = editor.templates['task'];\n * var clone = editor.graph.model.cloneCell(template);\n * (end)\n *\n * Resources:\n *\n * resources/editor - Language resources for mxEditor\n *\n * Callback: onInit\n *\n * Called from within the constructor. In the callback,\n * \"this\" refers to the editor instance.\n *\n * Cookie: mxgraph=seen\n *\n * Set when the editor is started. Never expires. Use\n * <resetFirstTime> to reset this cookie. This cookie\n * only exists if <onInit> is implemented.\n *\n * Event: mxEvent.OPEN\n *\n * Fires after a file was opened in <open>. The <code>filename</code> property\n * contains the filename that was used. The same value is also available in\n * <filename>.\n *\n * Event: mxEvent.SAVE\n *\n * Fires after the current file was saved in <save>. The <code>url</code>\n * property contains the URL that was used for saving.\n *\n * Event: mxEvent.POST\n *\n * Fires if a successful response was received in <postDiagram>. The\n * <code>request</code> property contains the <mxXmlRequest>, the\n * <code>url</code> and <code>data</code> properties contain the URL and the\n * data that were used in the post request.\n *\n * Event: mxEvent.ROOT\n *\n * Fires when the current root has changed, or when the title of the current\n * root has changed. This event has no properties.\n *\n * Event: mxEvent.BEFORE_ADD_VERTEX\n *\n * Fires before a vertex is added in <addVertex>. The <code>vertex</code>\n * property contains the new vertex and the <code>parent</code> property\n * contains its parent.\n *\n * Event: mxEvent.ADD_VERTEX\n *\n * Fires between begin- and endUpdate in <addVertex>. The <code>vertex</code>\n * property contains the vertex that is being inserted.\n *\n * Event: mxEvent.AFTER_ADD_VERTEX\n *\n * Fires after a vertex was inserted and selected in <addVertex>. The\n * <code>vertex</code> property contains the new vertex.\n *\n * Example:\n *\n * For starting an in-place edit after a new vertex has been added to the\n * graph, the following code can be used.\n *\n * (code)\n * editor.addListener(mxEvent.AFTER_ADD_VERTEX, function(sender, evt)\n * {\n *   var vertex = evt.getProperty('vertex');\n *\n *   if (editor.graph.isCellEditable(vertex))\n *   {\n *   \teditor.graph.startEditingAtCell(vertex);\n *   }\n * });\n * (end)\n *\n * Event: mxEvent.ESCAPE\n *\n * Fires when the escape key is pressed. The <code>event</code> property\n * contains the key event.\n *\n * Constructor: mxEditor\n *\n * Constructs a new editor. This function invokes the <onInit> callback\n * upon completion.\n *\n * Example:\n *\n * (code)\n * var config = mxUtils.load('config/diagrameditor.xml').getDocumentElement();\n * var editor = new mxEditor(config);\n * (end)\n *\n * Parameters:\n *\n * config - Optional XML node that contains the configuration.\n */\nfunction mxEditor(config)\n{\n\tthis.actions = [];\n\tthis.addActions();\n\n\t// Executes the following only if a document has been instanciated.\n\t// That is, don't execute when the editorcodec is setup.\n\tif (document.body != null)\n\t{\n\t\t// Defines instance fields\n\t\tthis.cycleAttributeValues = [];\n\t\tthis.popupHandler = new mxDefaultPopupMenu();\n\t\tthis.undoManager = new mxUndoManager();\n\n\t\t// Creates the graph and toolbar without the containers\n\t\tthis.graph = this.createGraph();\n\t\tthis.toolbar = this.createToolbar();\n\n\t\t// Creates the global keyhandler (requires graph instance)\n\t\tthis.keyHandler = new mxDefaultKeyHandler(this);\n\n\t\t// Configures the editor using the URI\n\t\t// which was passed to the ctor\n\t\tthis.configure(config);\n\n\t\t// Assigns the swimlaneIndicatorColorAttribute on the graph\n\t\tthis.graph.swimlaneIndicatorColorAttribute = this.cycleAttributeName;\n\n\t\t// Checks if the <onInit> hook has been set\n\t\tif (this.onInit != null)\n\t\t{\n\t\t\t// Invokes the <onInit> hook\n\t\t\tthis.onInit();\n\t\t}\n\n\t\t// Automatic deallocation of memory\n\t\tif (mxClient.IS_IE)\n\t\t{\n\t\t\tmxEvent.addListener(window, 'unload', mxUtils.bind(this, function()\n\t\t\t{\n\t\t\t\tthis.destroy();\n\t\t\t}));\n\t\t}\n\t}\n};\n\n/**\n * Installs the required language resources at class\n * loading time.\n */\nif (mxLoadResources)\n{\n\tmxResources.add(mxClient.basePath + '/resources/editor');\n}\nelse\n{\n\tmxClient.defaultBundles.push(mxClient.basePath + '/resources/editor');\n}\n\n/**\n * Extends mxEventSource.\n */\nmxEditor.prototype = new mxEventSource();\nmxEditor.prototype.constructor = mxEditor;\n\n/**\n * Group: Controls and Handlers\n */\n\n/**\n * Variable: askZoomResource\n *\n * Specifies the resource key for the zoom dialog. If the resource for this\n * key does not exist then the value is used as the error message. Default\n * is 'askZoom'.\n */\nmxEditor.prototype.askZoomResource = (mxClient.language != 'none') ? 'askZoom' : '';\n\n/**\n * Variable: lastSavedResource\n *\n * Specifies the resource key for the last saved info. If the resource for\n * this key does not exist then the value is used as the error message.\n * Default is 'lastSaved'.\n */\nmxEditor.prototype.lastSavedResource = (mxClient.language != 'none') ? 'lastSaved' : '';\n\n/**\n * Variable: currentFileResource\n *\n * Specifies the resource key for the current file info. If the resource for\n * this key does not exist then the value is used as the error message.\n * Default is 'currentFile'.\n */\nmxEditor.prototype.currentFileResource = (mxClient.language != 'none') ? 'currentFile' : '';\n\n/**\n * Variable: propertiesResource\n *\n * Specifies the resource key for the properties window title. If the\n * resource for this key does not exist then the value is used as the\n * error message. Default is 'properties'.\n */\nmxEditor.prototype.propertiesResource = (mxClient.language != 'none') ? 'properties' : '';\n\n/**\n * Variable: tasksResource\n *\n * Specifies the resource key for the tasks window title. If the\n * resource for this key does not exist then the value is used as the\n * error message. Default is 'tasks'.\n */\nmxEditor.prototype.tasksResource = (mxClient.language != 'none') ? 'tasks' : '';\n\n/**\n * Variable: helpResource\n *\n * Specifies the resource key for the help window title. If the\n * resource for this key does not exist then the value is used as the\n * error message. Default is 'help'.\n */\nmxEditor.prototype.helpResource = (mxClient.language != 'none') ? 'help' : '';\n\n/**\n * Variable: outlineResource\n *\n * Specifies the resource key for the outline window title. If the\n * resource for this key does not exist then the value is used as the\n * error message. Default is 'outline'.\n */\nmxEditor.prototype.outlineResource = (mxClient.language != 'none') ? 'outline' : '';\n\n/**\n * Variable: outline\n *\n * Reference to the <mxWindow> that contains the outline. The <mxOutline>\n * is stored in outline.outline.\n */\nmxEditor.prototype.outline = null;\n\n/**\n * Variable: graph\n *\n * Holds a <mxGraph> for displaying the diagram. The graph\n * is created in <setGraphContainer>.\n */\nmxEditor.prototype.graph = null;\n\n/**\n * Variable: graphRenderHint\n *\n * Holds the render hint used for creating the\n * graph in <setGraphContainer>. See <mxGraph>.\n * Default is null.\n */\nmxEditor.prototype.graphRenderHint = null;\n\n/**\n * Variable: toolbar\n *\n * Holds a <mxDefaultToolbar> for displaying the toolbar. The\n * toolbar is created in <setToolbarContainer>.\n */\nmxEditor.prototype.toolbar = null;\n\n/**\n * Variable: status\n *\n * DOM container that holds the statusbar. Default is null.\n * Use <setStatusContainer> to set this value.\n */\nmxEditor.prototype.status = null;\n\n/**\n * Variable: popupHandler\n *\n * Holds a <mxDefaultPopupMenu> for displaying\n * popupmenus.\n */\nmxEditor.prototype.popupHandler = null;\n\n/**\n * Variable: undoManager\n *\n * Holds an <mxUndoManager> for the command history.\n */\nmxEditor.prototype.undoManager = null;\n\n/**\n * Variable: keyHandler\n *\n * Holds a <mxDefaultKeyHandler> for handling keyboard events.\n * The handler is created in <setGraphContainer>.\n */\nmxEditor.prototype.keyHandler = null;\n\n/**\n * Group: Actions and Options\n */\n\n/**\n * Variable: actions\n *\n * Maps from actionnames to actions, which are functions taking\n * the editor and the cell as arguments. Use <addAction>\n * to add or replace an action and <execute> to execute an action\n * by name, passing the cell to be operated upon as the second\n * argument.\n */\nmxEditor.prototype.actions = null;\n\n/**\n * Variable: dblClickAction\n *\n * Specifies the name of the action to be executed\n * when a cell is double clicked. Default is 'edit'.\n *\n * To handle a singleclick, use the following code.\n *\n * (code)\n * editor.graph.addListener(mxEvent.CLICK, function(sender, evt)\n * {\n *   var e = evt.getProperty('event');\n *   var cell = evt.getProperty('cell');\n *\n *   if (cell != null && !e.isConsumed())\n *   {\n *     // Do something useful with cell...\n *     e.consume();\n *   }\n * });\n * (end)\n */\nmxEditor.prototype.dblClickAction = 'edit';\n\n/**\n * Variable: swimlaneRequired\n *\n * Specifies if new cells must be inserted\n * into an existing swimlane. Otherwise, cells\n * that are not swimlanes can be inserted as\n * top-level cells. Default is false.\n */\nmxEditor.prototype.swimlaneRequired = false;\n\n/**\n * Variable: disableContextMenu\n *\n * Specifies if the context menu should be disabled in the graph container.\n * Default is true.\n */\nmxEditor.prototype.disableContextMenu = true;\n\n/**\n * Group: Templates\n */\n\n/**\n * Variable: insertFunction\n *\n * Specifies the function to be used for inserting new\n * cells into the graph. This is assigned from the\n * <mxDefaultToolbar> if a vertex-tool is clicked.\n */\nmxEditor.prototype.insertFunction = null;\n\n/**\n * Variable: forcedInserting\n *\n * Specifies if a new cell should be inserted on a single\n * click even using <insertFunction> if there is a cell\n * under the mousepointer, otherwise the cell under the\n * mousepointer is selected. Default is false.\n */\nmxEditor.prototype.forcedInserting = false;\n\n/**\n * Variable: templates\n *\n * Maps from names to protoype cells to be used\n * in the toolbar for inserting new cells into\n * the diagram.\n */\nmxEditor.prototype.templates = null;\n\n/**\n * Variable: defaultEdge\n *\n * Prototype edge cell that is used for creating\n * new edges.\n */\nmxEditor.prototype.defaultEdge = null;\n\n/**\n * Variable: defaultEdgeStyle\n *\n * Specifies the edge style to be returned in <getEdgeStyle>.\n * Default is null.\n */\nmxEditor.prototype.defaultEdgeStyle = null;\n\n/**\n * Variable: defaultGroup\n *\n * Prototype group cell that is used for creating\n * new groups.\n */\nmxEditor.prototype.defaultGroup = null;\n\n/**\n * Variable: groupBorderSize\n *\n * Default size for the border of new groups. If null,\n * then then <mxGraph.gridSize> is used. Default is\n * null.\n */\nmxEditor.prototype.groupBorderSize = null;\n\n/**\n * Group: Backend Integration\n */\n\n/**\n * Variable: filename\n *\n * Contains the URL of the last opened file as a string.\n * Default is null.\n */\nmxEditor.prototype.filename = null;\n\n/**\n * Variable: lineFeed\n *\n * Character to be used for encoding linefeeds in <save>. Default is '&#xa;'.\n */\nmxEditor.prototype.linefeed = '&#xa;';\n\n/**\n * Variable: postParameterName\n *\n * Specifies if the name of the post parameter that contains the diagram\n * data in a post request to the server. Default is 'xml'.\n */\nmxEditor.prototype.postParameterName = 'xml';\n\n/**\n * Variable: escapePostData\n *\n * Specifies if the data in the post request for saving a diagram\n * should be converted using encodeURIComponent. Default is true.\n */\nmxEditor.prototype.escapePostData = true;\n\n/**\n * Variable: urlPost\n *\n * Specifies the URL to be used for posting the diagram\n * to a backend in <save>.\n */\nmxEditor.prototype.urlPost = null;\n\n/**\n * Variable: urlImage\n *\n * Specifies the URL to be used for creating a bitmap of\n * the graph in the image action.\n */\nmxEditor.prototype.urlImage = null;\n\n/**\n * Group: Autolayout\n */\n\n/**\n * Variable: horizontalFlow\n *\n * Specifies the direction of the flow\n * in the diagram. This is used in the\n * layout algorithms. Default is false,\n * ie. vertical flow.\n */\nmxEditor.prototype.horizontalFlow = false;\n\n/**\n * Variable: layoutDiagram\n *\n * Specifies if the top-level elements in the\n * diagram should be layed out using a vertical\n * or horizontal stack depending on the setting\n * of <horizontalFlow>. The spacing between the\n * swimlanes is specified by <swimlaneSpacing>.\n * Default is false.\n *\n * If the top-level elements are swimlanes, then\n * the intra-swimlane layout is activated by\n * the <layoutSwimlanes> switch.\n */\nmxEditor.prototype.layoutDiagram = false;\n\n/**\n * Variable: swimlaneSpacing\n *\n * Specifies the spacing between swimlanes if\n * automatic layout is turned on in\n * <layoutDiagram>. Default is 0.\n */\nmxEditor.prototype.swimlaneSpacing = 0;\n\n/**\n * Variable: maintainSwimlanes\n *\n * Specifies if the swimlanes should be kept at the same\n * width or height depending on the setting of\n * <horizontalFlow>.  Default is false.\n *\n * For horizontal flows, all swimlanes\n * have the same height and for vertical flows, all swimlanes\n * have the same width. Furthermore, the swimlanes are\n * automatically \"stacked\" if <layoutDiagram> is true.\n */\nmxEditor.prototype.maintainSwimlanes = false;\n\n/**\n * Variable: layoutSwimlanes\n *\n * Specifies if the children of swimlanes should\n * be layed out, either vertically or horizontally\n * depending on <horizontalFlow>.\n * Default is false.\n */\nmxEditor.prototype.layoutSwimlanes = false;\n\n/**\n * Group: Attribute Cycling\n */\n\n/**\n * Variable: cycleAttributeValues\n *\n * Specifies the attribute values to be cycled when\n * inserting new swimlanes. Default is an empty\n * array.\n */\nmxEditor.prototype.cycleAttributeValues = null;\n\n/**\n * Variable: cycleAttributeIndex\n *\n * Index of the last consumed attribute index. If a new\n * swimlane is inserted, then the <cycleAttributeValues>\n * at this index will be used as the value for\n * <cycleAttributeName>. Default is 0.\n */\nmxEditor.prototype.cycleAttributeIndex = 0;\n\n/**\n * Variable: cycleAttributeName\n *\n * Name of the attribute to be assigned a <cycleAttributeValues>\n * when inserting new swimlanes. Default is 'fillColor'.\n */\nmxEditor.prototype.cycleAttributeName = 'fillColor';\n\n/**\n * Group: Windows\n */\n\n/**\n * Variable: tasks\n *\n * Holds the <mxWindow> created in <showTasks>.\n */\nmxEditor.prototype.tasks = null;\n\n/**\n * Variable: tasksWindowImage\n *\n * Icon for the tasks window.\n */\nmxEditor.prototype.tasksWindowImage = null;\n\n/**\n * Variable: tasksTop\n *\n * Specifies the top coordinate of the tasks window in pixels.\n * Default is 20.\n */\nmxEditor.prototype.tasksTop = 20;\n\n/**\n * Variable: help\n *\n * Holds the <mxWindow> created in <showHelp>.\n */\nmxEditor.prototype.help = null;\n\n/**\n * Variable: helpWindowImage\n *\n * Icon for the help window.\n */\nmxEditor.prototype.helpWindowImage = null;\n\n/**\n * Variable: urlHelp\n *\n * Specifies the URL to be used for the contents of the\n * Online Help window. This is usually specified in the\n * resources file under urlHelp for language-specific\n * online help support.\n */\nmxEditor.prototype.urlHelp = null;\n\n/**\n * Variable: helpWidth\n *\n * Specifies the width of the help window in pixels.\n * Default is 300.\n */\nmxEditor.prototype.helpWidth = 300;\n\n/**\n * Variable: helpHeight\n *\n * Specifies the height of the help window in pixels.\n * Default is 260.\n */\nmxEditor.prototype.helpHeight = 260;\n\n/**\n * Variable: propertiesWidth\n *\n * Specifies the width of the properties window in pixels.\n * Default is 240.\n */\nmxEditor.prototype.propertiesWidth = 240;\n\n/**\n * Variable: propertiesHeight\n *\n * Specifies the height of the properties window in pixels.\n * If no height is specified then the window will be automatically\n * sized to fit its contents. Default is null.\n */\nmxEditor.prototype.propertiesHeight = null;\n\n/**\n * Variable: movePropertiesDialog\n *\n * Specifies if the properties dialog should be automatically\n * moved near the cell it is displayed for, otherwise the\n * dialog is not moved. This value is only taken into\n * account if the dialog is already visible. Default is false.\n */\nmxEditor.prototype.movePropertiesDialog = false;\n\n/**\n * Variable: validating\n *\n * Specifies if <mxGraph.validateGraph> should automatically be invoked after\n * each change. Default is false.\n */\nmxEditor.prototype.validating = false;\n\n/**\n * Variable: modified\n *\n * True if the graph has been modified since it was last saved.\n */\nmxEditor.prototype.modified = false;\n\n/**\n * Function: isModified\n *\n * Returns <modified>.\n */\nmxEditor.prototype.isModified = function ()\n{\n\treturn this.modified;\n};\n\n/**\n * Function: setModified\n *\n * Sets <modified> to the specified boolean value.\n */\nmxEditor.prototype.setModified = function (value)\n{\n\tthis.modified = value;\n};\n\n/**\n * Function: addActions\n *\n * Adds the built-in actions to the editor instance.\n *\n * save - Saves the graph using <urlPost>.\n * print - Shows the graph in a new print preview window.\n * show - Shows the graph in a new window.\n * exportImage - Shows the graph as a bitmap image using <getUrlImage>.\n * refresh - Refreshes the graph's display.\n * cut - Copies the current selection into the clipboard\n * and removes it from the graph.\n * copy - Copies the current selection into the clipboard.\n * paste - Pastes the clipboard into the graph.\n * delete - Removes the current selection from the graph.\n * group - Puts the current selection into a new group.\n * ungroup - Removes the selected groups and selects the children.\n * undo - Undoes the last change on the graph model.\n * redo - Redoes the last change on the graph model.\n * zoom - Sets the zoom via a dialog.\n * zoomIn - Zooms into the graph.\n * zoomOut - Zooms out of the graph\n * actualSize - Resets the scale and translation on the graph.\n * fit - Changes the scale so that the graph fits into the window.\n * showProperties - Shows the properties dialog.\n * selectAll - Selects all cells.\n * selectNone - Clears the selection.\n * selectVertices - Selects all vertices.\n * selectEdges = Selects all edges.\n * edit - Starts editing the current selection cell.\n * enterGroup - Drills down into the current selection cell.\n * exitGroup - Moves up in the drilling hierachy\n * home - Moves to the topmost parent in the drilling hierarchy\n * selectPrevious - Selects the previous cell.\n * selectNext - Selects the next cell.\n * selectParent - Selects the parent of the selection cell.\n * selectChild - Selects the first child of the selection cell.\n * collapse - Collapses the currently selected cells.\n * expand - Expands the currently selected cells.\n * bold - Toggle bold text style.\n * italic - Toggle italic text style.\n * underline - Toggle underline text style.\n * alignCellsLeft - Aligns the selection cells at the left.\n * alignCellsCenter - Aligns the selection cells in the center.\n * alignCellsRight - Aligns the selection cells at the right.\n * alignCellsTop - Aligns the selection cells at the top.\n * alignCellsMiddle - Aligns the selection cells in the middle.\n * alignCellsBottom - Aligns the selection cells at the bottom.\n * alignFontLeft - Sets the horizontal text alignment to left.\n * alignFontCenter - Sets the horizontal text alignment to center.\n * alignFontRight - Sets the horizontal text alignment to right.\n * alignFontTop - Sets the vertical text alignment to top.\n * alignFontMiddle - Sets the vertical text alignment to middle.\n * alignFontBottom - Sets the vertical text alignment to bottom.\n * toggleTasks - Shows or hides the tasks window.\n * toggleHelp - Shows or hides the help window.\n * toggleOutline - Shows or hides the outline window.\n * toggleConsole - Shows or hides the console window.\n */\nmxEditor.prototype.addActions = function ()\n{\n\tthis.addAction('save', function(editor)\n\t{\n\t\teditor.save();\n\t});\n\n\tthis.addAction('print', function(editor)\n\t{\n\t\tvar preview = new mxPrintPreview(editor.graph, 1);\n\t\tpreview.open();\n\t});\n\n\tthis.addAction('show', function(editor)\n\t{\n\t\tmxUtils.show(editor.graph, null, 10, 10);\n\t});\n\n\tthis.addAction('exportImage', function(editor)\n\t{\n\t\tvar url = editor.getUrlImage();\n\n\t\tif (url == null || mxClient.IS_LOCAL)\n\t\t{\n\t\t\teditor.execute('show');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar node = mxUtils.getViewXml(editor.graph, 1);\n\t\t\tvar xml = mxUtils.getXml(node, '\\n');\n\n\t\t\tmxUtils.submit(url, editor.postParameterName + '=' +\n\t\t\t\tencodeURIComponent(xml), document, '_blank');\n\t\t}\n\t});\n\n\tthis.addAction('refresh', function(editor)\n\t{\n\t\teditor.graph.refresh();\n\t});\n\n\tthis.addAction('cut', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\tmxClipboard.cut(editor.graph);\n\t\t}\n\t});\n\n\tthis.addAction('copy', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\tmxClipboard.copy(editor.graph);\n\t\t}\n\t});\n\n\tthis.addAction('paste', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\tmxClipboard.paste(editor.graph);\n\t\t}\n\t});\n\n\tthis.addAction('delete', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.removeCells();\n\t\t}\n\t});\n\n\tthis.addAction('group', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.setSelectionCell(editor.groupCells());\n\t\t}\n\t});\n\n\tthis.addAction('ungroup', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.setSelectionCells(editor.graph.ungroupCells());\n\t\t}\n\t});\n\n\tthis.addAction('removeFromParent', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.removeCellsFromParent();\n\t\t}\n\t});\n\n\tthis.addAction('undo', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.undo();\n\t\t}\n\t});\n\n\tthis.addAction('redo', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.redo();\n\t\t}\n\t});\n\n\tthis.addAction('zoomIn', function(editor)\n\t{\n\t\teditor.graph.zoomIn();\n\t});\n\n\tthis.addAction('zoomOut', function(editor)\n\t{\n\t\teditor.graph.zoomOut();\n\t});\n\n\tthis.addAction('actualSize', function(editor)\n\t{\n\t\teditor.graph.zoomActual();\n\t});\n\n\tthis.addAction('fit', function(editor)\n\t{\n\t\teditor.graph.fit();\n\t});\n\n\tthis.addAction('showProperties', function(editor, cell)\n\t{\n\t\teditor.showProperties(cell);\n\t});\n\n\tthis.addAction('selectAll', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.selectAll();\n\t\t}\n\t});\n\n\tthis.addAction('selectNone', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.clearSelection();\n\t\t}\n\t});\n\n\tthis.addAction('selectVertices', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.selectVertices();\n\t\t}\n\t});\n\n\tthis.addAction('selectEdges', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.selectEdges();\n\t\t}\n\t});\n\n\tthis.addAction('edit', function(editor, cell)\n\t{\n\t\tif (editor.graph.isEnabled() &&\n\t\t\teditor.graph.isCellEditable(cell))\n\t\t{\n\t\t\teditor.graph.startEditingAtCell(cell);\n\t\t}\n\t});\n\n\tthis.addAction('toBack', function(editor, cell)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.orderCells(true);\n\t\t}\n\t});\n\n\tthis.addAction('toFront', function(editor, cell)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.orderCells(false);\n\t\t}\n\t});\n\n\tthis.addAction('enterGroup', function(editor, cell)\n\t{\n\t\teditor.graph.enterGroup(cell);\n\t});\n\n\tthis.addAction('exitGroup', function(editor)\n\t{\n\t\teditor.graph.exitGroup();\n\t});\n\n\tthis.addAction('home', function(editor)\n\t{\n\t\teditor.graph.home();\n\t});\n\n\tthis.addAction('selectPrevious', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.selectPreviousCell();\n\t\t}\n\t});\n\n\tthis.addAction('selectNext', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.selectNextCell();\n\t\t}\n\t});\n\n\tthis.addAction('selectParent', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.selectParentCell();\n\t\t}\n\t});\n\n\tthis.addAction('selectChild', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.selectChildCell();\n\t\t}\n\t});\n\n\tthis.addAction('collapse', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.foldCells(true);\n\t\t}\n\t});\n\n\tthis.addAction('collapseAll', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\tvar cells = editor.graph.getChildVertices();\n\t\t\teditor.graph.foldCells(true, false, cells);\n\t\t}\n\t});\n\n\tthis.addAction('expand', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.foldCells(false);\n\t\t}\n\t});\n\n\tthis.addAction('expandAll', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\tvar cells = editor.graph.getChildVertices();\n\t\t\teditor.graph.foldCells(false, false, cells);\n\t\t}\n\t});\n\n\tthis.addAction('bold', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.toggleCellStyleFlags(\n\t\t\t\tmxConstants.STYLE_FONTSTYLE,\n\t\t\t\tmxConstants.FONT_BOLD);\n\t\t}\n\t});\n\n\tthis.addAction('italic', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.toggleCellStyleFlags(\n\t\t\t\tmxConstants.STYLE_FONTSTYLE,\n\t\t\t\tmxConstants.FONT_ITALIC);\n\t\t}\n\t});\n\n\tthis.addAction('underline', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.toggleCellStyleFlags(\n\t\t\t\tmxConstants.STYLE_FONTSTYLE,\n\t\t\t\tmxConstants.FONT_UNDERLINE);\n\t\t}\n\t});\n\n\tthis.addAction('alignCellsLeft', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.alignCells(mxConstants.ALIGN_LEFT);\n\t\t}\n\t});\n\n\tthis.addAction('alignCellsCenter', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.alignCells(mxConstants.ALIGN_CENTER);\n\t\t}\n\t});\n\n\tthis.addAction('alignCellsRight', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.alignCells(mxConstants.ALIGN_RIGHT);\n\t\t}\n\t});\n\n\tthis.addAction('alignCellsTop', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.alignCells(mxConstants.ALIGN_TOP);\n\t\t}\n\t});\n\n\tthis.addAction('alignCellsMiddle', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.alignCells(mxConstants.ALIGN_MIDDLE);\n\t\t}\n\t});\n\n\tthis.addAction('alignCellsBottom', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.alignCells(mxConstants.ALIGN_BOTTOM);\n\t\t}\n\t});\n\n\tthis.addAction('alignFontLeft', function(editor)\n\t{\n\n\t\teditor.graph.setCellStyles(\n\t\t\tmxConstants.STYLE_ALIGN,\n\t\t\tmxConstants.ALIGN_LEFT);\n\t});\n\n\tthis.addAction('alignFontCenter', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.setCellStyles(\n\t\t\t\tmxConstants.STYLE_ALIGN,\n\t\t\t\tmxConstants.ALIGN_CENTER);\n\t\t}\n\t});\n\n\tthis.addAction('alignFontRight', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.setCellStyles(\n\t\t\t\tmxConstants.STYLE_ALIGN,\n\t\t\t\tmxConstants.ALIGN_RIGHT);\n\t\t}\n\t});\n\n\tthis.addAction('alignFontTop', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.setCellStyles(\n\t\t\t\tmxConstants.STYLE_VERTICAL_ALIGN,\n\t\t\t\tmxConstants.ALIGN_TOP);\n\t\t}\n\t});\n\n\tthis.addAction('alignFontMiddle', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.setCellStyles(\n\t\t\t\tmxConstants.STYLE_VERTICAL_ALIGN,\n\t\t\t\tmxConstants.ALIGN_MIDDLE);\n\t\t}\n\t});\n\n\tthis.addAction('alignFontBottom', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.setCellStyles(\n\t\t\t\tmxConstants.STYLE_VERTICAL_ALIGN,\n\t\t\t\tmxConstants.ALIGN_BOTTOM);\n\t\t}\n\t});\n\n\tthis.addAction('zoom', function(editor)\n\t{\n\t\tvar current = editor.graph.getView().scale*100;\n\t\tvar scale = parseFloat(mxUtils.prompt(\n\t\t\tmxResources.get(editor.askZoomResource) ||\n\t\t\teditor.askZoomResource,\n\t\t\tcurrent))/100;\n\n\t\tif (!isNaN(scale))\n\t\t{\n\t\t\teditor.graph.getView().setScale(scale);\n\t\t}\n\t});\n\n\tthis.addAction('toggleTasks', function(editor)\n\t{\n\t\tif (editor.tasks != null)\n\t\t{\n\t\t\teditor.tasks.setVisible(!editor.tasks.isVisible());\n\t\t}\n\t\telse\n\t\t{\n\t\t\teditor.showTasks();\n\t\t}\n\t});\n\n\tthis.addAction('toggleHelp', function(editor)\n\t{\n\t\tif (editor.help != null)\n\t\t{\n\t\t\teditor.help.setVisible(!editor.help.isVisible());\n\t\t}\n\t\telse\n\t\t{\n\t\t\teditor.showHelp();\n\t\t}\n\t});\n\n\tthis.addAction('toggleOutline', function(editor)\n\t{\n\t\tif (editor.outline == null)\n\t\t{\n\t\t\teditor.showOutline();\n\t\t}\n\t\telse\n\t\t{\n\t\t\teditor.outline.setVisible(!editor.outline.isVisible());\n\t\t}\n\t});\n\n\tthis.addAction('toggleConsole', function(editor)\n\t{\n\t\tmxLog.setVisible(!mxLog.isVisible());\n\t});\n};\n\n/**\n * Function: configure\n *\n * Configures the editor using the specified node. To load the\n * configuration from a given URL the following code can be used to obtain\n * the XML node.\n *\n * (code)\n * var node = mxUtils.load(url).getDocumentElement();\n * (end)\n *\n * Parameters:\n *\n * node - XML node that contains the configuration.\n */\nmxEditor.prototype.configure = function (node)\n{\n\tif (node != null)\n\t{\n\t\t// Creates a decoder for the XML data\n\t\t// and uses it to configure the editor\n\t\tvar dec = new mxCodec(node.ownerDocument);\n\t\tdec.decode(node, this);\n\n\t\t// Resets the counters, modified state and\n\t\t// command history\n\t\tthis.resetHistory();\n\t}\n};\n\n/**\n * Function: resetFirstTime\n *\n * Resets the cookie that is used to remember if the editor has already\n * been used.\n */\nmxEditor.prototype.resetFirstTime = function ()\n{\n\tdocument.cookie =\n\t\t'mxgraph=seen; expires=Fri, 27 Jul 2001 02:47:11 UTC; path=/';\n};\n\n/**\n * Function: resetHistory\n *\n * Resets the command history, modified state and counters.\n */\nmxEditor.prototype.resetHistory = function ()\n{\n\tthis.lastSnapshot = new Date().getTime();\n\tthis.undoManager.clear();\n\tthis.ignoredChanges = 0;\n\tthis.setModified(false);\n};\n\n/**\n * Function: addAction\n *\n * Binds the specified actionname to the specified function.\n *\n * Parameters:\n *\n * actionname - String that specifies the name of the action\n * to be added.\n * funct - Function that implements the new action. The first\n * argument of the function is the editor it is used\n * with, the second argument is the cell it operates\n * upon.\n *\n * Example:\n * (code)\n * editor.addAction('test', function(editor, cell)\n * {\n * \t\tmxUtils.alert(\"test \"+cell);\n * });\n * (end)\n */\nmxEditor.prototype.addAction = function (actionname, funct)\n{\n\tthis.actions[actionname] = funct;\n};\n\n/**\n * Function: execute\n *\n * Executes the function with the given name in <actions> passing the\n * editor instance and given cell as the first and second argument. All\n * additional arguments are passed to the action as well. This method\n * contains a try-catch block and displays an error message if an action\n * causes an exception. The exception is re-thrown after the error\n * message was displayed.\n *\n * Example:\n *\n * (code)\n * editor.execute(\"showProperties\", cell);\n * (end)\n */\nmxEditor.prototype.execute = function (actionname, cell, evt)\n{\n\tvar action = this.actions[actionname];\n\n\tif (action != null)\n\t{\n\t\ttry\n\t\t{\n\t\t\t// Creates the array of arguments by replacing the actionname\n\t\t\t// with the editor instance in the args of this function\n\t\t\tvar args = arguments;\n\t\t\targs[0] = this;\n\n\t\t\t// Invokes the function on the editor using the args\n\t\t\taction.apply(this, args);\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\tmxUtils.error('Cannot execute ' + actionname +\n\t\t\t\t': ' + e.message, 280, true);\n\n\t\t\tthrow e;\n\t\t}\n\t}\n\telse\n\t{\n\t\tmxUtils.error('Cannot find action '+actionname, 280, true);\n\t}\n};\n\n/**\n * Function: addTemplate\n *\n * Adds the specified template under the given name in <templates>.\n */\nmxEditor.prototype.addTemplate = function (name, template)\n{\n\tthis.templates[name] = template;\n};\n\n/**\n * Function: getTemplate\n *\n * Returns the template for the given name.\n */\nmxEditor.prototype.getTemplate = function (name)\n{\n\treturn this.templates[name];\n};\n\n/**\n * Function: createGraph\n *\n * Creates the <graph> for the editor. The graph is created with no\n * container and is initialized from <setGraphContainer>.\n */\nmxEditor.prototype.createGraph = function ()\n{\n\tvar graph = new mxGraph(null, null, this.graphRenderHint);\n\n\t// Enables rubberband, tooltips, panning\n\tgraph.setTooltips(true);\n\tgraph.setPanning(true);\n\n\t// Overrides the dblclick method on the graph to\n\t// invoke the dblClickAction for a cell and reset\n\t// the selection tool in the toolbar\n\tthis.installDblClickHandler(graph);\n\n\t// Installs the command history\n\tthis.installUndoHandler(graph);\n\n\t// Installs the handlers for the root event\n\tthis.installDrillHandler(graph);\n\n\t// Installs the handler for validation\n\tthis.installChangeHandler(graph);\n\n\t// Installs the handler for calling the\n\t// insert function and consume the\n\t// event if an insert function is defined\n\tthis.installInsertHandler(graph);\n\n\t// Redirects the function for creating the\n\t// popupmenu items\n\tgraph.popupMenuHandler.factoryMethod =\n\t\tmxUtils.bind(this, function(menu, cell, evt)\n\t\t{\n\t\t\treturn this.createPopupMenu(menu, cell, evt);\n\t\t});\n\n\t// Redirects the function for creating\n\t// new connections in the diagram\n\tgraph.connectionHandler.factoryMethod =\n\t\tmxUtils.bind(this, function(source, target)\n\t\t{\n\t\t\treturn this.createEdge(source, target);\n\t\t});\n\n\t// Maintains swimlanes and installs autolayout\n\tthis.createSwimlaneManager(graph);\n\tthis.createLayoutManager(graph);\n\n\treturn graph;\n};\n\n/**\n * Function: createSwimlaneManager\n *\n * Sets the graph's container using <mxGraph.init>.\n */\nmxEditor.prototype.createSwimlaneManager = function (graph)\n{\n\tvar swimlaneMgr = new mxSwimlaneManager(graph, false);\n\n\tswimlaneMgr.isHorizontal = mxUtils.bind(this, function()\n\t{\n\t\treturn this.horizontalFlow;\n\t});\n\n\tswimlaneMgr.isEnabled = mxUtils.bind(this, function()\n\t{\n\t\treturn this.maintainSwimlanes;\n\t});\n\n\treturn swimlaneMgr;\n};\n\n/**\n * Function: createLayoutManager\n *\n * Creates a layout manager for the swimlane and diagram layouts, that\n * is, the locally defined inter- and intraswimlane layouts.\n */\nmxEditor.prototype.createLayoutManager = function (graph)\n{\n\tvar layoutMgr = new mxLayoutManager(graph);\n\n\tvar self = this; // closure\n\tlayoutMgr.getLayout = function(cell)\n\t{\n\t\tvar layout = null;\n\t\tvar model = self.graph.getModel();\n\n\t\tif (model.getParent(cell) != null)\n\t\t{\n\t\t\t// Executes the swimlane layout if a child of\n\t\t\t// a swimlane has been changed. The layout is\n\t\t\t// lazy created in createSwimlaneLayout.\n\t\t\tif (self.layoutSwimlanes &&\n\t\t\t\tgraph.isSwimlane(cell))\n\t\t\t{\n\t\t\t\tif (self.swimlaneLayout == null)\n\t\t\t\t{\n\t\t\t\t\tself.swimlaneLayout = self.createSwimlaneLayout();\n\t\t\t\t}\n\n\t\t\t\tlayout = self.swimlaneLayout;\n\t\t\t}\n\n\t\t\t// Executes the diagram layout if the modified\n\t\t\t// cell is a top-level cell. The layout is\n\t\t\t// lazy created in createDiagramLayout.\n\t\t\telse if (self.layoutDiagram &&\n\t\t\t\t(graph.isValidRoot(cell) ||\n\t\t\t\tmodel.getParent(model.getParent(cell)) == null))\n\t\t\t{\n\t\t\t\tif (self.diagramLayout == null)\n\t\t\t\t{\n\t\t\t\t\tself.diagramLayout = self.createDiagramLayout();\n\t\t\t\t}\n\n\t\t\t\tlayout = self.diagramLayout;\n\t\t\t}\n\t\t}\n\n\t\treturn layout;\n\t};\n\n\treturn layoutMgr;\n};\n\n/**\n * Function: setGraphContainer\n *\n * Sets the graph's container using <mxGraph.init>.\n */\nmxEditor.prototype.setGraphContainer = function (container)\n{\n\tif (this.graph.container == null)\n\t{\n\t\t// Creates the graph instance inside the given container and render hint\n\t\t//this.graph = new mxGraph(container, null, this.graphRenderHint);\n\t\tthis.graph.init(container);\n\n\t\t// Install rubberband selection as the last\n\t\t// action handler in the chain\n\t\tthis.rubberband = new mxRubberband(this.graph);\n\n\t\t// Disables the context menu\n\t\tif (this.disableContextMenu)\n\t\t{\n\t\t\tmxEvent.disableContextMenu(container);\n\t\t}\n\n\t\t// Workaround for stylesheet directives in IE\n\t\tif (mxClient.IS_QUIRKS)\n\t\t{\n\t\t\tnew mxDivResizer(container);\n\t\t}\n\t}\n};\n\n/**\n * Function: installDblClickHandler\n *\n * Overrides <mxGraph.dblClick> to invoke <dblClickAction>\n * on a cell and reset the selection tool in the toolbar.\n */\nmxEditor.prototype.installDblClickHandler = function (graph)\n{\n\t// Installs a listener for double click events\n\tgraph.addListener(mxEvent.DOUBLE_CLICK,\n\t\tmxUtils.bind(this, function(sender, evt)\n\t\t{\n\t\t\tvar cell = evt.getProperty('cell');\n\n\t\t\tif (cell != null &&\n\t\t\t\tgraph.isEnabled() &&\n\t\t\t\tthis.dblClickAction != null)\n\t\t\t{\n\t\t\t\tthis.execute(this.dblClickAction, cell);\n\t\t\t\tevt.consume();\n\t\t\t}\n\t\t})\n\t);\n};\n\n/**\n * Function: installUndoHandler\n *\n * Adds the <undoManager> to the graph model and the view.\n */\nmxEditor.prototype.installUndoHandler = function (graph)\n{\n\tvar listener = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tvar edit = evt.getProperty('edit');\n\t\tthis.undoManager.undoableEditHappened(edit);\n\t});\n\n\tgraph.getModel().addListener(mxEvent.UNDO, listener);\n\tgraph.getView().addListener(mxEvent.UNDO, listener);\n\n\t// Keeps the selection state in sync\n\tvar undoHandler = function(sender, evt)\n\t{\n\t\tvar changes = evt.getProperty('edit').changes;\n\t\tgraph.setSelectionCells(graph.getSelectionCellsForChanges(changes));\n\t};\n\n\tthis.undoManager.addListener(mxEvent.UNDO, undoHandler);\n\tthis.undoManager.addListener(mxEvent.REDO, undoHandler);\n};\n\n/**\n * Function: installDrillHandler\n *\n * Installs listeners for dispatching the <root> event.\n */\nmxEditor.prototype.installDrillHandler = function (graph)\n{\n\tvar listener = mxUtils.bind(this, function(sender)\n\t{\n\t\tthis.fireEvent(new mxEventObject(mxEvent.ROOT));\n\t});\n\n\tgraph.getView().addListener(mxEvent.DOWN, listener);\n\tgraph.getView().addListener(mxEvent.UP, listener);\n};\n\n/**\n * Function: installChangeHandler\n *\n * Installs the listeners required to automatically validate\n * the graph. On each change of the root, this implementation\n * fires a <root> event.\n */\nmxEditor.prototype.installChangeHandler = function (graph)\n{\n\tvar listener = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\t// Updates the modified state\n\t\tthis.setModified(true);\n\n\t\t// Automatically validates the graph\n\t\t// after each change\n\t\tif (this.validating == true)\n\t\t{\n\t\t\tgraph.validateGraph();\n\t\t}\n\n\t\t// Checks if the root has been changed\n\t\tvar changes = evt.getProperty('edit').changes;\n\n\t\tfor (var i = 0; i < changes.length; i++)\n\t\t{\n\t\t\tvar change = changes[i];\n\n\t\t\tif (change instanceof mxRootChange ||\n\t\t\t\t(change instanceof mxValueChange &&\n\t\t\t\tchange.cell == this.graph.model.root) ||\n\t\t\t\t(change instanceof mxCellAttributeChange &&\n\t\t\t\tchange.cell == this.graph.model.root))\n\t\t\t{\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.ROOT));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n\n\tgraph.getModel().addListener(mxEvent.CHANGE, listener);\n};\n\n/**\n * Function: installInsertHandler\n *\n * Installs the handler for invoking <insertFunction> if\n * one is defined.\n */\nmxEditor.prototype.installInsertHandler = function (graph)\n{\n\tvar self = this; // closure\n\tvar insertHandler =\n\t{\n\t\tmouseDown: function(sender, me)\n\t\t{\n\t\t\tif (self.insertFunction != null &&\n\t\t\t\t!me.isPopupTrigger() &&\n\t\t\t\t(self.forcedInserting ||\n\t\t\t\tme.getState() == null))\n\t\t\t{\n\t\t\t\tself.graph.clearSelection();\n\t\t\t\tself.insertFunction(me.getEvent(), me.getCell());\n\n\t\t\t\t// Consumes the rest of the events\n\t\t\t\t// for this gesture (down, move, up)\n\t\t\t\tthis.isActive = true;\n\t\t\t\tme.consume();\n\t\t\t}\n\t\t},\n\n\t\tmouseMove: function(sender, me)\n\t\t{\n\t\t\tif (this.isActive)\n\t\t\t{\n\t\t\t\tme.consume();\n\t\t\t}\n\t\t},\n\n\t\tmouseUp: function(sender, me)\n\t\t{\n\t\t\tif (this.isActive)\n\t\t\t{\n\t\t\t\tthis.isActive = false;\n\t\t\t\tme.consume();\n\t\t\t}\n\t\t}\n\t};\n\n\tgraph.addMouseListener(insertHandler);\n};\n\n/**\n * Function: createDiagramLayout\n *\n * Creates the layout instance used to layout the\n * swimlanes in the diagram.\n */\nmxEditor.prototype.createDiagramLayout = function ()\n{\n\tvar gs = this.graph.gridSize;\n\tvar layout = new mxStackLayout(this.graph, !this.horizontalFlow,\n\t\t this.swimlaneSpacing, 2*gs, 2*gs);\n\n\t// Overrides isIgnored to only take into account swimlanes\n\tlayout.isVertexIgnored = function(cell)\n\t{\n\t\treturn !layout.graph.isSwimlane(cell);\n\t};\n\n\treturn layout;\n};\n\n/**\n * Function: createSwimlaneLayout\n *\n * Creates the layout instance used to layout the\n * children of each swimlane.\n */\nmxEditor.prototype.createSwimlaneLayout = function ()\n{\n\treturn new mxCompactTreeLayout(this.graph, this.horizontalFlow);\n};\n\n/**\n * Function: createToolbar\n *\n * Creates the <toolbar> with no container.\n */\nmxEditor.prototype.createToolbar = function ()\n{\n\treturn new mxDefaultToolbar(null, this);\n};\n\n/**\n * Function: setToolbarContainer\n *\n * Initializes the toolbar for the given container.\n */\nmxEditor.prototype.setToolbarContainer = function (container)\n{\n\tthis.toolbar.init(container);\n\n\t// Workaround for stylesheet directives in IE\n\tif (mxClient.IS_QUIRKS)\n\t{\n\t\tnew mxDivResizer(container);\n\t}\n};\n\n/**\n * Function: setStatusContainer\n *\n * Creates the <status> using the specified container.\n *\n * This implementation adds listeners in the editor to\n * display the last saved time and the current filename\n * in the status bar.\n *\n * Parameters:\n *\n * container - DOM node that will contain the statusbar.\n */\nmxEditor.prototype.setStatusContainer = function (container)\n{\n\tif (this.status == null)\n\t{\n\t\tthis.status = container;\n\n\t\t// Prints the last saved time in the status bar\n\t\t// when files are saved\n\t\tthis.addListener(mxEvent.SAVE, mxUtils.bind(this, function()\n\t\t{\n\t\t\tvar tstamp = new Date().toLocaleString();\n\t\t\tthis.setStatus((mxResources.get(this.lastSavedResource) ||\n\t\t\t\tthis.lastSavedResource)+': '+tstamp);\n\t\t}));\n\n\t\t// Updates the statusbar to display the filename\n\t\t// when new files are opened\n\t\tthis.addListener(mxEvent.OPEN, mxUtils.bind(this, function()\n\t\t{\n\t\t\tthis.setStatus((mxResources.get(this.currentFileResource) ||\n\t\t\t\tthis.currentFileResource)+': '+this.filename);\n\t\t}));\n\n\t\t// Workaround for stylesheet directives in IE\n\t\tif (mxClient.IS_QUIRKS)\n\t\t{\n\t\t\tnew mxDivResizer(container);\n\t\t}\n\t}\n};\n\n/**\n * Function: setStatus\n *\n * Display the specified message in the status bar.\n *\n * Parameters:\n *\n * message - String the specified the message to\n * be displayed.\n */\nmxEditor.prototype.setStatus = function (message)\n{\n\tif (this.status != null && message != null)\n\t{\n\t\tthis.status.innerHTML = message;\n\t}\n};\n\n/**\n * Function: setTitleContainer\n *\n * Creates a listener to update the inner HTML of the\n * specified DOM node with the value of <getTitle>.\n *\n * Parameters:\n *\n * container - DOM node that will contain the title.\n */\nmxEditor.prototype.setTitleContainer = function (container)\n{\n\tthis.addListener(mxEvent.ROOT, mxUtils.bind(this, function(sender)\n\t{\n\t\tcontainer.innerHTML = this.getTitle();\n\t}));\n\n\t// Workaround for stylesheet directives in IE\n\tif (mxClient.IS_QUIRKS)\n\t{\n\t\tnew mxDivResizer(container);\n\t}\n};\n\n/**\n * Function: treeLayout\n *\n * Executes a vertical or horizontal compact tree layout\n * using the specified cell as an argument. The cell may\n * either be a group or the root of a tree.\n *\n * Parameters:\n *\n * cell - <mxCell> to use in the compact tree layout.\n * horizontal - Optional boolean to specify the tree's\n * orientation. Default is true.\n */\nmxEditor.prototype.treeLayout = function (cell, horizontal)\n{\n\tif (cell != null)\n\t{\n\t\tvar layout = new mxCompactTreeLayout(this.graph, horizontal);\n\t\tlayout.execute(cell);\n\t}\n};\n\n/**\n * Function: getTitle\n *\n * Returns the string value for the current root of the\n * diagram.\n */\nmxEditor.prototype.getTitle = function ()\n{\n\tvar title = '';\n\tvar graph = this.graph;\n\tvar cell = graph.getCurrentRoot();\n\n\twhile (cell != null &&\n\t\t   graph.getModel().getParent(\n\t\t\t\tgraph.getModel().getParent(cell)) != null)\n\t{\n\t\t// Append each label of a valid root\n\t\tif (graph.isValidRoot(cell))\n\t\t{\n\t\t\ttitle = ' > ' +\n\t\t\tgraph.convertValueToString(cell) + title;\n\t\t}\n\n\t\tcell = graph.getModel().getParent(cell);\n\t}\n\n\tvar prefix = this.getRootTitle();\n\n\treturn prefix + title;\n};\n\n/**\n * Function: getRootTitle\n *\n * Returns the string value of the root cell in\n * <mxGraph.model>.\n */\nmxEditor.prototype.getRootTitle = function ()\n{\n\tvar root = this.graph.getModel().getRoot();\n\treturn this.graph.convertValueToString(root);\n};\n\n/**\n * Function: undo\n *\n * Undo the last change in <graph>.\n */\nmxEditor.prototype.undo = function ()\n{\n\tthis.undoManager.undo();\n};\n\n/**\n * Function: redo\n *\n * Redo the last change in <graph>.\n */\nmxEditor.prototype.redo = function ()\n{\n\tthis.undoManager.redo();\n};\n\n/**\n * Function: groupCells\n *\n * Invokes <createGroup> to create a new group cell and the invokes\n * <mxGraph.groupCells>, using the grid size of the graph as the spacing\n * in the group's content area.\n */\nmxEditor.prototype.groupCells = function ()\n{\n\tvar border = (this.groupBorderSize != null) ?\n\t\tthis.groupBorderSize :\n\t\tthis.graph.gridSize;\n\treturn this.graph.groupCells(this.createGroup(), border);\n};\n\n/**\n * Function: createGroup\n *\n * Creates and returns a clone of <defaultGroup> to be used\n * as a new group cell in <group>.\n */\nmxEditor.prototype.createGroup = function ()\n{\n\tvar model = this.graph.getModel();\n\n\treturn model.cloneCell(this.defaultGroup);\n};\n\n/**\n * Function: open\n *\n * Opens the specified file synchronously and parses it using\n * <readGraphModel>. It updates <filename> and fires an <open>-event after\n * the file has been opened. Exceptions should be handled as follows:\n *\n * (code)\n * try\n * {\n *   editor.open(filename);\n * }\n * catch (e)\n * {\n *   mxUtils.error('Cannot open ' + filename +\n *     ': ' + e.message, 280, true);\n * }\n * (end)\n *\n * Parameters:\n *\n * filename - URL of the file to be opened.\n */\nmxEditor.prototype.open = function (filename)\n{\n\tif (filename != null)\n\t{\n\t\tvar xml = mxUtils.load(filename).getXml();\n\t\tthis.readGraphModel(xml.documentElement);\n\t\tthis.filename = filename;\n\n\t\tthis.fireEvent(new mxEventObject(mxEvent.OPEN, 'filename', filename));\n\t}\n};\n\n/**\n * Function: readGraphModel\n *\n * Reads the specified XML node into the existing graph model and resets\n * the command history and modified state.\n */\nmxEditor.prototype.readGraphModel = function (node)\n{\n\tvar dec = new mxCodec(node.ownerDocument);\n\tdec.decode(node, this.graph.getModel());\n\tthis.resetHistory();\n};\n\n/**\n * Function: save\n *\n * Posts the string returned by <writeGraphModel> to the given URL or the\n * URL returned by <getUrlPost>. The actual posting is carried out by\n * <postDiagram>. If the URL is null then the resulting XML will be\n * displayed using <mxUtils.popup>. Exceptions should be handled as\n * follows:\n *\n * (code)\n * try\n * {\n *   editor.save();\n * }\n * catch (e)\n * {\n *   mxUtils.error('Cannot save : ' + e.message, 280, true);\n * }\n * (end)\n */\nmxEditor.prototype.save = function (url, linefeed)\n{\n\t// Gets the URL to post the data to\n\turl = url || this.getUrlPost();\n\n\t// Posts the data if the URL is not empty\n\tif (url != null && url.length > 0)\n\t{\n\t\tvar data = this.writeGraphModel(linefeed);\n\t\tthis.postDiagram(url, data);\n\n\t\t// Resets the modified flag\n\t\tthis.setModified(false);\n\t}\n\n\t// Dispatches a save event\n\tthis.fireEvent(new mxEventObject(mxEvent.SAVE, 'url', url));\n};\n\n/**\n * Function: postDiagram\n *\n * Hook for subclassers to override the posting of a diagram\n * represented by the given node to the given URL. This fires\n * an asynchronous <post> event if the diagram has been posted.\n *\n * Example:\n *\n * To replace the diagram with the diagram in the response, use the\n * following code.\n *\n * (code)\n * editor.addListener(mxEvent.POST, function(sender, evt)\n * {\n *   // Process response (replace diagram)\n *   var req = evt.getProperty('request');\n *   var root = req.getDocumentElement();\n *   editor.graph.readGraphModel(root)\n * });\n * (end)\n */\nmxEditor.prototype.postDiagram = function (url, data)\n{\n\tif (this.escapePostData)\n\t{\n\t\tdata = encodeURIComponent(data);\n\t}\n\n\tmxUtils.post(url, this.postParameterName+'='+data,\n\t\tmxUtils.bind(this, function(req)\n\t\t{\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.POST,\n\t\t\t\t'request', req, 'url', url, 'data', data));\n\t\t})\n\t);\n};\n\n/**\n * Function: writeGraphModel\n *\n * Hook to create the string representation of the diagram. The default\n * implementation uses an <mxCodec> to encode the graph model as\n * follows:\n *\n * (code)\n * var enc = new mxCodec();\n * var node = enc.encode(this.graph.getModel());\n * return mxUtils.getXml(node, this.linefeed);\n * (end)\n *\n * Parameters:\n *\n * linefeed - Optional character to be used as the linefeed. Default is\n * <linefeed>.\n */\nmxEditor.prototype.writeGraphModel = function (linefeed)\n{\n\tlinefeed = (linefeed != null) ? linefeed : this.linefeed;\n\tvar enc = new mxCodec();\n\tvar node = enc.encode(this.graph.getModel());\n\n\treturn mxUtils.getXml(node, linefeed);\n};\n\n/**\n * Function: getUrlPost\n *\n * Returns the URL to post the diagram to. This is used\n * in <save>. The default implementation returns <urlPost>,\n * adding <code>?draft=true</code>.\n */\nmxEditor.prototype.getUrlPost = function ()\n{\n\treturn this.urlPost;\n};\n\n/**\n * Function: getUrlImage\n *\n * Returns the URL to create the image with. This is typically\n * the URL of a backend which accepts an XML representation\n * of a graph view to create an image. The function is used\n * in the image action to create an image. This implementation\n * returns <urlImage>.\n */\nmxEditor.prototype.getUrlImage = function ()\n{\n\treturn this.urlImage;\n};\n\n/**\n * Function: swapStyles\n *\n * Swaps the styles for the given names in the graph's\n * stylesheet and refreshes the graph.\n */\nmxEditor.prototype.swapStyles = function (first, second)\n{\n\tvar style = this.graph.getStylesheet().styles[second];\n\tthis.graph.getView().getStylesheet().putCellStyle(\n\t\tsecond, this.graph.getStylesheet().styles[first]);\n\tthis.graph.getStylesheet().putCellStyle(first, style);\n\tthis.graph.refresh();\n};\n\n/**\n * Function: showProperties\n *\n * Creates and shows the properties dialog for the given\n * cell. The content area of the dialog is created using\n * <createProperties>.\n */\nmxEditor.prototype.showProperties = function (cell)\n{\n\tcell = cell || this.graph.getSelectionCell();\n\n\t// Uses the root node for the properties dialog\n\t// if not cell was passed in and no cell is\n\t// selected\n\tif (cell == null)\n\t{\n\t\tcell = this.graph.getCurrentRoot();\n\n\t\tif (cell == null)\n\t\t{\n\t\t\tcell = this.graph.getModel().getRoot();\n\t\t}\n\t}\n\n\tif (cell != null)\n\t{\n\t\t// Makes sure there is no in-place editor in the\n\t\t// graph and computes the location of the dialog\n\t\tthis.graph.stopEditing(true);\n\n\t\tvar offset = mxUtils.getOffset(this.graph.container);\n\t\tvar x = offset.x+10;\n\t\tvar y = offset.y;\n\n\t\t// Avoids moving the dialog if it is alredy open\n\t\tif (this.properties != null && !this.movePropertiesDialog)\n\t\t{\n\t\t\tx = this.properties.getX();\n\t\t\ty = this.properties.getY();\n\t\t}\n\n\t\t// Places the dialog near the cell for which it\n\t\t// displays the properties\n\t\telse\n\t\t{\n\t\t\tvar bounds = this.graph.getCellBounds(cell);\n\n\t\t\tif (bounds != null)\n\t\t\t{\n\t\t\t\tx += bounds.x+Math.min(200, bounds.width);\n\t\t\t\ty += bounds.y;\n\t\t\t}\n\t\t}\n\n\t\t// Hides the existing properties dialog and creates a new one with the\n\t\t// contents created in the hook method\n\t\tthis.hideProperties();\n\t\tvar node = this.createProperties(cell);\n\n\t\tif (node != null)\n\t\t{\n\t\t\t// Displays the contents in a window and stores a reference to the\n\t\t\t// window for later hiding of the window\n\t\t\tthis.properties = new mxWindow(mxResources.get(this.propertiesResource) ||\n\t\t\t\tthis.propertiesResource, node, x, y, this.propertiesWidth, this.propertiesHeight, false);\n\t\t\tthis.properties.setVisible(true);\n\t\t}\n\t}\n};\n\n/**\n * Function: isPropertiesVisible\n *\n * Returns true if the properties dialog is currently visible.\n */\nmxEditor.prototype.isPropertiesVisible = function ()\n{\n\treturn this.properties != null;\n};\n\n/**\n * Function: createProperties\n *\n * Creates and returns the DOM node that represents the contents\n * of the properties dialog for the given cell. This implementation\n * works for user objects that are XML nodes and display all the\n * node attributes in a form.\n */\nmxEditor.prototype.createProperties = function (cell)\n{\n\tvar model = this.graph.getModel();\n\tvar value = model.getValue(cell);\n\n\tif (mxUtils.isNode(value))\n\t{\n\t\t// Creates a form for the user object inside\n\t\t// the cell\n\t\tvar form = new mxForm('properties');\n\n\t\t// Adds a readonly field for the cell id\n\t\tvar id = form.addText('ID', cell.getId());\n\t\tid.setAttribute('readonly', 'true');\n\n\t\tvar geo = null;\n\t\tvar yField = null;\n\t\tvar xField = null;\n\t\tvar widthField = null;\n\t\tvar heightField = null;\n\n\t\t// Adds fields for the location and size\n\t\tif (model.isVertex(cell))\n\t\t{\n\t\t\tgeo = model.getGeometry(cell);\n\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tyField = form.addText('top', geo.y);\n\t\t\t\txField = form.addText('left', geo.x);\n\t\t\t\twidthField = form.addText('width', geo.width);\n\t\t\t\theightField = form.addText('height', geo.height);\n\t\t\t}\n\t\t}\n\n\t\t// Adds a field for the cell style\n\t\tvar tmp = model.getStyle(cell);\n\t\tvar style = form.addText('Style', tmp || '');\n\n\t\t// Creates textareas for each attribute of the\n\t\t// user object within the cell\n\t\tvar attrs = value.attributes;\n\t\tvar texts = [];\n\n\t\tfor (var i = 0; i < attrs.length; i++)\n\t\t{\n\t\t\t// Creates a textarea with more lines for\n\t\t\t// the cell label\n\t\t\tvar val = attrs[i].value;\n\t\t\ttexts[i] = form.addTextarea(attrs[i].nodeName, val,\n\t\t\t\t(attrs[i].nodeName == 'label') ? 4 : 2);\n\t\t}\n\n\t\t// Adds an OK and Cancel button to the dialog\n\t\t// contents and implements the respective\n\t\t// actions below\n\n\t\t// Defines the function to be executed when the\n\t\t// OK button is pressed in the dialog\n\t\tvar okFunction = mxUtils.bind(this, function()\n\t\t{\n\t\t\t// Hides the dialog\n\t\t\tthis.hideProperties();\n\n\t\t\t// Supports undo for the changes on the underlying\n\t\t\t// XML structure / XML node attribute changes.\n\t\t\tmodel.beginUpdate();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (geo != null)\n\t\t\t\t{\n\t\t\t\t\tgeo = geo.clone();\n\n\t\t\t\t\tgeo.x = parseFloat(xField.value);\n\t\t\t\t\tgeo.y = parseFloat(yField.value);\n\t\t\t\t\tgeo.width = parseFloat(widthField.value);\n\t\t\t\t\tgeo.height = parseFloat(heightField.value);\n\n\t\t\t\t\tmodel.setGeometry(cell, geo);\n\t\t\t\t}\n\n\t\t\t\t// Applies the style\n\t\t\t\tif (style.value.length > 0)\n\t\t\t\t{\n\t\t\t\t\tmodel.setStyle(cell, style.value);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmodel.setStyle(cell, null);\n\t\t\t\t}\n\n\t\t\t\t// Creates an undoable change for each\n\t\t\t\t// attribute and executes it using the\n\t\t\t\t// model, which will also make the change\n\t\t\t\t// part of the current transaction\n\t\t\t\tfor (var i=0; i<attrs.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar edit = new mxCellAttributeChange(\n\t\t\t\t\t\tcell, attrs[i].nodeName,\n\t\t\t\t\t\ttexts[i].value);\n\t\t\t\t\tmodel.execute(edit);\n\t\t\t\t}\n\n\t\t\t\t// Checks if the graph wants cells to\n\t\t\t\t// be automatically sized and updates\n\t\t\t\t// the size as an undoable step if\n\t\t\t\t// the feature is enabled\n\t\t\t\tif (this.graph.isAutoSizeCell(cell))\n\t\t\t\t{\n\t\t\t\t\tthis.graph.updateCellSize(cell);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tmodel.endUpdate();\n\t\t\t}\n\t\t});\n\n\t\t// Defines the function to be executed when the\n\t\t// Cancel button is pressed in the dialog\n\t\tvar cancelFunction = mxUtils.bind(this, function()\n\t\t{\n\t\t\t// Hides the dialog\n\t\t\tthis.hideProperties();\n\t\t});\n\n\t\tform.addButtons(okFunction, cancelFunction);\n\n\t\treturn form.table;\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: hideProperties\n *\n * Hides the properties dialog.\n */\nmxEditor.prototype.hideProperties = function ()\n{\n\tif (this.properties != null)\n\t{\n\t\tthis.properties.destroy();\n\t\tthis.properties = null;\n\t}\n};\n\n/**\n * Function: showTasks\n *\n * Shows the tasks window. The tasks window is created using <createTasks>. The\n * default width of the window is 200 pixels, the y-coordinate of the location\n * can be specifies in <tasksTop> and the x-coordinate is right aligned with a\n * 20 pixel offset from the right border. To change the location of the tasks\n * window, the following code can be used:\n *\n * (code)\n * var oldShowTasks = mxEditor.prototype.showTasks;\n * mxEditor.prototype.showTasks = function()\n * {\n *   oldShowTasks.apply(this, arguments); // \"supercall\"\n *\n *   if (this.tasks != null)\n *   {\n *     this.tasks.setLocation(10, 10);\n *   }\n * };\n * (end)\n */\nmxEditor.prototype.showTasks = function ()\n{\n\tif (this.tasks == null)\n\t{\n\t\tvar div = document.createElement('div');\n\t\tdiv.style.padding = '4px';\n\t\tdiv.style.paddingLeft = '20px';\n\t\tvar w = document.body.clientWidth;\n\t\tvar wnd = new mxWindow(\n\t\t\tmxResources.get(this.tasksResource) ||\n\t\t\tthis.tasksResource,\n\t\t\tdiv, w - 220, this.tasksTop, 200);\n\t\twnd.setClosable(true);\n\t\twnd.destroyOnClose = false;\n\n\t\t// Installs a function to update the contents\n\t\t// of the tasks window on every change of the\n\t\t// model, selection or root.\n\t\tvar funct = mxUtils.bind(this, function(sender)\n\t\t{\n\t\t\tmxEvent.release(div);\n\t\t\tdiv.innerHTML = '';\n\t\t\tthis.createTasks(div);\n\t\t});\n\n\t\tthis.graph.getModel().addListener(mxEvent.CHANGE, funct);\n\t\tthis.graph.getSelectionModel().addListener(mxEvent.CHANGE, funct);\n\t\tthis.graph.addListener(mxEvent.ROOT, funct);\n\n\t\t// Assigns the icon to the tasks window\n\t\tif (this.tasksWindowImage != null)\n\t\t{\n\t\t\twnd.setImage(this.tasksWindowImage);\n\t\t}\n\n\t\tthis.tasks = wnd;\n\t\tthis.createTasks(div);\n\t}\n\n\tthis.tasks.setVisible(true);\n};\n\n/**\n * Function: refreshTasks\n *\n * Updates the contents of the tasks window using <createTasks>.\n */\nmxEditor.prototype.refreshTasks = function (div)\n{\n\tif (this.tasks != null)\n\t{\n\t\tvar div = this.tasks.content;\n\t\tmxEvent.release(div);\n\t\tdiv.innerHTML = '';\n\t\tthis.createTasks(div);\n\t}\n};\n\n/**\n * Function: createTasks\n *\n * Updates the contents of the given DOM node to\n * display the tasks associated with the current\n * editor state. This is invoked whenever there\n * is a possible change of state in the editor.\n * Default implementation is empty.\n */\nmxEditor.prototype.createTasks = function (div)\n{\n\t// override\n};\n\n/**\n * Function: showHelp\n *\n * Shows the help window. If the help window does not exist\n * then it is created using an iframe pointing to the resource\n * for the <code>urlHelp</code> key or <urlHelp> if the resource\n * is undefined.\n */\nmxEditor.prototype.showHelp = function (tasks)\n{\n\tif (this.help == null)\n\t{\n\t\tvar frame = document.createElement('iframe');\n\t\tframe.setAttribute('src', mxResources.get('urlHelp') || this.urlHelp);\n\t\tframe.setAttribute('height', '100%');\n\t\tframe.setAttribute('width', '100%');\n\t\tframe.setAttribute('frameBorder', '0');\n\t\tframe.style.backgroundColor = 'white';\n\n\t\tvar w = document.body.clientWidth;\n\t\tvar h = (document.body.clientHeight || document.documentElement.clientHeight);\n\n\t\tvar wnd = new mxWindow(mxResources.get(this.helpResource) || this.helpResource,\n\t\t\tframe, (w-this.helpWidth)/2, (h-this.helpHeight)/3, this.helpWidth, this.helpHeight);\n\t\twnd.setMaximizable(true);\n\t\twnd.setClosable(true);\n\t\twnd.destroyOnClose = false;\n\t\twnd.setResizable(true);\n\n\t\t// Assigns the icon to the help window\n\t\tif (this.helpWindowImage != null)\n\t\t{\n\t\t\twnd.setImage(this.helpWindowImage);\n\t\t}\n\n\t\t// Workaround for ignored iframe height 100% in FF\n\t\tif (mxClient.IS_NS)\n\t\t{\n\t\t\tvar handler = function(sender)\n\t\t\t{\n\t\t\t\tvar h = wnd.div.offsetHeight;\n\t\t\t\tframe.setAttribute('height', (h-26)+'px');\n\t\t\t};\n\n\t\t\twnd.addListener(mxEvent.RESIZE_END, handler);\n\t\t\twnd.addListener(mxEvent.MAXIMIZE, handler);\n\t\t\twnd.addListener(mxEvent.NORMALIZE, handler);\n\t\t\twnd.addListener(mxEvent.SHOW, handler);\n\t\t}\n\n\t\tthis.help = wnd;\n\t}\n\n\tthis.help.setVisible(true);\n};\n\n/**\n * Function: showOutline\n *\n * Shows the outline window. If the window does not exist, then it is\n * created using an <mxOutline>.\n */\nmxEditor.prototype.showOutline = function ()\n{\n\tvar create = this.outline == null;\n\n\tif (create)\n\t{\n\t\tvar div = document.createElement('div');\n\n\t\tdiv.style.overflow = 'hidden';\n\t\tdiv.style.position = 'relative';\n\t\tdiv.style.width = '100%';\n\t\tdiv.style.height = '100%';\n\t\tdiv.style.background = 'white';\n\t\tdiv.style.cursor = 'move';\n\n\t\tif (document.documentMode == 8)\n\t\t{\n\t\t\tdiv.style.filter = 'progid:DXImageTransform.Microsoft.alpha(opacity=100)';\n\t\t}\n\n\t\tvar wnd = new mxWindow(\n\t\t\tmxResources.get(this.outlineResource) ||\n\t\t\tthis.outlineResource,\n\t\t\tdiv, 600, 480, 200, 200, false);\n\n\t\t// Creates the outline in the specified div\n\t\t// and links it to the existing graph\n\t\tvar outline = new mxOutline(this.graph, div);\n\t\twnd.setClosable(true);\n\t\twnd.setResizable(true);\n\t\twnd.destroyOnClose = false;\n\n\t\twnd.addListener(mxEvent.RESIZE_END, function()\n\t\t{\n\t\t\toutline.update();\n\t\t});\n\n\t\tthis.outline = wnd;\n\t\tthis.outline.outline = outline;\n\t}\n\n\t// Finally shows the outline\n\tthis.outline.setVisible(true);\n\tthis.outline.outline.update(true);\n};\n\n/**\n * Function: setMode\n *\n * Puts the graph into the specified mode. The following modenames are\n * supported:\n *\n * select - Selects using the left mouse button, new connections\n * are disabled.\n * connect - Selects using the left mouse button or creates new\n * connections if mouse over cell hotspot. See <mxConnectionHandler>.\n * pan - Pans using the left mouse button, new connections are disabled.\n */\nmxEditor.prototype.setMode = function(modename)\n{\n\tif (modename == 'select')\n\t{\n\t\tthis.graph.panningHandler.useLeftButtonForPanning = false;\n\t\tthis.graph.setConnectable(false);\n\t}\n\telse if (modename == 'connect')\n\t{\n\t\tthis.graph.panningHandler.useLeftButtonForPanning = false;\n\t\tthis.graph.setConnectable(true);\n\t}\n\telse if (modename == 'pan')\n\t{\n\t\tthis.graph.panningHandler.useLeftButtonForPanning = true;\n\t\tthis.graph.setConnectable(false);\n\t}\n};\n\n/**\n * Function: createPopupMenu\n *\n * Uses <popupHandler> to create the menu in the graph's\n * panning handler. The redirection is setup in\n * <setToolbarContainer>.\n */\nmxEditor.prototype.createPopupMenu = function (menu, cell, evt)\n{\n\tthis.popupHandler.createMenu(this, menu, cell, evt);\n};\n\n/**\n * Function: createEdge\n *\n * Uses <defaultEdge> as the prototype for creating new edges\n * in the connection handler of the graph. The style of the\n * edge will be overridden with the value returned by\n * <getEdgeStyle>.\n */\nmxEditor.prototype.createEdge = function (source, target)\n{\n\t// Clones the defaultedge prototype\n\tvar e = null;\n\n\tif (this.defaultEdge != null)\n\t{\n\t\tvar model = this.graph.getModel();\n\t\te = model.cloneCell(this.defaultEdge);\n\t}\n\telse\n\t{\n\t\te = new mxCell('');\n\t\te.setEdge(true);\n\n\t\tvar geo = new mxGeometry();\n\t\tgeo.relative = true;\n\t\te.setGeometry(geo);\n\t}\n\n\t// Overrides the edge style\n\tvar style = this.getEdgeStyle();\n\n\tif (style != null)\n\t{\n\t\te.setStyle(style);\n\t}\n\n\treturn e;\n};\n\n/**\n * Function: getEdgeStyle\n *\n * Returns a string identifying the style of new edges.\n * The function is used in <createEdge> when new edges\n * are created in the graph.\n */\nmxEditor.prototype.getEdgeStyle = function ()\n{\n\treturn this.defaultEdgeStyle;\n};\n\n/**\n * Function: consumeCycleAttribute\n *\n * Returns the next attribute in <cycleAttributeValues>\n * or null, if not attribute should be used in the\n * specified cell.\n */\nmxEditor.prototype.consumeCycleAttribute = function (cell)\n{\n\treturn (this.cycleAttributeValues != null &&\n\t\tthis.cycleAttributeValues.length > 0 &&\n\t\tthis.graph.isSwimlane(cell)) ?\n\t\tthis.cycleAttributeValues[this.cycleAttributeIndex++ %\n\t\t\tthis.cycleAttributeValues.length] : null;\n};\n\n/**\n * Function: cycleAttribute\n *\n * Uses the returned value from <consumeCycleAttribute>\n * as the value for the <cycleAttributeName> key in\n * the given cell's style.\n */\nmxEditor.prototype.cycleAttribute = function (cell)\n{\n\tif (this.cycleAttributeName != null)\n\t{\n\t\tvar value = this.consumeCycleAttribute(cell);\n\n\t\tif (value != null)\n\t\t{\n\t\t\tcell.setStyle(cell.getStyle()+';'+\n\t\t\t\tthis.cycleAttributeName+'='+value);\n\t\t}\n\t}\n};\n\n/**\n * Function: addVertex\n *\n * Adds the given vertex as a child of parent at the specified\n * x and y coordinate and fires an <addVertex> event.\n */\nmxEditor.prototype.addVertex = function (parent, vertex, x, y)\n{\n\tvar model = this.graph.getModel();\n\n\twhile (parent != null && !this.graph.isValidDropTarget(parent))\n\t{\n\t\tparent = model.getParent(parent);\n\t}\n\n\tparent = (parent != null) ? parent : this.graph.getSwimlaneAt(x, y);\n\tvar scale = this.graph.getView().scale;\n\n\tvar geo = model.getGeometry(vertex);\n\tvar pgeo = model.getGeometry(parent);\n\n\tif (this.graph.isSwimlane(vertex) &&\n\t\t!this.graph.swimlaneNesting)\n\t{\n\t\tparent = null;\n\t}\n\telse if (parent == null && this.swimlaneRequired)\n\t{\n\t\treturn null;\n\t}\n\telse if (parent != null && pgeo != null)\n\t{\n\t\t// Keeps vertex inside parent\n\t\tvar state = this.graph.getView().getState(parent);\n\n\t\tif (state != null)\n\t\t{\n\t\t\tx -= state.origin.x * scale;\n\t\t\ty -= state.origin.y * scale;\n\n\t\t\tif (this.graph.isConstrainedMoving)\n\t\t\t{\n\t\t\t\tvar width = geo.width;\n\t\t\t\tvar height = geo.height;\n\t\t\t\tvar tmp = state.x+state.width;\n\n\t\t\t\tif (x+width > tmp)\n\t\t\t\t{\n\t\t\t\t\tx -= x+width - tmp;\n\t\t\t\t}\n\n\t\t\t\ttmp = state.y+state.height;\n\n\t\t\t\tif (y+height > tmp)\n\t\t\t\t{\n\t\t\t\t\ty -= y+height - tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (pgeo != null)\n\t\t{\n\t\t\tx -= pgeo.x*scale;\n\t\t\ty -= pgeo.y*scale;\n\t\t}\n\t}\n\n\tgeo = geo.clone();\n\tgeo.x = this.graph.snap(x / scale -\n\t\tthis.graph.getView().translate.x -\n\t\tthis.graph.gridSize/2);\n\tgeo.y = this.graph.snap(y / scale -\n\t\tthis.graph.getView().translate.y -\n\t\tthis.graph.gridSize/2);\n\tvertex.setGeometry(geo);\n\n\tif (parent == null)\n\t{\n\t\tparent = this.graph.getDefaultParent();\n\t}\n\n\tthis.cycleAttribute(vertex);\n\tthis.fireEvent(new mxEventObject(mxEvent.BEFORE_ADD_VERTEX,\n\t\t\t'vertex', vertex, 'parent', parent));\n\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tvertex = this.graph.addCell(vertex, parent);\n\n\t\tif (vertex != null)\n\t\t{\n\t\t\tthis.graph.constrainChild(vertex);\n\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.ADD_VERTEX, 'vertex', vertex));\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n\n\tif (vertex != null)\n\t{\n\t\tthis.graph.setSelectionCell(vertex);\n\t\tthis.graph.scrollCellToVisible(vertex);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.AFTER_ADD_VERTEX, 'vertex', vertex));\n\t}\n\n\treturn vertex;\n};\n\n/**\n * Function: destroy\n *\n * Removes the editor and all its associated resources. This does not\n * normally need to be called, it is called automatically when the window\n * unloads.\n */\nmxEditor.prototype.destroy = function ()\n{\n\tif (!this.destroyed)\n\t{\n\t\tthis.destroyed = true;\n\n\t\tif (this.tasks != null)\n\t\t{\n\t\t\tthis.tasks.destroy();\n\t\t}\n\n\t\tif (this.outline != null)\n\t\t{\n\t\t\tthis.outline.destroy();\n\t\t}\n\n\t\tif (this.properties != null)\n\t\t{\n\t\t\tthis.properties.destroy();\n\t\t}\n\n\t\tif (this.keyHandler != null)\n\t\t{\n\t\t\tthis.keyHandler.destroy();\n\t\t}\n\n\t\tif (this.rubberband != null)\n\t\t{\n\t\t\tthis.rubberband.destroy();\n\t\t}\n\n\t\tif (this.toolbar != null)\n\t\t{\n\t\t\tthis.toolbar.destroy();\n\t\t}\n\n\t\tif (this.graph != null)\n\t\t{\n\t\t\tthis.graph.destroy();\n\t\t}\n\n\t\tthis.status = null;\n\t\tthis.templates = null;\n\t}\n};\n\n__mxOutput.mxEditor = typeof mxEditor !== 'undefined' ? mxEditor : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxCodecRegistry =\n{\n\t/**\n\t * Class: mxCodecRegistry\n\t *\n\t * Singleton class that acts as a global registry for codecs.\n\t *\n\t * Adding an <mxCodec>:\n\t *\n\t * 1. Define a default codec with a new instance of the \n\t * object to be handled.\n\t *\n\t * (code)\n\t * var codec = new mxObjectCodec(new mxGraphModel());\n\t * (end)\n\t *\n\t * 2. Define the functions required for encoding and decoding\n\t * objects.\n\t *\n\t * (code)\n\t * codec.encode = function(enc, obj) { ... }\n\t * codec.decode = function(dec, node, into) { ... }\n\t * (end)\n\t *\n\t * 3. Register the codec in the <mxCodecRegistry>.\n\t *\n\t * (code)\n\t * mxCodecRegistry.register(codec);\n\t * (end)\n\t *\n\t * <mxObjectCodec.decode> may be used to either create a new \n\t * instance of an object or to configure an existing instance, \n\t * in which case the into argument points to the existing\n\t * object. In this case, we say the codec \"configures\" the\n\t * object.\n\t * \n\t * Variable: codecs\n\t *\n\t * Maps from constructor names to codecs.\n\t */\n\tcodecs: [],\n\t\n\t/**\n\t * Variable: aliases\n\t *\n\t * Maps from classnames to codecnames.\n\t */\n\taliases: [],\n\n\t/**\n\t * Function: register\n\t *\n\t * Registers a new codec and associates the name of the template\n\t * constructor in the codec with the codec object.\n\t *\n\t * Parameters:\n\t *\n\t * codec - <mxObjectCodec> to be registered.\n\t */\n\tregister: function(codec)\n\t{\n\t\tif (codec != null)\n\t\t{\n\t\t\tvar name = codec.getName();\n\t\t\tmxCodecRegistry.codecs[name] = codec;\n\t\t\t\n\t\t\tvar classname = mxUtils.getFunctionName(codec.template.constructor);\n\n\t\t\tif (classname != name)\n\t\t\t{\n\t\t\t\tmxCodecRegistry.addAlias(classname, name);\n\t\t\t}\n\t\t}\n\n\t\treturn codec;\n\t},\n\n\t/**\n\t * Function: addAlias\n\t *\n\t * Adds an alias for mapping a classname to a codecname.\n\t */\n\taddAlias: function(classname, codecname)\n\t{\n\t\tmxCodecRegistry.aliases[classname] = codecname;\n\t},\n\n\t/**\n\t * Function: getCodec\n\t *\n\t * Returns a codec that handles objects that are constructed\n\t * using the given constructor.\n\t *\n\t * Parameters:\n\t *\n\t * ctor - JavaScript constructor function. \n\t */\n\tgetCodec: function(ctor)\n\t{\n\t\tvar codec = null;\n\t\t\n\t\tif (ctor != null)\n\t\t{\n\t\t\tvar name = mxUtils.getFunctionName(ctor);\n\t\t\tvar tmp = mxCodecRegistry.aliases[name];\n\t\t\t\n\t\t\tif (tmp != null)\n\t\t\t{\n\t\t\t\tname = tmp;\n\t\t\t}\n\t\t\t\n\t\t\tcodec = mxCodecRegistry.codecs[name];\n\t\t\t\n\t\t\t// Registers a new default codec for the given constructor\n\t\t\t// if no codec has been previously defined.\n\t\t\tif (codec == null)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tcodec = new mxObjectCodec(new ctor());\n\t\t\t\t\tmxCodecRegistry.register(codec);\n\t\t\t\t}\n\t\t\t\tcatch (e)\n\t\t\t\t{\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn codec;\n\t}\n\n};\n\n__mxOutput.mxCodecRegistry = typeof mxCodecRegistry !== 'undefined' ? mxCodecRegistry : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCodec\n *\n * XML codec for JavaScript object graphs. See <mxObjectCodec> for a\n * description of the general encoding/decoding scheme. This class uses the\n * codecs registered in <mxCodecRegistry> for encoding/decoding each object.\n * \n * References:\n * \n * In order to resolve references, especially forward references, the mxCodec\n * constructor must be given the document that contains the referenced\n * elements.\n *\n * Examples:\n *\n * The following code is used to encode a graph model.\n *\n * (code)\n * var encoder = new mxCodec();\n * var result = encoder.encode(graph.getModel());\n * var xml = mxUtils.getXml(result);\n * (end)\n * \n * Example:\n * \n * Using the code below, an XML document is decoded into an existing model. The\n * document may be obtained using one of the functions in mxUtils for loading\n * an XML file, eg. <mxUtils.get>, or using <mxUtils.parseXml> for parsing an\n * XML string.\n * \n * (code)\n * var doc = mxUtils.parseXml(xmlString);\n * var codec = new mxCodec(doc);\n * codec.decode(doc.documentElement, graph.getModel());\n * (end)\n * \n * Example:\n * \n * This example demonstrates parsing a list of isolated cells into an existing\n * graph model. Note that the cells do not have a parent reference so they can\n * be added anywhere in the cell hierarchy after parsing.\n * \n * (code)\n * var xml = '<root><mxCell id=\"2\" value=\"Hello,\" vertex=\"1\"><mxGeometry x=\"20\" y=\"20\" width=\"80\" height=\"30\" as=\"geometry\"/></mxCell><mxCell id=\"3\" value=\"World!\" vertex=\"1\"><mxGeometry x=\"200\" y=\"150\" width=\"80\" height=\"30\" as=\"geometry\"/></mxCell><mxCell id=\"4\" value=\"\" edge=\"1\" source=\"2\" target=\"3\"><mxGeometry relative=\"1\" as=\"geometry\"/></mxCell></root>';\n * var doc = mxUtils.parseXml(xml);\n * var codec = new mxCodec(doc);\n * var elt = doc.documentElement.firstChild;\n * var cells = [];\n * \n * while (elt != null)\n * {\n *   cells.push(codec.decode(elt));\n *   elt = elt.nextSibling;\n * }\n * \n * graph.addCells(cells);\n * (end)\n * \n * Example:\n * \n * Using the following code, the selection cells of a graph are encoded and the\n * output is displayed in a dialog box.\n * \n * (code)\n * var enc = new mxCodec();\n * var cells = graph.getSelectionCells();\n * mxUtils.alert(mxUtils.getPrettyXml(enc.encode(cells)));\n * (end)\n * \n * Newlines in the XML can be converted to <br>, in which case a '<br>' argument\n * must be passed to <mxUtils.getXml> as the second argument.\n * \n * Debugging:\n * \n * For debugging I/O you can use the following code to get the sequence of\n * encoded objects:\n * \n * (code)\n * var oldEncode = mxCodec.prototype.encode;\n * mxCodec.prototype.encode = function(obj)\n * {\n *   mxLog.show();\n *   mxLog.debug('mxCodec.encode: obj='+mxUtils.getFunctionName(obj.constructor));\n *   \n *   return oldEncode.apply(this, arguments);\n * };\n * (end)\n * \n * Note that the I/O system adds object codecs for new object automatically. For\n * decoding those objects, the constructor should be written as follows:\n * \n * (code)\n * var MyObj = function(name)\n * {\n *   // ...\n * };\n * (end)\n * \n * Constructor: mxCodec\n *\n * Constructs an XML encoder/decoder for the specified\n * owner document.\n *\n * Parameters:\n *\n * document - Optional XML document that contains the data.\n * If no document is specified then a new document is created\n * using <mxUtils.createXmlDocument>.\n */\nfunction mxCodec(document)\n{\n\tthis.document = document || mxUtils.createXmlDocument();\n\tthis.objects = [];\n};\n\n/**\n * Variable: document\n *\n * The owner document of the codec.\n */\nmxCodec.prototype.document = null;\n\n/**\n * Variable: objects\n *\n * Maps from IDs to objects.\n */\nmxCodec.prototype.objects = null;\n\n/**\n * Variable: elements\n * \n * Lookup table for resolving IDs to elements.\n */\nmxCodec.prototype.elements = null;\n\n/**\n * Variable: encodeDefaults\n *\n * Specifies if default values should be encoded. Default is false.\n */\nmxCodec.prototype.encodeDefaults = false;\n\n\n/**\n * Function: putObject\n * \n * Assoiates the given object with the given ID and returns the given object.\n * \n * Parameters\n * \n * id - ID for the object to be associated with.\n * obj - Object to be associated with the ID.\n */\nmxCodec.prototype.putObject = function(id, obj)\n{\n\tthis.objects[id] = obj;\n\t\n\treturn obj;\n};\n\n/**\n * Function: getObject\n *\n * Returns the decoded object for the element with the specified ID in\n * <document>. If the object is not known then <lookup> is used to find an\n * object. If no object is found, then the element with the respective ID\n * from the document is parsed using <decode>.\n */\nmxCodec.prototype.getObject = function(id)\n{\n\tvar obj = null;\n\n\tif (id != null)\n\t{\n\t\tobj = this.objects[id];\n\t\t\n\t\tif (obj == null)\n\t\t{\n\t\t\tobj = this.lookup(id);\n\t\t\t\n\t\t\tif (obj == null)\n\t\t\t{\n\t\t\t\tvar node = this.getElementById(id);\n\t\t\t\t\n\t\t\t\tif (node != null)\n\t\t\t\t{\n\t\t\t\t\tobj = this.decode(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn obj;\n};\n\n/**\n * Function: lookup\n *\n * Hook for subclassers to implement a custom lookup mechanism for cell IDs.\n * This implementation always returns null.\n *\n * Example:\n *\n * (code)\n * var codec = new mxCodec();\n * codec.lookup = function(id)\n * {\n *   return model.getCell(id);\n * };\n * (end)\n *\n * Parameters:\n *\n * id - ID of the object to be returned.\n */\nmxCodec.prototype.lookup = function(id)\n{\n\treturn null;\n};\n\n/**\n * Function: getElementById\n *\n * Returns the element with the given ID from <document>.\n *\n * Parameters:\n *\n * id - String that contains the ID.\n */\nmxCodec.prototype.getElementById = function(id)\n{\n\tthis.updateElements();\n\t\n\treturn this.elements[id];\n};\n\n/**\n * Function: updateElements\n *\n * Returns the element with the given ID from <document>.\n *\n * Parameters:\n *\n * id - String that contains the ID.\n */\nmxCodec.prototype.updateElements = function()\n{\n\tif (this.elements == null)\n\t{\n\t\tthis.elements = new Object();\n\t\t\n\t\tif (this.document.documentElement != null)\n\t\t{\n\t\t\tthis.addElement(this.document.documentElement);\n\t\t}\n\t}\n};\n\n/**\n * Function: addElement\n *\n * Adds the given element to <elements> if it has an ID.\n */\nmxCodec.prototype.addElement = function(node)\n{\n\tif (node.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t{\n\t\tvar id = node.getAttribute('id');\n\t\t\n\t\tif (id != null)\n\t\t{\n\t\t\tif (this.elements[id] == null)\n\t\t\t{\n\t\t\t\tthis.elements[id] = node;\n\t\t\t}\n\t\t\telse if (this.elements[id] != node)\n\t\t\t{\n\t\t\t\tthrow new Error(id + ': Duplicate ID');\n\t\t\t}\n\t\t}\n\t}\n\t\n\tnode = node.firstChild;\n\t\n\twhile (node != null)\n\t{\n\t\tthis.addElement(node);\n\t\tnode = node.nextSibling;\n\t}\n};\n\n/**\n * Function: getId\n *\n * Returns the ID of the specified object. This implementation\n * calls <reference> first and if that returns null handles\n * the object as an <mxCell> by returning their IDs using\n * <mxCell.getId>. If no ID exists for the given cell, then\n * an on-the-fly ID is generated using <mxCellPath.create>.\n *\n * Parameters:\n *\n * obj - Object to return the ID for.\n */\nmxCodec.prototype.getId = function(obj)\n{\n\tvar id = null;\n\t\n\tif (obj != null)\n\t{\n\t\tid = this.reference(obj);\n\t\t\n\t\tif (id == null && obj instanceof mxCell)\n\t\t{\n\t\t\tid = obj.getId();\n\t\t\t\n\t\t\tif (id == null)\n\t\t\t{\n\t\t\t\t// Uses an on-the-fly Id\n\t\t\t\tid = mxCellPath.create(obj);\n\t\t\t\t\n\t\t\t\tif (id.length == 0)\n\t\t\t\t{\n\t\t\t\t\tid = 'root';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn id;\n};\n\n/**\n * Function: reference\n *\n * Hook for subclassers to implement a custom method\n * for retrieving IDs from objects. This implementation\n * always returns null.\n *\n * Example:\n *\n * (code)\n * var codec = new mxCodec();\n * codec.reference = function(obj)\n * {\n *   return obj.getCustomId();\n * };\n * (end)\n *\n * Parameters:\n *\n * obj - Object whose ID should be returned.\n */\nmxCodec.prototype.reference = function(obj)\n{\n\treturn null;\n};\n\n/**\n * Function: encode\n *\n * Encodes the specified object and returns the resulting\n * XML node.\n *\n * Parameters:\n *\n * obj - Object to be encoded. \n */\nmxCodec.prototype.encode = function(obj)\n{\n\tvar node = null;\n\t\n\tif (obj != null && obj.constructor != null)\n\t{\n\t\tvar enc = mxCodecRegistry.getCodec(obj.constructor);\n\t\t\n\t\tif (enc != null)\n\t\t{\n\t\t\tnode = enc.encode(this, obj);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (mxUtils.isNode(obj))\n\t\t\t{\n\t\t\t\tnode = mxUtils.importNode(this.document, obj, true);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t    \t\tmxLog.warn('mxCodec.encode: No codec for ' + mxUtils.getFunctionName(obj.constructor));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn node;\n};\n\n/**\n * Function: decode\n *\n * Decodes the given XML node. The optional \"into\"\n * argument specifies an existing object to be\n * used. If no object is given, then a new instance\n * is created using the constructor from the codec.\n *\n * The function returns the passed in object or\n * the new instance if no object was given.\n *\n * Parameters:\n *\n * node - XML node to be decoded.\n * into - Optional object to be decodec into.\n */\nmxCodec.prototype.decode = function(node, into)\n{\n\tthis.updateElements();\n\tvar obj = null;\n\t\n\tif (node != null && node.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t{\n\t\tvar ctor = null;\n\t\t\n\t\ttry\n\t\t{\n\t\t\tctor = window[node.nodeName];\n\t\t}\n\t\tcatch (err)\n\t\t{\n\t\t\t// ignore\n\t\t}\n\t\t\n\t\tvar dec = mxCodecRegistry.getCodec(ctor);\n\t\t\n\t\tif (dec != null)\n\t\t{\n\t\t\tobj = dec.decode(this, node, into);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tobj = node.cloneNode(true);\n\t\t\tobj.removeAttribute('as');\n\t\t}\n\t}\n\t\n\treturn obj;\n};\n\n/**\n * Function: encodeCell\n *\n * Encoding of cell hierarchies is built-into the core, but\n * is a higher-level function that needs to be explicitely\n * used by the respective object encoders (eg. <mxModelCodec>,\n * <mxChildChangeCodec> and <mxRootChangeCodec>). This\n * implementation writes the given cell and its children as a\n * (flat) sequence into the given node. The children are not\n * encoded if the optional includeChildren is false. The\n * function is in charge of adding the result into the\n * given node and has no return value.\n *\n * Parameters:\n *\n * cell - <mxCell> to be encoded.\n * node - Parent XML node to add the encoded cell into.\n * includeChildren - Optional boolean indicating if the\n * function should include all descendents. Default is true. \n */\nmxCodec.prototype.encodeCell = function(cell, node, includeChildren)\n{\n\tnode.appendChild(this.encode(cell));\n\t\n\tif (includeChildren == null || includeChildren)\n\t{\n\t\tvar childCount = cell.getChildCount();\n\t\t\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tthis.encodeCell(cell.getChildAt(i), node);\n\t\t}\n\t}\n};\n\n/**\n * Function: isCellCodec\n * \n * Returns true if the given codec is a cell codec. This uses\n * <mxCellCodec.isCellCodec> to check if the codec is of the\n * given type.\n */\nmxCodec.prototype.isCellCodec = function(codec)\n{\n\tif (codec != null && typeof(codec.isCellCodec) == 'function')\n\t{\n\t\treturn codec.isCellCodec();\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: decodeCell\n *\n * Decodes cells that have been encoded using inversion, ie.\n * where the user object is the enclosing node in the XML,\n * and restores the group and graph structure in the cells.\n * Returns a new <mxCell> instance that represents the\n * given node.\n *\n * Parameters:\n *\n * node - XML node that contains the cell data.\n * restoreStructures - Optional boolean indicating whether\n * the graph structure should be restored by calling insert\n * and insertEdge on the parent and terminals, respectively.\n * Default is true.\n */\nmxCodec.prototype.decodeCell = function(node, restoreStructures)\n{\n\trestoreStructures = (restoreStructures != null) ? restoreStructures : true;\n\tvar cell = null;\n\t\n\tif (node != null && node.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t{\n\t\t// Tries to find a codec for the given node name. If that does\n\t\t// not return a codec then the node is the user object (an XML node\n\t\t// that contains the mxCell, aka inversion).\n\t\tvar decoder = mxCodecRegistry.getCodec(node.nodeName);\n\t\t\n\t\t// Tries to find the codec for the cell inside the user object.\n\t\t// This assumes all node names inside the user object are either\n\t\t// not registered or they correspond to a class for cells.\n\t\tif (!this.isCellCodec(decoder))\n\t\t{\n\t\t\tvar child = node.firstChild;\n\t\t\t\n\t\t\twhile (child != null && !this.isCellCodec(decoder))\n\t\t\t{\n\t\t\t\tdecoder = mxCodecRegistry.getCodec(child.nodeName);\n\t\t\t\tchild = child.nextSibling;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!this.isCellCodec(decoder))\n\t\t{\n\t\t\tdecoder = mxCodecRegistry.getCodec(mxCell);\n\t\t}\n\n\t\tcell = decoder.decode(this, node);\n\t\t\n\t\tif (restoreStructures)\n\t\t{\n\t\t\tthis.insertIntoGraph(cell);\n\t\t}\n\t}\n\t\n\treturn cell;\n};\n\n/**\n * Function: insertIntoGraph\n *\n * Inserts the given cell into its parent and terminal cells.\n */\nmxCodec.prototype.insertIntoGraph = function(cell)\n{\n\tvar parent = cell.parent;\n\tvar source = cell.getTerminal(true);\n\tvar target = cell.getTerminal(false);\n\n\t// Fixes possible inconsistencies during insert into graph\n\tcell.setTerminal(null, false);\n\tcell.setTerminal(null, true);\n\tcell.parent = null;\n\t\n\tif (parent != null)\n\t{\n\t\tif (parent == cell)\n\t\t{\n\t\t\tthrow new Error(parent.id + ': Self Reference');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent.insert(cell);\n\t\t}\n\t}\n\n\tif (source != null)\n\t{\n\t\tsource.insertEdge(cell, true);\n\t}\n\n\tif (target != null)\n\t{\n\t\ttarget.insertEdge(cell, false);\n\t}\n};\n\n/**\n * Function: setAttribute\n *\n * Sets the attribute on the specified node to value. This is a\n * helper method that makes sure the attribute and value arguments\n * are not null.\n *\n * Parameters:\n *\n * node - XML node to set the attribute for.\n * attributes - Attributename to be set.\n * value - New value of the attribute.\n */\nmxCodec.prototype.setAttribute = function(node, attribute, value)\n{\n\tif (attribute != null && value != null)\n\t{\n\t\tnode.setAttribute(attribute, value);\n\t}\n};\n\n__mxOutput.mxCodec = typeof mxCodec !== 'undefined' ? mxCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxObjectCodec\n *\n * Generic codec for JavaScript objects that implements a mapping between\n * JavaScript objects and XML nodes that maps each field or element to an\n * attribute or child node, and vice versa.\n * \n * Atomic Values:\n * \n * Consider the following example.\n * \n * (code)\n * var obj = new Object();\n * obj.foo = \"Foo\";\n * obj.bar = \"Bar\";\n * (end)\n * \n * This object is encoded into an XML node using the following.\n * \n * (code)\n * var enc = new mxCodec();\n * var node = enc.encode(obj);\n * (end)\n * \n * The output of the encoding may be viewed using <mxLog> as follows.\n * \n * (code)\n * mxLog.show();\n * mxLog.debug(mxUtils.getPrettyXml(node));\n * (end)\n * \n * Finally, the result of the encoding looks as follows.\n * \n * (code)\n * <Object foo=\"Foo\" bar=\"Bar\"/>\n * (end)\n * \n * In the above output, the foo and bar fields have been mapped to attributes\n * with the same names, and the name of the constructor was used for the\n * nodename.\n * \n * Booleans:\n *\n * Since booleans are numbers in JavaScript, all boolean values are encoded\n * into 1 for true and 0 for false. The decoder also accepts the string true\n * and false for boolean values.\n * \n * Objects:\n * \n * The above scheme is applied to all atomic fields, that is, to all non-object\n * fields of an object. For object fields, a child node is created with a\n * special attribute that contains the fieldname. This special attribute is\n * called \"as\" and hence, as is a reserved word that should not be used for a\n * fieldname.\n * \n * Consider the following example where foo is an object and bar is an atomic\n * property of foo.\n * \n * (code)\n * var obj = {foo: {bar: \"Bar\"}};\n * (end)\n * \n * This will be mapped to the following XML structure by mxObjectCodec.\n * \n * (code)\n * <Object>\n *   <Object bar=\"Bar\" as=\"foo\"/>\n * </Object>\n * (end)\n * \n * In the above output, the inner Object node contains the as-attribute that\n * specifies the fieldname in the enclosing object. That is, the field foo was\n * mapped to a child node with an as-attribute that has the value foo.\n * \n * Arrays:\n * \n * Arrays are special objects that are either associative, in which case each\n * key, value pair is treated like a field where the key is the fieldname, or\n * they are a sequence of atomic values and objects, which is mapped to a\n * sequence of child nodes. For object elements, the above scheme is applied\n * without the use of the special as-attribute for creating each child. For\n * atomic elements, a special add-node is created with the value stored in the\n * value-attribute.\n * \n * For example, the following array contains one atomic value and one object\n * with a field called bar. Furthermore it contains two associative entries\n * called bar with an atomic value, and foo with an object value.\n * \n * (code)\n * var obj = [\"Bar\", {bar: \"Bar\"}];\n * obj[\"bar\"] = \"Bar\";\n * obj[\"foo\"] = {bar: \"Bar\"};\n * (end)\n * \n * This array is represented by the following XML nodes.\n * \n * (code)\n * <Array bar=\"Bar\">\n *   <add value=\"Bar\"/>\n *   <Object bar=\"Bar\"/>\n *   <Object bar=\"Bar\" as=\"foo\"/>\n * </Array>\n * (end)\n * \n * The Array node name is the name of the constructor. The additional\n * as-attribute in the last child contains the key of the associative entry,\n * whereas the second last child is part of the array sequence and does not\n * have an as-attribute.\n * \n * References:\n * \n * Objects may be represented as child nodes or attributes with ID values,\n * which are used to lookup the object in a table within <mxCodec>. The\n * <isReference> function is in charge of deciding if a specific field should\n * be encoded as a reference or not. Its default implementation returns true if\n * the fieldname is in <idrefs>, an array of strings that is used to configure\n * the <mxObjectCodec>.\n * \n * Using this approach, the mapping does not guarantee that the referenced\n * object itself exists in the document. The fields that are encoded as\n * references must be carefully chosen to make sure all referenced objects\n * exist in the document, or may be resolved by some other means if necessary.\n * \n * For example, in the case of the graph model all cells are stored in a tree\n * whose root is referenced by the model's root field. A tree is a structure\n * that is well suited for an XML representation, however, the additional edges\n * in the graph model have a reference to a source and target cell, which are\n * also contained in the tree. To handle this case, the source and target cell\n * of an edge are treated as references, whereas the children are treated as\n * objects. Since all cells are contained in the tree and no edge references a\n * source or target outside the tree, this setup makes sure all referenced\n * objects are contained in the document.\n * \n * In the case of a tree structure we must further avoid infinite recursion by\n * ignoring the parent reference of each child. This is done by returning true\n * in <isExcluded>, whose default implementation uses the array of excluded\n * fieldnames passed to the mxObjectCodec constructor.\n * \n * References are only used for cells in mxGraph. For defining other\n * referencable object types, the codec must be able to work out the ID of an\n * object. This is done by implementing <mxCodec.reference>. For decoding a\n * reference, the XML node with the respective id-attribute is fetched from the\n * document, decoded, and stored in a lookup table for later reference. For\n * looking up external objects, <mxCodec.lookup> may be implemented.\n * \n * Expressions:\n * \n * For decoding JavaScript expressions, the add-node may be used with a text\n * content that contains the JavaScript expression. For example, the following\n * creates a field called foo in the enclosing object and assigns it the value\n * of <mxConstants.ALIGN_LEFT>.\n * \n * (code)\n * <Object>\n *   <add as=\"foo\">mxConstants.ALIGN_LEFT</add>\n * </Object>\n * (end)\n * \n * The resulting object has a field called foo with the value \"left\". Its XML\n * representation looks as follows.\n * \n * (code)\n * <Object foo=\"left\"/>\n * (end)\n * \n * This means the expression is evaluated at decoding time and the result of\n * the evaluation is stored in the respective field. Valid expressions are all\n * JavaScript expressions, including function definitions, which are mapped to\n * functions on the resulting object.\n * \n * Expressions are only evaluated if <allowEval> is true.\n * \n * Constructor: mxObjectCodec\n *\n * Constructs a new codec for the specified template object.\n * The variables in the optional exclude array are ignored by\n * the codec. Variables in the optional idrefs array are\n * turned into references in the XML. The optional mapping\n * may be used to map from variable names to XML attributes.\n * The argument is created as follows:\n *\n * (code)\n * var mapping = new Object();\n * mapping['variableName'] = 'attribute-name';\n * (end)\n *\n * Parameters:\n *\n * template - Prototypical instance of the object to be\n * encoded/decoded.\n * exclude - Optional array of fieldnames to be ignored.\n * idrefs - Optional array of fieldnames to be converted to/from\n * references.\n * mapping - Optional mapping from field- to attributenames.\n */\nfunction mxObjectCodec(template, exclude, idrefs, mapping)\n{\n\tthis.template = template;\n\t\n\tthis.exclude = (exclude != null) ? exclude : [];\n\tthis.idrefs = (idrefs != null) ? idrefs : [];\n\tthis.mapping = (mapping != null) ? mapping : [];\n\t\n\tthis.reverse = new Object();\n\t\n\tfor (var i in this.mapping)\n\t{\n\t\tthis.reverse[this.mapping[i]] = i;\n\t}\n};\n\n/**\n * Variable: allowEval\n *\n * Static global switch that specifies if expressions in arrays are allowed.\n * Default is false. NOTE: Enabling this carries a possible security risk.\n */\nmxObjectCodec.allowEval = false;\n\n/**\n * Variable: template\n *\n * Holds the template object associated with this codec.\n */\nmxObjectCodec.prototype.template = null;\n\n/**\n * Variable: exclude\n *\n * Array containing the variable names that should be\n * ignored by the codec.\n */\nmxObjectCodec.prototype.exclude = null;\n\n/**\n * Variable: idrefs\n *\n * Array containing the variable names that should be\n * turned into or converted from references. See\n * <mxCodec.getId> and <mxCodec.getObject>.\n */\nmxObjectCodec.prototype.idrefs = null;\n\n/**\n * Variable: mapping\n *\n * Maps from from fieldnames to XML attribute names.\n */\nmxObjectCodec.prototype.mapping = null;\n\n/**\n * Variable: reverse\n *\n * Maps from from XML attribute names to fieldnames.\n */\nmxObjectCodec.prototype.reverse = null;\n\n/**\n * Function: getName\n * \n * Returns the name used for the nodenames and lookup of the codec when\n * classes are encoded and nodes are decoded. For classes to work with\n * this the codec registry automatically adds an alias for the classname\n * if that is different than what this returns. The default implementation\n * returns the classname of the template class.\n */\nmxObjectCodec.prototype.getName = function()\n{\n\treturn mxUtils.getFunctionName(this.template.constructor);\n};\n\n/**\n * Function: cloneTemplate\n * \n * Returns a new instance of the template for this codec.\n */\nmxObjectCodec.prototype.cloneTemplate = function()\n{\n\treturn new this.template.constructor();\n};\n\n/**\n * Function: getFieldName\n * \n * Returns the fieldname for the given attributename.\n * Looks up the value in the <reverse> mapping or returns\n * the input if there is no reverse mapping for the\n * given name.\n */\nmxObjectCodec.prototype.getFieldName = function(attributename)\n{\n\tif (attributename != null)\n\t{\n\t\tvar mapped = this.reverse[attributename];\n\t\t\n\t\tif (mapped != null)\n\t\t{\n\t\t\tattributename = mapped;\n\t\t}\n\t}\n\t\n\treturn attributename;\n};\n\n/**\n * Function: getAttributeName\n * \n * Returns the attributename for the given fieldname.\n * Looks up the value in the <mapping> or returns\n * the input if there is no mapping for the\n * given name.\n */\nmxObjectCodec.prototype.getAttributeName = function(fieldname)\n{\n\tif (fieldname != null)\n\t{\n\t\tvar mapped = this.mapping[fieldname];\n\t\t\n\t\tif (mapped != null)\n\t\t{\n\t\t\tfieldname = mapped;\n\t\t}\n\t}\n\t\n\treturn fieldname;\n};\n\n/**\n * Function: isExcluded\n *\n * Returns true if the given attribute is to be ignored by the codec. This\n * implementation returns true if the given fieldname is in <exclude> or\n * if the fieldname equals <mxObjectIdentity.FIELD_NAME>.\n *\n * Parameters:\n *\n * obj - Object instance that contains the field.\n * attr - Fieldname of the field.\n * value - Value of the field.\n * write - Boolean indicating if the field is being encoded or decoded.\n * Write is true if the field is being encoded, else it is being decoded.\n */\nmxObjectCodec.prototype.isExcluded = function(obj, attr, value, write)\n{\n\treturn attr == mxObjectIdentity.FIELD_NAME ||\n\t\tmxUtils.indexOf(this.exclude, attr) >= 0;\n};\n\n/**\n * Function: isReference\n *\n * Returns true if the given fieldname is to be treated\n * as a textual reference (ID). This implementation returns\n * true if the given fieldname is in <idrefs>.\n *\n * Parameters:\n *\n * obj - Object instance that contains the field.\n * attr - Fieldname of the field.\n * value - Value of the field. \n * write - Boolean indicating if the field is being encoded or decoded.\n * Write is true if the field is being encoded, else it is being decoded.\n */\nmxObjectCodec.prototype.isReference = function(obj, attr, value, write)\n{\n\treturn mxUtils.indexOf(this.idrefs, attr) >= 0;\n};\n\n/**\n * Function: encode\n *\n * Encodes the specified object and returns a node\n * representing then given object. Calls <beforeEncode>\n * after creating the node and <afterEncode> with the \n * resulting node after processing.\n *\n * Enc is a reference to the calling encoder. It is used\n * to encode complex objects and create references.\n *\n * This implementation encodes all variables of an\n * object according to the following rules:\n *\n * - If the variable name is in <exclude> then it is ignored.\n * - If the variable name is in <idrefs> then <mxCodec.getId>\n * is used to replace the object with its ID.\n * - The variable name is mapped using <mapping>.\n * - If obj is an array and the variable name is numeric\n * (ie. an index) then it is not encoded.\n * - If the value is an object, then the codec is used to\n * create a child node with the variable name encoded into\n * the \"as\" attribute.\n * - Else, if <encodeDefaults> is true or the value differs\n * from the template value, then ...\n * - ... if obj is not an array, then the value is mapped to\n * an attribute.\n * - ... else if obj is an array, the value is mapped to an\n * add child with a value attribute or a text child node,\n * if the value is a function.\n *\n * If no ID exists for a variable in <idrefs> or if an object\n * cannot be encoded, a warning is issued using <mxLog.warn>.\n *\n * Returns the resulting XML node that represents the given\n * object.\n *\n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Object to be encoded.\n */\nmxObjectCodec.prototype.encode = function(enc, obj)\n{\n\tvar node = enc.document.createElement(this.getName());\n\t\n\tobj = this.beforeEncode(enc, obj, node);\n\tthis.encodeObject(enc, obj, node);\n\t\n\treturn this.afterEncode(enc, obj, node);\n};\n\t\n/**\n * Function: encodeObject\n *\n * Encodes the value of each member in then given obj into the given node using\n * <encodeValue>.\n * \n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Object to be encoded.\n * node - XML node that contains the encoded object.\n */\nmxObjectCodec.prototype.encodeObject = function(enc, obj, node)\n{\n\tenc.setAttribute(node, 'id', enc.getId(obj));\n\t\n    for (var i in obj)\n    {\n\t\tvar name = i;\n\t\tvar value = obj[name];\n\t\t\n    \tif (value != null && !this.isExcluded(obj, name, value, true))\n    \t{\n    \t\tif (mxUtils.isInteger(name))\n    \t\t{\n    \t\t\tname = null;\n    \t\t}\n    \t\t\n    \t\tthis.encodeValue(enc, obj, name, value, node);\n    \t}\n    }\n};\n\n/**\n * Function: encodeValue\n * \n * Converts the given value according to the mappings\n * and id-refs in this codec and uses <writeAttribute>\n * to write the attribute into the given node.\n * \n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Object whose property is going to be encoded.\n * name - XML node that contains the encoded object.\n * value - Value of the property to be encoded.\n * node - XML node that contains the encoded object.\n */\nmxObjectCodec.prototype.encodeValue = function(enc, obj, name, value, node)\n{\n\tif (value != null)\n\t{\n\t\tif (this.isReference(obj, name, value, true))\n\t\t{\n\t\t\tvar tmp = enc.getId(value);\n\t\t\t\n\t\t\tif (tmp == null)\n\t\t\t{\n\t\t    \tmxLog.warn('mxObjectCodec.encode: No ID for ' +\n\t\t    \t\tthis.getName() + '.' + name + '=' + value);\n\t\t    \treturn; // exit\n\t\t    }\n\t\t    \n\t\t    value = tmp;\n\t\t}\n\n\t\tvar defaultValue = this.template[name];\n\t\t\n\t\t// Checks if the value is a default value and\n\t\t// the name is correct\n\t\tif (name == null || enc.encodeDefaults || defaultValue != value)\n\t\t{\n\t\t\tname = this.getAttributeName(name);\n\t\t\tthis.writeAttribute(enc, obj, name, value, node);\t\n\t\t}\n\t}\n};\n\n/**\n * Function: writeAttribute\n * \n * Writes the given value into node using <writePrimitiveAttribute>\n * or <writeComplexAttribute> depending on the type of the value.\n */\nmxObjectCodec.prototype.writeAttribute = function(enc, obj, name, value, node)\n{\n\tif (typeof(value) != 'object' /* primitive type */)\n\t{\n\t\tthis.writePrimitiveAttribute(enc, obj, name, value, node);\n\t}\n\telse /* complex type */\n\t{\n\t\tthis.writeComplexAttribute(enc, obj, name, value, node);\n\t}\n};\n\n/**\n * Function: writePrimitiveAttribute\n * \n * Writes the given value as an attribute of the given node.\n */\nmxObjectCodec.prototype.writePrimitiveAttribute = function(enc, obj, name, value, node)\n{\n\tvalue = this.convertAttributeToXml(enc, obj, name, value, node);\n\t\n\tif (name == null)\n\t{\n\t\tvar child = enc.document.createElement('add');\n\t\t\n\t\tif (typeof(value) == 'function')\n\t\t{\n    \t\tchild.appendChild(enc.document.createTextNode(value));\n    \t}\n    \telse\n    \t{\n    \t\tenc.setAttribute(child, 'value', value);\n    \t}\n    \t\n\t\tnode.appendChild(child);\n\t}\n\telse if (typeof(value) != 'function')\n\t{\n    \tenc.setAttribute(node, name, value);\n\t}\t\t\n};\n\t\n/**\n * Function: writeComplexAttribute\n * \n * Writes the given value as a child node of the given node.\n */\nmxObjectCodec.prototype.writeComplexAttribute = function(enc, obj, name, value, node)\n{\n\tvar child = enc.encode(value);\n\t\n\tif (child != null)\n\t{\n\t\tif (name != null)\n\t\t{\n    \t\tchild.setAttribute('as', name);\n    \t}\n    \t\n    \tnode.appendChild(child);\n\t}\n\telse\n\t{\n\t\tmxLog.warn('mxObjectCodec.encode: No node for ' + this.getName() + '.' + name + ': ' + value);\n\t}\n};\n\n/**\n * Function: convertAttributeToXml\n * \n * Converts true to \"1\" and false to \"0\" is <isBooleanAttribute> returns true.\n * All other values are not converted.\n * \n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Objec to convert the attribute for.\n * name - Name of the attribute to be converted.\n * value - Value to be converted.\n */\nmxObjectCodec.prototype.convertAttributeToXml = function(enc, obj, name, value)\n{\n\t// Makes sure to encode boolean values as numeric values\n\tif (this.isBooleanAttribute(enc, obj, name, value))\n\t{\t\n\t\t// Checks if the value is true (do not use the value as is, because\n\t\t// this would check if the value is not null, so 0 would be true)\n\t\tvalue = (value == true) ? '1' : '0';\n\t}\n\t\n\treturn value;\n};\n\n/**\n * Function: isBooleanAttribute\n * \n * Returns true if the given object attribute is a boolean value.\n * \n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Objec to convert the attribute for.\n * name - Name of the attribute to be converted.\n * value - Value of the attribute to be converted.\n */\nmxObjectCodec.prototype.isBooleanAttribute = function(enc, obj, name, value)\n{\n\treturn (typeof(value.length) == 'undefined' && (value == true || value == false));\n};\n\n/**\n * Function: convertAttributeFromXml\n * \n * Converts booleans and numeric values to the respective types. Values are\n * numeric if <isNumericAttribute> returns true.\n * \n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * attr - XML attribute to be converted.\n * obj - Objec to convert the attribute for.\n */\nmxObjectCodec.prototype.convertAttributeFromXml = function(dec, attr, obj)\n{\n\tvar value = attr.value;\n\t\n\tif (this.isNumericAttribute(dec, attr, obj))\n\t{\n\t\tvalue = parseFloat(value);\n\t\t\n\t\tif (isNaN(value) || !isFinite(value))\n\t\t{\n\t\t\tvalue = 0;\n\t\t}\n\t}\n\t\n\treturn value;\n};\n\n/**\n * Function: isNumericAttribute\n * \n * Returns true if the given XML attribute is or should be a numeric value.\n * \n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * attr - XML attribute to be converted.\n * obj - Objec to convert the attribute for.\n */\nmxObjectCodec.prototype.isNumericAttribute = function(dec, attr, obj)\n{\n\t// Handles known numeric attributes for generic objects\n\tvar result = (obj.constructor == mxGeometry &&\n\t\t(attr.name == 'x' || attr.name == 'y' ||\n\t\tattr.name == 'width' || attr.name == 'height')) ||\n\t\t(obj.constructor == mxPoint &&\n\t\t(attr.name == 'x' || attr.name == 'y')) ||\n\t\tmxUtils.isNumeric(attr.value);\n\t\n\treturn result;\n};\n\n/**\n * Function: beforeEncode\n *\n * Hook for subclassers to pre-process the object before\n * encoding. This returns the input object. The return\n * value of this function is used in <encode> to perform\n * the default encoding into the given node.\n *\n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Object to be encoded.\n * node - XML node to encode the object into.\n */\nmxObjectCodec.prototype.beforeEncode = function(enc, obj, node)\n{\n\treturn obj;\n};\n\n/**\n * Function: afterEncode\n *\n * Hook for subclassers to post-process the node\n * for the given object after encoding and return the\n * post-processed node. This implementation returns \n * the input node. The return value of this method\n * is returned to the encoder from <encode>.\n *\n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Object to be encoded.\n * node - XML node that represents the default encoding.\n */\nmxObjectCodec.prototype.afterEncode = function(enc, obj, node)\n{\n\treturn node;\n};\n\n/**\n * Function: decode\n *\n * Parses the given node into the object or returns a new object\n * representing the given node.\n *\n * Dec is a reference to the calling decoder. It is used to decode\n * complex objects and resolve references.\n *\n * If a node has an id attribute then the object cache is checked for the\n * object. If the object is not yet in the cache then it is constructed\n * using the constructor of <template> and cached in <mxCodec.objects>.\n *\n * This implementation decodes all attributes and childs of a node\n * according to the following rules:\n *\n * - If the variable name is in <exclude> or if the attribute name is \"id\"\n * or \"as\" then it is ignored.\n * - If the variable name is in <idrefs> then <mxCodec.getObject> is used\n * to replace the reference with an object.\n * - The variable name is mapped using a reverse <mapping>.\n * - If the value has a child node, then the codec is used to create a\n * child object with the variable name taken from the \"as\" attribute.\n * - If the object is an array and the variable name is empty then the\n * value or child object is appended to the array.\n * - If an add child has no value or the object is not an array then\n * the child text content is evaluated using <mxUtils.eval>.\n *\n * For add nodes where the object is not an array and the variable name\n * is defined, the default mechanism is used, allowing to override/add\n * methods as follows:\n *\n * (code)\n * <Object>\n *   <add as=\"hello\"><![CDATA[\n *     function(arg1) {\n *       mxUtils.alert('Hello '+arg1);\n *     }\n *   ]]></add>\n * </Object>\n * (end) \n *\n * If no object exists for an ID in <idrefs> a warning is issued\n * using <mxLog.warn>.\n *\n * Returns the resulting object that represents the given XML node\n * or the object given to the method as the into parameter.\n *\n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * node - XML node to be decoded.\n * into - Optional objec to encode the node into.\n */\nmxObjectCodec.prototype.decode = function(dec, node, into)\n{\n\tvar id = node.getAttribute('id');\n\tvar obj = dec.objects[id];\n\t\n\tif (obj == null)\n\t{\n\t\tobj = into || this.cloneTemplate();\n\t\t\n\t\tif (id != null)\n\t\t{\n\t\t\tdec.putObject(id, obj);\n\t\t}\n\t}\n\t\n\tnode = this.beforeDecode(dec, node, obj);\n\tthis.decodeNode(dec, node, obj);\n\t\n    return this.afterDecode(dec, node, obj);\n};\t\n\n/**\n * Function: decodeNode\n * \n * Calls <decodeAttributes> and <decodeChildren> for the given node.\n * \n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * node - XML node to be decoded.\n * obj - Objec to encode the node into.\n */\t\nmxObjectCodec.prototype.decodeNode = function(dec, node, obj)\n{\n\tif (node != null)\n\t{\n\t\tthis.decodeAttributes(dec, node, obj);\n\t\tthis.decodeChildren(dec, node, obj);\n\t}\n};\n\n/**\n * Function: decodeAttributes\n * \n * Decodes all attributes of the given node using <decodeAttribute>.\n * \n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * node - XML node to be decoded.\n * obj - Objec to encode the node into.\n */\t\nmxObjectCodec.prototype.decodeAttributes = function(dec, node, obj)\n{\n\tvar attrs = node.attributes;\n\t\n\tif (attrs != null)\n\t{\n\t\tfor (var i = 0; i < attrs.length; i++)\n\t\t{\n\t\t\tthis.decodeAttribute(dec, attrs[i], obj);\n\t\t}\n\t}\n};\n\n/**\n * Function: isIgnoredAttribute\n * \n * Returns true if the given attribute should be ignored. This implementation\n * returns true if the attribute name is \"as\" or \"id\".\n * \n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * attr - XML attribute to be decoded.\n * obj - Objec to encode the attribute into.\n */\t\nmxObjectCodec.prototype.isIgnoredAttribute = function(dec, attr, obj)\n{\n\treturn attr.nodeName == 'as' || attr.nodeName == 'id';\n};\n\n/**\n * Function: decodeAttribute\n * \n * Reads the given attribute into the specified object.\n * \n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * attr - XML attribute to be decoded.\n * obj - Objec to encode the attribute into.\n */\t\nmxObjectCodec.prototype.decodeAttribute = function(dec, attr, obj)\n{\n\tif (!this.isIgnoredAttribute(dec, attr, obj))\n\t{\n\t\tvar name = attr.nodeName;\n\t\t\n\t\t// Converts the string true and false to their boolean values.\n\t\t// This may require an additional check on the obj to see if\n\t\t// the existing field is a boolean value or uninitialized, in\n\t\t// which case we may want to convert true and false to a string.\n\t\tvar value = this.convertAttributeFromXml(dec, attr, obj);\n\t\tvar fieldname = this.getFieldName(name);\n\t\t\n\t\tif (this.isReference(obj, fieldname, value, false))\n\t\t{\n\t\t\tvar tmp = dec.getObject(value);\n\t\t\t\n\t\t\tif (tmp == null)\n\t\t\t{\n\t\t    \tmxLog.warn('mxObjectCodec.decode: No object for ' +\n\t\t    \t\tthis.getName() + '.' + name + '=' + value);\n\t\t    \treturn; // exit\n\t\t    }\n\t\t    \n\t\t    value = tmp;\n\t\t}\n\n\t\tif (!this.isExcluded(obj, name, value, false))\n\t\t{\n\t\t\t//mxLog.debug(mxUtils.getFunctionName(obj.constructor)+'.'+name+'='+value);\n\t\t\tobj[name] = value;\n\t\t}\n\t}\n};\n\n/**\n * Function: decodeChildren\n * \n * Decodes all children of the given node using <decodeChild>.\n * \n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * node - XML node to be decoded.\n * obj - Objec to encode the node into.\n */\t\nmxObjectCodec.prototype.decodeChildren = function(dec, node, obj)\n{\n\tvar child = node.firstChild;\n\t\n\twhile (child != null)\n\t{\n\t\tvar tmp = child.nextSibling;\n\t\t\n\t\tif (child.nodeType == mxConstants.NODETYPE_ELEMENT &&\n\t\t\t!this.processInclude(dec, child, obj))\n\t\t{\n\t\t\tthis.decodeChild(dec, child, obj);\n\t\t}\n\t\t\n\t\tchild = tmp;\n\t}\n};\n\n/**\n * Function: decodeChild\n * \n * Reads the specified child into the given object.\n * \n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * child - XML child element to be decoded.\n * obj - Objec to encode the node into.\n */\t\nmxObjectCodec.prototype.decodeChild = function(dec, child, obj)\n{\n\tvar fieldname = this.getFieldName(child.getAttribute('as'));\n\t\n\tif (fieldname == null || !this.isExcluded(obj, fieldname, child, false))\n\t{\n\t\tvar template = this.getFieldTemplate(obj, fieldname, child);\n\t\tvar value = null;\n\t\t\n\t\tif (child.nodeName == 'add')\n\t\t{\n\t\t\tvalue = child.getAttribute('value');\n\t\t\t\n\t\t\tif (value == null && mxObjectCodec.allowEval)\n\t\t\t{\n\t\t\t\tvalue = mxUtils.eval(mxUtils.getTextContent(child));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalue = dec.decode(child, template);\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tthis.addObjectValue(obj, fieldname, value, template);\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\tthrow new Error(e.message + ' for ' + child.nodeName);\n\t\t}\n\t}\n};\n\n/**\n * Function: getFieldTemplate\n * \n * Returns the template instance for the given field. This returns the\n * value of the field, null if the value is an array or an empty collection\n * if the value is a collection. The value is then used to populate the\n * field for a new instance. For strongly typed languages it may be\n * required to override this to return the correct collection instance\n * based on the encoded child.\n */\t\nmxObjectCodec.prototype.getFieldTemplate = function(obj, fieldname, child)\n{\n\tvar template = obj[fieldname];\n\t\n\t// Non-empty arrays are replaced completely\n    if (template instanceof Array && template.length > 0)\n    {\n        template = null;\n    }\n    \n    return template;\n};\n\n/**\n * Function: addObjectValue\n * \n * Sets the decoded child node as a value of the given object. If the\n * object is a map, then the value is added with the given fieldname as a\n * key. If the fieldname is not empty, then setFieldValue is called or\n * else, if the object is a collection, the value is added to the\n * collection. For strongly typed languages it may be required to\n * override this with the correct code to add an entry to an object.\n */\t\nmxObjectCodec.prototype.addObjectValue = function(obj, fieldname, value, template)\n{\n\tif (value != null && value != template)\n\t{\n\t\tif (fieldname != null && fieldname.length > 0)\n\t\t{\n\t\t\tobj[fieldname] = value;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tobj.push(value);\n\t\t}\n\t\t//mxLog.debug('Decoded '+mxUtils.getFunctionName(obj.constructor)+'.'+fieldname+': '+value);\n\t}\n};\n\n/**\n * Function: processInclude\n *\n * Returns true if the given node is an include directive and\n * executes the include by decoding the XML document. Returns\n * false if the given node is not an include directive.\n *\n * Parameters:\n *\n * dec - <mxCodec> that controls the encoding/decoding process.\n * node - XML node to be checked.\n * into - Optional object to pass-thru to the codec.\n */\nmxObjectCodec.prototype.processInclude = function(dec, node, into)\n{\n\tif (node.nodeName == 'include')\n\t{\n\t\tvar name = node.getAttribute('name');\n\t\t\n\t\tif (name != null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar xml = mxUtils.load(name).getDocumentElement();\n\t\t\t\t\n\t\t\t\tif (xml != null)\n\t\t\t\t{\n\t\t\t\t\tdec.decode(xml, into);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e)\n\t\t\t{\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\treturn false;\n};\n\n/**\n * Function: beforeDecode\n *\n * Hook for subclassers to pre-process the node for\n * the specified object and return the node to be\n * used for further processing by <decode>.\n * The object is created based on the template in the \n * calling method and is never null. This implementation\n * returns the input node. The return value of this\n * function is used in <decode> to perform\n * the default decoding into the given object.\n *\n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * node - XML node to be decoded.\n * obj - Object to encode the node into.\n */\nmxObjectCodec.prototype.beforeDecode = function(dec, node, obj)\n{\n\treturn node;\n};\n\n/**\n * Function: afterDecode\n *\n * Hook for subclassers to post-process the object after\n * decoding. This implementation returns the given object\n * without any changes. The return value of this method\n * is returned to the decoder from <decode>.\n *\n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * node - XML node to be decoded.\n * obj - Object that represents the default decoding.\n */\nmxObjectCodec.prototype.afterDecode = function(dec, node, obj)\n{\n\treturn obj;\n};\n\n__mxOutput.mxObjectCodec = typeof mxObjectCodec !== 'undefined' ? mxObjectCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxCellCodec\n\t *\n\t * Codec for <mxCell>s. This class is created and registered\n\t * dynamically at load time and used implicitly via <mxCodec>\n\t * and the <mxCodecRegistry>.\n\t *\n\t * Transient Fields:\n\t *\n\t * - children\n\t * - edges\n\t * - overlays\n\t * - mxTransient\n\t *\n\t * Reference Fields:\n\t *\n\t * - parent\n\t * - source\n\t * - target\n\t * \n\t * Transient fields can be added using the following code:\n\t * \n\t * mxCodecRegistry.getCodec(mxCell).exclude.push('name_of_field');\n\t * \n\t * To subclass <mxCell>, replace the template and add an alias as\n\t * follows.\n\t * \n\t * (code)\n\t * function CustomCell(value, geometry, style)\n\t * {\n\t *   mxCell.apply(this, arguments);\n\t * }\n\t * \n\t * mxUtils.extend(CustomCell, mxCell);\n\t * \n\t * mxCodecRegistry.getCodec(mxCell).template = new CustomCell();\n\t * mxCodecRegistry.addAlias('CustomCell', 'mxCell');\n\t * (end)\n\t */\n\tvar codec = new mxObjectCodec(new mxCell(),\n\t\t['children', 'edges', 'overlays', 'mxTransient'],\n\t\t['parent', 'source', 'target']);\n\n\t/**\n\t * Function: isCellCodec\n\t *\n\t * Returns true since this is a cell codec.\n\t */\n\tcodec.isCellCodec = function()\n\t{\n\t\treturn true;\n\t};\n\n\t/**\n\t * Overidden to disable conversion of value to number.\n\t */\n\tcodec.isNumericAttribute = function(dec, attr, obj)\n\t{\n\t\treturn attr.nodeName !== 'value' && mxObjectCodec.prototype.isNumericAttribute.apply(this, arguments);\n\t};\n\t\n\t/**\n\t * Function: isExcluded\n\t *\n\t * Excludes user objects that are XML nodes.\n\t */ \n\tcodec.isExcluded = function(obj, attr, value, isWrite)\n\t{\n\t\treturn mxObjectCodec.prototype.isExcluded.apply(this, arguments) ||\n\t\t\t(isWrite && attr == 'value' &&\n\t\t\tvalue.nodeType == mxConstants.NODETYPE_ELEMENT);\n\t};\n\t\n\t/**\n\t * Function: afterEncode\n\t *\n\t * Encodes an <mxCell> and wraps the XML up inside the\n\t * XML of the user object (inversion).\n\t */\n\tcodec.afterEncode = function(enc, obj, node)\n\t{\n\t\tif (obj.value != null && obj.value.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t{\n\t\t\t// Wraps the graphical annotation up in the user object (inversion)\n\t\t\t// by putting the result of the default encoding into a clone of the\n\t\t\t// user object (node type 1) and returning this cloned user object.\n\t\t\tvar tmp = node;\n\t\t\tnode = mxUtils.importNode(enc.document, obj.value, true);\n\t\t\tnode.appendChild(tmp);\n\t\t\t\n\t\t\t// Moves the id attribute to the outermost XML node, namely the\n\t\t\t// node which denotes the object boundaries in the file.\n\t\t\tvar id = tmp.getAttribute('id');\n\t\t\tnode.setAttribute('id', id);\n\t\t\ttmp.removeAttribute('id');\n\t\t}\n\n\t\treturn node;\n\t};\n\n\t/**\n\t * Function: beforeDecode\n\t *\n\t * Decodes an <mxCell> and uses the enclosing XML node as\n\t * the user object for the cell (inversion).\n\t */\n\tcodec.beforeDecode = function(dec, node, obj)\n\t{\n\t\tvar inner = node.cloneNode(true);\n\t\tvar classname = this.getName();\n\t\t\n\t\tif (node.nodeName != classname)\n\t\t{\n\t\t\t// Passes the inner graphical annotation node to the\n\t\t\t// object codec for further processing of the cell.\n\t\t\tvar tmp = node.getElementsByTagName(classname)[0];\n\t\t\t\n\t\t\tif (tmp != null && tmp.parentNode == node)\n\t\t\t{\n\t\t\t\tmxUtils.removeWhitespace(tmp, true);\n\t\t\t\tmxUtils.removeWhitespace(tmp, false);\n\t\t\t\ttmp.parentNode.removeChild(tmp);\n\t\t\t\tinner = tmp;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinner = null;\n\t\t\t}\n\t\t\t\n\t\t\t// Creates the user object out of the XML node\n\t\t\tobj.value = node.cloneNode(true);\n\t\t\tvar id = obj.value.getAttribute('id');\n\t\t\t\n\t\t\tif (id != null)\n\t\t\t{\n\t\t\t\tobj.setId(id);\n\t\t\t\tobj.value.removeAttribute('id');\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Uses ID from XML file as ID for cell in model\n\t\t\tobj.setId(node.getAttribute('id'));\n\t\t}\n\t\t\t\n\t\t// Preprocesses and removes all Id-references in order to use the\n\t\t// correct encoder (this) for the known references to cells (all).\n\t\tif (inner != null)\n\t\t{\n\t\t\tfor (var i = 0; i < this.idrefs.length; i++)\n\t\t\t{\n\t\t\t\tvar attr = this.idrefs[i];\n\t\t\t\tvar ref = inner.getAttribute(attr);\n\t\t\t\t\n\t\t\t\tif (ref != null)\n\t\t\t\t{\n\t\t\t\t\tinner.removeAttribute(attr);\n\t\t\t\t\tvar object = dec.objects[ref] || dec.lookup(ref);\n\t\t\t\t\t\n\t\t\t\t\tif (object == null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Needs to decode forward reference\n\t\t\t\t\t\tvar element = dec.getElementById(ref);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (element != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar decoder = mxCodecRegistry.codecs[element.nodeName] || this;\n\t\t\t\t\t\t\tobject = decoder.decode(dec, element);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tobj[attr] = object;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn inner;\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxCellCodec = typeof mxCellCodec !== 'undefined' ? mxCellCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxModelCodec\n\t *\n\t * Codec for <mxGraphModel>s. This class is created and registered\n\t * dynamically at load time and used implicitly via <mxCodec>\n\t * and the <mxCodecRegistry>.\n\t */\n\tvar codec = new mxObjectCodec(new mxGraphModel());\n\n\t/**\n\t * Function: encodeObject\n\t *\n\t * Encodes the given <mxGraphModel> by writing a (flat) XML sequence of\n\t * cell nodes as produced by the <mxCellCodec>. The sequence is\n\t * wrapped-up in a node with the name root.\n\t */\n\tcodec.encodeObject = function(enc, obj, node)\n\t{\n\t\tvar rootNode = enc.document.createElement('root');\n\t\tenc.encodeCell(obj.getRoot(), rootNode);\n\t\tnode.appendChild(rootNode);\n\t};\n\n\t/**\n\t * Function: decodeChild\n\t * \n\t * Overrides decode child to handle special child nodes.\n\t */\t\n\tcodec.decodeChild = function(dec, child, obj)\n\t{\n\t\tif (child.nodeName == 'root')\n\t\t{\n\t\t\tthis.decodeRoot(dec, child, obj);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmxObjectCodec.prototype.decodeChild.apply(this, arguments);\n\t\t}\n\t};\n\n\t/**\n\t * Function: decodeRoot\n\t *\n\t * Reads the cells into the graph model. All cells\n\t * are children of the root element in the node.\n\t */\n\tcodec.decodeRoot = function(dec, root, model)\n\t{\n\t\tvar rootCell = null;\n\t\tvar tmp = root.firstChild;\n\t\t\n\t\twhile (tmp != null)\n\t\t{\n\t\t\tvar cell = dec.decodeCell(tmp);\n\t\t\t\n\t\t\tif (cell != null && cell.getParent() == null)\n\t\t\t{\n\t\t\t\trootCell = cell;\n\t\t\t}\n\t\t\t\n\t\t\ttmp = tmp.nextSibling;\n\t\t}\n\n\t\t// Sets the root on the model if one has been decoded\n\t\tif (rootCell != null)\n\t\t{\n\t\t\tmodel.setRoot(rootCell);\n\t\t}\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxModelCodec = typeof mxModelCodec !== 'undefined' ? mxModelCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxRootChangeCodec\n\t *\n\t * Codec for <mxRootChange>s. This class is created and registered\n\t * dynamically at load time and used implicitly via <mxCodec> and\n\t * the <mxCodecRegistry>.\n\t *\n\t * Transient Fields:\n\t *\n\t * - model\n\t * - previous\n\t * - root\n\t */\n\tvar codec = new mxObjectCodec(new mxRootChange(),\n\t\t['model', 'previous', 'root']);\n\n\t/**\n\t * Function: onEncode\n\t *\n\t * Encodes the child recursively.\n\t */\n\tcodec.afterEncode = function(enc, obj, node)\n\t{\n\t\tenc.encodeCell(obj.root, node);\n\t\t\n\t\treturn node;\n\t};\n\n\t/**\n\t * Function: beforeDecode\n\t *\n\t * Decodes the optional children as cells\n\t * using the respective decoder.\n\t */\n\tcodec.beforeDecode = function(dec, node, obj)\n\t{\n\t\tif (node.firstChild != null &&\n\t\t\tnode.firstChild.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t{\n\t\t\t// Makes sure the original node isn't modified\n\t\t\tnode = node.cloneNode(true);\n\t\t\t\n\t\t\tvar tmp = node.firstChild;\n\t\t\tobj.root = dec.decodeCell(tmp, false);\n\n\t\t\tvar tmp2 = tmp.nextSibling;\n\t\t\ttmp.parentNode.removeChild(tmp);\n\t\t\ttmp = tmp2;\n\t\t\n\t\t\twhile (tmp != null)\n\t\t\t{\n\t\t\t\ttmp2 = tmp.nextSibling;\n\t\t\t\tdec.decodeCell(tmp);\n\t\t\t\ttmp.parentNode.removeChild(tmp);\n\t\t\t\ttmp = tmp2;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn node;\n\t};\n\t\n\t/**\n\t * Function: afterDecode\n\t *\n\t * Restores the state by assigning the previous value.\n\t */\n\tcodec.afterDecode = function(dec, node, obj)\n\t{\n\t\tobj.previous = obj.root;\n\t\t\n\t\treturn obj;\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxRootChangeCodec = typeof mxRootChangeCodec !== 'undefined' ? mxRootChangeCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxChildChangeCodec\n\t *\n\t * Codec for <mxChildChange>s. This class is created and registered\n\t * dynamically at load time and used implicitly via <mxCodec> and\n\t * the <mxCodecRegistry>.\n\t *\n\t * Transient Fields:\n\t *\n\t * - model\n\t * - previous\n\t * - previousIndex\n\t * - child\n\t *\n\t * Reference Fields:\n\t *\n\t * - parent\n\t */\n\tvar codec = new mxObjectCodec(new mxChildChange(),\n\t\t['model', 'child', 'previousIndex'],\n\t\t['parent', 'previous']);\n\n\t/**\n\t * Function: isReference\n\t *\n\t * Returns true for the child attribute if the child\n\t * cell had a previous parent or if we're reading the\n\t * child as an attribute rather than a child node, in\n\t * which case it's always a reference.\n\t */\n\tcodec.isReference = function(obj, attr, value, isWrite)\n\t{\n\t\tif (attr == 'child' && (!isWrite || obj.model.contains(obj.previous)))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn mxUtils.indexOf(this.idrefs, attr) >= 0;\n\t};\n\n\t/**\n\t * Function: isExcluded\n\t *\n\t * Excludes references to parent or previous if not in the model.\n\t */\n  \tcodec.isExcluded = function(obj, attr, value, write)\n  \t{\n  \t\treturn mxObjectCodec.prototype.isExcluded.apply(this, arguments) ||\n  \t\t\t(write && value != null && (attr == 'previous' ||\n  \t\t\tattr == 'parent') && !obj.model.contains(value));\n  \t};\n  \t\n\t/**\n\t * Function: afterEncode\n\t *\n\t * Encodes the child recusively and adds the result\n\t * to the given node.\n\t */\n\tcodec.afterEncode = function(enc, obj, node)\n\t{\n\t\tif (this.isReference(obj, 'child', obj.child, true))\n\t\t{\n\t\t\t// Encodes as reference (id)\n\t\t\tnode.setAttribute('child', enc.getId(obj.child));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// At this point, the encoder is no longer able to know which cells\n\t\t\t// are new, so we have to encode the complete cell hierarchy and\n\t\t\t// ignore the ones that are already there at decoding time. Note:\n\t\t\t// This can only be resolved by moving the notify event into the\n\t\t\t// execute of the edit.\n\t\t\tenc.encodeCell(obj.child, node);\n\t\t}\n\t\t\n\t\treturn node;\n\t};\n\n\t/**\n\t * Function: beforeDecode\n\t *\n\t * Decodes the any child nodes as using the respective\n\t * codec from the registry.\n\t */\n\tcodec.beforeDecode = function(dec, node, obj)\n\t{\n\t\tif (node.firstChild != null &&\n\t\t\tnode.firstChild.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t{\n\t\t\t// Makes sure the original node isn't modified\n\t\t\tnode = node.cloneNode(true);\n\t\t\t\n\t\t\tvar tmp = node.firstChild;\n\t\t\tobj.child = dec.decodeCell(tmp, false);\n\n\t\t\tvar tmp2 = tmp.nextSibling;\n\t\t\ttmp.parentNode.removeChild(tmp);\n\t\t\ttmp = tmp2;\n\t\t\t\n\t\t\twhile (tmp != null)\n\t\t\t{\n\t\t\t\ttmp2 = tmp.nextSibling;\n\t\t\t\t\n\t\t\t\tif (tmp.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t\t\t{\n\t\t\t\t\t// Ignores all existing cells because those do not need to\n\t\t\t\t\t// be re-inserted into the model. Since the encoded version\n\t\t\t\t\t// of these cells contains the new parent, this would leave\n\t\t\t\t\t// to an inconsistent state on the model (ie. a parent\n\t\t\t\t\t// change without a call to parentForCellChanged).\n\t\t\t\t\tvar id = tmp.getAttribute('id');\n\t\t\t\t\t\n\t\t\t\t\tif (dec.lookup(id) == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tdec.decodeCell(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttmp.parentNode.removeChild(tmp);\n\t\t\t\ttmp = tmp2;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar childRef = node.getAttribute('child');\n\t\t\tobj.child = dec.getObject(childRef);\n\t\t}\n\t\t\n\t\treturn node;\n\t};\n\t\n\t/**\n\t * Function: afterDecode\n\t *\n\t * Restores object state in the child change.\n\t */\n\tcodec.afterDecode = function(dec, node, obj)\n\t{\n\t\t// Cells are decoded here after a complete transaction so the previous\n\t\t// parent must be restored on the cell for the case where the cell was\n\t\t// added. This is needed for the local model to identify the cell as a\n\t\t// new cell and register the ID.\n        if (obj.child != null)\n        {\n            if (obj.child.parent != null && obj.previous != null &&\n                obj.child.parent != obj.previous)\n            {\n                obj.previous = obj.child.parent;\n            }\n\n            obj.child.parent = obj.previous;\n            obj.previous = obj.parent;\n            obj.previousIndex = obj.index;\n        }\n\n\t\treturn obj;\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxChildChangeCodec = typeof mxChildChangeCodec !== 'undefined' ? mxChildChangeCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxTerminalChangeCodec\n\t *\n\t * Codec for <mxTerminalChange>s. This class is created and registered\n\t * dynamically at load time and used implicitly via <mxCodec> and\n\t * the <mxCodecRegistry>.\n\t *\n\t * Transient Fields:\n\t *\n\t * - model\n\t * - previous\n\t *\n\t * Reference Fields:\n\t *\n\t * - cell\n\t * - terminal\n\t */\n\tvar codec = new mxObjectCodec(new mxTerminalChange(),\n\t\t['model', 'previous'], ['cell', 'terminal']);\n\n\t/**\n\t * Function: afterDecode\n\t *\n\t * Restores the state by assigning the previous value.\n\t */\n\tcodec.afterDecode = function(dec, node, obj)\n\t{\n\t\tobj.previous = obj.terminal;\n\t\t\n\t\treturn obj;\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxTerminalChangeCodec = typeof mxTerminalChangeCodec !== 'undefined' ? mxTerminalChangeCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGenericChangeCodec\n *\n * Codec for <mxValueChange>s, <mxStyleChange>s, <mxGeometryChange>s,\n * <mxCollapseChange>s and <mxVisibleChange>s. This class is created\n * and registered dynamically at load time and used implicitly\n * via <mxCodec> and the <mxCodecRegistry>.\n *\n * Transient Fields:\n *\n * - model\n * - previous\n *\n * Reference Fields:\n *\n * - cell\n * \n * Constructor: mxGenericChangeCodec\n *\n * Factory function that creates a <mxObjectCodec> for\n * the specified change and fieldname.\n *\n * Parameters:\n *\n * obj - An instance of the change object.\n * variable - The fieldname for the change data.\n */\nvar mxGenericChangeCodec = function(obj, variable)\n{\n\tvar codec = new mxObjectCodec(obj,  ['model', 'previous'], ['cell']);\n\n\t/**\n\t * Function: afterDecode\n\t *\n\t * Restores the state by assigning the previous value.\n\t */\n\tcodec.afterDecode = function(dec, node, obj)\n\t{\n\t\t// Allows forward references in sessions. This is a workaround\n\t\t// for the sequence of edits in mxGraph.moveCells and cellsAdded.\n\t\tif (mxUtils.isNode(obj.cell))\n\t\t{\n\t\t\tobj.cell = dec.decodeCell(obj.cell, false);\n\t\t}\n\n\t\tobj.previous = obj[variable];\n\n\t\treturn obj;\n\t};\n\t\n\treturn codec;\n};\n\n// Registers the codecs\nmxCodecRegistry.register(mxGenericChangeCodec(new mxValueChange(), 'value'));\nmxCodecRegistry.register(mxGenericChangeCodec(new mxStyleChange(), 'style'));\nmxCodecRegistry.register(mxGenericChangeCodec(new mxGeometryChange(), 'geometry'));\nmxCodecRegistry.register(mxGenericChangeCodec(new mxCollapseChange(), 'collapsed'));\nmxCodecRegistry.register(mxGenericChangeCodec(new mxVisibleChange(), 'visible'));\nmxCodecRegistry.register(mxGenericChangeCodec(new mxCellAttributeChange(), 'value'));\n\n__mxOutput.mxGenericChangeCodec = typeof mxGenericChangeCodec !== 'undefined' ? mxGenericChangeCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxGraphCodec\n\t *\n\t * Codec for <mxGraph>s. This class is created and registered\n\t * dynamically at load time and used implicitly via <mxCodec>\n\t * and the <mxCodecRegistry>.\n\t *\n\t * Transient Fields:\n\t *\n\t * - graphListeners\n\t * - eventListeners\n\t * - view\n\t * - container\n\t * - cellRenderer\n\t * - editor\n\t * - selection\n\t */\n\treturn new mxObjectCodec(new mxGraph(),\n\t\t['graphListeners', 'eventListeners', 'view', 'container',\n\t\t'cellRenderer', 'editor', 'selection']);\n\n}());\n\n__mxOutput.mxGraphCodec = typeof mxGraphCodec !== 'undefined' ? mxGraphCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxGraphViewCodec\n\t *\n\t * Custom encoder for <mxGraphView>s. This class is created\n\t * and registered dynamically at load time and used implicitly via\n\t * <mxCodec> and the <mxCodecRegistry>. This codec only writes views\n\t * into a XML format that can be used to create an image for\n\t * the graph, that is, it contains absolute coordinates with\n\t * computed perimeters, edge styles and cell styles.\n\t */\n\tvar codec = new mxObjectCodec(new mxGraphView());\n\n\t/**\n\t * Function: encode\n\t *\n\t * Encodes the given <mxGraphView> using <encodeCell>\n\t * starting at the model's root. This returns the\n\t * top-level graph node of the recursive encoding.\n\t */\n\tcodec.encode = function(enc, view)\n\t{\n\t\treturn this.encodeCell(enc, view,\n\t\t\tview.graph.getModel().getRoot());\n\t};\n\n\t/**\n\t * Function: encodeCell\n\t *\n\t * Recursively encodes the specifed cell. Uses layer\n\t * as the default nodename. If the cell's parent is\n\t * null, then graph is used for the nodename. If\n\t * <mxGraphModel.isEdge> returns true for the cell,\n\t * then edge is used for the nodename, else if\n\t * <mxGraphModel.isVertex> returns true for the cell,\n\t * then vertex is used for the nodename.\n\t *\n\t * <mxGraph.getLabel> is used to create the label\n\t * attribute for the cell. For graph nodes and vertices\n\t * the bounds are encoded into x, y, width and height.\n\t * For edges the points are encoded into a points\n\t * attribute as a space-separated list of comma-separated\n\t * coordinate pairs (eg. x0,y0 x1,y1 ... xn,yn). All\n\t * values from the cell style are added as attribute\n\t * values to the node. \n\t */\n\tcodec.encodeCell = function(enc, view, cell)\n\t{\n\t\tvar model = view.graph.getModel();\n\t\tvar state = view.getState(cell);\n\t\tvar parent = model.getParent(cell);\n\t\t\n\t\tif (parent == null || state != null)\n\t\t{\n\t\t\tvar childCount = model.getChildCount(cell);\n\t\t\tvar geo = view.graph.getCellGeometry(cell);\n\t\t\tvar name = null;\n\t\t\t\n\t\t\tif (parent == model.getRoot())\n\t\t\t{\n\t\t\t\tname = 'layer';\n\t\t\t}\n\t\t\telse if (parent == null)\n\t\t\t{\n\t\t\t\tname = 'graph';\n\t\t\t}\n\t\t\telse if (model.isEdge(cell))\n\t\t\t{\n\t\t\t\tname = 'edge';\n\t\t\t}\n\t\t\telse if (childCount > 0 && geo != null)\n\t\t\t{\n\t\t\t\tname = 'group';\n\t\t\t}\n\t\t\telse if (model.isVertex(cell))\n\t\t\t{\n\t\t\t\tname = 'vertex';\n\t\t\t}\n\t\t\t\n\t\t\tif (name != null)\n\t\t\t{\n\t\t\t\tvar node = enc.document.createElement(name);\n\t\t\t\tvar lab = view.graph.getLabel(cell);\n\t\t\t\t\n\t\t\t\tif (lab != null)\n\t\t\t\t{\n\t\t\t\t\tnode.setAttribute('label', view.graph.getLabel(cell));\n\t\t\t\t\t\n\t\t\t\t\tif (view.graph.isHtmlLabel(cell))\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.setAttribute('html', true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n\t\t\t\tif (parent == null)\n\t\t\t\t{\n\t\t\t\t\tvar bounds = view.getGraphBounds();\n\t\t\t\t\t\n\t\t\t\t\tif (bounds != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.setAttribute('x', Math.round(bounds.x));\n\t\t\t\t\t\tnode.setAttribute('y', Math.round(bounds.y));\n\t\t\t\t\t\tnode.setAttribute('width', Math.round(bounds.width));\n\t\t\t\t\t\tnode.setAttribute('height', Math.round(bounds.height));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tnode.setAttribute('scale', view.scale);\n\t\t\t\t}\n\t\t\t\telse if (state != null && geo != null)\n\t\t\t\t{\n\t\t\t\t\t// Writes each key, value in the style pair to an attribute\n\t\t\t\t    for (var i in state.style)\n\t\t\t\t    {\n\t\t\t\t    \tvar value = state.style[i];\n\t\t\n\t\t\t\t    \t// Tries to turn objects and functions into strings\n\t\t\t\t\t    if (typeof(value) == 'function' &&\n\t\t\t\t\t\t\ttypeof(value) == 'object')\n\t\t\t\t\t\t{\n\t\t\t\t\t    \tvalue = mxStyleRegistry.getName(value);\n\t\t\t\t        }\n\t\t\t\t    \t\n\t\t\t\t    \tif (value != null &&\n\t\t\t\t    \t\ttypeof(value) != 'function' &&\n\t\t\t\t\t\t\ttypeof(value) != 'object')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnode.setAttribute(i, value);\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t    \n\t\t\t\t\tvar abs = state.absolutePoints;\n\t\t\t\t\t\n\t\t\t\t\t// Writes the list of points into one attribute\n\t\t\t\t\tif (abs != null && abs.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar pts = Math.round(abs[0].x) + ',' + Math.round(abs[0].y);\n\t\t\n\t\t\t\t\t\tfor (var i=1; i<abs.length; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpts += ' ' + Math.round(abs[i].x) + ',' +\n\t\t\t\t\t\t\t\tMath.round(abs[i].y);\n\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t\tnode.setAttribute('points', pts);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Writes the bounds into 4 attributes\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.setAttribute('x', Math.round(state.x));\n\t\t\t\t\t\tnode.setAttribute('y', Math.round(state.y));\n\t\t\t\t\t\tnode.setAttribute('width', Math.round(state.width));\n\t\t\t\t\t\tnode.setAttribute('height', Math.round(state.height));\t\t\t\t\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tvar offset = state.absoluteOffset;\n\t\t\t\t\t\n\t\t\t\t\t// Writes the offset into 2 attributes\n\t\t\t\t\tif (offset != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (offset.x != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnode.setAttribute('dx', Math.round(offset.x));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (offset.y != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnode.setAttribute('dy', Math.round(offset.y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n\t\t\t\tfor (var i=0; i<childCount; i++)\n\t\t\t\t{\n\t\t\t\t\tvar childNode = this.encodeCell(enc,\n\t\t\t\t\t\t\tview, model.getChildAt(cell, i));\n\t\t\t\t\t\n\t\t\t\t\tif (childNode != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.appendChild(childNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn node;\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxGraphViewCodec = typeof mxGraphViewCodec !== 'undefined' ? mxGraphViewCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxStylesheetCodec\n *\n * Codec for <mxStylesheet>s. This class is created and registered\n * dynamically at load time and used implicitly via <mxCodec>\n * and the <mxCodecRegistry>.\n */\nvar mxStylesheetCodec = mxCodecRegistry.register(function()\n{\n\tvar codec = new mxObjectCodec(new mxStylesheet());\n\n\t/**\n\t * Function: encode\n\t *\n\t * Encodes a stylesheet. See <decode> for a description of the\n\t * format.\n\t */\n\tcodec.encode = function(enc, obj)\n\t{\n\t\tvar node = enc.document.createElement(this.getName());\n\t\t\n\t\tfor (var i in obj.styles)\n\t\t{\n\t\t\tvar style = obj.styles[i];\n\t\t\tvar styleNode = enc.document.createElement('add');\n\t\t\t\n\t\t\tif (i != null)\n\t\t\t{\n\t\t\t\tstyleNode.setAttribute('as', i);\n\t\t\t\t\n\t\t\t\tfor (var j in style)\n\t\t\t\t{\n\t\t\t\t\tvar value = this.getStringValue(j, style[j]);\n\t\t\t\t\t\n\t\t\t\t\tif (value != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar entry = enc.document.createElement('add');\n\t\t\t\t\t\tentry.setAttribute('value', value);\n\t\t\t\t\t\tentry.setAttribute('as', j);\n\t\t\t\t\t\tstyleNode.appendChild(entry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (styleNode.childNodes.length > 0)\n\t\t\t\t{\n\t\t\t\t\tnode.appendChild(styleNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t    return node;\n\t};\n\n\t/**\n\t * Function: getStringValue\n\t *\n\t * Returns the string for encoding the given value.\n\t */\n\tcodec.getStringValue = function(key, value)\n\t{\n\t\tvar type = typeof(value);\n\t\t\n\t\tif (type == 'function')\n\t\t{\n\t\t\tvalue = mxStyleRegistry.getName(value);\n\t\t}\n\t\telse if (type == 'object')\n\t\t{\n\t\t\tvalue = null;\n\t\t}\n\t\t\n\t\treturn value;\n\t};\n\t\n\t/**\n\t * Function: decode\n\t *\n\t * Reads a sequence of the following child nodes\n\t * and attributes:\n\t *\n\t * Child Nodes:\n\t *\n\t * add - Adds a new style.\n\t *\n\t * Attributes:\n\t *\n\t * as - Name of the style.\n\t * extend - Name of the style to inherit from.\n\t *\n\t * Each node contains another sequence of add and remove nodes with the following\n\t * attributes:\n\t *\n\t * as - Name of the style (see <mxConstants>).\n\t * value - Value for the style.\n\t *\n\t * Instead of the value-attribute, one can put Javascript expressions into\n\t * the node as follows if <mxStylesheetCodec.allowEval> is true:\n\t * <add as=\"perimeter\">mxPerimeter.RectanglePerimeter</add>\n\t *\n\t * A remove node will remove the entry with the name given in the as-attribute\n\t * from the style.\n\t * \n\t * Example:\n\t *\n\t * (code)\n\t * <mxStylesheet as=\"stylesheet\">\n\t *   <add as=\"text\">\n\t *     <add as=\"fontSize\" value=\"12\"/>\n\t *   </add>\n\t *   <add as=\"defaultVertex\" extend=\"text\">\n\t *     <add as=\"shape\" value=\"rectangle\"/>\n\t *   </add>\n\t * </mxStylesheet>\n\t * (end)\n\t */\n\tcodec.decode = function(dec, node, into)\n\t{\n\t\tvar obj = into || new this.template.constructor();\n\t\tvar id = node.getAttribute('id');\n\t\t\n\t\tif (id != null)\n\t\t{\n\t\t\tdec.objects[id] = obj;\n\t\t}\n\t\t\n\t\tnode = node.firstChild;\n\t\t\n\t\twhile (node != null)\n\t\t{\n\t\t\tif (!this.processInclude(dec, node, obj) && node.nodeName == 'add')\n\t\t\t{\n\t\t\t\tvar as = node.getAttribute('as');\n\t\t\t\t\n\t\t\t\tif (as != null)\n\t\t\t\t{\n\t\t\t\t\tvar extend = node.getAttribute('extend');\n\t\t\t\t\tvar style = (extend != null) ? mxUtils.clone(obj.styles[extend]) : null;\n\t\t\t\t\t\n\t\t\t\t\tif (style == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (extend != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmxLog.warn('mxStylesheetCodec.decode: stylesheet ' +\n\t\t\t\t\t\t\t\textend + ' not found to extend');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tstyle = new Object();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar entry = node.firstChild;\n\t\t\t\t\t\n\t\t\t\t\twhile (entry != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (entry.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t \tvar key = entry.getAttribute('as');\n\t\t\t\t\t\t \t\n\t\t\t\t\t\t \tif (entry.nodeName == 'add')\n\t\t\t\t\t\t \t{\n\t\t\t\t\t\t\t \tvar text = mxUtils.getTextContent(entry);\n\t\t\t\t\t\t\t \tvar value = null;\n\t\t\t\t\t\t\t \t\n\t\t\t\t\t\t\t \tif (text != null && text.length > 0 && mxStylesheetCodec.allowEval)\n\t\t\t\t\t\t\t \t{\n\t\t\t\t\t\t\t \t\tvalue = mxUtils.eval(text);\n\t\t\t\t\t\t\t \t}\n\t\t\t\t\t\t\t \telse\n\t\t\t\t\t\t\t \t{\n\t\t\t\t\t\t\t \t\tvalue = entry.getAttribute('value');\n\t\t\t\t\t\t\t \t\t\n\t\t\t\t\t\t\t \t\tif (mxUtils.isNumeric(value))\n\t\t\t\t\t\t\t \t\t{\n\t\t\t\t\t\t\t\t\t\tvalue = parseFloat(value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t \t}\n\n\t\t\t\t\t\t\t \tif (value != null)\n\t\t\t\t\t\t\t \t{\n\t\t\t\t\t\t\t \t\tstyle[key] = value;\n\t\t\t\t\t\t\t \t}\n\t\t\t\t\t\t \t}\n\t\t\t\t\t\t \telse if (entry.nodeName == 'remove')\n\t\t\t\t\t\t \t{\n\t\t\t\t\t\t \t\tdelete style[key];\n\t\t\t\t\t\t \t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tentry = entry.nextSibling;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tobj.putCellStyle(as, style);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tnode = node.nextSibling;\n\t\t}\n\t\t\n\t\treturn obj;\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n/**\n * Variable: allowEval\n * \n * Static global switch that specifies if the use of eval is allowed for\n * evaluating text content. Default is true. Set this to false if stylesheets\n * may contain user input.\n */\nmxStylesheetCodec.allowEval = true;\n\n__mxOutput.mxStylesheetCodec = typeof mxStylesheetCodec !== 'undefined' ? mxStylesheetCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxDefaultKeyHandlerCodec\n\t *\n\t * Custom codec for configuring <mxDefaultKeyHandler>s. This class is created\n\t * and registered dynamically at load time and used implicitly via\n\t * <mxCodec> and the <mxCodecRegistry>. This codec only reads configuration\n\t * data for existing key handlers, it does not encode or create key handlers.\n\t */\n\tvar codec = new mxObjectCodec(new mxDefaultKeyHandler());\n\n\t/**\n\t * Function: encode\n\t *\n\t * Returns null.\n\t */\n\tcodec.encode = function(enc, obj)\n\t{\n\t\treturn null;\n\t};\n\t\n\t/**\n\t * Function: decode\n\t *\n\t * Reads a sequence of the following child nodes\n\t * and attributes:\n\t *\n\t * Child Nodes:\n\t *\n\t * add - Binds a keystroke to an actionname.\n\t *\n\t * Attributes:\n\t *\n\t * as - Keycode.\n\t * action - Actionname to execute in editor.\n\t * control - Optional boolean indicating if\n\t * \t\tthe control key must be pressed.\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * <mxDefaultKeyHandler as=\"keyHandler\">\n\t *   <add as=\"88\" control=\"true\" action=\"cut\"/>\n\t *   <add as=\"67\" control=\"true\" action=\"copy\"/>\n\t *   <add as=\"86\" control=\"true\" action=\"paste\"/>\n\t * </mxDefaultKeyHandler>\n\t * (end)\n\t *\n\t * The keycodes are for the x, c and v keys.\n\t *\n\t * See also: <mxDefaultKeyHandler.bindAction>,\n\t * http://www.js-examples.com/page/tutorials__key_codes.html\n\t */\n\tcodec.decode = function(dec, node, into)\n\t{\n\t\tif (into != null)\n\t\t{\n\t\t\tvar editor = into.editor;\n\t\t\tnode = node.firstChild;\n\t\t\t\n\t\t\twhile (node != null)\n\t\t\t{\n\t\t\t\tif (!this.processInclude(dec, node, into) &&\n\t\t\t\t\tnode.nodeName == 'add')\n\t\t\t\t{\n\t\t\t\t\tvar as = node.getAttribute('as');\n\t\t\t\t\tvar action = node.getAttribute('action');\n\t\t\t\t\tvar control = node.getAttribute('control');\n\t\t\t\t\t\n\t\t\t\t\tinto.bindAction(as, action, control);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnode = node.nextSibling;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn into;\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxDefaultKeyHandlerCodec = typeof mxDefaultKeyHandlerCodec !== 'undefined' ? mxDefaultKeyHandlerCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxDefaultToolbarCodec\n *\n * Custom codec for configuring <mxDefaultToolbar>s. This class is created\n * and registered dynamically at load time and used implicitly via\n * <mxCodec> and the <mxCodecRegistry>. This codec only reads configuration\n * data for existing toolbars handlers, it does not encode or create toolbars.\n */\nvar mxDefaultToolbarCodec = mxCodecRegistry.register(function()\n{\n\tvar codec = new mxObjectCodec(new mxDefaultToolbar());\n\n\t/**\n\t * Function: encode\n\t *\n\t * Returns null.\n\t */\n\tcodec.encode = function(enc, obj)\n\t{\n\t\treturn null;\n\t};\n\t\n\t/**\n\t * Function: decode\n\t *\n\t * Reads a sequence of the following child nodes\n\t * and attributes:\n\t *\n\t * Child Nodes:\n\t *\n\t * add - Adds a new item to the toolbar. See below for attributes.\n\t * separator - Adds a vertical separator. No attributes.\n\t * hr - Adds a horizontal separator. No attributes.\n\t * br - Adds a linefeed. No attributes. \n\t *\n\t * Attributes:\n\t *\n\t * as - Resource key for the label.\n\t * action - Name of the action to execute in enclosing editor.\n\t * mode - Modename (see below).\n\t * template - Template name for cell insertion.\n\t * style - Optional style to override the template style.\n\t * icon - Icon (relative/absolute URL).\n\t * pressedIcon - Optional icon for pressed state (relative/absolute URL).\n\t * id - Optional ID to be used for the created DOM element.\n\t * toggle - Optional 0 or 1 to disable toggling of the element. Default is\n\t * 1 (true).\n\t *\n\t * The action, mode and template attributes are mutually exclusive. The\n\t * style can only be used with the template attribute. The add node may\n\t * contain another sequence of add nodes with as and action attributes\n\t * to create a combo box in the toolbar. If the icon is specified then\n\t * a list of the child node is expected to have its template attribute\n\t * set and the action is ignored instead.\n\t * \n\t * Nodes with a specified template may define a function to be used for\n\t * inserting the cloned template into the graph. Here is an example of such\n\t * a node:\n\t * \n\t * (code)\n\t * <add as=\"Swimlane\" template=\"swimlane\" icon=\"images/swimlane.gif\"><![CDATA[\n\t *   function (editor, cell, evt, targetCell)\n\t *   {\n\t *     var pt = mxUtils.convertPoint(\n\t *       editor.graph.container, mxEvent.getClientX(evt),\n\t *         mxEvent.getClientY(evt));\n\t *     return editor.addVertex(targetCell, cell, pt.x, pt.y);\n\t *   }\n\t * ]]></add>\n\t * (end)\n\t * \n\t * In the above function, editor is the enclosing <mxEditor> instance, cell\n\t * is the clone of the template, evt is the mouse event that represents the\n\t * drop and targetCell is the cell under the mousepointer where the drop\n\t * occurred. The targetCell is retrieved using <mxGraph.getCellAt>.\n\t *\n\t * Futhermore, nodes with the mode attribute may define a function to\n\t * be executed upon selection of the respective toolbar icon. In the\n\t * example below, the default edge style is set when this specific\n\t * connect-mode is activated:\n\t *\n\t * (code)\n\t * <add as=\"connect\" mode=\"connect\"><![CDATA[\n\t *   function (editor)\n\t *   {\n\t *     if (editor.defaultEdge != null)\n\t *     {\n\t *       editor.defaultEdge.style = 'straightEdge';\n\t *     }\n\t *   }\n\t * ]]></add>\n\t * (end)\n\t * \n\t * Both functions require <mxDefaultToolbarCodec.allowEval> to be set to true.\n\t *\n\t * Modes:\n\t *\n\t * select - Left mouse button used for rubberband- & cell-selection.\n\t * connect - Allows connecting vertices by inserting new edges.\n\t * pan - Disables selection and switches to panning on the left button.\n\t *\n\t * Example:\n\t *\n\t * To add items to the toolbar:\n\t * \n\t * (code)\n\t * <mxDefaultToolbar as=\"toolbar\">\n\t *   <add as=\"save\" action=\"save\" icon=\"images/save.gif\"/>\n\t *   <br/><hr/>\n\t *   <add as=\"select\" mode=\"select\" icon=\"images/select.gif\"/>\n\t *   <add as=\"connect\" mode=\"connect\" icon=\"images/connect.gif\"/>\n\t * </mxDefaultToolbar>\n\t * (end)\n\t */\n\tcodec.decode = function(dec, node, into)\n\t{\n\t\tif (into != null)\n\t\t{\n\t\t\tvar editor = into.editor;\n\t\t\tnode = node.firstChild;\n\t\t\t\n\t\t\twhile (node != null)\n\t\t\t{\n\t\t\t\tif (node.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t\t\t{\n\t\t\t\t\tif (!this.processInclude(dec, node, into))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (node.nodeName == 'separator')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinto.addSeparator();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (node.nodeName == 'br')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinto.toolbar.addBreak();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (node.nodeName == 'hr')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinto.toolbar.addLine();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (node.nodeName == 'add')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar as = node.getAttribute('as');\n\t\t\t\t\t\t\tas = mxResources.get(as) || as;\n\t\t\t\t\t\t\tvar icon = node.getAttribute('icon');\n\t\t\t\t\t\t\tvar pressedIcon = node.getAttribute('pressedIcon');\n\t\t\t\t\t\t\tvar action = node.getAttribute('action');\n\t\t\t\t\t\t\tvar mode = node.getAttribute('mode');\n\t\t\t\t\t\t\tvar template = node.getAttribute('template');\n\t\t\t\t\t\t\tvar toggle = node.getAttribute('toggle') != '0';\n\t\t\t\t\t\t\tvar text = mxUtils.getTextContent(node);\n\t\t\t\t\t\t\tvar elt = null;\n\n\t\t\t\t\t\t\tif (action != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\telt = into.addItem(as, icon, action, pressedIcon);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (mode != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar funct = (mxDefaultToolbarCodec.allowEval) ? mxUtils.eval(text) : null;\n\t\t\t\t\t\t\t\telt = into.addMode(as, icon, mode, pressedIcon, funct);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (template != null || (text != null && text.length > 0))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar cell = editor.templates[template];\n\t\t\t\t\t\t\t\tvar style = node.getAttribute('style');\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (cell != null && style != null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcell = editor.graph.cloneCell(cell);\n\t\t\t\t\t\t\t\t\tcell.setStyle(style);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tvar insertFunction = null;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (text != null && text.length > 0 && mxDefaultToolbarCodec.allowEval)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tinsertFunction = mxUtils.eval(text);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\telt = into.addPrototype(as, icon, cell, pressedIcon, insertFunction, toggle);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar children = mxUtils.getChildNodes(node);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (children.length > 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (icon == null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar combo = into.addActionCombo(as);\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tfor (var i=0; i<children.length; i++)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tvar child = children[i];\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif (child.nodeName == 'separator')\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinto.addOption(combo, '---');\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse if (child.nodeName == 'add')\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tvar lab = child.getAttribute('as');\n\t\t\t\t\t\t\t\t\t\t\t\tvar act = child.getAttribute('action');\n\t\t\t\t\t\t\t\t\t\t\t\tinto.addActionOption(combo, lab, act);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar select = null;\n\t\t\t\t\t\t\t\t\t\tvar create = function()\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tvar template = editor.templates[select.value];\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif (template != null)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tvar clone = template.clone();\n\t\t\t\t\t\t\t\t\t\t\t\tvar style = select.options[select.selectedIndex].cellStyle;\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\tif (style != null)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tclone.setStyle(style);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\treturn clone;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tmxLog.warn('Template '+template+' not found');\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tvar img = into.addPrototype(as, icon, create, null, null, toggle);\n\t\t\t\t\t\t\t\t\t\tselect = into.addCombo();\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t// Selects the toolbar icon if a selection change\n\t\t\t\t\t\t\t\t\t\t// is made in the corresponding combobox.\n\t\t\t\t\t\t\t\t\t\tmxEvent.addListener(select, 'change', function()\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tinto.toolbar.selectMode(img, function(evt)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tvar pt = mxUtils.convertPoint(editor.graph.container,\n\t\t\t\t\t\t\t\t\t\t\t\t\tmxEvent.getClientX(evt), mxEvent.getClientY(evt));\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\treturn editor.addVertex(null, funct(), pt.x, pt.y);\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tinto.toolbar.noReset = false;\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t// Adds the entries to the combobox\n\t\t\t\t\t\t\t\t\t\tfor (var i=0; i<children.length; i++)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tvar child = children[i];\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif (child.nodeName == 'separator')\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinto.addOption(select, '---');\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse if (child.nodeName == 'add')\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tvar lab = child.getAttribute('as');\n\t\t\t\t\t\t\t\t\t\t\t\tvar tmp = child.getAttribute('template');\n\t\t\t\t\t\t\t\t\t\t\t\tvar option = into.addOption(select, lab, tmp || template);\n\t\t\t\t\t\t\t\t\t\t\t\toption.cellStyle = child.getAttribute('style');\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Assigns an ID to the created element to access it later.\n\t\t\t\t\t\t\tif (elt != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar id = node.getAttribute('id');\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (id != null && id.length > 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\telt.setAttribute('id', id);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnode = node.nextSibling;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn into;\n\t};\n\t\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n/**\n * Variable: allowEval\n * \n * Static global switch that specifies if the use of eval is allowed for\n * evaluating text content. Default is true. Set this to false if stylesheets\n * may contain user input\n */\nmxDefaultToolbarCodec.allowEval = true;\n\n__mxOutput.mxDefaultToolbarCodec = typeof mxDefaultToolbarCodec !== 'undefined' ? mxDefaultToolbarCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxDefaultPopupMenuCodec\n\t *\n\t * Custom codec for configuring <mxDefaultPopupMenu>s. This class is created\n\t * and registered dynamically at load time and used implicitly via\n\t * <mxCodec> and the <mxCodecRegistry>. This codec only reads configuration\n\t * data for existing popup menus, it does not encode or create menus. Note\n\t * that this codec only passes the configuration node to the popup menu,\n\t * which uses the config to dynamically create menus. See\n\t * <mxDefaultPopupMenu.createMenu>.\n\t */\n\tvar codec = new mxObjectCodec(new mxDefaultPopupMenu());\n\n\t/**\n\t * Function: encode\n\t *\n\t * Returns null.\n\t */\n\tcodec.encode = function(enc, obj)\n\t{\n\t\treturn null;\n\t};\n\t\n\t/**\n\t * Function: decode\n\t *\n\t * Uses the given node as the config for <mxDefaultPopupMenu>.\n\t */\n\tcodec.decode = function(dec, node, into)\n\t{\n\t\tvar inc = node.getElementsByTagName('include')[0];\n\t\t\n\t\tif (inc != null)\n\t\t{\n\t\t\tthis.processInclude(dec, inc, into);\n\t\t}\n\t\telse if (into != null)\n\t\t{\n\t\t\tinto.config = node;\n\t\t}\n\t\t\n\t\treturn into;\n\t};\n\t\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxDefaultPopupMenuCodec = typeof mxDefaultPopupMenuCodec !== 'undefined' ? mxDefaultPopupMenuCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxEditorCodec\n\t *\n\t * Codec for <mxEditor>s. This class is created and registered\n\t * dynamically at load time and used implicitly via <mxCodec>\n\t * and the <mxCodecRegistry>.\n\t *\n\t * Transient Fields:\n\t *\n\t * - modified\n\t * - lastSnapshot\n\t * - ignoredChanges\n\t * - undoManager\n\t * - graphContainer\n\t * - toolbarContainer\n\t */\n\tvar codec = new mxObjectCodec(new mxEditor(),\n\t\t['modified', 'lastSnapshot', 'ignoredChanges',\n\t\t'undoManager', 'graphContainer', 'toolbarContainer']);\n\n\t/**\n\t * Function: beforeDecode\n\t *\n\t * Decodes the ui-part of the configuration node by reading\n\t * a sequence of the following child nodes and attributes\n\t * and passes the control to the default decoding mechanism:\n\t *\n\t * Child Nodes:\n\t *\n\t * stylesheet - Adds a CSS stylesheet to the document.\n\t * resource - Adds the basename of a resource bundle.\n\t * add - Creates or configures a known UI element.\n\t *\n\t * These elements may appear in any order given that the\n\t * graph UI element is added before the toolbar element\n\t * (see Known Keys).\n\t *\n\t * Attributes:\n\t *\n\t * as - Key for the UI element (see below).\n\t * element - ID for the element in the document.\n\t * style - CSS style to be used for the element or window.\n\t * x - X coordinate for the new window.\n\t * y - Y coordinate for the new window.\n\t * width - Width for the new window.\n\t * height - Optional height for the new window.\n\t * name - Name of the stylesheet (absolute/relative URL).\n\t * basename - Basename of the resource bundle (see <mxResources>).\n\t *\n\t * The x, y, width and height attributes are used to create a new\n\t * <mxWindow> if the element attribute is not specified in an add\n\t * node. The name and basename are only used in the stylesheet and\n\t * resource nodes, respectively.\n\t *\n\t * Known Keys:\n\t *\n\t * graph - Main graph element (see <mxEditor.setGraphContainer>).\n\t * title - Title element (see <mxEditor.setTitleContainer>).\n\t * toolbar - Toolbar element (see <mxEditor.setToolbarContainer>).\n\t * status - Status bar element (see <mxEditor.setStatusContainer>).\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * <ui>\n\t *   <stylesheet name=\"css/process.css\"/>\n\t *   <resource basename=\"resources/app\"/>\n\t *   <add as=\"graph\" element=\"graph\"\n\t *     style=\"left:70px;right:20px;top:20px;bottom:40px\"/>\n\t *   <add as=\"status\" element=\"status\"/>\n\t *   <add as=\"toolbar\" x=\"10\" y=\"20\" width=\"54\"/>\n\t * </ui>\n\t * (end)\n\t */\n\tcodec.afterDecode = function(dec, node, obj)\n\t{\n\t\t// Assigns the specified templates for edges\n\t\tvar defaultEdge = node.getAttribute('defaultEdge');\n\t\t\n\t\tif (defaultEdge != null)\n\t\t{\n\t\t\tnode.removeAttribute('defaultEdge');\n\t\t\tobj.defaultEdge = obj.templates[defaultEdge];\n\t\t}\n\n\t\t// Assigns the specified templates for groups\n\t\tvar defaultGroup = node.getAttribute('defaultGroup');\n\t\t\n\t\tif (defaultGroup != null)\n\t\t{\n\t\t\tnode.removeAttribute('defaultGroup');\n\t\t\tobj.defaultGroup = obj.templates[defaultGroup];\n\t\t}\n\n\t\treturn obj;\n\t};\n\t\n\t/**\n\t * Function: decodeChild\n\t * \n\t * Overrides decode child to handle special child nodes.\n\t */\t\n\tcodec.decodeChild = function(dec, child, obj)\n\t{\n\t\tif (child.nodeName == 'Array')\n\t\t{\n\t\t\tvar role = child.getAttribute('as');\n\t\t\t\n\t\t\tif (role == 'templates')\n\t\t\t{\n\t\t\t\tthis.decodeTemplates(dec, child, obj);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse if (child.nodeName == 'ui')\n\t\t{\n\t\t\tthis.decodeUi(dec, child, obj);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmxObjectCodec.prototype.decodeChild.apply(this, arguments);\n\t};\n\t\t\n\t/**\n\t * Function: decodeUi\n\t *\n\t * Decodes the ui elements from the given node.\n\t */\n\tcodec.decodeUi = function(dec, node, editor)\n\t{\n\t\tvar tmp = node.firstChild;\n\t\twhile (tmp != null)\n\t\t{\n\t\t\tif (tmp.nodeName == 'add')\n\t\t\t{\n\t\t\t\tvar as = tmp.getAttribute('as');\n\t\t\t\tvar elt = tmp.getAttribute('element');\n\t\t\t\tvar style = tmp.getAttribute('style');\n\t\t\t\tvar element = null;\n\n\t\t\t\tif (elt != null)\n\t\t\t\t{\n\t\t\t\t\telement = document.getElementById(elt);\n\t\t\t\t\t\n\t\t\t\t\tif (element != null && style != null)\n\t\t\t\t\t{\n\t\t\t\t\t\telement.style.cssText += ';' + style;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar x = parseInt(tmp.getAttribute('x'));\n\t\t\t\t\tvar y = parseInt(tmp.getAttribute('y'));\n\t\t\t\t\tvar width = tmp.getAttribute('width');\n\t\t\t\t\tvar height = tmp.getAttribute('height');\n\n\t\t\t\t\t// Creates a new window around the element\n\t\t\t\t\telement = document.createElement('div');\n\t\t\t\t\telement.style.cssText = style;\n\t\t\t\t\t\n\t\t\t\t\tvar wnd = new mxWindow(mxResources.get(as) || as,\n\t\t\t\t\t\telement, x, y, width, height, false, true);\n\t\t\t\t\twnd.setVisible(true);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// TODO: Make more generic\n\t\t\t\tif (as == 'graph')\n\t\t\t\t{\n\t\t\t\t\teditor.setGraphContainer(element);\n\t\t\t\t}\n\t\t\t\telse if (as == 'toolbar')\n\t\t\t\t{\n\t\t\t\t\teditor.setToolbarContainer(element);\n\t\t\t\t}\n\t\t\t\telse if (as == 'title')\n\t\t\t\t{\n\t\t\t\t\teditor.setTitleContainer(element);\n\t\t\t\t}\n\t\t\t\telse if (as == 'status')\n\t\t\t\t{\n\t\t\t\t\teditor.setStatusContainer(element);\n\t\t\t\t}\n\t\t\t\telse if (as == 'map')\n\t\t\t\t{\n\t\t\t\t\teditor.setMapContainer(element);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (tmp.nodeName == 'resource')\n\t\t\t{\n\t\t\t\tmxResources.add(tmp.getAttribute('basename'));\n\t\t\t}\n\t\t\telse if (tmp.nodeName == 'stylesheet')\n\t\t\t{\n\t\t\t\tmxClient.link('stylesheet', tmp.getAttribute('name'));\n\t\t\t}\n\t\t\t\n\t\t\ttmp = tmp.nextSibling;\n\t\t}\t\n\t};\n\t\n\t/**\n\t * Function: decodeTemplates\n\t *\n\t * Decodes the cells from the given node as templates.\n\t */\n\tcodec.decodeTemplates = function(dec, node, editor)\n\t{\n\t\tif (editor.templates == null)\n\t\t{\n\t\t\teditor.templates = [];\n\t\t}\n\t\t\n\t\tvar children = mxUtils.getChildNodes(node);\n\t\tfor (var j=0; j<children.length; j++)\n\t\t{\n\t\t\tvar name = children[j].getAttribute('as');\n\t\t\tvar child = children[j].firstChild;\n\t\t\t\n\t\t\twhile (child != null && child.nodeType != 1)\n\t\t\t{\n\t\t\t\tchild = child.nextSibling;\n\t\t\t}\n\t\t\t\n\t\t\tif (child != null)\n\t\t\t{\n\t\t\t\t// LATER: Only single cells means you need\n\t\t\t\t// to group multiple cells within another\n\t\t\t\t// cell. This should be changed to support\n\t\t\t\t// arrays of cells, or the wrapper must\n\t\t\t\t// be automatically handled in this class.\n\t\t\t\teditor.templates[name] = dec.decodeCell(child);\n\t\t\t}\n\t\t}\n\t};\n\t\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxEditorCodec = typeof mxEditorCodec !== 'undefined' ? mxEditorCodec : undefined;\nreturn __mxOutput;\n};\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/mxgraph/javascript/dist/build.js\n// module id = 1dLi\n// module chunks = 3"],"sourceRoot":""}